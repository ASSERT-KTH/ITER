bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] return null; [FE] AssertionError [CONTEXT] public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { [BUGGY] return null; [BUGGY] } if (currEntry != null) {  skip(Long.MAX_VALUE);  skipRecordPadding(); }  [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	1.0	227	227	1	replace	
2	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { [BUGGY] [BUGGY] return null; } if (currEntry != null) {  skip(Long.MAX_VALUE);  skipRecordPadding(); }  [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	1.0	227	227	1	add	
3	[BUG] [BUGGY] hasHitEOF = true; [FE] AssertionError [CONTEXT] if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); count(totalRead); if (totalRead == -1) { [BUGGY] hasHitEOF = true; [BUGGY] } else { entryOffset += totalRead; } return totalRead; } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding encoding InputStream i is int SMALL_BUFFER_SIZE blockSize ch got len length numToRead offset read readNow recordSize totalRead long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	1.0	586	586	1	replace	
4	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); count(totalRead); if (totalRead == -1) { [BUGGY] [BUGGY] hasHitEOF = true; } else { entryOffset += totalRead; } return totalRead; } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding encoding InputStream i is int SMALL_BUFFER_SIZE blockSize ch got len length numToRead offset read readNow recordSize totalRead long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	1.0	586	586	1	add	
5	[BUG] [BUGGY] if (entrySize - entryOffset > Integer.MAX_VALUE) { [FE] AssertionError [CONTEXT] public int available() throws IOException { [BUGGY] if (entrySize - entryOffset > Integer.MAX_VALUE) { [BUGGY] return Integer.MAX_VALUE; } return (int) (entrySize - entryOffset); } [CLASS] TarArchiveInputStream [METHOD] available [RETURN_TYPE] int  [VARIABLES] byte[] SMALL_BUF boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long entryOffset entrySize TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5	177	177	1	replace	
6	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public int available() throws IOException { [BUGGY] [BUGGY] if (entrySize - entryOffset > Integer.MAX_VALUE) { return Integer.MAX_VALUE; } return (int) (entrySize - entryOffset); } [CLASS] TarArchiveInputStream [METHOD] available [RETURN_TYPE] int  [VARIABLES] byte[] SMALL_BUF boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long entryOffset entrySize TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5	177	177	1	add	
7	[BUG] [BUGGY] return (int) (entrySize - entryOffset); [FE] AssertionError [CONTEXT] public int available() throws IOException { if (entrySize - entryOffset > Integer.MAX_VALUE) { return Integer.MAX_VALUE; } [BUGGY] return (int) (entrySize - entryOffset); [BUGGY] } [CLASS] TarArchiveInputStream [METHOD] available [RETURN_TYPE] int  [VARIABLES] byte[] SMALL_BUF boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long entryOffset entrySize TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5	180	180	1	replace	
8	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public int available() throws IOException { if (entrySize - entryOffset > Integer.MAX_VALUE) { return Integer.MAX_VALUE; } [BUGGY] [BUGGY] return (int) (entrySize - entryOffset); } [CLASS] TarArchiveInputStream [METHOD] available [RETURN_TYPE] int  [VARIABLES] byte[] SMALL_BUF boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long entryOffset entrySize TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5	180	180	1	add	
9	[BUG] [BUGGY] int totalRead = 0; [FE] AssertionError [CONTEXT] public int read(byte[] buf, int offset, int numToRead) throws IOException { [BUGGY] int totalRead = 0; [BUGGY]  if (hasHitEOF || entryOffset >= entrySize) { return -1; } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding encoding InputStream i is int SMALL_BUFFER_SIZE blockSize ch got len length numToRead offset read readNow recordSize totalRead long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5	570	570	1	replace	
10	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public int read(byte[] buf, int offset, int numToRead) throws IOException { [BUGGY] [BUGGY] int totalRead = 0; if (hasHitEOF || entryOffset >= entrySize) { return -1; } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding encoding InputStream i is int SMALL_BUFFER_SIZE blockSize ch got len length numToRead offset read readNow recordSize totalRead long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5	570	570	1	add	
11	[BUG] [BUGGY] if (hasHitEOF || entryOffset >= entrySize) { [FE] AssertionError [CONTEXT] public int read(byte[] buf, int offset, int numToRead) throws IOException { int totalRead = 0; [BUGGY] if (hasHitEOF || entryOffset >= entrySize) { [BUGGY] return -1; } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding encoding InputStream i is int SMALL_BUFFER_SIZE blockSize ch got len length numToRead offset read readNow recordSize totalRead long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5	572	572	1	replace	
12	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public int read(byte[] buf, int offset, int numToRead) throws IOException { int totalRead = 0; [BUGGY] [BUGGY] if (hasHitEOF || entryOffset >= entrySize) { return -1; } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding encoding InputStream i is int SMALL_BUFFER_SIZE blockSize ch got len length numToRead offset read readNow recordSize totalRead long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5	572	572	1	add	
13	[BUG] [BUGGY] return -1; [FE] AssertionError [CONTEXT] public int read(byte[] buf, int offset, int numToRead) throws IOException { int totalRead = 0; if (hasHitEOF || entryOffset >= entrySize) { [BUGGY] return -1; [BUGGY] } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); count(totalRead); [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding encoding InputStream i is int SMALL_BUFFER_SIZE blockSize ch got len length numToRead offset read readNow recordSize totalRead long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5	573	573	1	replace	
14	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public int read(byte[] buf, int offset, int numToRead) throws IOException { int totalRead = 0; if (hasHitEOF || entryOffset >= entrySize) { [BUGGY] [BUGGY] return -1; } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); count(totalRead); [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding encoding InputStream i is int SMALL_BUFFER_SIZE blockSize ch got len length numToRead offset read readNow recordSize totalRead long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5	573	573	1	add	
15	[BUG] [BUGGY] if (currEntry == null) { [FE] AssertionError [CONTEXT] public int read(byte[] buf, int offset, int numToRead) throws IOException { int totalRead = 0; if (hasHitEOF || entryOffset >= entrySize) { return -1; } [BUGGY] if (currEntry == null) { [BUGGY] throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); count(totalRead); if (totalRead == -1) { hasHitEOF = true; [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding encoding InputStream i is int SMALL_BUFFER_SIZE blockSize ch got len length numToRead offset read readNow recordSize totalRead long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5	576	576	1	replace	
16	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public int read(byte[] buf, int offset, int numToRead) throws IOException { int totalRead = 0; if (hasHitEOF || entryOffset >= entrySize) { return -1; } [BUGGY] [BUGGY] if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); count(totalRead); if (totalRead == -1) { hasHitEOF = true; [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding encoding InputStream i is int SMALL_BUFFER_SIZE blockSize ch got len length numToRead offset read readNow recordSize totalRead long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5	576	576	1	add	
17	[BUG] [BUGGY] numToRead = Math.min(numToRead, available()); [FE] AssertionError [CONTEXT] int totalRead = 0; if (hasHitEOF || entryOffset >= entrySize) { return -1; } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } [BUGGY] numToRead = Math.min(numToRead, available()); [BUGGY]  totalRead = is.read(buf, offset, numToRead); count(totalRead); if (totalRead == -1) { hasHitEOF = true; } else { entryOffset += totalRead; }  [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding encoding InputStream i is int SMALL_BUFFER_SIZE blockSize ch got len length numToRead offset read readNow recordSize totalRead long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5	580	580	1	replace	
18	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] int totalRead = 0; if (hasHitEOF || entryOffset >= entrySize) { return -1; } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } [BUGGY] [BUGGY] numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); count(totalRead); if (totalRead == -1) { hasHitEOF = true; } else { entryOffset += totalRead; }  [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding encoding InputStream i is int SMALL_BUFFER_SIZE blockSize ch got len length numToRead offset read readNow recordSize totalRead long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5	580	580	1	add	
19	[BUG] [BUGGY] totalRead = is.read(buf, offset, numToRead); [FE] AssertionError [CONTEXT] if (hasHitEOF || entryOffset >= entrySize) { return -1; } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); [BUGGY] totalRead = is.read(buf, offset, numToRead); [BUGGY] count(totalRead); if (totalRead == -1) { hasHitEOF = true; } else { entryOffset += totalRead; } return totalRead; } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding encoding InputStream i is int SMALL_BUFFER_SIZE blockSize ch got len length numToRead offset read readNow recordSize totalRead long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5	582	582	1	replace	
20	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] if (hasHitEOF || entryOffset >= entrySize) { return -1; } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); [BUGGY] [BUGGY] totalRead = is.read(buf, offset, numToRead); count(totalRead); if (totalRead == -1) { hasHitEOF = true; } else { entryOffset += totalRead; } return totalRead; } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding encoding InputStream i is int SMALL_BUFFER_SIZE blockSize ch got len length numToRead offset read readNow recordSize totalRead long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5	582	582	1	add	
21	[BUG] [BUGGY] count(totalRead); [FE] AssertionError [CONTEXT] return -1; } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); [BUGGY] count(totalRead); [BUGGY]  if (totalRead == -1) { hasHitEOF = true; } else { entryOffset += totalRead; } return totalRead; } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding encoding InputStream i is int SMALL_BUFFER_SIZE blockSize ch got len length numToRead offset read readNow recordSize totalRead long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5	583	583	1	replace	
22	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] return -1; } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); [BUGGY] [BUGGY] count(totalRead); if (totalRead == -1) { hasHitEOF = true; } else { entryOffset += totalRead; } return totalRead; } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding encoding InputStream i is int SMALL_BUFFER_SIZE blockSize ch got len length numToRead offset read readNow recordSize totalRead long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5	583	583	1	add	
23	[BUG] [BUGGY] if (totalRead == -1) { [FE] AssertionError [CONTEXT] if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); count(totalRead); [BUGGY] if (totalRead == -1) { [BUGGY] hasHitEOF = true; } else { entryOffset += totalRead; } return totalRead; } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding encoding InputStream i is int SMALL_BUFFER_SIZE blockSize ch got len length numToRead offset read readNow recordSize totalRead long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5	585	585	1	replace	
24	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); count(totalRead); [BUGGY] [BUGGY] if (totalRead == -1) { hasHitEOF = true; } else { entryOffset += totalRead; } return totalRead; } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding encoding InputStream i is int SMALL_BUFFER_SIZE blockSize ch got len length numToRead offset read readNow recordSize totalRead long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5	585	585	1	add	
25	[BUG] [BUGGY] entryOffset += totalRead; [FE] AssertionError [CONTEXT] } numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); count(totalRead); if (totalRead == -1) { hasHitEOF = true; } else { [BUGGY] entryOffset += totalRead; [BUGGY] } return totalRead; } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding encoding InputStream i is int SMALL_BUFFER_SIZE blockSize ch got len length numToRead offset read readNow recordSize totalRead long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5	588	588	1	replace	
26	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] } numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); count(totalRead); if (totalRead == -1) { hasHitEOF = true; } else { [BUGGY] [BUGGY] entryOffset += totalRead; } return totalRead; } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding encoding InputStream i is int SMALL_BUFFER_SIZE blockSize ch got len length numToRead offset read readNow recordSize totalRead long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5	588	588	1	add	
27	[BUG] [BUGGY] return totalRead; [FE] AssertionError [CONTEXT] totalRead = is.read(buf, offset, numToRead); count(totalRead); if (totalRead == -1) { hasHitEOF = true; } else { entryOffset += totalRead; } [BUGGY] return totalRead; [BUGGY] } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding encoding InputStream i is int SMALL_BUFFER_SIZE blockSize ch got len length numToRead offset read readNow recordSize totalRead long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5	591	591	1	replace	
28	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] totalRead = is.read(buf, offset, numToRead); count(totalRead); if (totalRead == -1) { hasHitEOF = true; } else { entryOffset += totalRead; } [BUGGY] [BUGGY] return totalRead; } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding encoding InputStream i is int SMALL_BUFFER_SIZE blockSize ch got len length numToRead offset read readNow recordSize totalRead long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5	591	591	1	add	
29	[BUG] [BUGGY] long numRecords = (this.entrySize / this.recordSize) + 1; [FE] AssertionError [CONTEXT] private void skipRecordPadding() throws IOException { if (this.entrySize > 0 && this.entrySize % this.recordSize != 0) { [BUGGY] long numRecords = (this.entrySize / this.recordSize) + 1; [BUGGY] long padding = (numRecords * this.recordSize) - this.entrySize; long skipped = IOUtils.skip(is, padding); count(skipped); } } [CLASS] TarArchiveInputStream [METHOD] skipRecordPadding [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4082482904638631	302	302	1	replace	
30	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] private void skipRecordPadding() throws IOException { if (this.entrySize > 0 && this.entrySize % this.recordSize != 0) { [BUGGY] [BUGGY] long numRecords = (this.entrySize / this.recordSize) + 1; long padding = (numRecords * this.recordSize) - this.entrySize; long skipped = IOUtils.skip(is, padding); count(skipped); } } [CLASS] TarArchiveInputStream [METHOD] skipRecordPadding [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4082482904638631	302	302	1	add	
31	[BUG] [BUGGY] long padding = (numRecords * this.recordSize) - this.entrySize; [FE] AssertionError [CONTEXT] private void skipRecordPadding() throws IOException { if (this.entrySize > 0 && this.entrySize % this.recordSize != 0) { long numRecords = (this.entrySize / this.recordSize) + 1; [BUGGY] long padding = (numRecords * this.recordSize) - this.entrySize; [BUGGY] long skipped = IOUtils.skip(is, padding); count(skipped); } } [CLASS] TarArchiveInputStream [METHOD] skipRecordPadding [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4082482904638631	303	303	1	replace	
32	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] private void skipRecordPadding() throws IOException { if (this.entrySize > 0 && this.entrySize % this.recordSize != 0) { long numRecords = (this.entrySize / this.recordSize) + 1; [BUGGY] [BUGGY] long padding = (numRecords * this.recordSize) - this.entrySize; long skipped = IOUtils.skip(is, padding); count(skipped); } } [CLASS] TarArchiveInputStream [METHOD] skipRecordPadding [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4082482904638631	303	303	1	add	
33	[BUG] [BUGGY] long skipped = IOUtils.skip(is, padding); [FE] AssertionError [CONTEXT] private void skipRecordPadding() throws IOException { if (this.entrySize > 0 && this.entrySize % this.recordSize != 0) { long numRecords = (this.entrySize / this.recordSize) + 1; long padding = (numRecords * this.recordSize) - this.entrySize; [BUGGY] long skipped = IOUtils.skip(is, padding); [BUGGY] count(skipped); } } [CLASS] TarArchiveInputStream [METHOD] skipRecordPadding [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4082482904638631	304	304	1	replace	
34	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] private void skipRecordPadding() throws IOException { if (this.entrySize > 0 && this.entrySize % this.recordSize != 0) { long numRecords = (this.entrySize / this.recordSize) + 1; long padding = (numRecords * this.recordSize) - this.entrySize; [BUGGY] [BUGGY] long skipped = IOUtils.skip(is, padding); count(skipped); } } [CLASS] TarArchiveInputStream [METHOD] skipRecordPadding [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4082482904638631	304	304	1	add	
35	[BUG] [BUGGY] count(skipped); [FE] AssertionError [CONTEXT] private void skipRecordPadding() throws IOException { if (this.entrySize > 0 && this.entrySize % this.recordSize != 0) { long numRecords = (this.entrySize / this.recordSize) + 1; long padding = (numRecords * this.recordSize) - this.entrySize; long skipped = IOUtils.skip(is, padding); [BUGGY] count(skipped); [BUGGY] } } [CLASS] TarArchiveInputStream [METHOD] skipRecordPadding [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4082482904638631	305	305	1	replace	
36	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] private void skipRecordPadding() throws IOException { if (this.entrySize > 0 && this.entrySize % this.recordSize != 0) { long numRecords = (this.entrySize / this.recordSize) + 1; long padding = (numRecords * this.recordSize) - this.entrySize; long skipped = IOUtils.skip(is, padding); [BUGGY] [BUGGY] count(skipped); } } [CLASS] TarArchiveInputStream [METHOD] skipRecordPadding [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4082482904638631	305	305	1	add	
37	[BUG] [BUGGY] long available = entrySize - entryOffset; [FE] AssertionError [CONTEXT] public long skip(long numToSkip) throws IOException { [BUGGY] long available = entrySize - entryOffset; [BUGGY] numToSkip = Math.min(numToSkip, available); long skipped = IOUtils.skip(is, numToSkip); count(skipped); entryOffset += skipped; return skipped; } [CLASS] TarArchiveInputStream [METHOD] skip [RETURN_TYPE] long  long numToSkip [VARIABLES] byte[] SMALL_BUF boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	196	196	1	replace	
38	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public long skip(long numToSkip) throws IOException { [BUGGY] [BUGGY] long available = entrySize - entryOffset; numToSkip = Math.min(numToSkip, available); long skipped = IOUtils.skip(is, numToSkip); count(skipped); entryOffset += skipped; return skipped; } [CLASS] TarArchiveInputStream [METHOD] skip [RETURN_TYPE] long  long numToSkip [VARIABLES] byte[] SMALL_BUF boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	196	196	1	add	
39	[BUG] [BUGGY] numToSkip = Math.min(numToSkip, available); [FE] AssertionError [CONTEXT] public long skip(long numToSkip) throws IOException { long available = entrySize - entryOffset; [BUGGY] numToSkip = Math.min(numToSkip, available); [BUGGY]  long skipped = IOUtils.skip(is, numToSkip); count(skipped); entryOffset += skipped; return skipped; } [CLASS] TarArchiveInputStream [METHOD] skip [RETURN_TYPE] long  long numToSkip [VARIABLES] byte[] SMALL_BUF boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	197	197	1	replace	
40	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public long skip(long numToSkip) throws IOException { long available = entrySize - entryOffset; [BUGGY] [BUGGY] numToSkip = Math.min(numToSkip, available); long skipped = IOUtils.skip(is, numToSkip); count(skipped); entryOffset += skipped; return skipped; } [CLASS] TarArchiveInputStream [METHOD] skip [RETURN_TYPE] long  long numToSkip [VARIABLES] byte[] SMALL_BUF boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	197	197	1	add	
41	[BUG] [BUGGY] long skipped = IOUtils.skip(is, numToSkip); [FE] AssertionError [CONTEXT] public long skip(long numToSkip) throws IOException { long available = entrySize - entryOffset; numToSkip = Math.min(numToSkip, available); [BUGGY] long skipped = IOUtils.skip(is, numToSkip); [BUGGY] count(skipped); entryOffset += skipped; return skipped; } [CLASS] TarArchiveInputStream [METHOD] skip [RETURN_TYPE] long  long numToSkip [VARIABLES] byte[] SMALL_BUF boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	199	199	1	replace	
42	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public long skip(long numToSkip) throws IOException { long available = entrySize - entryOffset; numToSkip = Math.min(numToSkip, available); [BUGGY] [BUGGY] long skipped = IOUtils.skip(is, numToSkip); count(skipped); entryOffset += skipped; return skipped; } [CLASS] TarArchiveInputStream [METHOD] skip [RETURN_TYPE] long  long numToSkip [VARIABLES] byte[] SMALL_BUF boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	199	199	1	add	
43	[BUG] [BUGGY] count(skipped); [FE] AssertionError [CONTEXT] public long skip(long numToSkip) throws IOException { long available = entrySize - entryOffset; numToSkip = Math.min(numToSkip, available); long skipped = IOUtils.skip(is, numToSkip); [BUGGY] count(skipped); [BUGGY] entryOffset += skipped; return skipped; } [CLASS] TarArchiveInputStream [METHOD] skip [RETURN_TYPE] long  long numToSkip [VARIABLES] byte[] SMALL_BUF boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	200	200	1	replace	
44	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public long skip(long numToSkip) throws IOException { long available = entrySize - entryOffset; numToSkip = Math.min(numToSkip, available); long skipped = IOUtils.skip(is, numToSkip); [BUGGY] [BUGGY] count(skipped); entryOffset += skipped; return skipped; } [CLASS] TarArchiveInputStream [METHOD] skip [RETURN_TYPE] long  long numToSkip [VARIABLES] byte[] SMALL_BUF boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	200	200	1	add	
45	[BUG] [BUGGY] entryOffset += skipped; [FE] AssertionError [CONTEXT] public long skip(long numToSkip) throws IOException { long available = entrySize - entryOffset; numToSkip = Math.min(numToSkip, available); long skipped = IOUtils.skip(is, numToSkip); count(skipped); [BUGGY] entryOffset += skipped; [BUGGY] return skipped; } [CLASS] TarArchiveInputStream [METHOD] skip [RETURN_TYPE] long  long numToSkip [VARIABLES] byte[] SMALL_BUF boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	201	201	1	replace	
46	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public long skip(long numToSkip) throws IOException { long available = entrySize - entryOffset; numToSkip = Math.min(numToSkip, available); long skipped = IOUtils.skip(is, numToSkip); count(skipped); [BUGGY] [BUGGY] entryOffset += skipped; return skipped; } [CLASS] TarArchiveInputStream [METHOD] skip [RETURN_TYPE] long  long numToSkip [VARIABLES] byte[] SMALL_BUF boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	201	201	1	add	
47	[BUG] [BUGGY] return skipped; [FE] AssertionError [CONTEXT] public long skip(long numToSkip) throws IOException { long available = entrySize - entryOffset; numToSkip = Math.min(numToSkip, available); long skipped = IOUtils.skip(is, numToSkip); count(skipped); entryOffset += skipped; [BUGGY] return skipped; [BUGGY] } [CLASS] TarArchiveInputStream [METHOD] skip [RETURN_TYPE] long  long numToSkip [VARIABLES] byte[] SMALL_BUF boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	202	202	1	replace	
48	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public long skip(long numToSkip) throws IOException { long available = entrySize - entryOffset; numToSkip = Math.min(numToSkip, available); long skipped = IOUtils.skip(is, numToSkip); count(skipped); entryOffset += skipped; [BUGGY] [BUGGY] return skipped; } [CLASS] TarArchiveInputStream [METHOD] skip [RETURN_TYPE] long  long numToSkip [VARIABLES] byte[] SMALL_BUF boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	202	202	1	add	
49	[BUG] [BUGGY] skip(Long.MAX_VALUE); [FE] AssertionError [CONTEXT] public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; } if (currEntry != null) {  [BUGGY] skip(Long.MAX_VALUE); [BUGGY]   skipRecordPadding(); } byte[] headerBuf = getRecord(); if (headerBuf == null) {  currEntry = null; [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	232	232	1	replace	
50	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; } if (currEntry != null) {  [BUGGY] [BUGGY] skip(Long.MAX_VALUE);  skipRecordPadding(); } byte[] headerBuf = getRecord(); if (headerBuf == null) {  currEntry = null; [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	232	232	1	add	
51	[BUG] [BUGGY] skipRecordPadding(); [FE] AssertionError [CONTEXT] public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; } if (currEntry != null) {  skip(Long.MAX_VALUE);  [BUGGY] skipRecordPadding(); [BUGGY] } byte[] headerBuf = getRecord(); if (headerBuf == null) {  currEntry = null; return null; }  [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	235	235	1	replace	
52	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; } if (currEntry != null) {  skip(Long.MAX_VALUE);  [BUGGY] [BUGGY] skipRecordPadding(); } byte[] headerBuf = getRecord(); if (headerBuf == null) {  currEntry = null; return null; }  [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	235	235	1	add	
53	[BUG] [BUGGY] if (this.entrySize > 0 && this.entrySize % this.recordSize != 0) { [FE] AssertionError [CONTEXT] private void skipRecordPadding() throws IOException { [BUGGY] if (this.entrySize > 0 && this.entrySize % this.recordSize != 0) { [BUGGY] long numRecords = (this.entrySize / this.recordSize) + 1; long padding = (numRecords * this.recordSize) - this.entrySize; long skipped = IOUtils.skip(is, padding); count(skipped); } } [CLASS] TarArchiveInputStream [METHOD] skipRecordPadding [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	301	301	1	replace	
54	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] private void skipRecordPadding() throws IOException { [BUGGY] [BUGGY] if (this.entrySize > 0 && this.entrySize % this.recordSize != 0) { long numRecords = (this.entrySize / this.recordSize) + 1; long padding = (numRecords * this.recordSize) - this.entrySize; long skipped = IOUtils.skip(is, padding); count(skipped); } } [CLASS] TarArchiveInputStream [METHOD] skipRecordPadding [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	301	301	1	add	
55	[BUG] [BUGGY] } [FE] AssertionError [CONTEXT] private void skipRecordPadding() throws IOException { if (this.entrySize > 0 && this.entrySize % this.recordSize != 0) { long numRecords = (this.entrySize / this.recordSize) + 1; long padding = (numRecords * this.recordSize) - this.entrySize; long skipped = IOUtils.skip(is, padding); count(skipped); } [BUGGY] } [BUGGY]  [CLASS] TarArchiveInputStream [METHOD] skipRecordPadding [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	307	307	1	replace	
56	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] private void skipRecordPadding() throws IOException { if (this.entrySize > 0 && this.entrySize % this.recordSize != 0) { long numRecords = (this.entrySize / this.recordSize) + 1; long padding = (numRecords * this.recordSize) - this.entrySize; long skipped = IOUtils.skip(is, padding); count(skipped); } [BUGGY] [BUGGY] } [CLASS] TarArchiveInputStream [METHOD] skipRecordPadding [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	307	307	1	add	
57	[BUG] [BUGGY] if (hasHitEOF) { [FE] AssertionError [CONTEXT] public TarArchiveEntry getNextTarEntry() throws IOException { [BUGGY] if (hasHitEOF) { [BUGGY] return null; } if (currEntry != null) {  skip(Long.MAX_VALUE);  skipRecordPadding(); } [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	226	226	1	replace	
58	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public TarArchiveEntry getNextTarEntry() throws IOException { [BUGGY] [BUGGY] if (hasHitEOF) { return null; } if (currEntry != null) {  skip(Long.MAX_VALUE);  skipRecordPadding(); } [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	226	226	1	add	
59	[BUG] [BUGGY] if (currEntry != null) { [FE] AssertionError [CONTEXT] public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; } [BUGGY] if (currEntry != null) { [BUGGY]  skip(Long.MAX_VALUE);  skipRecordPadding(); } byte[] headerBuf = getRecord(); if (headerBuf == null) { [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	230	230	1	replace	
60	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; } [BUGGY] [BUGGY] if (currEntry != null) {  skip(Long.MAX_VALUE);  skipRecordPadding(); } byte[] headerBuf = getRecord(); if (headerBuf == null) { [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	230	230	1	add	
61	[BUG] [BUGGY] byte[] headerBuf = getRecord(); [FE] AssertionError [CONTEXT] } if (currEntry != null) {  skip(Long.MAX_VALUE);  skipRecordPadding(); } [BUGGY] byte[] headerBuf = getRecord(); [BUGGY]  if (headerBuf == null) {  currEntry = null; return null; } try { currEntry = new TarArchiveEntry(headerBuf, encoding); } catch (IllegalArgumentException e) { [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	238	238	1	replace	
62	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] } if (currEntry != null) {  skip(Long.MAX_VALUE);  skipRecordPadding(); } [BUGGY] [BUGGY] byte[] headerBuf = getRecord(); if (headerBuf == null) {  currEntry = null; return null; } try { currEntry = new TarArchiveEntry(headerBuf, encoding); } catch (IllegalArgumentException e) { [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	238	238	1	add	
63	[BUG] [BUGGY] if (headerBuf == null) { [FE] AssertionError [CONTEXT] if (currEntry != null) {  skip(Long.MAX_VALUE);  skipRecordPadding(); } byte[] headerBuf = getRecord(); [BUGGY] if (headerBuf == null) { [BUGGY]  currEntry = null; return null; } try { currEntry = new TarArchiveEntry(headerBuf, encoding); } catch (IllegalArgumentException e) { IOException ioe = new IOException("Error detected parsing the header"); ioe.initCause(e); [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	240	240	1	replace	
64	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] if (currEntry != null) {  skip(Long.MAX_VALUE);  skipRecordPadding(); } byte[] headerBuf = getRecord(); [BUGGY] [BUGGY] if (headerBuf == null) {  currEntry = null; return null; } try { currEntry = new TarArchiveEntry(headerBuf, encoding); } catch (IllegalArgumentException e) { IOException ioe = new IOException("Error detected parsing the header"); ioe.initCause(e); [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	240	240	1	add	
65	[BUG] [BUGGY] currEntry = new TarArchiveEntry(headerBuf, encoding); [FE] AssertionError [CONTEXT] byte[] headerBuf = getRecord(); if (headerBuf == null) {  currEntry = null; return null; } try { [BUGGY] currEntry = new TarArchiveEntry(headerBuf, encoding); [BUGGY] } catch (IllegalArgumentException e) { IOException ioe = new IOException("Error detected parsing the header"); ioe.initCause(e); throw ioe; } entryOffset = 0; entrySize = currEntry.getSize(); if (currEntry.isGNULongLinkEntry()) { [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	247	247	1	replace	
66	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] byte[] headerBuf = getRecord(); if (headerBuf == null) {  currEntry = null; return null; } try { [BUGGY] [BUGGY] currEntry = new TarArchiveEntry(headerBuf, encoding); } catch (IllegalArgumentException e) { IOException ioe = new IOException("Error detected parsing the header"); ioe.initCause(e); throw ioe; } entryOffset = 0; entrySize = currEntry.getSize(); if (currEntry.isGNULongLinkEntry()) { [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	247	247	1	add	
67	[BUG] [BUGGY] } [FE] AssertionError [CONTEXT] currEntry = null; return null; } try { currEntry = new TarArchiveEntry(headerBuf, encoding); } catch (IllegalArgumentException e) { IOException ioe = new IOException("Error detected parsing the header"); ioe.initCause(e); throw ioe; [BUGGY] } [BUGGY]  entryOffset = 0; entrySize = currEntry.getSize(); if (currEntry.isGNULongLinkEntry()) { byte[] longLinkData = getLongNameData(); if (longLinkData == null) {    [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	252	252	1	replace	
68	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] currEntry = null; return null; } try { currEntry = new TarArchiveEntry(headerBuf, encoding); } catch (IllegalArgumentException e) { IOException ioe = new IOException("Error detected parsing the header"); ioe.initCause(e); throw ioe; [BUGGY] [BUGGY] } entryOffset = 0; entrySize = currEntry.getSize(); if (currEntry.isGNULongLinkEntry()) { byte[] longLinkData = getLongNameData(); if (longLinkData == null) {    [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	252	252	1	add	
69	[BUG] [BUGGY] entryOffset = 0; [FE] AssertionError [CONTEXT] } try { currEntry = new TarArchiveEntry(headerBuf, encoding); } catch (IllegalArgumentException e) { IOException ioe = new IOException("Error detected parsing the header"); ioe.initCause(e); throw ioe; } [BUGGY] entryOffset = 0; [BUGGY] entrySize = currEntry.getSize(); if (currEntry.isGNULongLinkEntry()) { byte[] longLinkData = getLongNameData(); if (longLinkData == null) {    return null; } [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	254	254	1	replace	
70	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] } try { currEntry = new TarArchiveEntry(headerBuf, encoding); } catch (IllegalArgumentException e) { IOException ioe = new IOException("Error detected parsing the header"); ioe.initCause(e); throw ioe; } [BUGGY] [BUGGY] entryOffset = 0; entrySize = currEntry.getSize(); if (currEntry.isGNULongLinkEntry()) { byte[] longLinkData = getLongNameData(); if (longLinkData == null) {    return null; } [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	254	254	1	add	
71	[BUG] [BUGGY] entrySize = currEntry.getSize(); [FE] AssertionError [CONTEXT] try { currEntry = new TarArchiveEntry(headerBuf, encoding); } catch (IllegalArgumentException e) { IOException ioe = new IOException("Error detected parsing the header"); ioe.initCause(e); throw ioe; } entryOffset = 0; [BUGGY] entrySize = currEntry.getSize(); [BUGGY]  if (currEntry.isGNULongLinkEntry()) { byte[] longLinkData = getLongNameData(); if (longLinkData == null) {    return null; } currEntry.setLinkName(encoding.decode(longLinkData)); [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	255	255	1	replace	
72	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] try { currEntry = new TarArchiveEntry(headerBuf, encoding); } catch (IllegalArgumentException e) { IOException ioe = new IOException("Error detected parsing the header"); ioe.initCause(e); throw ioe; } entryOffset = 0; [BUGGY] [BUGGY] entrySize = currEntry.getSize(); if (currEntry.isGNULongLinkEntry()) { byte[] longLinkData = getLongNameData(); if (longLinkData == null) {    return null; } currEntry.setLinkName(encoding.decode(longLinkData)); [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	255	255	1	add	
73	[BUG] [BUGGY] if (currEntry.isGNULongLinkEntry()) { [FE] AssertionError [CONTEXT] currEntry = new TarArchiveEntry(headerBuf, encoding); } catch (IllegalArgumentException e) { IOException ioe = new IOException("Error detected parsing the header"); ioe.initCause(e); throw ioe; } entryOffset = 0; entrySize = currEntry.getSize(); [BUGGY] if (currEntry.isGNULongLinkEntry()) { [BUGGY] byte[] longLinkData = getLongNameData(); if (longLinkData == null) {    return null; } currEntry.setLinkName(encoding.decode(longLinkData)); }  [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	257	257	1	replace	
74	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] currEntry = new TarArchiveEntry(headerBuf, encoding); } catch (IllegalArgumentException e) { IOException ioe = new IOException("Error detected parsing the header"); ioe.initCause(e); throw ioe; } entryOffset = 0; entrySize = currEntry.getSize(); [BUGGY] [BUGGY] if (currEntry.isGNULongLinkEntry()) { byte[] longLinkData = getLongNameData(); if (longLinkData == null) {    return null; } currEntry.setLinkName(encoding.decode(longLinkData)); }  [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	257	257	1	add	
75	[BUG] [BUGGY] if (currEntry.isGNULongNameEntry()) { [FE] AssertionError [CONTEXT] byte[] longLinkData = getLongNameData(); if (longLinkData == null) {    return null; } currEntry.setLinkName(encoding.decode(longLinkData)); } [BUGGY] if (currEntry.isGNULongNameEntry()) { [BUGGY] byte[] longNameData = getLongNameData(); if (longNameData == null) {    return null; } currEntry.setName(encoding.decode(longNameData)); }  [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	268	268	1	replace	
76	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] byte[] longLinkData = getLongNameData(); if (longLinkData == null) {    return null; } currEntry.setLinkName(encoding.decode(longLinkData)); } [BUGGY] [BUGGY] if (currEntry.isGNULongNameEntry()) { byte[] longNameData = getLongNameData(); if (longNameData == null) {    return null; } currEntry.setName(encoding.decode(longNameData)); }  [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	268	268	1	add	
77	[BUG] [BUGGY] if (currEntry.isPaxHeader()){ // Process Pax headers paxHeaders(); [FE] AssertionError [CONTEXT] byte[] longNameData = getLongNameData(); if (longNameData == null) {    return null; } currEntry.setName(encoding.decode(longNameData)); } [BUGGY] if (currEntry.isPaxHeader()){ // Process Pax headers   paxHeaders(); [BUGGY] paxHeaders(); } if (currEntry.isGNUSparse()){ // Process sparse files readGNUSparse(); }     [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	279	280	1	replace	
78	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] byte[] longNameData = getLongNameData(); if (longNameData == null) {    return null; } currEntry.setName(encoding.decode(longNameData)); } [BUGGY] [BUGGY] if (currEntry.isPaxHeader()){ // Process Pax headers   paxHeaders(); paxHeaders(); } if (currEntry.isGNUSparse()){ // Process sparse files readGNUSparse(); }     [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	279	280	1	add	
79	[BUG] [BUGGY] if (currEntry.isGNUSparse()){ // Process sparse files readGNUSparse(); [FE] AssertionError [CONTEXT]  return null; } currEntry.setName(encoding.decode(longNameData)); } if (currEntry.isPaxHeader()){ // Process Pax headers paxHeaders(); } [BUGGY] if (currEntry.isGNUSparse()){ // Process sparse files   readGNUSparse(); [BUGGY] readGNUSparse(); }     entrySize = currEntry.getSize(); return currEntry; [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	283	284	1	replace	
80	[BUG] [BUGGY] [FE] AssertionError [CONTEXT]  return null; } currEntry.setName(encoding.decode(longNameData)); } if (currEntry.isPaxHeader()){ // Process Pax headers paxHeaders(); } [BUGGY] [BUGGY] if (currEntry.isGNUSparse()){ // Process sparse files   readGNUSparse(); readGNUSparse(); }     entrySize = currEntry.getSize(); return currEntry; [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	283	284	1	add	
81	[BUG] [BUGGY] entrySize = currEntry.getSize(); [FE] AssertionError [CONTEXT] } if (currEntry.isGNUSparse()){ // Process sparse files readGNUSparse(); }     [BUGGY] entrySize = currEntry.getSize(); [BUGGY]  return currEntry; } [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	291	291	1	replace	
82	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] } if (currEntry.isGNUSparse()){ // Process sparse files readGNUSparse(); }     [BUGGY] [BUGGY] entrySize = currEntry.getSize(); return currEntry; } [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	291	291	1	add	
83	[BUG] [BUGGY] return currEntry; [FE] AssertionError [CONTEXT] if (currEntry.isGNUSparse()){ // Process sparse files readGNUSparse(); }     entrySize = currEntry.getSize(); [BUGGY] return currEntry; [BUGGY] } [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	293	293	1	replace	
84	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] if (currEntry.isGNUSparse()){ // Process sparse files readGNUSparse(); }     entrySize = currEntry.getSize(); [BUGGY] [BUGGY] return currEntry; } [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is IOException ioe int SMALL_BUFFER_SIZE blockSize recordSize long available entryOffset entrySize numToSkip skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	293	293	1	add	
85	[BUG] [BUGGY] byte[] headerBuf = readRecord(); [FE] AssertionError [CONTEXT] private byte[] getRecord() throws IOException { [BUGGY] byte[] headerBuf = readRecord(); [BUGGY] hasHitEOF = isEOFRecord(headerBuf); if (hasHitEOF && headerBuf != null) { tryToConsumeSecondEOFRecord(); consumeRemainderOfLastBlock(); headerBuf = null; } return headerBuf; } [CLASS] TarArchiveInputStream [METHOD] getRecord [RETURN_TYPE] byte[]  [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize length recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	357	357	1	replace	
86	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] private byte[] getRecord() throws IOException { [BUGGY] [BUGGY] byte[] headerBuf = readRecord(); hasHitEOF = isEOFRecord(headerBuf); if (hasHitEOF && headerBuf != null) { tryToConsumeSecondEOFRecord(); consumeRemainderOfLastBlock(); headerBuf = null; } return headerBuf; } [CLASS] TarArchiveInputStream [METHOD] getRecord [RETURN_TYPE] byte[]  [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize length recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	357	357	1	add	
87	[BUG] [BUGGY] hasHitEOF = isEOFRecord(headerBuf); [FE] AssertionError [CONTEXT] private byte[] getRecord() throws IOException { byte[] headerBuf = readRecord(); [BUGGY] hasHitEOF = isEOFRecord(headerBuf); [BUGGY] if (hasHitEOF && headerBuf != null) { tryToConsumeSecondEOFRecord(); consumeRemainderOfLastBlock(); headerBuf = null; } return headerBuf; } [CLASS] TarArchiveInputStream [METHOD] getRecord [RETURN_TYPE] byte[]  [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize length recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	358	358	1	replace	
88	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] private byte[] getRecord() throws IOException { byte[] headerBuf = readRecord(); [BUGGY] [BUGGY] hasHitEOF = isEOFRecord(headerBuf); if (hasHitEOF && headerBuf != null) { tryToConsumeSecondEOFRecord(); consumeRemainderOfLastBlock(); headerBuf = null; } return headerBuf; } [CLASS] TarArchiveInputStream [METHOD] getRecord [RETURN_TYPE] byte[]  [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize length recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	358	358	1	add	
89	[BUG] [BUGGY] if (hasHitEOF && headerBuf != null) { [FE] AssertionError [CONTEXT] private byte[] getRecord() throws IOException { byte[] headerBuf = readRecord(); hasHitEOF = isEOFRecord(headerBuf); [BUGGY] if (hasHitEOF && headerBuf != null) { [BUGGY] tryToConsumeSecondEOFRecord(); consumeRemainderOfLastBlock(); headerBuf = null; } return headerBuf; } [CLASS] TarArchiveInputStream [METHOD] getRecord [RETURN_TYPE] byte[]  [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize length recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	359	359	1	replace	
90	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] private byte[] getRecord() throws IOException { byte[] headerBuf = readRecord(); hasHitEOF = isEOFRecord(headerBuf); [BUGGY] [BUGGY] if (hasHitEOF && headerBuf != null) { tryToConsumeSecondEOFRecord(); consumeRemainderOfLastBlock(); headerBuf = null; } return headerBuf; } [CLASS] TarArchiveInputStream [METHOD] getRecord [RETURN_TYPE] byte[]  [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize length recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	359	359	1	add	
91	[BUG] [BUGGY] return headerBuf; [FE] AssertionError [CONTEXT] private byte[] getRecord() throws IOException { byte[] headerBuf = readRecord(); hasHitEOF = isEOFRecord(headerBuf); if (hasHitEOF && headerBuf != null) { tryToConsumeSecondEOFRecord(); consumeRemainderOfLastBlock(); headerBuf = null; } [BUGGY] return headerBuf; [BUGGY] } [CLASS] TarArchiveInputStream [METHOD] getRecord [RETURN_TYPE] byte[]  [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize length recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	364	364	1	replace	
92	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] private byte[] getRecord() throws IOException { byte[] headerBuf = readRecord(); hasHitEOF = isEOFRecord(headerBuf); if (hasHitEOF && headerBuf != null) { tryToConsumeSecondEOFRecord(); consumeRemainderOfLastBlock(); headerBuf = null; } [BUGGY] [BUGGY] return headerBuf; } [CLASS] TarArchiveInputStream [METHOD] getRecord [RETURN_TYPE] byte[]  [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize length recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	364	364	1	add	
93	[BUG] [BUGGY] return record == null || ArchiveUtils.isArrayZero(record, recordSize); [FE] AssertionError [CONTEXT] protected boolean isEOFRecord(byte[] record) { [BUGGY] return record == null || ArchiveUtils.isArrayZero(record, recordSize); [BUGGY] } [CLASS] TarArchiveInputStream [METHOD] isEOFRecord [RETURN_TYPE] boolean  byte[] record [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize length recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	375	375	1	replace	
94	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] protected boolean isEOFRecord(byte[] record) { [BUGGY] [BUGGY] return record == null || ArchiveUtils.isArrayZero(record, recordSize); } [CLASS] TarArchiveInputStream [METHOD] isEOFRecord [RETURN_TYPE] boolean  byte[] record [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize length recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	375	375	1	add	
95	[BUG] [BUGGY] byte[] record = new byte[recordSize]; [FE] AssertionError [CONTEXT] protected byte[] readRecord() throws IOException { [BUGGY] byte[] record = new byte[recordSize]; [BUGGY]  int readNow = IOUtils.readFully(is, record); count(readNow); if (readNow != recordSize) { return null; } return record; } [CLASS] TarArchiveInputStream [METHOD] readRecord [RETURN_TYPE] byte[]  [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize length readNow recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	386	386	1	replace	
96	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] protected byte[] readRecord() throws IOException { [BUGGY] [BUGGY] byte[] record = new byte[recordSize]; int readNow = IOUtils.readFully(is, record); count(readNow); if (readNow != recordSize) { return null; } return record; } [CLASS] TarArchiveInputStream [METHOD] readRecord [RETURN_TYPE] byte[]  [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize length readNow recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	386	386	1	add	
97	[BUG] [BUGGY] int readNow = IOUtils.readFully(is, record); [FE] AssertionError [CONTEXT] protected byte[] readRecord() throws IOException { byte[] record = new byte[recordSize]; [BUGGY] int readNow = IOUtils.readFully(is, record); [BUGGY] count(readNow); if (readNow != recordSize) { return null; } return record; } [CLASS] TarArchiveInputStream [METHOD] readRecord [RETURN_TYPE] byte[]  [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize length readNow recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	388	388	1	replace	
98	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] protected byte[] readRecord() throws IOException { byte[] record = new byte[recordSize]; [BUGGY] [BUGGY] int readNow = IOUtils.readFully(is, record); count(readNow); if (readNow != recordSize) { return null; } return record; } [CLASS] TarArchiveInputStream [METHOD] readRecord [RETURN_TYPE] byte[]  [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize length readNow recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	388	388	1	add	
99	[BUG] [BUGGY] count(readNow); [FE] AssertionError [CONTEXT] protected byte[] readRecord() throws IOException { byte[] record = new byte[recordSize]; int readNow = IOUtils.readFully(is, record); [BUGGY] count(readNow); [BUGGY] if (readNow != recordSize) { return null; } return record; } [CLASS] TarArchiveInputStream [METHOD] readRecord [RETURN_TYPE] byte[]  [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize length readNow recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	389	389	1	replace	
100	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] protected byte[] readRecord() throws IOException { byte[] record = new byte[recordSize]; int readNow = IOUtils.readFully(is, record); [BUGGY] [BUGGY] count(readNow); if (readNow != recordSize) { return null; } return record; } [CLASS] TarArchiveInputStream [METHOD] readRecord [RETURN_TYPE] byte[]  [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record boolean hasHitEOF ZipEncoding encoding InputStream is int SMALL_BUFFER_SIZE blockSize length readNow recordSize long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry  	projects/Compress28/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	389	389	1	add	
