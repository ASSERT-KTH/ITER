bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  ScmaFunction  <  T>  sc  =  getScammaFunction(i).getScalar();  [CE]  [FE]            AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  ScmaFunction  <  T>  sc  =  getScammaFunction(i).getScalar();  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	ScmaFunction  <  T>  sc  =  getScammaFunction(i).getScalar();	  ScmaFunction    <    T>    sc    =    getScamaFunction(i).getScalar();    	non-compiled	[CE]  	14	None	replace
2	[BUG]  [BUGGY]  For(int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {  fitness[i]  =  new  double[maxIterations];  }  [CE]  [FE]            AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  For(int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {  fitness[i]  =  new  double[maxIterations];  }  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	For(int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {  fitness[i]  =  new  double[maxIterations];  }	  if(sigma!=    null)    {    for(int    i    =    0;    i    <    checkFeasableCount;    i++)    {    fitness[i]    =    new    double[maxIterations];    }    	non-compiled	[CE]  	31	None	replace
3	[BUG]  [BUGGY]  For(int  i  =  0;  i  <  maxIterations;  i++)  {  fitness[i]  =  new  double[maxIterations];  }  [CE]  [FE]              AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  For(int  i  =  0;  i  <  maxIterations;  i++)  {  fitness[i]  =  new  double[maxIterations];  }  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	For(int  i  =  0;  i  <  maxIterations;  i++)  {  fitness[i]  =  new  double[maxIterations];  }	  if(sigma!=    null)    {    for(int    i    =    0;    i    <    checkFeasableCount;    i++)    {    fitness[i]    =    new    double[maxIterations];    }    	non-compiled	[CE]  	31	None	replace
4	[BUG]  [BUGGY]  safeMultiply(sigma)  {  for(int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {  fitness[i]  =  new  double[maxIterations];  }  [CE]  [FE]                  AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  safeMultiply(sigma)  {  for(int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {  fitness[i]  =  new  double[maxIterations];  }  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	safeMultiply(sigma)  {  for(int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {  fitness[i]  =  new  double[maxIterations];  }	  safeMultiply(sigma)    {    for(int    i    =    0;    i    <    checkFeasableCount;    i++)    {    fitness[i]    =    new    double[maxIterations];    }    	non-compiled	[CE]  	8	None	replace
5	[BUG]  [BUGGY]  safeMultiply(i);  [CE]  [FE]              AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  safeMultiply(i);  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	safeMultiply(i);	  safeMultiply(sigma);    	non-compiled	[CE]  	9	None	replace
6	[BUG]  [BUGGY]  safeMultiply(sigma,  k);  [CE]  [FE]                AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  safeMultiply(sigma,  k);  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	safeMultiply(sigma,  k);	  safeMultiply(sigma,    i);    	non-compiled	[CE]  	10	None	replace
7	[BUG]  [BUGGY]  safeMultiply(i,  s);  [CE]  [FE]                  AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  safeMultiply(i,  s);  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	safeMultiply(i,  s);	  safeMultiply(sigma,    i);    	non-compiled	[CE]  	10	None	replace
8	[BUG]  [BUGGY]  ScmaFunction  <  T>  sc  =  getScm(k).getScm(i  +  1);  [CE]  [FE]              AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  ScmaFunction  <  T>  sc  =  getScm(k).getScm(i  +  1);  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	ScmaFunction  <  T>  sc  =  getScm(k).getScm(i  +  1);	  ScmaFunction    <    T>    sc    =    getScm(k).getScm(i);    	non-compiled	[CE]  	30	None	replace
9	[BUG]  [BUGGY]  For(int  i  =  0;  i  <  maxIterations;  i++)  {  arxk.add(times(diagD,arz.getRowMatrix(k)));  }  [CE]  [FE]                  AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  For(int  i  =  0;  i  <  maxIterations;  i++)  {  arxk.add(times(diagD,arz.getRowMatrix(k)));  }  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	For(int  i  =  0;  i  <  maxIterations;  i++)  {  arxk.add(times(diagD,arz.getRowMatrix(k)));  }	  if(sigma!=    null)    {    for(int    i    =    0;    i    <    maxIterations;    i++)    {    arxk.add(times(diagD,arz.getRowMatrix(k)));    }    	non-compiled	[CE]  	33	None	replace
10	[BUG]  [BUGGY]  For(int  i  =  0;  i  <  maxIterations;  i++)  {  arxk.add(times(diagD,arz.getColumnMatrix(k)));  }  [CE]  [FE]                    AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  For(int  i  =  0;  i  <  maxIterations;  i++)  {  arxk.add(times(diagD,arz.getColumnMatrix(k)));  }  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	For(int  i  =  0;  i  <  maxIterations;  i++)  {  arxk.add(times(diagD,arz.getColumnMatrix(k)));  }	  if(sigma!=    null)    {    for(int    i    =    0;    i    <    maxIterations;    i++)    {    arxk.add(times(diagD,arz.getRowMatrix(k)));    }    	non-compiled	[CE]  	33	None	replace
11	[BUG]  [BUGGY]  ScmaFunction  <  T>  sc  =  getScalaFunction(i  +  1);  [CE]  [FE]                AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  ScmaFunction  <  T>  sc  =  getScalaFunction(i  +  1);  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	ScmaFunction  <  T>  sc  =  getScalaFunction(i  +  1);	  ScmaFunction    <    T>    sc    =    getScalaFunction(i);    	non-compiled	[CE]  	1	None	replace
12	[BUG]  [BUGGY]  ScmaFunction  <  T>  sc  =  getScamaFunction(i).getSambda(k);  [CE]  [FE]            AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  ScmaFunction  <  T>  sc  =  getScamaFunction(i).getSambda(k);  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	ScmaFunction  <  T>  sc  =  getScamaFunction(i).getSambda(k);	  ScmaFunction    <    T>    sc    =    getScamaFunction(i).getSambda();    	non-compiled	[CE]  	37	None	replace
13	[BUG]  [BUGGY]  if(i  ==  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  [CE]  [FE]            AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  if(i  ==  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	if(i  ==  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {	  if(i    ==    checkFeasableCount)    {    	non-compiled	[CE]  	35	None	replace
14	[BUG]  [BUGGY]  if(i  ==  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(1)))  {  [CE]  [FE]              AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  if(i  ==  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(1)))  {  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	if(i  ==  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(1)))  {	  if(i    ==    checkFeasableCount)    {    	non-compiled	[CE]  	35	None	replace
15	[BUG]  [BUGGY]  sigma  =  getSigma(k);  [CE]  [FE]                AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  sigma  =  getSigma(k);  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	sigma  =  getSigma(k);	  sigma    =    getSigma(i);    	non-compiled	[CE]  	16	None	replace
16	[BUG]  [BUGGY]  sigma  =  getSigma(i  +  1);  [CE]  [FE]                  AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  sigma  =  getSigma(i  +  1);  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	sigma  =  getSigma(i  +  1);	  sigma    =    getSigma(i);    	non-compiled	[CE]  	16	None	replace
17	[BUG]  [BUGGY]  if  (checkFeasableCount  >  1)  {  [CE]  [FE]              AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  if  (checkFeasableCount  >  1)  {  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	if  (checkFeasableCount  >  1)  {	  if    (checkFeasableCount    <    1)    {    	non-compiled	[CE]  	12	None	replace
18	[BUG]  [BUGGY]  Magimize  s  =  arxk.getSimilarity()  +  1;  [CE]  [FE]            AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  Magimize  s  =  arxk.getSimilarity()  +  1;  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	Magimize  s  =  arxk.getSimilarity()  +  1;	  Magimize    s    =    arxk.getSimilarity();    	non-compiled	[CE]  	20	None	replace
19	[BUG]  [BUGGY]  Magimize  pcCol  =  Math.min(i,  checkFeasableCount);  [CE]  [FE]              AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  Magimize  pcCol  =  Math.min(i,  checkFeasableCount);  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	Magimize  pcCol  =  Math.min(i,  checkFeasableCount);	  Magimize    pcCol    =    Math.min(i,    maxIterations);    	non-compiled	[CE]  	28	None	replace
20	[BUG]  [BUGGY]  Magimize  pcCol  =  Math.min(k,  maxIterations);  [CE]  [FE]                AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  Magimize  pcCol  =  Math.min(k,  maxIterations);  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	Magimize  pcCol  =  Math.min(k,  maxIterations);	  Magimize    pcCol    =    Math.min(i,    maxIterations);    	non-compiled	[CE]  	28	None	replace
21	[BUG]  [BUGGY]  for(iterations  =  1;  iterations  <  =  maxIterations;  iterations++)  {  fitness[i]  =  new  double[lambda].doubleValue();  }  [CE]  [FE]                  AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  for(iterations  =  1;  iterations  <  =  maxIterations;  iterations++)  {  fitness[i]  =  new  double[lambda].doubleValue();  }  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	for(iterations  =  1;  iterations  <  =  maxIterations;  iterations++)  {  fitness[i]  =  new  double[lambda].doubleValue();  }	  if(i    >    maxIterations)    {    for(iterations    =    1;    iterations    <    maxIterations;    iterations++)    {    fitness[i]    =    new    double[lambda].doubleValue();    }    	non-compiled	[CE]  	24	None	replace
22	[BUG]  [BUGGY]  For(iterations  =  1;  iterations  <  =  maxIterations;  iterations++)  {  fitness[i]  =  new  double[lambda].doubleValue();  }  [CE]  [FE]                    AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  For(iterations  =  1;  iterations  <  =  maxIterations;  iterations++)  {  fitness[i]  =  new  double[lambda].doubleValue();  }  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	For(iterations  =  1;  iterations  <  =  maxIterations;  iterations++)  {  fitness[i]  =  new  double[lambda].doubleValue();  }	  if(i    >    maxIterations)    {    for(iterations    =    1;    iterations    <    maxIterations;    iterations++)    {    fitness[i]    =    new    double[lambda].doubleValue();    }    	non-compiled	[CE]  	24	None	replace
23	[BUG]  [BUGGY]  sigma  =  getSigma(k).getSigma();  [CE]  [FE]                  AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  sigma  =  getSigma(k).getSigma();  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	sigma  =  getSigma(k).getSigma();	  sigma    =    getSigma(i).getSigma();    	non-compiled	[CE]  	17	None	replace
24	[BUG]  [BUGGY]  ScmaFunction  <  T>  sc  =  getSamaFunction(i).getSigma();  [CE]  [FE]              AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  ScmaFunction  <  T>  sc  =  getSamaFunction(i).getSigma();  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	ScmaFunction  <  T>  sc  =  getSamaFunction(i).getSigma();	  ScmaFunction    <    T>    sc    =    getScamaFunction(i).getSigma();    	non-compiled	[CE]  	15	None	replace
25	[BUG]  [BUGGY]  Magimize  pcCol  =  generateStatistics  &&  pcCol!=  null  &&  pcCol.equals(gamma);  [CE]  [FE]                AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  Magimize  pcCol  =  generateStatistics  &&  pcCol!=  null  &&  pcCol.equals(gamma);  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	Magimize  pcCol  =  generateStatistics  &&  pcCol!=  null  &&  pcCol.equals(gamma);	  Magimize    pcCol    =    generateStatistics    &&    pcCol!=    null    &&    pcCol.equals(pcCol);    	non-compiled	[CE]  	25	None	replace
26	[BUG]  [BUGGY]  Magimize  pcCol  =  generateStatistics  ||  pcCol!=  null  &&  pcCol.isMultiply(pcCol));  [CE]  [FE]                  AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  Magimize  pcCol  =  generateStatistics  ||  pcCol!=  null  &&  pcCol.isMultiply(pcCol));  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	Magimize  pcCol  =  generateStatistics  ||  pcCol!=  null  &&  pcCol.isMultiply(pcCol));	  Magimize    pcCol    =    generateStatistics    &&    pcCol!=    null    &&    pcCol.isMultiply(pcCol));    	non-compiled	[CE]  	26	None	replace
27	[BUG]  [BUGGY]  vice.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(sigma));  [CE]  [FE]                AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  vice.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(sigma));  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	vice.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(sigma));	  if(sigma!=    null)    {    for(int    i    =    0;    i    <    maxIterations;    i++)    {    arxk.add(times(diagD,arz.getColumnMatrix(k)).scalarMultiply(sigma));    }    	non-compiled	[CE]  	32	None	replace
28	[BUG]  [BUGGY]  vice.add(BD.multiply(arz.getColumnMatrix(k))).scalarMultiply(sigma));  [CE]  [FE]                  AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  vice.add(BD.multiply(arz.getColumnMatrix(k))).scalarMultiply(sigma));  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	vice.add(BD.multiply(arz.getColumnMatrix(k))).scalarMultiply(sigma));	  if(sigma!=    null)    {    for(int    i    =    0;    i    <    maxIterations;    i++)    {    arxk.add(times(diagD,arz.getColumnMatrix(k)).scalarMultiply(sigma));    }    	non-compiled	[CE]  	32	None	replace
29	[BUG]  [BUGGY]  ScmaFunction  <  T>  sc  =  getScm(i).getScm(k  +  1);  [CE]  [FE]              AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  ScmaFunction  <  T>  sc  =  getScm(i).getScm(k  +  1);  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	ScmaFunction  <  T>  sc  =  getScm(i).getScm(k  +  1);	  ScmaFunction    <    T>    sc    =    getScm(i).getScm(k);    	non-compiled	[CE]  	3	None	replace
30	[BUG]  [BUGGY]  safeMultiply(sigma)  {  for(int  i  =  0;  i  <  maxIterations;  i++)  {  fitness[i]  =  new  double[minIterations];  }  [CE]  [FE]                AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  safeMultiply(sigma)  {  for(int  i  =  0;  i  <  maxIterations;  i++)  {  fitness[i]  =  new  double[minIterations];  }  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	safeMultiply(sigma)  {  for(int  i  =  0;  i  <  maxIterations;  i++)  {  fitness[i]  =  new  double[minIterations];  }	  if(sigma!=    null)    {    for(int    i    =    0;    i    <    maxIterations;    i++)    {    fitness[i]    =    new    double[minIterations];    }    	non-compiled	[CE]  	34	None	replace
31	[BUG]  [BUGGY]  safeMultiply(sigma)  {  for(int  i  =  0;  i  <  minIterations;  i++)  {  fitness[i]  =  new  double[minIterations];  }  [CE]  [FE]                  AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  safeMultiply(sigma)  {  for(int  i  =  0;  i  <  minIterations;  i++)  {  fitness[i]  =  new  double[minIterations];  }  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	safeMultiply(sigma)  {  for(int  i  =  0;  i  <  minIterations;  i++)  {  fitness[i]  =  new  double[minIterations];  }	  if(sigma!=    null)    {    for(int    i    =    0;    i    <    maxIterations;    i++)    {    fitness[i]    =    new    double[minIterations];    }    	non-compiled	[CE]  	34	None	replace
32	[BUG]  [BUGGY]  for(iterations  =  1;  iterations  <  maxIterations;  iterations++)  {  fitness[i]  =  new  double[lambda];  }  [CE]  [FE]                AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  for(iterations  =  1;  iterations  <  maxIterations;  iterations++)  {  fitness[i]  =  new  double[lambda];  }  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	for(iterations  =  1;  iterations  <  maxIterations;  iterations++)  {  fitness[i]  =  new  double[lambda];  }	  if(i    >    maxIterations)    {    for(iterations    =    1;    iterations    <    maxIterations;    iterations++)    {    fitness[i]    =    new    double[lambda];    }    	non-compiled	[CE]  	23	None	replace
33	[BUG]  [BUGGY]  for(iterations  =  1;  iterations  <  =  maxIterations;  iterations++)  {  fitness[i]  =  new  double[lambda];  }  [CE]  [FE]                  AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  for(iterations  =  1;  iterations  <  =  maxIterations;  iterations++)  {  fitness[i]  =  new  double[lambda];  }  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	for(iterations  =  1;  iterations  <  =  maxIterations;  iterations++)  {  fitness[i]  =  new  double[lambda];  }	  if(i    >    maxIterations)    {    for(iterations    =    1;    iterations    <    maxIterations;    iterations++)    {    fitness[i]    =    new    double[lambda];    }    	non-compiled	[CE]  	23	None	replace
34	[BUG]  [BUGGY]  Magimize  pcCol  =  generateStatistics(i);  [CE]  [FE]              AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  Magimize  pcCol  =  generateStatistics(i);  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	Magimize  pcCol  =  generateStatistics(i);	  Magimize    pcCol    =    generateStatistics(arxk);    	non-compiled	[CE]  	21	None	replace
35	[BUG]  [BUGGY]  Magimize  pcCol  =  generateStatistics(i,  arxk);  [CE]  [FE]                AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  Magimize  pcCol  =  generateStatistics(i,  arxk);  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	Magimize  pcCol  =  generateStatistics(i,  arxk);	  Magimize    pcCol    =    generateStatistics(arxk);    	non-compiled	[CE]  	21	None	replace
36	[BUG]  [BUGGY]  if  (i  <  checkFeasableCount)  {  [CE]  [FE]              AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  if  (i  <  checkFeasableCount)  {  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	if  (i  <  checkFeasableCount)  {	  if    (i    <    maxIterations)    {    	non-compiled	[CE]  	18	None	replace
37	[BUG]  [BUGGY]  if  (i  <  =  maxIterations)  {  [CE]  [FE]                AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  if  (i  <  =  maxIterations)  {  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	if  (i  <  =  maxIterations)  {	  if    (i    <    maxIterations)    {    	non-compiled	[CE]  	18	None	replace
38	[BUG]  [BUGGY]  Magimize  pcCol  =  Math.min(maxIterations,  i);  [CE]  [FE]                AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  Magimize  pcCol  =  Math.min(maxIterations,  i);  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	Magimize  pcCol  =  Math.min(maxIterations,  i);	  Magimize    pcCol    =    Math.min(i,    minIterations);    	non-compiled	[CE]  	29	None	replace
39	[BUG]  [BUGGY]  if(k  ==  0)  {  [CE]  [FE]              AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  if(k  ==  0)  {  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	if(k  ==  0)  {	  if    (i    ==    0)    {    	non-compiled	[CE]  	5	None	replace
40	[BUG]  [BUGGY]  if(i  >  1)  {  [CE]  [FE]            AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  if(i  >  1)  {  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	if(i  >  1)  {	  if(i    >    0)    {    	non-compiled	[CE]  	13	None	replace
41	[BUG]  [BUGGY]  Magimize  pcCol  =  generateStatistics(arxk,  i);  [CE]  [FE]              AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  Magimize  pcCol  =  generateStatistics(arxk,  i);  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	Magimize  pcCol  =  generateStatistics(arxk,  i);	  Magimize    pcCol    =    generateStatistics(arxk);    	non-compiled	[CE]  	21	None	replace
42	[BUG]  [BUGGY]  ScmaFunction  <  T>  sc  =  getScalarFunction(i);  [CE]  [FE]                AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  ScmaFunction  <  T>  sc  =  getScalarFunction(i);  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	ScmaFunction  <  T>  sc  =  getScalarFunction(i);	  ScmaFunction    <    T>    sc    =    getScammaFunction(i);    	non-compiled	[CE]  	22	None	replace
43	[BUG]  [BUGGY]  ScmaFunction  <  T>  sc  =  getScalaFunction(i,  k);  [CE]  [FE]                AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  ScmaFunction  <  T>  sc  =  getScalaFunction(i,  k);  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	ScmaFunction  <  T>  sc  =  getScalaFunction(i,  k);	  ScmaFunction    <    T>    sc    =    getScalaFunction(i);    	non-compiled	[CE]  	1	None	replace
44	[BUG]  [BUGGY]  Magimize  s  =  arxk.getSimilarity()  +  i;  [CE]  [FE]            AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  Magimize  s  =  arxk.getSimilarity()  +  i;  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	Magimize  s  =  arxk.getSimilarity()  +  i;	  Magimize    s    =    arxk.getSimilarity();    	non-compiled	[CE]  	20	None	replace
45	[BUG]  [BUGGY]  safely(sigma)  {  for(int  i  =  0;  i  <  checkFeasableCount;  i++)  {  fitness[i]  =  new  double[maxIterations];  }  [CE]  [FE]                  AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  safely(sigma)  {  for(int  i  =  0;  i  <  checkFeasableCount;  i++)  {  fitness[i]  =  new  double[maxIterations];  }  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	safely(sigma)  {  for(int  i  =  0;  i  <  checkFeasableCount;  i++)  {  fitness[i]  =  new  double[maxIterations];  }	  safeMultiply(sigma)    {    for(int    i    =    0;    i    <    checkFeasableCount;    i++)    {    fitness[i]    =    new    double[maxIterations];    }    	non-compiled	[CE]  	8	None	replace
46	[BUG]  [BUGGY]  cast(arxk);  [CE]  [FE]                  AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  cast(arxk);  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	cast(arxk);	  if(sigma!=    null)    {    for(int    i    =    0;    i    <    maxIterations;    i++)    {    arxk.add(times(diagD,arz.getRowMatrix(k)));    }    	non-compiled	[CE]  	33	None	replace
47	[BUG]  [BUGGY]  cast(arxk,  sigma));  [CE]  [FE]                    AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  cast(arxk,  sigma));  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	cast(arxk,  sigma));	  if(sigma!=    null)    {    for(int    i    =    0;    i    <    maxIterations;    i++)    {    arxk.add(times(diagD,arz.getRowMatrix(k)));    }    	non-compiled	[CE]  	33	None	replace
48	[BUG]  [BUGGY]  Magimize  pcCol  =  Math.min(lambda,  i);  [CE]  [FE]              AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  Magimize  pcCol  =  Math.min(lambda,  i);  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	Magimize  pcCol  =  Math.min(lambda,  i);	  if(sigma!=    null)    {    for(int    k    =    0;    k    <    lambda;    k++)    {    fitness[k]    =    new    double[maxIterations];    }    	non-compiled	[CE]  	36	None	replace
49	[BUG]  [BUGGY]  Magimize  pcCol  =  arxk.getImplicitMatrix();  [CE]  [FE]            AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  Magimize  pcCol  =  arxk.getImplicitMatrix();  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	Magimize  pcCol  =  arxk.getImplicitMatrix();	  if(sigma!=    null)    {    for(int    i    =    0;    i    <    checkFeasableCount;    i++)    {    fitness[i]    =    new    double[maxIterations];    }    	non-compiled	[CE]  	31	None	replace
50	[BUG]  [BUGGY]  Magimize  pcCol  =  generateStatistics  &&  pcCol!=  null  &&  pcCol.equals(i);  [CE]  [FE]                AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  Magimize  pcCol  =  generateStatistics  &&  pcCol!=  null  &&  pcCol.equals(i);  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	Magimize  pcCol  =  generateStatistics  &&  pcCol!=  null  &&  pcCol.equals(i);	  Magimize    pcCol    =    generateStatistics    &&    pcCol!=    null    &&    pcCol.equals(pcCol);    	non-compiled	[CE]  	25	None	replace
51	[BUG]  [BUGGY]  Iterator  <  Number>  iterations  =  arxk.iterator();  [CE]  [FE]                AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  Iterator  <  Number>  iterations  =  arxk.iterator();  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	Iterator  <  Number>  iterations  =  arxk.iterator();	  if(i    >    maxIterations)    {    for(iterations    =    1;    iterations    <    maxIterations;    iterations++)    {    fitness[i]    =    new    double[lambda];    }    	non-compiled	[CE]  	23	None	replace
52	[BUG]  [BUGGY]  Iterator  <  E>  iterations  =  arxk.iterator();  [CE]  [FE]                  AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  Iterator  <  E>  iterations  =  arxk.iterator();  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	Iterator  <  E>  iterations  =  arxk.iterator();	  if(i    >    maxIterations)    {    for(iterations    =    1;    iterations    <    maxIterations;    iterations++)    {    fitness[i]    =    new    double[lambda];    }    	non-compiled	[CE]  	23	None	replace
53	[BUG]  [BUGGY]  Magimize  pcCol  =  generateStatistics  &&  pcCol!=  null  &&  pcCol.isMultiply(i));  [CE]  [FE]                  AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  Magimize  pcCol  =  generateStatistics  &&  pcCol!=  null  &&  pcCol.isMultiply(i));  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	Magimize  pcCol  =  generateStatistics  &&  pcCol!=  null  &&  pcCol.isMultiply(i));	  Magimize    pcCol    =    generateStatistics    &&    pcCol!=    null    &&    pcCol.isMultiply(pcCol));    	non-compiled	[CE]  	26	None	replace
54	[BUG]  [BUGGY]  Magimize  pcCol  =  generateStatistics?  this  :  null;  [CE]  [FE]                AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  Magimize  pcCol  =  generateStatistics?  this  :  null;  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	Magimize  pcCol  =  generateStatistics?  this  :  null;	  if(sigma!=    null)    {    for(int    i    =    0;    i    <    maxIterations;    i++)    {    fitness[i]    =    new    double[minIterations];    }    	non-compiled	[CE]  	34	None	replace
55	[BUG]  [BUGGY]  ScmaFunction  <  T>  sc  =  getScammaFunction(i).getSigma();  [CE]  [FE]              AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  ScmaFunction  <  T>  sc  =  getScammaFunction(i).getSigma();  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	ScmaFunction  <  T>  sc  =  getScammaFunction(i).getSigma();	  ScmaFunction    <    T>    sc    =    getScamaFunction(i).getSigma();    	non-compiled	[CE]  	15	None	replace
56	[BUG]  [BUGGY]  Iterator  <  String>  iterations  =  fitness[i].iterator();  [CE]  [FE]                  AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  Iterator  <  String>  iterations  =  fitness[i].iterator();  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	Iterator  <  String>  iterations  =  fitness[i].iterator();	  if(i    >    maxIterations)    {    for(iterations    =    1;    iterations    <    maxIterations;    iterations++)    {    fitness[i]    =    new    double[lambda].doubleValue();    }    	non-compiled	[CE]  	24	None	replace
57	[BUG]  [BUGGY]  Iterator  <  Number>  iterations  =  fitness.iterator();  [CE]  [FE]                    AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  Iterator  <  Number>  iterations  =  fitness.iterator();  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	Iterator  <  Number>  iterations  =  fitness.iterator();	  if(i    >    maxIterations)    {    for(iterations    =    1;    iterations    <    maxIterations;    iterations++)    {    fitness[i]    =    new    double[lambda].doubleValue();    }    	non-compiled	[CE]  	24	None	replace
58	[BUG]  [BUGGY]  if  (i  >  maxIterations)  {  [CE]  [FE]              AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  if  (i  >  maxIterations)  {  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	if  (i  >  maxIterations)  {	  if    (i    <    maxIterations)    {    	non-compiled	[CE]  	18	None	replace
59	[BUG]  [BUGGY]  if(sigma!=  null)  {  safeMultiply(sigma)  {  for(int  i  =  0;  i  <  maxIterations;  i++)  {  fitness[i]  =  new  double[maxIterations];  }  }  [CE]  [FE]                AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  if(sigma!=  null)  {  safeMultiply(sigma)  {  for(int  i  =  0;  i  <  maxIterations;  i++)  {  fitness[i]  =  new  double[maxIterations];  }  }  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	if(sigma!=  null)  {  safeMultiply(sigma)  {  for(int  i  =  0;  i  <  maxIterations;  i++)  {  fitness[i]  =  new  double[maxIterations];  }  }	  safeMultiply(sigma)    {    for(int    i    =    0;    i    <    maxIterations;    i++)    {    fitness[i]    =    new    double[maxIterations];    }    	non-compiled	[CE]  	7	None	replace
60	[BUG]  [BUGGY]  Iterator  <  Class  <?>  iterations  =  fitness.iterator();  [CE]  [FE]                AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  Iterator  <  Class  <?>  iterations  =  fitness.iterator();  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	Iterator  <  Class  <?>  iterations  =  fitness.iterator();	  if(i    >    maxIterations)    {    for(iterations    =    1;    iterations    <    maxIterations;    iterations++)    {    fitness[i]    =    new    double[lambda];    }    	non-compiled	[CE]  	23	None	replace
61	[BUG]  [BUGGY]  Iterator  <  Number>  iterations  =  fitness[i].iterator();  [CE]  [FE]                  AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  Iterator  <  Number>  iterations  =  fitness[i].iterator();  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	Iterator  <  Number>  iterations  =  fitness[i].iterator();	  if(i    >    maxIterations)    {    for(iterations    =    1;    iterations    <    maxIterations;    iterations++)    {    fitness[i]    =    new    double[lambda].doubleValue();    }    	non-compiled	[CE]  	24	None	replace
62	[BUG]  [BUGGY]  ScmaFunction  <  T>  sc  =  getScalaFunction(i).getSigma();  [CE]  [FE]              AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  ScmaFunction  <  T>  sc  =  getScalaFunction(i).getSigma();  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	ScmaFunction  <  T>  sc  =  getScalaFunction(i).getSigma();	  ScmaFunction    <    T>    sc    =    getScamaFunction(i).getScala();    	non-compiled	[CE]  	38	None	replace
63	[BUG]  [BUGGY]  Magimize  pcCol  =  generateStatistics  ||  pcCol!=  null  &&  pcCol.equals(pcCol);  [CE]  [FE]                AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  Magimize  pcCol  =  generateStatistics  ||  pcCol!=  null  &&  pcCol.equals(pcCol);  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	Magimize  pcCol  =  generateStatistics  ||  pcCol!=  null  &&  pcCol.equals(pcCol);	  Magimize    pcCol    =    generateStatistics    &&    pcCol!=    null    &&    pcCol.equals(pcCol);    	non-compiled	[CE]  	25	None	replace
64	[BUG]  [BUGGY]  vice.add(BD.multiply(arz.getColumnMatrix(k)));  [CE]  [FE]                  AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  vice.add(BD.multiply(arz.getColumnMatrix(k)));  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	vice.add(BD.multiply(arz.getColumnMatrix(k)));	  if(sigma!=    null)    {    for(int    i    =    0;    i    <    maxIterations;    i++)    {    arxk.add(times(diagD,arz.getRowMatrix(k)));    }    	non-compiled	[CE]  	33	None	replace
65	[BUG]  [BUGGY]  [Delete]  [CE]  [FE]                AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  [Delete]  [BUGGY]      arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	[Delete]	  if(sigma!=    null)    {    for(int    i    =    0;    i    <    maxIterations;    i++)    {    arxk.add(times(diagD,arz.getColumnMatrix(k)).scalarMultiply(sigma));    }    	non-compiled	[CE]  	32	None	replace
66	[BUG]  [BUGGY]  Iterator  <  Class  <?>  iter  =  maxIterations.iterator();  [CE]  [FE]            AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  Iterator  <  Class  <?>  iter  =  maxIterations.iterator();  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	Iterator  <  Class  <?>  iter  =  maxIterations.iterator();	  if(sigma!=    null)    {    for(int    i    =    0;    i    <    checkFeasableCount;    i++)    {    fitness[i]    =    new    double[maxIterations];    }    	non-compiled	[CE]  	31	None	replace
67	[BUG]  [BUGGY]  Iterator  <  Number>  iterator  =  sigma.iterator();  [CE]  [FE]              AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  Iterator  <  Number>  iterator  =  sigma.iterator();  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	Iterator  <  Number>  iterator  =  sigma.iterator();	  if(sigma!=    null)    {    for(int    i    =    0;    i    <    checkFeasableCount;    i++)    {    fitness[i]    =    new    double[maxIterations];    }    	non-compiled	[CE]  	31	None	replace
68	[BUG]  [BUGGY]  if(sigma!=  null)  {  for(int  i  =  0;  i  <  minIterations;  i++)  {  fitness[i]  =  new  double[minIterations];  }  [CE]  [FE]                AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  if(sigma!=  null)  {  for(int  i  =  0;  i  <  minIterations;  i++)  {  fitness[i]  =  new  double[minIterations];  }  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	if(sigma!=  null)  {  for(int  i  =  0;  i  <  minIterations;  i++)  {  fitness[i]  =  new  double[minIterations];  }	  if(sigma!=    null)    {    for(int    i    =    0;    i    <    maxIterations;    i++)    {    fitness[i]    =    new    double[minIterations];    }    	non-compiled	[CE]  	34	None	replace
69	[BUG]  [BUGGY]  safeMultiply(sigma,  i  +  1);  [CE]  [FE]                AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  safeMultiply(sigma,  i  +  1);  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	safeMultiply(sigma,  i  +  1);	  safeMultiply(sigma,    i);    	non-compiled	[CE]  	10	None	replace
70	[BUG]  [BUGGY]  ScmaFunction  <  T>  sc  =  getScm(i).getScm(k,  i);  [CE]  [FE]              AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  ScmaFunction  <  T>  sc  =  getScm(i).getScm(k,  i);  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	ScmaFunction  <  T>  sc  =  getScm(i).getScm(k,  i);	  ScmaFunction    <    T>    sc    =    getScm(i).getScm(k);    	non-compiled	[CE]  	3	None	replace
71	[BUG]  [BUGGY]  ScmaFunction  <  T>  sc  =  getSambdaFunction(i).getSigma();  [CE]  [FE]            AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  ScmaFunction  <  T>  sc  =  getSambdaFunction(i).getSigma();  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	ScmaFunction  <  T>  sc  =  getSambdaFunction(i).getSigma();	  ScmaFunction    <    T>    sc    =    getScamaFunction(i).getSambda();    	non-compiled	[CE]  	37	None	replace
72	[BUG]  [BUGGY]  Iterator  <  Math.abs(lambda)  {  for(int  k  =  0;  k  <  lambda;  k++)  {  fitness[k]  =  new  double[maxIterations];  }  [CE]  [FE]              AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  Iterator  <  Math.abs(lambda)  {  for(int  k  =  0;  k  <  lambda;  k++)  {  fitness[k]  =  new  double[maxIterations];  }  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	Iterator  <  Math.abs(lambda)  {  for(int  k  =  0;  k  <  lambda;  k++)  {  fitness[k]  =  new  double[maxIterations];  }	  if(sigma!=    null)    {    for(int    k    =    0;    k    <    lambda;    k++)    {    fitness[k]    =    new    double[maxIterations];    }    	non-compiled	[CE]  	36	None	replace
73	[BUG]  [BUGGY]  Iterator  <  Math.abs(lambda)  {  for(int  k  =  0;  k  <  math.length;  k++)  {  fitness[k]  =  new  double[maxIterations];  }  [CE]  [FE]                AssertionError      [CONTEXT]      for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  final  RealMatrix  arz  =  randn1(dimension,  lambda);  final  RealMatrix  arx  =  zeros(dimension,  lambda);  final  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount  +  1;  i++)  {      [BUGGY]  Iterator  <  Math.abs(lambda)  {  for(int  k  =  0;  k  <  math.length;  k++)  {  fitness[k]  =  new  double[maxIterations];  }  [BUGGY]      if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  .scalarMultiply(sigma));  }  if  (i  >=  checkFeasableCount  ||  fitfun.isFeasible(arxk.getColumn(0)))  {  break;  }  [CLASS]  CMAESOptimizer  Sigma  PopulationSize  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  s  sigma  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  size  RandomGenerator  random  PointValuePair  current  lastResult  optimum  	projects/Math6/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java	0.7126966450997984	397	397	28	replace	Iterator  <  Math.abs(lambda)  {  for(int  k  =  0;  k  <  math.length;  k++)  {  fitness[k]  =  new  double[maxIterations];  }	  if(sigma!=    null)    {    for(int    k    =    0;    k    <    lambda;    k++)    {    fitness[k]    =    new    double[maxIterations];    }    	non-compiled	[CE]  	36	None	replace
