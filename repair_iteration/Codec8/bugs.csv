bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] lineLength = 0;// disable chunk-separating lineSeparator = CHUNK_SEPARATOR; // this just gets ignored } [FE] ArrayIndexOutOfBoundsException [CONTEXT] public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) { if (lineSeparator == null) { [BUGGY] lineLength = 0;// disable chunk-separating   lineSeparator = CHUNK_SEPARATOR; // this just gets ignored    } [BUGGY] lineSeparator = CHUNK_SEPARATOR;// this just gets ignored } this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0; this.lineSeparator = new byte[lineSeparator.length]; System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length); if (lineLength > 0) { this.encodeSize = 4 + lineSeparator.length; } else { this.encodeSize = 4; } [CLASS] Base64 [METHOD] <init> [RETURN_TYPE] Base64(int,byte[],boolean)  int lineLength byte[] lineSeparator boolean urlSafe [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE buffer encodeTable lineSeparator boolean eof urlSafe String sep byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE currentLinePos decodeSize encodeSize lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	1.0	334	336	1	replace	
2	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) { if (lineSeparator == null) { [BUGGY] [BUGGY] lineLength = 0;// disable chunk-separating   lineSeparator = CHUNK_SEPARATOR; // this just gets ignored    } lineSeparator = CHUNK_SEPARATOR;// this just gets ignored } this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0; this.lineSeparator = new byte[lineSeparator.length]; System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length); if (lineLength > 0) { this.encodeSize = 4 + lineSeparator.length; } else { this.encodeSize = 4; } [CLASS] Base64 [METHOD] <init> [RETURN_TYPE] Base64(int,byte[],boolean)  int lineLength byte[] lineSeparator boolean urlSafe [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE buffer encodeTable lineSeparator boolean eof urlSafe String sep byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE currentLinePos decodeSize encodeSize lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	1.0	334	336	1	add	
3	[BUG] [BUGGY] lineSeparator = CHUNK_SEPARATOR;// this just gets ignored } [FE] ArrayIndexOutOfBoundsException [CONTEXT] public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) { if (lineSeparator == null) { lineLength = 0;// disable chunk-separating [BUGGY] lineSeparator = CHUNK_SEPARATOR;// this just gets ignored  } [BUGGY] } this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0; this.lineSeparator = new byte[lineSeparator.length]; System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length); if (lineLength > 0) { this.encodeSize = 4 + lineSeparator.length; } else { this.encodeSize = 4; } this.decodeSize = this.encodeSize - 1; [CLASS] Base64 [METHOD] <init> [RETURN_TYPE] Base64(int,byte[],boolean)  int lineLength byte[] lineSeparator boolean urlSafe [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE buffer encodeTable lineSeparator boolean eof urlSafe String sep byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE currentLinePos decodeSize encodeSize lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	1.0	335	336	1	replace	
4	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) { if (lineSeparator == null) { lineLength = 0;// disable chunk-separating [BUGGY] [BUGGY] lineSeparator = CHUNK_SEPARATOR;// this just gets ignored  } } this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0; this.lineSeparator = new byte[lineSeparator.length]; System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length); if (lineLength > 0) { this.encodeSize = 4 + lineSeparator.length; } else { this.encodeSize = 4; } this.decodeSize = this.encodeSize - 1; [CLASS] Base64 [METHOD] <init> [RETURN_TYPE] Base64(int,byte[],boolean)  int lineLength byte[] lineSeparator boolean urlSafe [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE buffer encodeTable lineSeparator boolean eof urlSafe String sep byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE currentLinePos decodeSize encodeSize lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	1.0	335	336	1	add	
5	[BUG] [BUGGY] this.encodeSize = 4; [FE] ArrayIndexOutOfBoundsException [CONTEXT] if (lineSeparator == null) { lineLength = 0;// disable chunk-separating lineSeparator = CHUNK_SEPARATOR;// this just gets ignored } this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0; this.lineSeparator = new byte[lineSeparator.length]; System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length); if (lineLength > 0) { this.encodeSize = 4 + lineSeparator.length; } else { [BUGGY] this.encodeSize = 4; [BUGGY] } this.decodeSize = this.encodeSize - 1; if (containsBase64Byte(lineSeparator)) { String sep = StringUtils.newStringUtf8(lineSeparator); throw new IllegalArgumentException("lineSeperator must not contain base64 characters: [" + sep + "]"); } this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE; } [CLASS] Base64 [METHOD] <init> [RETURN_TYPE] Base64(int,byte[],boolean)  int lineLength byte[] lineSeparator boolean urlSafe [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE buffer encodeTable lineSeparator boolean eof urlSafe String sep byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE currentLinePos decodeSize encodeSize lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	343	343	1	replace	
6	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] if (lineSeparator == null) { lineLength = 0;// disable chunk-separating lineSeparator = CHUNK_SEPARATOR;// this just gets ignored } this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0; this.lineSeparator = new byte[lineSeparator.length]; System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length); if (lineLength > 0) { this.encodeSize = 4 + lineSeparator.length; } else { [BUGGY] [BUGGY] this.encodeSize = 4; } this.decodeSize = this.encodeSize - 1; if (containsBase64Byte(lineSeparator)) { String sep = StringUtils.newStringUtf8(lineSeparator); throw new IllegalArgumentException("lineSeperator must not contain base64 characters: [" + sep + "]"); } this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE; } [CLASS] Base64 [METHOD] <init> [RETURN_TYPE] Base64(int,byte[],boolean)  int lineLength byte[] lineSeparator boolean urlSafe [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE buffer encodeTable lineSeparator boolean eof urlSafe String sep byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE currentLinePos decodeSize encodeSize lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	343	343	1	add	
7	[BUG] [BUGGY] byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR]; [FE] ArrayIndexOutOfBoundsException [CONTEXT] private void resizeBuffer() { if (buffer == null) { buffer = new byte[DEFAULT_BUFFER_SIZE]; pos = 0; readPos = 0; } else { [BUGGY] byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR]; [BUGGY] System.arraycopy(buffer, 0, b, 0, buffer.length); buffer = b; } } [CLASS] Base64 [METHOD] resizeBuffer [RETURN_TYPE] void  [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE currentLinePos decodeSize encodeSize lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	388	388	1	replace	
8	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] private void resizeBuffer() { if (buffer == null) { buffer = new byte[DEFAULT_BUFFER_SIZE]; pos = 0; readPos = 0; } else { [BUGGY] [BUGGY] byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR]; System.arraycopy(buffer, 0, b, 0, buffer.length); buffer = b; } } [CLASS] Base64 [METHOD] resizeBuffer [RETURN_TYPE] void  [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE currentLinePos decodeSize encodeSize lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	388	388	1	add	
9	[BUG] [BUGGY] System.arraycopy(buffer, 0, b, 0, buffer.length); [FE] ArrayIndexOutOfBoundsException [CONTEXT] private void resizeBuffer() { if (buffer == null) { buffer = new byte[DEFAULT_BUFFER_SIZE]; pos = 0; readPos = 0; } else { byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR]; [BUGGY] System.arraycopy(buffer, 0, b, 0, buffer.length); [BUGGY] buffer = b; } } [CLASS] Base64 [METHOD] resizeBuffer [RETURN_TYPE] void  [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE currentLinePos decodeSize encodeSize lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	389	389	1	replace	
10	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] private void resizeBuffer() { if (buffer == null) { buffer = new byte[DEFAULT_BUFFER_SIZE]; pos = 0; readPos = 0; } else { byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR]; [BUGGY] [BUGGY] System.arraycopy(buffer, 0, b, 0, buffer.length); buffer = b; } } [CLASS] Base64 [METHOD] resizeBuffer [RETURN_TYPE] void  [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE currentLinePos decodeSize encodeSize lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	389	389	1	add	
11	[BUG] [BUGGY] buffer = b; [FE] ArrayIndexOutOfBoundsException [CONTEXT] private void resizeBuffer() { if (buffer == null) { buffer = new byte[DEFAULT_BUFFER_SIZE]; pos = 0; readPos = 0; } else { byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR]; System.arraycopy(buffer, 0, b, 0, buffer.length); [BUGGY] buffer = b; [BUGGY] } } [CLASS] Base64 [METHOD] resizeBuffer [RETURN_TYPE] void  [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE currentLinePos decodeSize encodeSize lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	390	390	1	replace	
12	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] private void resizeBuffer() { if (buffer == null) { buffer = new byte[DEFAULT_BUFFER_SIZE]; pos = 0; readPos = 0; } else { byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR]; System.arraycopy(buffer, 0, b, 0, buffer.length); [BUGGY] [BUGGY] buffer = b; } } [CLASS] Base64 [METHOD] resizeBuffer [RETURN_TYPE] void  [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE currentLinePos decodeSize encodeSize lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	390	390	1	add	
13	[BUG] [BUGGY] for (int i = 0; i < inAvail; i++) { [FE] ArrayIndexOutOfBoundsException [CONTEXT] break; }   byte b = lineSeparator[lineSeparator.length - 1]; if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) { System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length); pos += lineSeparator.length; } } else { [BUGGY] for (int i = 0; i < inAvail; i++) { [BUGGY] if (buffer == null || buffer.length - pos < encodeSize) { resizeBuffer(); } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { [CLASS] Base64 [METHOD] encode [RETURN_TYPE] void  byte[] in int inPos int inAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	484	484	1	replace	
14	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] break; }   byte b = lineSeparator[lineSeparator.length - 1]; if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) { System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length); pos += lineSeparator.length; } } else { [BUGGY] [BUGGY] for (int i = 0; i < inAvail; i++) { if (buffer == null || buffer.length - pos < encodeSize) { resizeBuffer(); } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { [CLASS] Base64 [METHOD] encode [RETURN_TYPE] void  byte[] in int inPos int inAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	484	484	1	add	
15	[BUG] [BUGGY] if (buffer == null || buffer.length - pos < encodeSize) { [FE] ArrayIndexOutOfBoundsException [CONTEXT] }   byte b = lineSeparator[lineSeparator.length - 1]; if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) { System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length); pos += lineSeparator.length; } } else { for (int i = 0; i < inAvail; i++) { [BUGGY] if (buffer == null || buffer.length - pos < encodeSize) { [BUGGY] resizeBuffer(); } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; [CLASS] Base64 [METHOD] encode [RETURN_TYPE] void  byte[] in int inPos int inAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	485	485	1	replace	
16	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] }   byte b = lineSeparator[lineSeparator.length - 1]; if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) { System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length); pos += lineSeparator.length; } } else { for (int i = 0; i < inAvail; i++) { [BUGGY] [BUGGY] if (buffer == null || buffer.length - pos < encodeSize) { resizeBuffer(); } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; [CLASS] Base64 [METHOD] encode [RETURN_TYPE] void  byte[] in int inPos int inAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	485	485	1	add	
17	[BUG] [BUGGY] resizeBuffer(); [FE] ArrayIndexOutOfBoundsException [CONTEXT]   byte b = lineSeparator[lineSeparator.length - 1]; if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) { System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length); pos += lineSeparator.length; } } else { for (int i = 0; i < inAvail; i++) { if (buffer == null || buffer.length - pos < encodeSize) { [BUGGY] resizeBuffer(); [BUGGY] } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; [CLASS] Base64 [METHOD] encode [RETURN_TYPE] void  byte[] in int inPos int inAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	486	486	1	replace	
18	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT]   byte b = lineSeparator[lineSeparator.length - 1]; if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) { System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length); pos += lineSeparator.length; } } else { for (int i = 0; i < inAvail; i++) { if (buffer == null || buffer.length - pos < encodeSize) { [BUGGY] [BUGGY] resizeBuffer(); } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; [CLASS] Base64 [METHOD] encode [RETURN_TYPE] void  byte[] in int inPos int inAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	486	486	1	add	
19	[BUG] [BUGGY] modulus = (++modulus) % 3; [FE] ArrayIndexOutOfBoundsException [CONTEXT] byte b = lineSeparator[lineSeparator.length - 1]; if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) { System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length); pos += lineSeparator.length; } } else { for (int i = 0; i < inAvail; i++) { if (buffer == null || buffer.length - pos < encodeSize) { resizeBuffer(); } [BUGGY] modulus = (++modulus) % 3; [BUGGY] int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buffer[pos++] = encodeTable[x & MASK_6BITS]; [CLASS] Base64 [METHOD] encode [RETURN_TYPE] void  byte[] in int inPos int inAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	488	488	1	replace	
20	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] byte b = lineSeparator[lineSeparator.length - 1]; if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) { System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length); pos += lineSeparator.length; } } else { for (int i = 0; i < inAvail; i++) { if (buffer == null || buffer.length - pos < encodeSize) { resizeBuffer(); } [BUGGY] [BUGGY] modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buffer[pos++] = encodeTable[x & MASK_6BITS]; [CLASS] Base64 [METHOD] encode [RETURN_TYPE] void  byte[] in int inPos int inAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	488	488	1	add	
21	[BUG] [BUGGY] int b = in[inPos++]; [FE] ArrayIndexOutOfBoundsException [CONTEXT] if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) { System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length); pos += lineSeparator.length; } } else { for (int i = 0; i < inAvail; i++) { if (buffer == null || buffer.length - pos < encodeSize) { resizeBuffer(); } modulus = (++modulus) % 3; [BUGGY] int b = in[inPos++]; [BUGGY] if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buffer[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; [CLASS] Base64 [METHOD] encode [RETURN_TYPE] void  byte[] in int inPos int inAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	489	489	1	replace	
22	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) { System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length); pos += lineSeparator.length; } } else { for (int i = 0; i < inAvail; i++) { if (buffer == null || buffer.length - pos < encodeSize) { resizeBuffer(); } modulus = (++modulus) % 3; [BUGGY] [BUGGY] int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buffer[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; [CLASS] Base64 [METHOD] encode [RETURN_TYPE] void  byte[] in int inPos int inAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	489	489	1	add	
23	[BUG] [BUGGY] if (b < 0) { [FE] ArrayIndexOutOfBoundsException [CONTEXT] System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length); pos += lineSeparator.length; } } else { for (int i = 0; i < inAvail; i++) { if (buffer == null || buffer.length - pos < encodeSize) { resizeBuffer(); } modulus = (++modulus) % 3; int b = in[inPos++]; [BUGGY] if (b < 0) { [BUGGY] b += 256; } x = (x << 8) + b; if (0 == modulus) { buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buffer[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; if (lineLength > 0 && lineLength <= currentLinePos) { [CLASS] Base64 [METHOD] encode [RETURN_TYPE] void  byte[] in int inPos int inAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	490	490	1	replace	
24	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length); pos += lineSeparator.length; } } else { for (int i = 0; i < inAvail; i++) { if (buffer == null || buffer.length - pos < encodeSize) { resizeBuffer(); } modulus = (++modulus) % 3; int b = in[inPos++]; [BUGGY] [BUGGY] if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buffer[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; if (lineLength > 0 && lineLength <= currentLinePos) { [CLASS] Base64 [METHOD] encode [RETURN_TYPE] void  byte[] in int inPos int inAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	490	490	1	add	
25	[BUG] [BUGGY] x = (x << 8) + b; [FE] ArrayIndexOutOfBoundsException [CONTEXT] } else { for (int i = 0; i < inAvail; i++) { if (buffer == null || buffer.length - pos < encodeSize) { resizeBuffer(); } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } [BUGGY] x = (x << 8) + b; [BUGGY] if (0 == modulus) { buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buffer[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; if (lineLength > 0 && lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length); pos += lineSeparator.length; currentLinePos = 0; [CLASS] Base64 [METHOD] encode [RETURN_TYPE] void  byte[] in int inPos int inAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	493	493	1	replace	
26	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] } else { for (int i = 0; i < inAvail; i++) { if (buffer == null || buffer.length - pos < encodeSize) { resizeBuffer(); } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } [BUGGY] [BUGGY] x = (x << 8) + b; if (0 == modulus) { buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buffer[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; if (lineLength > 0 && lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length); pos += lineSeparator.length; currentLinePos = 0; [CLASS] Base64 [METHOD] encode [RETURN_TYPE] void  byte[] in int inPos int inAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	493	493	1	add	
27	[BUG] [BUGGY] if (0 == modulus) { [FE] ArrayIndexOutOfBoundsException [CONTEXT] for (int i = 0; i < inAvail; i++) { if (buffer == null || buffer.length - pos < encodeSize) { resizeBuffer(); } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; [BUGGY] if (0 == modulus) { [BUGGY] buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buffer[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; if (lineLength > 0 && lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length); pos += lineSeparator.length; currentLinePos = 0; } [CLASS] Base64 [METHOD] encode [RETURN_TYPE] void  byte[] in int inPos int inAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	494	494	1	replace	
28	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] for (int i = 0; i < inAvail; i++) { if (buffer == null || buffer.length - pos < encodeSize) { resizeBuffer(); } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; [BUGGY] [BUGGY] if (0 == modulus) { buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buffer[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; if (lineLength > 0 && lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length); pos += lineSeparator.length; currentLinePos = 0; } [CLASS] Base64 [METHOD] encode [RETURN_TYPE] void  byte[] in int inPos int inAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	494	494	1	add	
29	[BUG] [BUGGY] buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; [FE] ArrayIndexOutOfBoundsException [CONTEXT] if (buffer == null || buffer.length - pos < encodeSize) { resizeBuffer(); } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { [BUGGY] buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; [BUGGY] buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buffer[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; if (lineLength > 0 && lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length); pos += lineSeparator.length; currentLinePos = 0; } } [CLASS] Base64 [METHOD] encode [RETURN_TYPE] void  byte[] in int inPos int inAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	495	495	1	replace	
30	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] if (buffer == null || buffer.length - pos < encodeSize) { resizeBuffer(); } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { [BUGGY] [BUGGY] buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buffer[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; if (lineLength > 0 && lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length); pos += lineSeparator.length; currentLinePos = 0; } } [CLASS] Base64 [METHOD] encode [RETURN_TYPE] void  byte[] in int inPos int inAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	495	495	1	add	
31	[BUG] [BUGGY] buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; [FE] ArrayIndexOutOfBoundsException [CONTEXT] resizeBuffer(); } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; [BUGGY] buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; [BUGGY] buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buffer[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; if (lineLength > 0 && lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length); pos += lineSeparator.length; currentLinePos = 0; } } } [CLASS] Base64 [METHOD] encode [RETURN_TYPE] void  byte[] in int inPos int inAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	496	496	1	replace	
32	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] resizeBuffer(); } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; [BUGGY] [BUGGY] buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buffer[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; if (lineLength > 0 && lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length); pos += lineSeparator.length; currentLinePos = 0; } } } [CLASS] Base64 [METHOD] encode [RETURN_TYPE] void  byte[] in int inPos int inAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	496	496	1	add	
33	[BUG] [BUGGY] buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; [FE] ArrayIndexOutOfBoundsException [CONTEXT] } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; [BUGGY] buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; [BUGGY] buffer[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; if (lineLength > 0 && lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length); pos += lineSeparator.length; currentLinePos = 0; } } } } [CLASS] Base64 [METHOD] encode [RETURN_TYPE] void  byte[] in int inPos int inAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	497	497	1	replace	
34	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; [BUGGY] [BUGGY] buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buffer[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; if (lineLength > 0 && lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length); pos += lineSeparator.length; currentLinePos = 0; } } } } [CLASS] Base64 [METHOD] encode [RETURN_TYPE] void  byte[] in int inPos int inAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.5773502691896258	497	497	1	add	
35	[BUG] [BUGGY] int r = read(singleByte, 0, 1); [FE] ArrayIndexOutOfBoundsException [CONTEXT] public int read() throws IOException { [BUGGY] int r = read(singleByte, 0, 1); [BUGGY] while (r == 0) { r = read(singleByte, 0, 1); } if (r > 0) { return singleByte[0] < 0 ? 256 + singleByte[0] : singleByte[0]; } return -1; } [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  [VARIABLES] byte[] lineSeparator singleByte boolean doEncode Base64 base64 int r  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4472135954999579	109	109	1	replace	
36	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] public int read() throws IOException { [BUGGY] [BUGGY] int r = read(singleByte, 0, 1); while (r == 0) { r = read(singleByte, 0, 1); } if (r > 0) { return singleByte[0] < 0 ? 256 + singleByte[0] : singleByte[0]; } return -1; } [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  [VARIABLES] byte[] lineSeparator singleByte boolean doEncode Base64 base64 int r  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4472135954999579	109	109	1	add	
37	[BUG] [BUGGY] base64.encode(buf, 0, c); [FE] ArrayIndexOutOfBoundsException [CONTEXT] This is a fix for CODEC-101  while (readLen == 0) { if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } if (doEncode) { [BUGGY] base64.encode(buf, 0, c); [BUGGY] } else { base64.decode(buf, 0, c); } } readLen = base64.readResults(b, offset, len); } return readLen; } } [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset readLen  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4472135954999579	173	173	1	replace	
38	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] This is a fix for CODEC-101  while (readLen == 0) { if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } if (doEncode) { [BUGGY] [BUGGY] base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } } readLen = base64.readResults(b, offset, len); } return readLen; } } [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset readLen  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4472135954999579	173	173	1	add	
39	[BUG] [BUGGY] if (eof) { [FE] ArrayIndexOutOfBoundsException [CONTEXT] void encode(byte[] in, int inPos, int inAvail) { [BUGGY] if (eof) { [BUGGY] return; }   if (inAvail < 0) { eof = true; if (buffer == null || buffer.length - pos < encodeSize) { resizeBuffer(); } switch (modulus) { [CLASS] Base64 [METHOD] encode [RETURN_TYPE] void  byte[] in int inPos int inAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.4472135954999579	445	445	1	replace	
40	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] void encode(byte[] in, int inPos, int inAvail) { [BUGGY] [BUGGY] if (eof) { return; }   if (inAvail < 0) { eof = true; if (buffer == null || buffer.length - pos < encodeSize) { resizeBuffer(); } switch (modulus) { [CLASS] Base64 [METHOD] encode [RETURN_TYPE] void  byte[] in int inPos int inAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.4472135954999579	445	445	1	add	
41	[BUG] [BUGGY] if (inAvail < 0) { [FE] ArrayIndexOutOfBoundsException [CONTEXT] void encode(byte[] in, int inPos, int inAvail) { if (eof) { return; }   [BUGGY] if (inAvail < 0) { [BUGGY] eof = true; if (buffer == null || buffer.length - pos < encodeSize) { resizeBuffer(); } switch (modulus) { case 1 : buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS]; buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];  if (encodeTable == STANDARD_ENCODE_TABLE) { [CLASS] Base64 [METHOD] encode [RETURN_TYPE] void  byte[] in int inPos int inAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.4472135954999579	450	450	1	replace	
42	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] void encode(byte[] in, int inPos, int inAvail) { if (eof) { return; }   [BUGGY] [BUGGY] if (inAvail < 0) { eof = true; if (buffer == null || buffer.length - pos < encodeSize) { resizeBuffer(); } switch (modulus) { case 1 : buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS]; buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];  if (encodeTable == STANDARD_ENCODE_TABLE) { [CLASS] Base64 [METHOD] encode [RETURN_TYPE] void  byte[] in int inPos int inAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.4472135954999579	450	450	1	add	
44	[BUG] [BUGGY] base64.setInitialBuffer(b, offset, len); [FE] ArrayIndexOutOfBoundsException [CONTEXT] being decoded was non-base64, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  while (readLen == 0) { if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); if (c > 0 && b.length == len) { [BUGGY] base64.setInitialBuffer(b, offset, len); [BUGGY] } if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } } readLen = base64.readResults(b, offset, len); } return readLen; [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset readLen  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	170	170	1	replace	
45	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] being decoded was non-base64, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  while (readLen == 0) { if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); if (c > 0 && b.length == len) { [BUGGY] [BUGGY] base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } } readLen = base64.readResults(b, offset, len); } return readLen; [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset readLen  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.4082482904638631	170	170	1	add	
46	[BUG] [BUGGY] if (out != null && out.length == outAvail) { [FE] ArrayIndexOutOfBoundsException [CONTEXT] void setInitialBuffer(byte[] out, int outPos, int outAvail) { [BUGGY] if (out != null && out.length == outAvail) { [BUGGY] buffer = out; pos = outPos; readPos = outPos; } } [CLASS] Base64 [METHOD] setInitialBuffer [RETURN_TYPE] void  byte[] out int outPos int outAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator out boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE bAvail bPos currentLinePos decodeSize encodeSize len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.4082482904638631	420	420	1	replace	
47	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] void setInitialBuffer(byte[] out, int outPos, int outAvail) { [BUGGY] [BUGGY] if (out != null && out.length == outAvail) { buffer = out; pos = outPos; readPos = outPos; } } [CLASS] Base64 [METHOD] setInitialBuffer [RETURN_TYPE] void  byte[] out int outPos int outAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator out boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE bAvail bPos currentLinePos decodeSize encodeSize len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.4082482904638631	420	420	1	add	
48	[BUG] [BUGGY] buffer = out; [FE] ArrayIndexOutOfBoundsException [CONTEXT] void setInitialBuffer(byte[] out, int outPos, int outAvail) { if (out != null && out.length == outAvail) { [BUGGY] buffer = out; [BUGGY] pos = outPos; readPos = outPos; } } [CLASS] Base64 [METHOD] setInitialBuffer [RETURN_TYPE] void  byte[] out int outPos int outAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator out boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE bAvail bPos currentLinePos decodeSize encodeSize len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.4082482904638631	421	421	1	replace	
49	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] void setInitialBuffer(byte[] out, int outPos, int outAvail) { if (out != null && out.length == outAvail) { [BUGGY] [BUGGY] buffer = out; pos = outPos; readPos = outPos; } } [CLASS] Base64 [METHOD] setInitialBuffer [RETURN_TYPE] void  byte[] out int outPos int outAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator out boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE bAvail bPos currentLinePos decodeSize encodeSize len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.4082482904638631	421	421	1	add	
50	[BUG] [BUGGY] pos = outPos; [FE] ArrayIndexOutOfBoundsException [CONTEXT] void setInitialBuffer(byte[] out, int outPos, int outAvail) { if (out != null && out.length == outAvail) { buffer = out; [BUGGY] pos = outPos; [BUGGY] readPos = outPos; } } [CLASS] Base64 [METHOD] setInitialBuffer [RETURN_TYPE] void  byte[] out int outPos int outAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator out boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE bAvail bPos currentLinePos decodeSize encodeSize len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.4082482904638631	422	422	1	replace	
51	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] void setInitialBuffer(byte[] out, int outPos, int outAvail) { if (out != null && out.length == outAvail) { buffer = out; [BUGGY] [BUGGY] pos = outPos; readPos = outPos; } } [CLASS] Base64 [METHOD] setInitialBuffer [RETURN_TYPE] void  byte[] out int outPos int outAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator out boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE bAvail bPos currentLinePos decodeSize encodeSize len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.4082482904638631	422	422	1	add	
52	[BUG] [BUGGY] readPos = outPos; [FE] ArrayIndexOutOfBoundsException [CONTEXT] void setInitialBuffer(byte[] out, int outPos, int outAvail) { if (out != null && out.length == outAvail) { buffer = out; pos = outPos; [BUGGY] readPos = outPos; [BUGGY] } } [CLASS] Base64 [METHOD] setInitialBuffer [RETURN_TYPE] void  byte[] out int outPos int outAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator out boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE bAvail bPos currentLinePos decodeSize encodeSize len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.4082482904638631	423	423	1	replace	
53	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] void setInitialBuffer(byte[] out, int outPos, int outAvail) { if (out != null && out.length == outAvail) { buffer = out; pos = outPos; [BUGGY] [BUGGY] readPos = outPos; } } [CLASS] Base64 [METHOD] setInitialBuffer [RETURN_TYPE] void  byte[] out int outPos int outAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator out boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE bAvail bPos currentLinePos decodeSize encodeSize len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.4082482904638631	423	423	1	add	
54	[BUG] [BUGGY] } [FE] ArrayIndexOutOfBoundsException [CONTEXT] void setInitialBuffer(byte[] out, int outPos, int outAvail) { if (out != null && out.length == outAvail) { buffer = out; pos = outPos; readPos = outPos; } [BUGGY] } [BUGGY]  [CLASS] Base64 [METHOD] setInitialBuffer [RETURN_TYPE] void  byte[] out int outPos int outAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator out boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE bAvail bPos currentLinePos decodeSize encodeSize len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.4082482904638631	425	425	1	replace	
55	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] void setInitialBuffer(byte[] out, int outPos, int outAvail) { if (out != null && out.length == outAvail) { buffer = out; pos = outPos; readPos = outPos; } [BUGGY] [BUGGY] } [CLASS] Base64 [METHOD] setInitialBuffer [RETURN_TYPE] void  byte[] out int outPos int outAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator out boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE bAvail bPos currentLinePos decodeSize encodeSize len lineLength modulus outAvail outPos pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.4082482904638631	425	425	1	add	
56	[BUG] [BUGGY] int readLen = 0; [FE] ArrayIndexOutOfBoundsException [CONTEXT] } else if (len == 0) { return 0; } else { [BUGGY] int readLen = 0; [BUGGY]  Rationale for while-loop on (readLen == 0): ----- Base64.readResults() usually returns > 0 or EOF (-1).In the rare case where it returns 0, we just keep trying. This is essentially an undocumented contract for InputStream implementors that want their code to work properly with java.io.InputStreamReader, since the latter hates it when InputStream.read(byte[]) returns a zero.Unfortunately our [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset readLen  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.35355339059327373	148	148	1	replace	
57	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] } else if (len == 0) { return 0; } else { [BUGGY] [BUGGY] int readLen = 0;  Rationale for while-loop on (readLen == 0): ----- Base64.readResults() usually returns > 0 or EOF (-1).In the rare case where it returns 0, we just keep trying. This is essentially an undocumented contract for InputStream implementors that want their code to work properly with java.io.InputStreamReader, since the latter hates it when InputStream.read(byte[]) returns a zero.Unfortunately our [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset readLen  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.35355339059327373	148	148	1	add	
58	[BUG] [BUGGY] while (readLen == 0) { [FE] ArrayIndexOutOfBoundsException [CONTEXT] This is essentially an undocumented contract for InputStream implementors that want their code to work properly with java.io.InputStreamReader, since the latter hates it when InputStream.read(byte[]) returns a zero.Unfortunately our readResults() call must return 0 if a large amount of the data being decoded was non-base64, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  [BUGGY] while (readLen == 0) { [BUGGY] if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset readLen  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.35355339059327373	165	165	1	replace	
59	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] This is essentially an undocumented contract for InputStream implementors that want their code to work properly with java.io.InputStreamReader, since the latter hates it when InputStream.read(byte[]) returns a zero.Unfortunately our readResults() call must return 0 if a large amount of the data being decoded was non-base64, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  [BUGGY] [BUGGY] while (readLen == 0) { if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset readLen  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.35355339059327373	165	165	1	add	
60	[BUG] [BUGGY] if (!base64.hasData()) { [FE] ArrayIndexOutOfBoundsException [CONTEXT] implementors that want their code to work properly with java.io.InputStreamReader, since the latter hates it when InputStream.read(byte[]) returns a zero.Unfortunately our readResults() call must return 0 if a large amount of the data being decoded was non-base64, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  while (readLen == 0) { [BUGGY] if (!base64.hasData()) { [BUGGY] byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset readLen  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.35355339059327373	166	166	1	replace	
61	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] implementors that want their code to work properly with java.io.InputStreamReader, since the latter hates it when InputStream.read(byte[]) returns a zero.Unfortunately our readResults() call must return 0 if a large amount of the data being decoded was non-base64, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  while (readLen == 0) { [BUGGY] [BUGGY] if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset readLen  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.35355339059327373	166	166	1	add	
62	[BUG] [BUGGY] byte[] buf = new byte[doEncode ? 4096 : 8192]; [FE] ArrayIndexOutOfBoundsException [CONTEXT] java.io.InputStreamReader, since the latter hates it when InputStream.read(byte[]) returns a zero.Unfortunately our readResults() call must return 0 if a large amount of the data being decoded was non-base64, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  while (readLen == 0) { if (!base64.hasData()) { [BUGGY] byte[] buf = new byte[doEncode ? 4096 : 8192]; [BUGGY] int c = in.read(buf); if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } } [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset readLen  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.35355339059327373	167	167	1	replace	
63	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] java.io.InputStreamReader, since the latter hates it when InputStream.read(byte[]) returns a zero.Unfortunately our readResults() call must return 0 if a large amount of the data being decoded was non-base64, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  while (readLen == 0) { if (!base64.hasData()) { [BUGGY] [BUGGY] byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } } [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset readLen  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.35355339059327373	167	167	1	add	
64	[BUG] [BUGGY] int c = in.read(buf); [FE] ArrayIndexOutOfBoundsException [CONTEXT] InputStream.read(byte[]) returns a zero.Unfortunately our readResults() call must return 0 if a large amount of the data being decoded was non-base64, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  while (readLen == 0) { if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; [BUGGY] int c = in.read(buf); [BUGGY] if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } } readLen = base64.readResults(b, offset, len); [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset readLen  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.35355339059327373	168	168	1	replace	
65	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] InputStream.read(byte[]) returns a zero.Unfortunately our readResults() call must return 0 if a large amount of the data being decoded was non-base64, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  while (readLen == 0) { if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; [BUGGY] [BUGGY] int c = in.read(buf); if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } } readLen = base64.readResults(b, offset, len); [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset readLen  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.35355339059327373	168	168	1	add	
66	[BUG] [BUGGY] if (c > 0 && b.length == len) { [FE] ArrayIndexOutOfBoundsException [CONTEXT] readResults() call must return 0 if a large amount of the data being decoded was non-base64, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  while (readLen == 0) { if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); [BUGGY] if (c > 0 && b.length == len) { [BUGGY] base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } } readLen = base64.readResults(b, offset, len); } [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset readLen  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.35355339059327373	169	169	1	replace	
67	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] readResults() call must return 0 if a large amount of the data being decoded was non-base64, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101  while (readLen == 0) { if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); [BUGGY] [BUGGY] if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } } readLen = base64.readResults(b, offset, len); } [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset readLen  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.35355339059327373	169	169	1	add	
68	[BUG] [BUGGY] if (doEncode) { [FE] ArrayIndexOutOfBoundsException [CONTEXT] ----- This is a fix for CODEC-101  while (readLen == 0) { if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } [BUGGY] if (doEncode) { [BUGGY] base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } } readLen = base64.readResults(b, offset, len); } return readLen; } } [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset readLen  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.35355339059327373	172	172	1	replace	
69	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] ----- This is a fix for CODEC-101  while (readLen == 0) { if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } [BUGGY] [BUGGY] if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } } readLen = base64.readResults(b, offset, len); } return readLen; } } [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset readLen  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.35355339059327373	172	172	1	add	
70	[BUG] [BUGGY] readLen = base64.readResults(b, offset, len); [FE] ArrayIndexOutOfBoundsException [CONTEXT] int c = in.read(buf); if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } } [BUGGY] readLen = base64.readResults(b, offset, len); [BUGGY] } return readLen; } } [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset readLen  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.35355339059327373	178	178	1	replace	
71	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] int c = in.read(buf); if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } } [BUGGY] [BUGGY] readLen = base64.readResults(b, offset, len); } return readLen; } } [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int  byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset readLen  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.35355339059327373	178	178	1	add	
72	[BUG] [BUGGY] return this.buffer != null; [FE] ArrayIndexOutOfBoundsException [CONTEXT] boolean hasData() { [BUGGY] return this.buffer != null; [BUGGY] } [CLASS] Base64 [METHOD] hasData [RETURN_TYPE] boolean  [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE currentLinePos decodeSize encodeSize lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.35355339059327373	369	369	1	replace	
73	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] boolean hasData() { [BUGGY] [BUGGY] return this.buffer != null; } [CLASS] Base64 [METHOD] hasData [RETURN_TYPE] boolean  [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE currentLinePos decodeSize encodeSize lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.35355339059327373	369	369	1	add	
74	[BUG] [BUGGY] return buffer != null ? pos - readPos : 0; [FE] ArrayIndexOutOfBoundsException [CONTEXT] int avail() { [BUGGY] return buffer != null ? pos - readPos : 0; [BUGGY] } [CLASS] Base64 [METHOD] avail [RETURN_TYPE] int  [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE currentLinePos decodeSize encodeSize lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.35355339059327373	378	378	1	replace	
75	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] int avail() { [BUGGY] [BUGGY] return buffer != null ? pos - readPos : 0; } [CLASS] Base64 [METHOD] avail [RETURN_TYPE] int  [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE currentLinePos decodeSize encodeSize lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.35355339059327373	378	378	1	add	
76	[BUG] [BUGGY] if (buffer == null) { [FE] ArrayIndexOutOfBoundsException [CONTEXT] private void resizeBuffer() { [BUGGY] if (buffer == null) { [BUGGY] buffer = new byte[DEFAULT_BUFFER_SIZE]; pos = 0; readPos = 0; } else { byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR]; System.arraycopy(buffer, 0, b, 0, buffer.length); buffer = b; } } [CLASS] Base64 [METHOD] resizeBuffer [RETURN_TYPE] void  [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE currentLinePos decodeSize encodeSize lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.35355339059327373	383	383	1	replace	
77	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] private void resizeBuffer() { [BUGGY] [BUGGY] if (buffer == null) { buffer = new byte[DEFAULT_BUFFER_SIZE]; pos = 0; readPos = 0; } else { byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR]; System.arraycopy(buffer, 0, b, 0, buffer.length); buffer = b; } } [CLASS] Base64 [METHOD] resizeBuffer [RETURN_TYPE] void  [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE currentLinePos decodeSize encodeSize lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.35355339059327373	383	383	1	add	
78	[BUG] [BUGGY] } [FE] ArrayIndexOutOfBoundsException [CONTEXT] private void resizeBuffer() { if (buffer == null) { buffer = new byte[DEFAULT_BUFFER_SIZE]; pos = 0; readPos = 0; } else { byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR]; System.arraycopy(buffer, 0, b, 0, buffer.length); buffer = b; } [BUGGY] } [BUGGY]  [CLASS] Base64 [METHOD] resizeBuffer [RETURN_TYPE] void  [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE currentLinePos decodeSize encodeSize lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.35355339059327373	392	392	1	replace	
79	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] private void resizeBuffer() { if (buffer == null) { buffer = new byte[DEFAULT_BUFFER_SIZE]; pos = 0; readPos = 0; } else { byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR]; System.arraycopy(buffer, 0, b, 0, buffer.length); buffer = b; } [BUGGY] [BUGGY] } [CLASS] Base64 [METHOD] resizeBuffer [RETURN_TYPE] void  [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE currentLinePos decodeSize encodeSize lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.35355339059327373	392	392	1	add	
80	[BUG] [BUGGY] if (buffer != null) { [FE] ArrayIndexOutOfBoundsException [CONTEXT] int readResults(byte[] b, int bPos, int bAvail) { [BUGGY] if (buffer != null) { [BUGGY] int len = Math.min(avail(), bAvail); System.arraycopy(buffer, readPos, b, bPos, len); readPos += len; if (readPos >= pos) { buffer = null; } return len; } return eof ? -1 : 0; } [CLASS] Base64 [METHOD] readResults [RETURN_TYPE] int  byte[] b int bPos int bAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE bAvail bPos currentLinePos decodeSize encodeSize len lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.35355339059327373	407	407	1	replace	
81	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] int readResults(byte[] b, int bPos, int bAvail) { [BUGGY] [BUGGY] if (buffer != null) { int len = Math.min(avail(), bAvail); System.arraycopy(buffer, readPos, b, bPos, len); readPos += len; if (readPos >= pos) { buffer = null; } return len; } return eof ? -1 : 0; } [CLASS] Base64 [METHOD] readResults [RETURN_TYPE] int  byte[] b int bPos int bAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE bAvail bPos currentLinePos decodeSize encodeSize len lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.35355339059327373	407	407	1	add	
82	[BUG] [BUGGY] int len = Math.min(avail(), bAvail); [FE] ArrayIndexOutOfBoundsException [CONTEXT] int readResults(byte[] b, int bPos, int bAvail) { if (buffer != null) { [BUGGY] int len = Math.min(avail(), bAvail); [BUGGY] System.arraycopy(buffer, readPos, b, bPos, len); readPos += len; if (readPos >= pos) { buffer = null; } return len; } return eof ? -1 : 0; } [CLASS] Base64 [METHOD] readResults [RETURN_TYPE] int  byte[] b int bPos int bAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE bAvail bPos currentLinePos decodeSize encodeSize len lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.35355339059327373	408	408	1	replace	
83	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] int readResults(byte[] b, int bPos, int bAvail) { if (buffer != null) { [BUGGY] [BUGGY] int len = Math.min(avail(), bAvail); System.arraycopy(buffer, readPos, b, bPos, len); readPos += len; if (readPos >= pos) { buffer = null; } return len; } return eof ? -1 : 0; } [CLASS] Base64 [METHOD] readResults [RETURN_TYPE] int  byte[] b int bPos int bAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE bAvail bPos currentLinePos decodeSize encodeSize len lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.35355339059327373	408	408	1	add	
84	[BUG] [BUGGY] System.arraycopy(buffer, readPos, b, bPos, len); [FE] ArrayIndexOutOfBoundsException [CONTEXT] int readResults(byte[] b, int bPos, int bAvail) { if (buffer != null) { int len = Math.min(avail(), bAvail); [BUGGY] System.arraycopy(buffer, readPos, b, bPos, len); [BUGGY] readPos += len; if (readPos >= pos) { buffer = null; } return len; } return eof ? -1 : 0; } [CLASS] Base64 [METHOD] readResults [RETURN_TYPE] int  byte[] b int bPos int bAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE bAvail bPos currentLinePos decodeSize encodeSize len lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.35355339059327373	409	409	1	replace	
85	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] int readResults(byte[] b, int bPos, int bAvail) { if (buffer != null) { int len = Math.min(avail(), bAvail); [BUGGY] [BUGGY] System.arraycopy(buffer, readPos, b, bPos, len); readPos += len; if (readPos >= pos) { buffer = null; } return len; } return eof ? -1 : 0; } [CLASS] Base64 [METHOD] readResults [RETURN_TYPE] int  byte[] b int bPos int bAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE bAvail bPos currentLinePos decodeSize encodeSize len lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.35355339059327373	409	409	1	add	
86	[BUG] [BUGGY] readPos += len; [FE] ArrayIndexOutOfBoundsException [CONTEXT] int readResults(byte[] b, int bPos, int bAvail) { if (buffer != null) { int len = Math.min(avail(), bAvail); System.arraycopy(buffer, readPos, b, bPos, len); [BUGGY] readPos += len; [BUGGY] if (readPos >= pos) { buffer = null; } return len; } return eof ? -1 : 0; } [CLASS] Base64 [METHOD] readResults [RETURN_TYPE] int  byte[] b int bPos int bAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE bAvail bPos currentLinePos decodeSize encodeSize len lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.35355339059327373	410	410	1	replace	
87	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] int readResults(byte[] b, int bPos, int bAvail) { if (buffer != null) { int len = Math.min(avail(), bAvail); System.arraycopy(buffer, readPos, b, bPos, len); [BUGGY] [BUGGY] readPos += len; if (readPos >= pos) { buffer = null; } return len; } return eof ? -1 : 0; } [CLASS] Base64 [METHOD] readResults [RETURN_TYPE] int  byte[] b int bPos int bAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE bAvail bPos currentLinePos decodeSize encodeSize len lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.35355339059327373	410	410	1	add	
88	[BUG] [BUGGY] if (readPos >= pos) { [FE] ArrayIndexOutOfBoundsException [CONTEXT] int readResults(byte[] b, int bPos, int bAvail) { if (buffer != null) { int len = Math.min(avail(), bAvail); System.arraycopy(buffer, readPos, b, bPos, len); readPos += len; [BUGGY] if (readPos >= pos) { [BUGGY] buffer = null; } return len; } return eof ? -1 : 0; } [CLASS] Base64 [METHOD] readResults [RETURN_TYPE] int  byte[] b int bPos int bAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE bAvail bPos currentLinePos decodeSize encodeSize len lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.35355339059327373	411	411	1	replace	
89	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] int readResults(byte[] b, int bPos, int bAvail) { if (buffer != null) { int len = Math.min(avail(), bAvail); System.arraycopy(buffer, readPos, b, bPos, len); readPos += len; [BUGGY] [BUGGY] if (readPos >= pos) { buffer = null; } return len; } return eof ? -1 : 0; } [CLASS] Base64 [METHOD] readResults [RETURN_TYPE] int  byte[] b int bPos int bAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE bAvail bPos currentLinePos decodeSize encodeSize len lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.35355339059327373	411	411	1	add	
90	[BUG] [BUGGY] buffer = null; [FE] ArrayIndexOutOfBoundsException [CONTEXT] int readResults(byte[] b, int bPos, int bAvail) { if (buffer != null) { int len = Math.min(avail(), bAvail); System.arraycopy(buffer, readPos, b, bPos, len); readPos += len; if (readPos >= pos) { [BUGGY] buffer = null; [BUGGY] } return len; } return eof ? -1 : 0; } [CLASS] Base64 [METHOD] readResults [RETURN_TYPE] int  byte[] b int bPos int bAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE bAvail bPos currentLinePos decodeSize encodeSize len lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.35355339059327373	412	412	1	replace	
91	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] int readResults(byte[] b, int bPos, int bAvail) { if (buffer != null) { int len = Math.min(avail(), bAvail); System.arraycopy(buffer, readPos, b, bPos, len); readPos += len; if (readPos >= pos) { [BUGGY] [BUGGY] buffer = null; } return len; } return eof ? -1 : 0; } [CLASS] Base64 [METHOD] readResults [RETURN_TYPE] int  byte[] b int bPos int bAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE bAvail bPos currentLinePos decodeSize encodeSize len lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.35355339059327373	412	412	1	add	
92	[BUG] [BUGGY] return len; [FE] ArrayIndexOutOfBoundsException [CONTEXT] int readResults(byte[] b, int bPos, int bAvail) { if (buffer != null) { int len = Math.min(avail(), bAvail); System.arraycopy(buffer, readPos, b, bPos, len); readPos += len; if (readPos >= pos) { buffer = null; } [BUGGY] return len; [BUGGY] } return eof ? -1 : 0; } [CLASS] Base64 [METHOD] readResults [RETURN_TYPE] int  byte[] b int bPos int bAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE bAvail bPos currentLinePos decodeSize encodeSize len lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.35355339059327373	414	414	1	replace	
93	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] int readResults(byte[] b, int bPos, int bAvail) { if (buffer != null) { int len = Math.min(avail(), bAvail); System.arraycopy(buffer, readPos, b, bPos, len); readPos += len; if (readPos >= pos) { buffer = null; } [BUGGY] [BUGGY] return len; } return eof ? -1 : 0; } [CLASS] Base64 [METHOD] readResults [RETURN_TYPE] int  byte[] b int bPos int bAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE bAvail bPos currentLinePos decodeSize encodeSize len lineLength modulus pos readPos x  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64.java	0.35355339059327373	414	414	1	add	
94	[BUG] [BUGGY] super(in); [FE] ArrayIndexOutOfBoundsException [CONTEXT] public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) { [BUGGY] super(in); [BUGGY] this.doEncode = doEncode; this.base64 = new Base64(lineLength, lineSeparator); } [CLASS] Base64InputStream [METHOD] <init> [RETURN_TYPE] InputStream,boolean,int,byte[])  InputStream in boolean doEncode int lineLength byte[] lineSeparator [VARIABLES] byte[] lineSeparator singleByte boolean doEncode Base64 base64 InputStream in int lineLength  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.3333333333333333	96	96	1	replace	
95	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) { [BUGGY] [BUGGY] super(in); this.doEncode = doEncode; this.base64 = new Base64(lineLength, lineSeparator); } [CLASS] Base64InputStream [METHOD] <init> [RETURN_TYPE] InputStream,boolean,int,byte[])  InputStream in boolean doEncode int lineLength byte[] lineSeparator [VARIABLES] byte[] lineSeparator singleByte boolean doEncode Base64 base64 InputStream in int lineLength  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.3333333333333333	96	96	1	add	
96	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] private final Base64 base64; [CLASS] Base64InputStream  [VARIABLES] 	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.3333333333333333	52	52	1	replace	
97	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] private final Base64 base64; [CLASS] Base64InputStream  [VARIABLES] 	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.3333333333333333	52	52	1	add	
98	[BUG] [BUGGY] this.doEncode = doEncode; [FE] ArrayIndexOutOfBoundsException [CONTEXT] public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) { super(in); [BUGGY] this.doEncode = doEncode; [BUGGY] this.base64 = new Base64(lineLength, lineSeparator); } [CLASS] Base64InputStream [METHOD] <init> [RETURN_TYPE] InputStream,boolean,int,byte[])  InputStream in boolean doEncode int lineLength byte[] lineSeparator [VARIABLES] byte[] lineSeparator singleByte boolean doEncode Base64 base64 InputStream in int lineLength  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.3333333333333333	97	97	1	replace	
99	[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException [CONTEXT] public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) { super(in); [BUGGY] [BUGGY] this.doEncode = doEncode; this.base64 = new Base64(lineLength, lineSeparator); } [CLASS] Base64InputStream [METHOD] <init> [RETURN_TYPE] InputStream,boolean,int,byte[])  InputStream in boolean doEncode int lineLength byte[] lineSeparator [VARIABLES] byte[] lineSeparator singleByte boolean doEncode Base64 base64 InputStream in int lineLength  	projects/Codec8/src/java/org/apache/commons/codec/binary/Base64InputStream.java	0.3333333333333333	97	97	1	add	
