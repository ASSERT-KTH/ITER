bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] final double convergence, final int maxIterationCount) { [FE] MathRuntimeException$4 [CONTEXT] public EventState(final EventHandler handler, final double maxCheckInterval, [BUGGY] final double convergence, final int maxIterationCount) { [BUGGY] this.handler = handler; this.maxCheckInterval= maxCheckInterval; this.convergence = Math.abs(convergence); this.maxIterationCount = maxIterationCount;  t0= Double.NaN; g0= Double.NaN; g0Positive= true; pendingEvent= false; [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	95	95	1	replace	
2	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] public EventState(final EventHandler handler, final double maxCheckInterval, [BUGGY] [BUGGY] final double convergence, final int maxIterationCount) { this.handler = handler; this.maxCheckInterval= maxCheckInterval; this.convergence = Math.abs(convergence); this.maxIterationCount = maxIterationCount;  t0= Double.NaN; g0= Double.NaN; g0Positive= true; pendingEvent= false; [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	95	95	1	add	
3	[BUG] [BUGGY] this.handler = handler; [FE] MathRuntimeException$4 [CONTEXT] public EventState(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount) { [BUGGY] this.handler = handler; [BUGGY] this.maxCheckInterval= maxCheckInterval; this.convergence = Math.abs(convergence); this.maxIterationCount = maxIterationCount;  t0= Double.NaN; g0= Double.NaN; g0Positive= true; pendingEvent= false; pendingEventTime= Double.NaN; [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	96	96	1	replace	
4	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] public EventState(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount) { [BUGGY] [BUGGY] this.handler = handler; this.maxCheckInterval= maxCheckInterval; this.convergence = Math.abs(convergence); this.maxIterationCount = maxIterationCount;  t0= Double.NaN; g0= Double.NaN; g0Positive= true; pendingEvent= false; pendingEventTime= Double.NaN; [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	96	96	1	add	
5	[BUG] [BUGGY] this.maxCheckInterval= maxCheckInterval; [FE] MathRuntimeException$4 [CONTEXT] public EventState(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount) { this.handler = handler; [BUGGY] this.maxCheckInterval= maxCheckInterval; [BUGGY] this.convergence = Math.abs(convergence); this.maxIterationCount = maxIterationCount;  t0= Double.NaN; g0= Double.NaN; g0Positive= true; pendingEvent= false; pendingEventTime= Double.NaN; previousEventTime = Double.NaN; [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	97	97	1	replace	
6	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] public EventState(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount) { this.handler = handler; [BUGGY] [BUGGY] this.maxCheckInterval= maxCheckInterval; this.convergence = Math.abs(convergence); this.maxIterationCount = maxIterationCount;  t0= Double.NaN; g0= Double.NaN; g0Positive= true; pendingEvent= false; pendingEventTime= Double.NaN; previousEventTime = Double.NaN; [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	97	97	1	add	
7	[BUG] [BUGGY] this.convergence = Math.abs(convergence); [FE] MathRuntimeException$4 [CONTEXT] public EventState(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount) { this.handler = handler; this.maxCheckInterval= maxCheckInterval; [BUGGY] this.convergence = Math.abs(convergence); [BUGGY] this.maxIterationCount = maxIterationCount;  t0= Double.NaN; g0= Double.NaN; g0Positive= true; pendingEvent= false; pendingEventTime= Double.NaN; previousEventTime = Double.NaN; increasing= true; [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	98	98	1	replace	
8	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] public EventState(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount) { this.handler = handler; this.maxCheckInterval= maxCheckInterval; [BUGGY] [BUGGY] this.convergence = Math.abs(convergence); this.maxIterationCount = maxIterationCount;  t0= Double.NaN; g0= Double.NaN; g0Positive= true; pendingEvent= false; pendingEventTime= Double.NaN; previousEventTime = Double.NaN; increasing= true; [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	98	98	1	add	
9	[BUG] [BUGGY] this.maxIterationCount = maxIterationCount; [FE] MathRuntimeException$4 [CONTEXT] public EventState(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount) { this.handler = handler; this.maxCheckInterval= maxCheckInterval; this.convergence = Math.abs(convergence); [BUGGY] this.maxIterationCount = maxIterationCount; [BUGGY]   t0= Double.NaN; g0= Double.NaN; g0Positive= true; pendingEvent= false; pendingEventTime= Double.NaN; previousEventTime = Double.NaN; increasing= true; nextAction= EventHandler.CONTINUE; [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	99	99	1	replace	
10	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] public EventState(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount) { this.handler = handler; this.maxCheckInterval= maxCheckInterval; this.convergence = Math.abs(convergence); [BUGGY] [BUGGY] this.maxIterationCount = maxIterationCount;  t0= Double.NaN; g0= Double.NaN; g0Positive= true; pendingEvent= false; pendingEventTime= Double.NaN; previousEventTime = Double.NaN; increasing= true; nextAction= EventHandler.CONTINUE; [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	99	99	1	add	
11	[BUG] [BUGGY] t0= Double.NaN; [FE] MathRuntimeException$4 [CONTEXT] public EventState(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount) { this.handler = handler; this.maxCheckInterval= maxCheckInterval; this.convergence = Math.abs(convergence); this.maxIterationCount = maxIterationCount;  [BUGGY] t0= Double.NaN; [BUGGY] g0= Double.NaN; g0Positive= true; pendingEvent= false; pendingEventTime= Double.NaN; previousEventTime = Double.NaN; increasing= true; nextAction= EventHandler.CONTINUE; } [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	102	102	1	replace	
12	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] public EventState(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount) { this.handler = handler; this.maxCheckInterval= maxCheckInterval; this.convergence = Math.abs(convergence); this.maxIterationCount = maxIterationCount;  [BUGGY] [BUGGY] t0= Double.NaN; g0= Double.NaN; g0Positive= true; pendingEvent= false; pendingEventTime= Double.NaN; previousEventTime = Double.NaN; increasing= true; nextAction= EventHandler.CONTINUE; } [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	102	102	1	add	
13	[BUG] [BUGGY] g0= Double.NaN; [FE] MathRuntimeException$4 [CONTEXT] public EventState(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount) { this.handler = handler; this.maxCheckInterval= maxCheckInterval; this.convergence = Math.abs(convergence); this.maxIterationCount = maxIterationCount;  t0= Double.NaN; [BUGGY] g0= Double.NaN; [BUGGY] g0Positive= true; pendingEvent= false; pendingEventTime= Double.NaN; previousEventTime = Double.NaN; increasing= true; nextAction= EventHandler.CONTINUE; } [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	103	103	1	replace	
14	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] public EventState(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount) { this.handler = handler; this.maxCheckInterval= maxCheckInterval; this.convergence = Math.abs(convergence); this.maxIterationCount = maxIterationCount;  t0= Double.NaN; [BUGGY] [BUGGY] g0= Double.NaN; g0Positive= true; pendingEvent= false; pendingEventTime= Double.NaN; previousEventTime = Double.NaN; increasing= true; nextAction= EventHandler.CONTINUE; } [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	103	103	1	add	
15	[BUG] [BUGGY] g0Positive= true; [FE] MathRuntimeException$4 [CONTEXT] public EventState(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount) { this.handler = handler; this.maxCheckInterval= maxCheckInterval; this.convergence = Math.abs(convergence); this.maxIterationCount = maxIterationCount;  t0= Double.NaN; g0= Double.NaN; [BUGGY] g0Positive= true; [BUGGY] pendingEvent= false; pendingEventTime= Double.NaN; previousEventTime = Double.NaN; increasing= true; nextAction= EventHandler.CONTINUE; } [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	104	104	1	replace	
16	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] public EventState(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount) { this.handler = handler; this.maxCheckInterval= maxCheckInterval; this.convergence = Math.abs(convergence); this.maxIterationCount = maxIterationCount;  t0= Double.NaN; g0= Double.NaN; [BUGGY] [BUGGY] g0Positive= true; pendingEvent= false; pendingEventTime= Double.NaN; previousEventTime = Double.NaN; increasing= true; nextAction= EventHandler.CONTINUE; } [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	104	104	1	add	
17	[BUG] [BUGGY] pendingEvent= false; [FE] MathRuntimeException$4 [CONTEXT] final double convergence, final int maxIterationCount) { this.handler = handler; this.maxCheckInterval= maxCheckInterval; this.convergence = Math.abs(convergence); this.maxIterationCount = maxIterationCount;  t0= Double.NaN; g0= Double.NaN; g0Positive= true; [BUGGY] pendingEvent= false; [BUGGY] pendingEventTime= Double.NaN; previousEventTime = Double.NaN; increasing= true; nextAction= EventHandler.CONTINUE; } [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	105	105	1	replace	
18	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] final double convergence, final int maxIterationCount) { this.handler = handler; this.maxCheckInterval= maxCheckInterval; this.convergence = Math.abs(convergence); this.maxIterationCount = maxIterationCount;  t0= Double.NaN; g0= Double.NaN; g0Positive= true; [BUGGY] [BUGGY] pendingEvent= false; pendingEventTime= Double.NaN; previousEventTime = Double.NaN; increasing= true; nextAction= EventHandler.CONTINUE; } [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	105	105	1	add	
19	[BUG] [BUGGY] pendingEventTime= Double.NaN; [FE] MathRuntimeException$4 [CONTEXT] this.handler = handler; this.maxCheckInterval= maxCheckInterval; this.convergence = Math.abs(convergence); this.maxIterationCount = maxIterationCount;  t0= Double.NaN; g0= Double.NaN; g0Positive= true; pendingEvent= false; [BUGGY] pendingEventTime= Double.NaN; [BUGGY] previousEventTime = Double.NaN; increasing= true; nextAction= EventHandler.CONTINUE; } [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	106	106	1	replace	
20	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] this.handler = handler; this.maxCheckInterval= maxCheckInterval; this.convergence = Math.abs(convergence); this.maxIterationCount = maxIterationCount;  t0= Double.NaN; g0= Double.NaN; g0Positive= true; pendingEvent= false; [BUGGY] [BUGGY] pendingEventTime= Double.NaN; previousEventTime = Double.NaN; increasing= true; nextAction= EventHandler.CONTINUE; } [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	106	106	1	add	
21	[BUG] [BUGGY] previousEventTime = Double.NaN; [FE] MathRuntimeException$4 [CONTEXT] this.maxCheckInterval= maxCheckInterval; this.convergence = Math.abs(convergence); this.maxIterationCount = maxIterationCount;  t0= Double.NaN; g0= Double.NaN; g0Positive= true; pendingEvent= false; pendingEventTime= Double.NaN; [BUGGY] previousEventTime = Double.NaN; [BUGGY] increasing= true; nextAction= EventHandler.CONTINUE; } [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	107	107	1	replace	
22	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] this.maxCheckInterval= maxCheckInterval; this.convergence = Math.abs(convergence); this.maxIterationCount = maxIterationCount;  t0= Double.NaN; g0= Double.NaN; g0Positive= true; pendingEvent= false; pendingEventTime= Double.NaN; [BUGGY] [BUGGY] previousEventTime = Double.NaN; increasing= true; nextAction= EventHandler.CONTINUE; } [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	107	107	1	add	
23	[BUG] [BUGGY] increasing= true; [FE] MathRuntimeException$4 [CONTEXT] this.convergence = Math.abs(convergence); this.maxIterationCount = maxIterationCount;  t0= Double.NaN; g0= Double.NaN; g0Positive= true; pendingEvent= false; pendingEventTime= Double.NaN; previousEventTime = Double.NaN; [BUGGY] increasing= true; [BUGGY] nextAction= EventHandler.CONTINUE; } [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	108	108	1	replace	
24	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] this.convergence = Math.abs(convergence); this.maxIterationCount = maxIterationCount;  t0= Double.NaN; g0= Double.NaN; g0Positive= true; pendingEvent= false; pendingEventTime= Double.NaN; previousEventTime = Double.NaN; [BUGGY] [BUGGY] increasing= true; nextAction= EventHandler.CONTINUE; } [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	108	108	1	add	
25	[BUG] [BUGGY] nextAction= EventHandler.CONTINUE; [FE] MathRuntimeException$4 [CONTEXT] this.maxIterationCount = maxIterationCount;  t0= Double.NaN; g0= Double.NaN; g0Positive= true; pendingEvent= false; pendingEventTime= Double.NaN; previousEventTime = Double.NaN; increasing= true; [BUGGY] nextAction= EventHandler.CONTINUE; [BUGGY]  } [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	109	109	1	replace	
26	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] this.maxIterationCount = maxIterationCount;  t0= Double.NaN; g0= Double.NaN; g0Positive= true; pendingEvent= false; pendingEventTime= Double.NaN; previousEventTime = Double.NaN; increasing= true; [BUGGY] [BUGGY] nextAction= EventHandler.CONTINUE; } [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	109	109	1	add	
27	[BUG] [BUGGY] } [FE] MathRuntimeException$4 [CONTEXT]  t0= Double.NaN; g0= Double.NaN; g0Positive= true; pendingEvent= false; pendingEventTime= Double.NaN; previousEventTime = Double.NaN; increasing= true; nextAction= EventHandler.CONTINUE; [BUGGY] } [BUGGY]  [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	111	111	1	replace	
28	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT]  t0= Double.NaN; g0= Double.NaN; g0Positive= true; pendingEvent= false; pendingEventTime= Double.NaN; previousEventTime = Double.NaN; increasing= true; nextAction= EventHandler.CONTINUE; [BUGGY] [BUGGY] } [CLASS] EventState 1 [METHOD] <init> [RETURN_TYPE] EventHandler,double,double,int)  EventHandler handler final double maxCheckInterval final double convergence final int maxIterationCount [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	111	111	1	add	
29	[BUG] [BUGGY] t0 = tStart; [FE] MathRuntimeException$4 [CONTEXT] public void reinitializeBegin(final double tStart, final double[] yStart) throws EventException { [BUGGY] t0 = tStart; [BUGGY] g0 = handler.g(tStart, yStart); g0Positive = g0 >= 0; } [CLASS] EventState 1 [METHOD] reinitializeBegin [RETURN_TYPE] void  final double tStart final double[] yStart [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double[] yStart double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 tStart int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	151	151	1	replace	
30	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] public void reinitializeBegin(final double tStart, final double[] yStart) throws EventException { [BUGGY] [BUGGY] t0 = tStart; g0 = handler.g(tStart, yStart); g0Positive = g0 >= 0; } [CLASS] EventState 1 [METHOD] reinitializeBegin [RETURN_TYPE] void  final double tStart final double[] yStart [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double[] yStart double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 tStart int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	151	151	1	add	
31	[BUG] [BUGGY] g0 = handler.g(tStart, yStart); [FE] MathRuntimeException$4 [CONTEXT] public void reinitializeBegin(final double tStart, final double[] yStart) throws EventException { t0 = tStart; [BUGGY] g0 = handler.g(tStart, yStart); [BUGGY] g0Positive = g0 >= 0; } [CLASS] EventState 1 [METHOD] reinitializeBegin [RETURN_TYPE] void  final double tStart final double[] yStart [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double[] yStart double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 tStart int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	152	152	1	replace	
32	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] public void reinitializeBegin(final double tStart, final double[] yStart) throws EventException { t0 = tStart; [BUGGY] [BUGGY] g0 = handler.g(tStart, yStart); g0Positive = g0 >= 0; } [CLASS] EventState 1 [METHOD] reinitializeBegin [RETURN_TYPE] void  final double tStart final double[] yStart [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double[] yStart double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 tStart int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	152	152	1	add	
33	[BUG] [BUGGY] g0Positive = g0 >= 0; [FE] MathRuntimeException$4 [CONTEXT] public void reinitializeBegin(final double tStart, final double[] yStart) throws EventException { t0 = tStart; g0 = handler.g(tStart, yStart); [BUGGY] g0Positive = g0 >= 0; [BUGGY] } [CLASS] EventState 1 [METHOD] reinitializeBegin [RETURN_TYPE] void  final double tStart final double[] yStart [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double[] yStart double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 tStart int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	153	153	1	replace	
34	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] public void reinitializeBegin(final double tStart, final double[] yStart) throws EventException { t0 = tStart; g0 = handler.g(tStart, yStart); [BUGGY] [BUGGY] g0Positive = g0 >= 0; } [CLASS] EventState 1 [METHOD] reinitializeBegin [RETURN_TYPE] void  final double tStart final double[] yStart [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double[] yStart double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 tStart int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	153	153	1	add	
35	[BUG] [BUGGY] } [FE] MathRuntimeException$4 [CONTEXT] public void reinitializeBegin(final double tStart, final double[] yStart) throws EventException { t0 = tStart; g0 = handler.g(tStart, yStart); g0Positive = g0 >= 0; [BUGGY] } [BUGGY]  [CLASS] EventState 1 [METHOD] reinitializeBegin [RETURN_TYPE] void  final double tStart final double[] yStart [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double[] yStart double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 tStart int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	154	154	1	replace	
36	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] public void reinitializeBegin(final double tStart, final double[] yStart) throws EventException { t0 = tStart; g0 = handler.g(tStart, yStart); g0Positive = g0 >= 0; [BUGGY] [BUGGY] } [CLASS] EventState 1 [METHOD] reinitializeBegin [RETURN_TYPE] void  final double tStart final double[] yStart [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double[] yStart double convergence g0 maxCheckInterval pendingEventTime previousEventTime t0 tStart int maxIterationCount nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	154	154	1	add	
37	[BUG] [BUGGY] forward = interpolator.isForward(); [FE] MathRuntimeException$4 [CONTEXT] throws DerivativeException, EventException, ConvergenceException { try { [BUGGY] forward = interpolator.isForward(); [BUGGY] final double t1 = interpolator.getCurrentTime(); final intn= Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval)); final double h= (t1 - t0) / n; double ta = t0; double ga = g0; double tb = t0 + (interpolator.isForward() ? convergence : -convergence); for (int i = 0; i < n; ++i) {   [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	172	172	1	replace	
38	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] throws DerivativeException, EventException, ConvergenceException { try { [BUGGY] [BUGGY] forward = interpolator.isForward(); final double t1 = interpolator.getCurrentTime(); final intn= Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval)); final double h= (t1 - t0) / n; double ta = t0; double ga = g0; double tb = t0 + (interpolator.isForward() ? convergence : -convergence); for (int i = 0; i < n; ++i) {   [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	172	172	1	add	
39	[BUG] [BUGGY] final double t1 = interpolator.getCurrentTime(); [FE] MathRuntimeException$4 [CONTEXT] throws DerivativeException, EventException, ConvergenceException { try { forward = interpolator.isForward(); [BUGGY] final double t1 = interpolator.getCurrentTime(); [BUGGY] final intn= Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval)); final double h= (t1 - t0) / n; double ta = t0; double ga = g0; double tb = t0 + (interpolator.isForward() ? convergence : -convergence); for (int i = 0; i < n; ++i) {  tb += h; [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	173	173	1	replace	
40	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] throws DerivativeException, EventException, ConvergenceException { try { forward = interpolator.isForward(); [BUGGY] [BUGGY] final double t1 = interpolator.getCurrentTime(); final intn= Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval)); final double h= (t1 - t0) / n; double ta = t0; double ga = g0; double tb = t0 + (interpolator.isForward() ? convergence : -convergence); for (int i = 0; i < n; ++i) {  tb += h; [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	173	173	1	add	
41	[BUG] [BUGGY] final intn= Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval)); [FE] MathRuntimeException$4 [CONTEXT] throws DerivativeException, EventException, ConvergenceException { try { forward = interpolator.isForward(); final double t1 = interpolator.getCurrentTime(); [BUGGY] final intn= Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval)); [BUGGY] final double h= (t1 - t0) / n; double ta = t0; double ga = g0; double tb = t0 + (interpolator.isForward() ? convergence : -convergence); for (int i = 0; i < n; ++i) {  tb += h; interpolator.setInterpolatedTime(tb); [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	174	174	1	replace	
42	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] throws DerivativeException, EventException, ConvergenceException { try { forward = interpolator.isForward(); final double t1 = interpolator.getCurrentTime(); [BUGGY] [BUGGY] final intn= Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval)); final double h= (t1 - t0) / n; double ta = t0; double ga = g0; double tb = t0 + (interpolator.isForward() ? convergence : -convergence); for (int i = 0; i < n; ++i) {  tb += h; interpolator.setInterpolatedTime(tb); [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	174	174	1	add	
43	[BUG] [BUGGY] final double h= (t1 - t0) / n; [FE] MathRuntimeException$4 [CONTEXT] throws DerivativeException, EventException, ConvergenceException { try { forward = interpolator.isForward(); final double t1 = interpolator.getCurrentTime(); final intn= Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval)); [BUGGY] final double h= (t1 - t0) / n; [BUGGY]  double ta = t0; double ga = g0; double tb = t0 + (interpolator.isForward() ? convergence : -convergence); for (int i = 0; i < n; ++i) {  tb += h; interpolator.setInterpolatedTime(tb); final double gb = handler.g(tb, interpolator.getInterpolatedState()); [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	175	175	1	replace	
44	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] throws DerivativeException, EventException, ConvergenceException { try { forward = interpolator.isForward(); final double t1 = interpolator.getCurrentTime(); final intn= Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval)); [BUGGY] [BUGGY] final double h= (t1 - t0) / n; double ta = t0; double ga = g0; double tb = t0 + (interpolator.isForward() ? convergence : -convergence); for (int i = 0; i < n; ++i) {  tb += h; interpolator.setInterpolatedTime(tb); final double gb = handler.g(tb, interpolator.getInterpolatedState()); [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	175	175	1	add	
45	[BUG] [BUGGY] double ta = t0; [FE] MathRuntimeException$4 [CONTEXT] throws DerivativeException, EventException, ConvergenceException { try { forward = interpolator.isForward(); final double t1 = interpolator.getCurrentTime(); final intn= Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval)); final double h= (t1 - t0) / n; [BUGGY] double ta = t0; [BUGGY] double ga = g0; double tb = t0 + (interpolator.isForward() ? convergence : -convergence); for (int i = 0; i < n; ++i) {  tb += h; interpolator.setInterpolatedTime(tb); final double gb = handler.g(tb, interpolator.getInterpolatedState());   [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	177	177	1	replace	
46	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] throws DerivativeException, EventException, ConvergenceException { try { forward = interpolator.isForward(); final double t1 = interpolator.getCurrentTime(); final intn= Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval)); final double h= (t1 - t0) / n; [BUGGY] [BUGGY] double ta = t0; double ga = g0; double tb = t0 + (interpolator.isForward() ? convergence : -convergence); for (int i = 0; i < n; ++i) {  tb += h; interpolator.setInterpolatedTime(tb); final double gb = handler.g(tb, interpolator.getInterpolatedState());   [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	177	177	1	add	
47	[BUG] [BUGGY] double ga = g0; [FE] MathRuntimeException$4 [CONTEXT] throws DerivativeException, EventException, ConvergenceException { try { forward = interpolator.isForward(); final double t1 = interpolator.getCurrentTime(); final intn= Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval)); final double h= (t1 - t0) / n; double ta = t0; [BUGGY] double ga = g0; [BUGGY] double tb = t0 + (interpolator.isForward() ? convergence : -convergence); for (int i = 0; i < n; ++i) {  tb += h; interpolator.setInterpolatedTime(tb); final double gb = handler.g(tb, interpolator.getInterpolatedState());  if (g0Positive ^ (gb >= 0)) { [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	178	178	1	replace	
48	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] throws DerivativeException, EventException, ConvergenceException { try { forward = interpolator.isForward(); final double t1 = interpolator.getCurrentTime(); final intn= Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval)); final double h= (t1 - t0) / n; double ta = t0; [BUGGY] [BUGGY] double ga = g0; double tb = t0 + (interpolator.isForward() ? convergence : -convergence); for (int i = 0; i < n; ++i) {  tb += h; interpolator.setInterpolatedTime(tb); final double gb = handler.g(tb, interpolator.getInterpolatedState());  if (g0Positive ^ (gb >= 0)) { [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	178	178	1	add	
49	[BUG] [BUGGY] double tb = t0 + (interpolator.isForward() ? convergence : -convergence); [FE] MathRuntimeException$4 [CONTEXT] try { forward = interpolator.isForward(); final double t1 = interpolator.getCurrentTime(); final intn= Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval)); final double h= (t1 - t0) / n; double ta = t0; double ga = g0; [BUGGY] double tb = t0 + (interpolator.isForward() ? convergence : -convergence); [BUGGY] for (int i = 0; i < n; ++i) {  tb += h; interpolator.setInterpolatedTime(tb); final double gb = handler.g(tb, interpolator.getInterpolatedState());  if (g0Positive ^ (gb >= 0)) {  [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	179	179	1	replace	
50	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] try { forward = interpolator.isForward(); final double t1 = interpolator.getCurrentTime(); final intn= Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval)); final double h= (t1 - t0) / n; double ta = t0; double ga = g0; [BUGGY] [BUGGY] double tb = t0 + (interpolator.isForward() ? convergence : -convergence); for (int i = 0; i < n; ++i) {  tb += h; interpolator.setInterpolatedTime(tb); final double gb = handler.g(tb, interpolator.getInterpolatedState());  if (g0Positive ^ (gb >= 0)) {  [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	179	179	1	add	
51	[BUG] [BUGGY] for (int i = 0; i < n; ++i) { [FE] MathRuntimeException$4 [CONTEXT] try { forward = interpolator.isForward(); final double t1 = interpolator.getCurrentTime(); final intn= Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval)); final double h= (t1 - t0) / n; double ta = t0; double ga = g0; double tb = t0 + (interpolator.isForward() ? convergence : -convergence); [BUGGY] for (int i = 0; i < n; ++i) { [BUGGY]   tb += h; interpolator.setInterpolatedTime(tb); final double gb = handler.g(tb, interpolator.getInterpolatedState());  if (g0Positive ^ (gb >= 0)) {   [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	180	180	1	replace	
52	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] try { forward = interpolator.isForward(); final double t1 = interpolator.getCurrentTime(); final intn= Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval)); final double h= (t1 - t0) / n; double ta = t0; double ga = g0; double tb = t0 + (interpolator.isForward() ? convergence : -convergence); [BUGGY] [BUGGY] for (int i = 0; i < n; ++i) {  tb += h; interpolator.setInterpolatedTime(tb); final double gb = handler.g(tb, interpolator.getInterpolatedState());  if (g0Positive ^ (gb >= 0)) {   [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	180	180	1	add	
53	[BUG] [BUGGY] tb += h; [FE] MathRuntimeException$4 [CONTEXT] final double t1 = interpolator.getCurrentTime(); final intn= Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval)); final double h= (t1 - t0) / n; double ta = t0; double ga = g0; double tb = t0 + (interpolator.isForward() ? convergence : -convergence); for (int i = 0; i < n; ++i) {  [BUGGY] tb += h; [BUGGY] interpolator.setInterpolatedTime(tb); final double gb = handler.g(tb, interpolator.getInterpolatedState());  if (g0Positive ^ (gb >= 0)) {      [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	183	183	1	replace	
54	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] final double t1 = interpolator.getCurrentTime(); final intn= Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval)); final double h= (t1 - t0) / n; double ta = t0; double ga = g0; double tb = t0 + (interpolator.isForward() ? convergence : -convergence); for (int i = 0; i < n; ++i) {  [BUGGY] [BUGGY] tb += h; interpolator.setInterpolatedTime(tb); final double gb = handler.g(tb, interpolator.getInterpolatedState());  if (g0Positive ^ (gb >= 0)) {      [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	183	183	1	add	
55	[BUG] [BUGGY] interpolator.setInterpolatedTime(tb); [FE] MathRuntimeException$4 [CONTEXT] final intn= Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval)); final double h= (t1 - t0) / n; double ta = t0; double ga = g0; double tb = t0 + (interpolator.isForward() ? convergence : -convergence); for (int i = 0; i < n; ++i) {  tb += h; [BUGGY] interpolator.setInterpolatedTime(tb); [BUGGY] final double gb = handler.g(tb, interpolator.getInterpolatedState());  if (g0Positive ^ (gb >= 0)) {       [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	184	184	1	replace	
56	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] final intn= Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval)); final double h= (t1 - t0) / n; double ta = t0; double ga = g0; double tb = t0 + (interpolator.isForward() ? convergence : -convergence); for (int i = 0; i < n; ++i) {  tb += h; [BUGGY] [BUGGY] interpolator.setInterpolatedTime(tb); final double gb = handler.g(tb, interpolator.getInterpolatedState());  if (g0Positive ^ (gb >= 0)) {       [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	184	184	1	add	
57	[BUG] [BUGGY] final double gb = handler.g(tb, interpolator.getInterpolatedState()); [FE] MathRuntimeException$4 [CONTEXT] final double h= (t1 - t0) / n; double ta = t0; double ga = g0; double tb = t0 + (interpolator.isForward() ? convergence : -convergence); for (int i = 0; i < n; ++i) {  tb += h; interpolator.setInterpolatedTime(tb); [BUGGY] final double gb = handler.g(tb, interpolator.getInterpolatedState()); [BUGGY]   if (g0Positive ^ (gb >= 0)) {        [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	185	185	1	replace	
58	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] final double h= (t1 - t0) / n; double ta = t0; double ga = g0; double tb = t0 + (interpolator.isForward() ? convergence : -convergence); for (int i = 0; i < n; ++i) {  tb += h; interpolator.setInterpolatedTime(tb); [BUGGY] [BUGGY] final double gb = handler.g(tb, interpolator.getInterpolatedState());  if (g0Positive ^ (gb >= 0)) {        [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	185	185	1	add	
59	[BUG] [BUGGY] if (g0Positive ^ (gb >= 0)) { [FE] MathRuntimeException$4 [CONTEXT] double ga = g0; double tb = t0 + (interpolator.isForward() ? convergence : -convergence); for (int i = 0; i < n; ++i) {  tb += h; interpolator.setInterpolatedTime(tb); final double gb = handler.g(tb, interpolator.getInterpolatedState());  [BUGGY] if (g0Positive ^ (gb >= 0)) { [BUGGY]           [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	188	188	1	replace	
60	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] double ga = g0; double tb = t0 + (interpolator.isForward() ? convergence : -convergence); for (int i = 0; i < n; ++i) {  tb += h; interpolator.setInterpolatedTime(tb); final double gb = handler.g(tb, interpolator.getInterpolatedState());  [BUGGY] [BUGGY] if (g0Positive ^ (gb >= 0)) {           [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	188	188	1	add	
61	[BUG] [BUGGY] increasing = gb >= ga; [FE] MathRuntimeException$4 [CONTEXT]          [BUGGY] increasing = gb >= ga; [BUGGY]  final UnivariateRealFunction f = new UnivariateRealFunction() { public double value(final double t) throws FunctionEvaluationException { try { interpolator.setInterpolatedTime(t); return handler.g(t, interpolator.getInterpolatedState()); } catch (DerivativeException e) { throw new FunctionEvaluationException(e, t); } catch (EventException e) { throw new FunctionEvaluationException(e, t); [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	201	201	1	replace	
62	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT]          [BUGGY] [BUGGY] increasing = gb >= ga; final UnivariateRealFunction f = new UnivariateRealFunction() { public double value(final double t) throws FunctionEvaluationException { try { interpolator.setInterpolatedTime(t); return handler.g(t, interpolator.getInterpolatedState()); } catch (DerivativeException e) { throw new FunctionEvaluationException(e, t); } catch (EventException e) { throw new FunctionEvaluationException(e, t); [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	201	201	1	add	
63	[BUG] [BUGGY] final UnivariateRealFunction f = new UnivariateRealFunction() { [FE] MathRuntimeException$4 [CONTEXT]        increasing = gb >= ga; [BUGGY] final UnivariateRealFunction f = new UnivariateRealFunction() { [BUGGY] public double value(final double t) throws FunctionEvaluationException { try { interpolator.setInterpolatedTime(t); return handler.g(t, interpolator.getInterpolatedState()); } catch (DerivativeException e) { throw new FunctionEvaluationException(e, t); } catch (EventException e) { throw new FunctionEvaluationException(e, t); } } [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	203	203	1	replace	
64	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT]        increasing = gb >= ga; [BUGGY] [BUGGY] final UnivariateRealFunction f = new UnivariateRealFunction() { public double value(final double t) throws FunctionEvaluationException { try { interpolator.setInterpolatedTime(t); return handler.g(t, interpolator.getInterpolatedState()); } catch (DerivativeException e) { throw new FunctionEvaluationException(e, t); } catch (EventException e) { throw new FunctionEvaluationException(e, t); } } [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	203	203	1	add	
65	[BUG] [BUGGY] final BrentSolver solver = new BrentSolver(); [FE] MathRuntimeException$4 [CONTEXT] try { interpolator.setInterpolatedTime(t); return handler.g(t, interpolator.getInterpolatedState()); } catch (DerivativeException e) { throw new FunctionEvaluationException(e, t); } catch (EventException e) { throw new FunctionEvaluationException(e, t); } } }; [BUGGY] final BrentSolver solver = new BrentSolver(); [BUGGY] solver.setAbsoluteAccuracy(convergence); solver.setMaximalIterationCount(maxIterationCount); final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta); if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {  ta = tb; ga = gb; } else if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) { [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	215	215	1	replace	
66	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] try { interpolator.setInterpolatedTime(t); return handler.g(t, interpolator.getInterpolatedState()); } catch (DerivativeException e) { throw new FunctionEvaluationException(e, t); } catch (EventException e) { throw new FunctionEvaluationException(e, t); } } }; [BUGGY] [BUGGY] final BrentSolver solver = new BrentSolver(); solver.setAbsoluteAccuracy(convergence); solver.setMaximalIterationCount(maxIterationCount); final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta); if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {  ta = tb; ga = gb; } else if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) { [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	215	215	1	add	
67	[BUG] [BUGGY] solver.setAbsoluteAccuracy(convergence); [FE] MathRuntimeException$4 [CONTEXT] interpolator.setInterpolatedTime(t); return handler.g(t, interpolator.getInterpolatedState()); } catch (DerivativeException e) { throw new FunctionEvaluationException(e, t); } catch (EventException e) { throw new FunctionEvaluationException(e, t); } } }; final BrentSolver solver = new BrentSolver(); [BUGGY] solver.setAbsoluteAccuracy(convergence); [BUGGY] solver.setMaximalIterationCount(maxIterationCount); final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta); if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {  ta = tb; ga = gb; } else if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) { pendingEventTime = root; [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	216	216	1	replace	
68	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] interpolator.setInterpolatedTime(t); return handler.g(t, interpolator.getInterpolatedState()); } catch (DerivativeException e) { throw new FunctionEvaluationException(e, t); } catch (EventException e) { throw new FunctionEvaluationException(e, t); } } }; final BrentSolver solver = new BrentSolver(); [BUGGY] [BUGGY] solver.setAbsoluteAccuracy(convergence); solver.setMaximalIterationCount(maxIterationCount); final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta); if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {  ta = tb; ga = gb; } else if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) { pendingEventTime = root; [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	216	216	1	add	
69	[BUG] [BUGGY] solver.setMaximalIterationCount(maxIterationCount); [FE] MathRuntimeException$4 [CONTEXT] return handler.g(t, interpolator.getInterpolatedState()); } catch (DerivativeException e) { throw new FunctionEvaluationException(e, t); } catch (EventException e) { throw new FunctionEvaluationException(e, t); } } }; final BrentSolver solver = new BrentSolver(); solver.setAbsoluteAccuracy(convergence); [BUGGY] solver.setMaximalIterationCount(maxIterationCount); [BUGGY] final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta); if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {  ta = tb; ga = gb; } else if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) { pendingEventTime = root; if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) { [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	217	217	1	replace	
70	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] return handler.g(t, interpolator.getInterpolatedState()); } catch (DerivativeException e) { throw new FunctionEvaluationException(e, t); } catch (EventException e) { throw new FunctionEvaluationException(e, t); } } }; final BrentSolver solver = new BrentSolver(); solver.setAbsoluteAccuracy(convergence); [BUGGY] [BUGGY] solver.setMaximalIterationCount(maxIterationCount); final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta); if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {  ta = tb; ga = gb; } else if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) { pendingEventTime = root; if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) { [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	217	217	1	add	
71	[BUG] [BUGGY] final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta); [FE] MathRuntimeException$4 [CONTEXT] } catch (DerivativeException e) { throw new FunctionEvaluationException(e, t); } catch (EventException e) { throw new FunctionEvaluationException(e, t); } } }; final BrentSolver solver = new BrentSolver(); solver.setAbsoluteAccuracy(convergence); solver.setMaximalIterationCount(maxIterationCount); [BUGGY] final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta); [BUGGY] if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {  ta = tb; ga = gb; } else if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) { pendingEventTime = root; if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {  [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	218	218	1	replace	
72	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] } catch (DerivativeException e) { throw new FunctionEvaluationException(e, t); } catch (EventException e) { throw new FunctionEvaluationException(e, t); } } }; final BrentSolver solver = new BrentSolver(); solver.setAbsoluteAccuracy(convergence); solver.setMaximalIterationCount(maxIterationCount); [BUGGY] [BUGGY] final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta); if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {  ta = tb; ga = gb; } else if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) { pendingEventTime = root; if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {  [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	218	218	1	add	
73	[BUG] [BUGGY] if ((Math.abs(root - ta) <= convergence) &&  (Math.abs(root - previousEventTime) <= convergence)) { [FE] MathRuntimeException$4 [CONTEXT] throw new FunctionEvaluationException(e, t); } catch (EventException e) { throw new FunctionEvaluationException(e, t); } } }; final BrentSolver solver = new BrentSolver(); solver.setAbsoluteAccuracy(convergence); solver.setMaximalIterationCount(maxIterationCount); final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta); [BUGGY] if ((Math.abs(root - ta) <= convergence) &&       (Math.abs(root - previousEventTime) <= convergence)) { [BUGGY] (Math.abs(root - previousEventTime) <= convergence)) {  ta = tb; ga = gb; } else if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) { pendingEventTime = root; if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {   [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	219	220	1	replace	
74	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] throw new FunctionEvaluationException(e, t); } catch (EventException e) { throw new FunctionEvaluationException(e, t); } } }; final BrentSolver solver = new BrentSolver(); solver.setAbsoluteAccuracy(convergence); solver.setMaximalIterationCount(maxIterationCount); final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta); [BUGGY] [BUGGY] if ((Math.abs(root - ta) <= convergence) &&       (Math.abs(root - previousEventTime) <= convergence)) { (Math.abs(root - previousEventTime) <= convergence)) {  ta = tb; ga = gb; } else if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) { pendingEventTime = root; if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {   [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	219	220	1	add	
75	[BUG] [BUGGY] } else if (Double.isNaN(previousEventTime) ||  (Math.abs(previousEventTime - root) > convergence)) { [FE] MathRuntimeException$4 [CONTEXT] }; final BrentSolver solver = new BrentSolver(); solver.setAbsoluteAccuracy(convergence); solver.setMaximalIterationCount(maxIterationCount); final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta); if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {  ta = tb; ga = gb; [BUGGY] } else if (Double.isNaN(previousEventTime) ||        (Math.abs(previousEventTime - root) > convergence)) { [BUGGY] (Math.abs(previousEventTime - root) > convergence)) { pendingEventTime = root; if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {     return false; }  [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	224	225	1	replace	
76	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] }; final BrentSolver solver = new BrentSolver(); solver.setAbsoluteAccuracy(convergence); solver.setMaximalIterationCount(maxIterationCount); final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta); if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {  ta = tb; ga = gb; [BUGGY] [BUGGY] } else if (Double.isNaN(previousEventTime) ||        (Math.abs(previousEventTime - root) > convergence)) { (Math.abs(previousEventTime - root) > convergence)) { pendingEventTime = root; if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {     return false; }  [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	224	225	1	add	
77	[BUG] [BUGGY] pendingEventTime = root; [FE] MathRuntimeException$4 [CONTEXT] solver.setAbsoluteAccuracy(convergence); solver.setMaximalIterationCount(maxIterationCount); final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta); if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {  ta = tb; ga = gb; } else if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) { [BUGGY] pendingEventTime = root; [BUGGY] if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {     return false; }   pendingEvent = true; [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	226	226	1	replace	
78	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] solver.setAbsoluteAccuracy(convergence); solver.setMaximalIterationCount(maxIterationCount); final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta); if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {  ta = tb; ga = gb; } else if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) { [BUGGY] [BUGGY] pendingEventTime = root; if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {     return false; }   pendingEvent = true; [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	226	226	1	add	
79	[BUG] [BUGGY] if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) { [FE] MathRuntimeException$4 [CONTEXT] } else if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) { pendingEventTime = root; [BUGGY] if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) { [BUGGY]     return false; }   pendingEvent = true; return true; [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	227	227	1	replace	
80	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] } else if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) { pendingEventTime = root; [BUGGY] [BUGGY] if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {     return false; }   pendingEvent = true; return true; [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	227	227	1	add	
81	[BUG] [BUGGY] pendingEvent = true; [FE] MathRuntimeException$4 [CONTEXT] pendingEventTime = root; if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {     return false; }   [BUGGY] pendingEvent = true; [BUGGY] return true; } [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	236	236	1	replace	
82	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] pendingEventTime = root; if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {     return false; }   [BUGGY] [BUGGY] pendingEvent = true; return true; } [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	236	236	1	add	
83	[BUG] [BUGGY] return true; [FE] MathRuntimeException$4 [CONTEXT] if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {     return false; }   pendingEvent = true; [BUGGY] return true; [BUGGY] } [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	237	237	1	replace	
84	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {     return false; }   pendingEvent = true; [BUGGY] [BUGGY] return true; } [CLASS] EventState 1 [METHOD] evaluateStep [RETURN_TYPE] boolean  StepInterpolator interpolator [VARIABLES] BrentSolver solver boolean forward g0Positive increasing pendingEvent EventException e double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb EventHandler handler Throwable cause UnivariateRealFunction f StepInterpolator interpolator FunctionEvaluationException e int i maxIterationCount n nextAction DerivativeException e  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	237	237	1	add	
85	[BUG] [BUGGY] return pendingEventTime; [FE] MathRuntimeException$4 [CONTEXT] public double getEventTime() { [BUGGY] return pendingEventTime; [BUGGY] } [CLASS] EventState 1 [METHOD] getEventTime [RETURN_TYPE] double  [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb int i maxIterationCount n nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	271	271	1	replace	
86	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] public double getEventTime() { [BUGGY] [BUGGY] return pendingEventTime; } [CLASS] EventState 1 [METHOD] getEventTime [RETURN_TYPE] double  [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb int i maxIterationCount n nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	271	271	1	add	
87	[BUG] [BUGGY] t0 = t; [FE] MathRuntimeException$4 [CONTEXT] public void stepAccepted(final double t, final double[] y) throws EventException { [BUGGY] t0 = t; [BUGGY] g0 = handler.g(t, y); if (pendingEvent) {  previousEventTime = t; g0Positive= increasing; nextAction= handler.eventOccurred(t, y, !(increasing ^ forward)); } else { g0Positive = g0 >= 0; nextAction = EventHandler.CONTINUE; [CLASS] EventState 1 [METHOD] stepAccepted [RETURN_TYPE] void  final double t final double[] y [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double[] y double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb int i maxIterationCount n nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	285	285	1	replace	
88	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] public void stepAccepted(final double t, final double[] y) throws EventException { [BUGGY] [BUGGY] t0 = t; g0 = handler.g(t, y); if (pendingEvent) {  previousEventTime = t; g0Positive= increasing; nextAction= handler.eventOccurred(t, y, !(increasing ^ forward)); } else { g0Positive = g0 >= 0; nextAction = EventHandler.CONTINUE; [CLASS] EventState 1 [METHOD] stepAccepted [RETURN_TYPE] void  final double t final double[] y [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double[] y double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb int i maxIterationCount n nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	285	285	1	add	
89	[BUG] [BUGGY] g0 = handler.g(t, y); [FE] MathRuntimeException$4 [CONTEXT] public void stepAccepted(final double t, final double[] y) throws EventException { t0 = t; [BUGGY] g0 = handler.g(t, y); [BUGGY]  if (pendingEvent) {  previousEventTime = t; g0Positive= increasing; nextAction= handler.eventOccurred(t, y, !(increasing ^ forward)); } else { g0Positive = g0 >= 0; nextAction = EventHandler.CONTINUE; } [CLASS] EventState 1 [METHOD] stepAccepted [RETURN_TYPE] void  final double t final double[] y [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double[] y double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb int i maxIterationCount n nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	286	286	1	replace	
90	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] public void stepAccepted(final double t, final double[] y) throws EventException { t0 = t; [BUGGY] [BUGGY] g0 = handler.g(t, y); if (pendingEvent) {  previousEventTime = t; g0Positive= increasing; nextAction= handler.eventOccurred(t, y, !(increasing ^ forward)); } else { g0Positive = g0 >= 0; nextAction = EventHandler.CONTINUE; } [CLASS] EventState 1 [METHOD] stepAccepted [RETURN_TYPE] void  final double t final double[] y [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double[] y double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb int i maxIterationCount n nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	286	286	1	add	
91	[BUG] [BUGGY] if (pendingEvent) { [FE] MathRuntimeException$4 [CONTEXT] public void stepAccepted(final double t, final double[] y) throws EventException { t0 = t; g0 = handler.g(t, y); [BUGGY] if (pendingEvent) { [BUGGY]  previousEventTime = t; g0Positive= increasing; nextAction= handler.eventOccurred(t, y, !(increasing ^ forward)); } else { g0Positive = g0 >= 0; nextAction = EventHandler.CONTINUE; } } [CLASS] EventState 1 [METHOD] stepAccepted [RETURN_TYPE] void  final double t final double[] y [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double[] y double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb int i maxIterationCount n nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	288	288	1	replace	
92	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] public void stepAccepted(final double t, final double[] y) throws EventException { t0 = t; g0 = handler.g(t, y); [BUGGY] [BUGGY] if (pendingEvent) {  previousEventTime = t; g0Positive= increasing; nextAction= handler.eventOccurred(t, y, !(increasing ^ forward)); } else { g0Positive = g0 >= 0; nextAction = EventHandler.CONTINUE; } } [CLASS] EventState 1 [METHOD] stepAccepted [RETURN_TYPE] void  final double t final double[] y [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double[] y double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb int i maxIterationCount n nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	288	288	1	add	
93	[BUG] [BUGGY] previousEventTime = t; [FE] MathRuntimeException$4 [CONTEXT] public void stepAccepted(final double t, final double[] y) throws EventException { t0 = t; g0 = handler.g(t, y); if (pendingEvent) {  [BUGGY] previousEventTime = t; [BUGGY] g0Positive= increasing; nextAction= handler.eventOccurred(t, y, !(increasing ^ forward)); } else { g0Positive = g0 >= 0; nextAction = EventHandler.CONTINUE; } } [CLASS] EventState 1 [METHOD] stepAccepted [RETURN_TYPE] void  final double t final double[] y [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double[] y double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb int i maxIterationCount n nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	290	290	1	replace	
94	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] public void stepAccepted(final double t, final double[] y) throws EventException { t0 = t; g0 = handler.g(t, y); if (pendingEvent) {  [BUGGY] [BUGGY] previousEventTime = t; g0Positive= increasing; nextAction= handler.eventOccurred(t, y, !(increasing ^ forward)); } else { g0Positive = g0 >= 0; nextAction = EventHandler.CONTINUE; } } [CLASS] EventState 1 [METHOD] stepAccepted [RETURN_TYPE] void  final double t final double[] y [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double[] y double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb int i maxIterationCount n nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	290	290	1	add	
95	[BUG] [BUGGY] g0Positive= increasing; [FE] MathRuntimeException$4 [CONTEXT] public void stepAccepted(final double t, final double[] y) throws EventException { t0 = t; g0 = handler.g(t, y); if (pendingEvent) {  previousEventTime = t; [BUGGY] g0Positive= increasing; [BUGGY] nextAction= handler.eventOccurred(t, y, !(increasing ^ forward)); } else { g0Positive = g0 >= 0; nextAction = EventHandler.CONTINUE; } } [CLASS] EventState 1 [METHOD] stepAccepted [RETURN_TYPE] void  final double t final double[] y [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double[] y double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb int i maxIterationCount n nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	291	291	1	replace	
96	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] public void stepAccepted(final double t, final double[] y) throws EventException { t0 = t; g0 = handler.g(t, y); if (pendingEvent) {  previousEventTime = t; [BUGGY] [BUGGY] g0Positive= increasing; nextAction= handler.eventOccurred(t, y, !(increasing ^ forward)); } else { g0Positive = g0 >= 0; nextAction = EventHandler.CONTINUE; } } [CLASS] EventState 1 [METHOD] stepAccepted [RETURN_TYPE] void  final double t final double[] y [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double[] y double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb int i maxIterationCount n nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	291	291	1	add	
97	[BUG] [BUGGY] nextAction= handler.eventOccurred(t, y, !(increasing ^ forward)); [FE] MathRuntimeException$4 [CONTEXT] public void stepAccepted(final double t, final double[] y) throws EventException { t0 = t; g0 = handler.g(t, y); if (pendingEvent) {  previousEventTime = t; g0Positive= increasing; [BUGGY] nextAction= handler.eventOccurred(t, y, !(increasing ^ forward)); [BUGGY] } else { g0Positive = g0 >= 0; nextAction = EventHandler.CONTINUE; } } [CLASS] EventState 1 [METHOD] stepAccepted [RETURN_TYPE] void  final double t final double[] y [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double[] y double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb int i maxIterationCount n nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	292	292	1	replace	
98	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] public void stepAccepted(final double t, final double[] y) throws EventException { t0 = t; g0 = handler.g(t, y); if (pendingEvent) {  previousEventTime = t; g0Positive= increasing; [BUGGY] [BUGGY] nextAction= handler.eventOccurred(t, y, !(increasing ^ forward)); } else { g0Positive = g0 >= 0; nextAction = EventHandler.CONTINUE; } } [CLASS] EventState 1 [METHOD] stepAccepted [RETURN_TYPE] void  final double t final double[] y [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double[] y double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb int i maxIterationCount n nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	292	292	1	add	
99	[BUG] [BUGGY] } [FE] MathRuntimeException$4 [CONTEXT] if (pendingEvent) {  previousEventTime = t; g0Positive= increasing; nextAction= handler.eventOccurred(t, y, !(increasing ^ forward)); } else { g0Positive = g0 >= 0; nextAction = EventHandler.CONTINUE; } [BUGGY] } [BUGGY]  [CLASS] EventState 1 [METHOD] stepAccepted [RETURN_TYPE] void  final double t final double[] y [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double[] y double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb int i maxIterationCount n nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	297	297	1	replace	
100	[BUG] [BUGGY] [FE] MathRuntimeException$4 [CONTEXT] if (pendingEvent) {  previousEventTime = t; g0Positive= increasing; nextAction= handler.eventOccurred(t, y, !(increasing ^ forward)); } else { g0Positive = g0 >= 0; nextAction = EventHandler.CONTINUE; } [BUGGY] [BUGGY] } [CLASS] EventState 1 [METHOD] stepAccepted [RETURN_TYPE] void  final double t final double[] y [VARIABLES] EventHandler handler boolean forward g0Positive increasing pendingEvent double[] y double convergence g0 ga gb h maxCheckInterval pendingEventTime previousEventTime root t t0 t1 tStart ta tb int i maxIterationCount n nextAction  	projects/Math78/src/main/java/org/apache/commons/math/ode/events/EventState.java	1.0	297	297	1	add	
