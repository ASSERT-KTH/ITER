bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  if(unitField.isUnknown()  ||  unitField.isSupported())  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  if(unitField.isUnknown()  ||  unitField.isSupported())  {  [BUGGY]      for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	if(unitField.isUnknown()  ||  unitField.isSupported())  {	  if(unitField.isUnknown()    ||    unitField.isUnknown())    {    	non-compiled	[CE]  	4	None	replace
2	[BUG]  [BUGGY]  if(unitField.isUnknown()  ||  unitField.isUnknownType())  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  if(unitField.isUnknown()  ||  unitField.isUnknownType())  {  [BUGGY]      for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	if(unitField.isUnknown()  ||  unitField.isUnknownType())  {	  if(unitField.isSupported()    &&    unitField.isUnknownType())    {    	non-compiled	[CE]  	1	None	replace
3	[BUG]  [BUGGY]  newTypes[index]  =  unitField.getValue(iChronology,  value);  [CE]  [FE]                AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  newTypes[index]  =  unitField.getValue(iChronology,  value);  [BUGGY]      for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	newTypes[index]  =  unitField.getValue(iChronology,  value);	  newTypes[index]    =    unitField.getValue(iChronology);    	non-compiled	[CE]  	16	None	replace
4	[BUG]  [BUGGY]  iChronology  =  unitField.withValue(newValues[i]);  [CE]  [FE]              AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  iChronology  =  unitField.withValue(newValues[i]);  [BUGGY]      if  (unitField.isSupported())  {  for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	iChronology  =  unitField.withValue(newValues[i]);	  iChronology    =    unitField.withUTC();    	non-compiled	[CE]  	5	None	replace
5	[BUG]  [BUGGY]  iChronology  =  unitField.withValue(newValues[index]);  [CE]  [FE]                AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  iChronology  =  unitField.withValue(newValues[index]);  [BUGGY]      if  (unitField.isSupported())  {  for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	iChronology  =  unitField.withValue(newValues[index]);	  iChronology    =    unitField.withUTC();    	non-compiled	[CE]  	5	None	replace
6	[BUG]  [BUGGY]  int[]  iValues  =  newValues.toArray(newValues,  unitField);  [CE]  [FE]              AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  int[]  iValues  =  newValues.toArray(newValues,  unitField);  [BUGGY]      if  (unitField.isSupported())  {  for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	int[]  iValues  =  newValues.toArray(newValues,  unitField);	  int[]    iValues    =    newValues.toArray(newValues,    value);    	non-compiled	[CE]  	9	None	replace
7	[BUG]  [BUGGY]  int[]  iValues  =  newValues.toArray(newTypes,  value);  [CE]  [FE]                AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  int[]  iValues  =  newValues.toArray(newTypes,  value);  [BUGGY]      if  (unitField.isSupported())  {  for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	int[]  iValues  =  newValues.toArray(newTypes,  value);	  int[]    iValues    =    newValues.toArray(newValues,    value);    	non-compiled	[CE]  	9	None	replace
8	[BUG]  [BUGGY]  int[]  iValues  =  newValues[iTypes.length  +  2];  [CE]  [FE]                AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  int[]  iValues  =  newValues[iTypes.length  +  2];  [BUGGY]      if  (unitField.isSupported())  {  for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	int[]  iValues  =  newValues[iTypes.length  +  2];	  int[]    iValues    =    newValues[iTypes.length    +    1];    	non-compiled	[CE]  	14	None	replace
9	[BUG]  [BUGGY]  iChronology  =  newChronology.withUTC(newValues[i],  unitField);  [CE]  [FE]              AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  iChronology  =  newChronology.withUTC(newValues[i],  unitField);  [BUGGY]      if  (unitField.isSupported())  {  for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	iChronology  =  newChronology.withUTC(newValues[i],  unitField);	  iChronology    =    newChronology.withUTC(newValues[i]);    	non-compiled	[CE]  	17	None	replace
10	[BUG]  [BUGGY]  iChronology  =  newChronology.withUTC(newValues[index]);  [CE]  [FE]                AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  iChronology  =  newChronology.withUTC(newValues[index]);  [BUGGY]      if  (unitField.isSupported())  {  for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	iChronology  =  newChronology.withUTC(newValues[index]);	  iChronology    =    newChronology.withUTC(newValues[i]);    	non-compiled	[CE]  	17	None	replace
11	[BUG]  [BUGGY]  int[]  newValues  =  iTypes[i  +  1];  [CE]  [FE]                AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  int[]  newValues  =  iTypes[i  +  1];  [BUGGY]      if  (unitField.isSupported())  {  for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	int[]  newValues  =  iTypes[i  +  1];	  int[]    newValues    =    iTypes[index    +    1];    	non-compiled	[CE]  	11	None	replace
12	[BUG]  [BUGGY]  iChronology  =  newChronology.withField(iChronology);  [CE]  [FE]                AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  iChronology  =  newChronology.withField(iChronology);  [BUGGY]      for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	iChronology  =  newChronology.withField(iChronology);	  iChronology    =    newChronology.withField(unitField);    	non-compiled	[CE]  	27	None	replace
13	[BUG]  [BUGGY]  iChronology  =  newChronology.withValue(unitField);  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  iChronology  =  newChronology.withValue(unitField);  [BUGGY]      for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	iChronology  =  newChronology.withValue(unitField);	  iChronology    =    newChronology.withField(unitField);    	non-compiled	[CE]  	27	None	replace
14	[BUG]  [BUGGY]  if(unitField.isSupported()  ||  unitField.isUnknown()  ||  newValues[i]!=  0)  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  if(unitField.isSupported()  ||  unitField.isUnknown()  ||  newValues[i]!=  0)  {  [BUGGY]      for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	if(unitField.isSupported()  ||  unitField.isUnknown()  ||  newValues[i]!=  0)  {	  if(unitField.isSupported()    ||    unitField.isUnknown()    ||    newValues[i]    ==    0)    {    	non-compiled	[CE]  	22	None	replace
15	[BUG]  [BUGGY]  if(unitField.isSupported()  ||  unitField.isUnknown()  ||  newValues[0]!=  null)  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  if(unitField.isSupported()  ||  unitField.isUnknown()  ||  newValues[0]!=  null)  {  [BUGGY]      for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	if(unitField.isSupported()  ||  unitField.isUnknown()  ||  newValues[0]!=  null)  {	  if(unitField.isSupported()    ||    unitField.isUnknown()    ||    newValues[0]    ==    null)    {    	non-compiled	[CE]  	25	None	replace
16	[BUG]  [BUGGY]  int[]  newValues  =  new  int[unitField.length];  [CE]  [FE]              AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  int[]  newValues  =  new  int[unitField.length];  [BUGGY]      if  (unitField.isSupported())  {  for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	int[]  newValues  =  new  int[unitField.length];	  int[]    newValues    =    new    int[iTypes.length];    	non-compiled	[CE]  	20	None	replace
17	[BUG]  [BUGGY]  int[]  newValues  =  new  int[iValues.length  ];  [CE]  [FE]                AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  int[]  newValues  =  new  int[iValues.length  ];  [BUGGY]      if  (unitField.isSupported())  {  for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	int[]  newValues  =  new  int[iValues.length  ];	  int[]    newValues    =    new    int[iValues.length    +    1];    	non-compiled	[CE]  	10	None	replace
18	[BUG]  [BUGGY]  int[]  newValues  =  unitField.toArray(newValues,  value);  [CE]  [FE]            AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  int[]  newValues  =  unitField.toArray(newValues,  value);  [BUGGY]      if  (unitField.isSupported())  {  for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	int[]  newValues  =  unitField.toArray(newValues,  value);	  int[]    newValues    =    unitField.toArray(newValues);    	non-compiled	[CE]  	8	None	replace
19	[BUG]  [BUGGY]  int[]  newValues  =  unitField.toArray(newValues,  index);  [CE]  [FE]              AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  int[]  newValues  =  unitField.toArray(newValues,  index);  [BUGGY]      if  (unitField.isSupported())  {  for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	int[]  newValues  =  unitField.toArray(newValues,  index);	  int[]    newValues    =    unitField.toArray(newValues);    	non-compiled	[CE]  	8	None	replace
20	[BUG]  [BUGGY]  if(unitField.isInitialized()  &&  unitField.isSupported())  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  if(unitField.isInitialized()  &&  unitField.isSupported())  {  [BUGGY]      for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	if(unitField.isInitialized()  &&  unitField.isSupported())  {	  if(unitField.isInitialized()    ||    unitField.isSupported())    {    	non-compiled	[CE]  	3	None	replace
21	[BUG]  [BUGGY]  int[]  iValues  =  unitField.toArray(newValues,  value);  [CE]  [FE]            AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  int[]  iValues  =  unitField.toArray(newValues,  value);  [BUGGY]      if  (unitField.isSupported())  {  for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	int[]  iValues  =  unitField.toArray(newValues,  value);	  int[]    iValues    =    unitField.toArray(newValues);    	non-compiled	[CE]  	23	None	replace
22	[BUG]  [BUGGY]  if(unitField.isSupported()  ||  unitField.isUnknownType()  ||  newValues[0]!=  null)  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  if(unitField.isSupported()  ||  unitField.isUnknownType()  ||  newValues[0]!=  null)  {  [BUGGY]      for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	if(unitField.isSupported()  ||  unitField.isUnknownType()  ||  newValues[0]!=  null)  {	  if(unitField.isSupported()    ||    unitField.isUnknownType()    ||    newValues[0]    ==    null)    {    	non-compiled	[CE]  	28	None	replace
23	[BUG]  [BUGGY]  newTypes[i]  =  unitField.getValue(iChronology);  [CE]  [FE]            AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  newTypes[i]  =  unitField.getValue(iChronology);  [BUGGY]      if  (unitField.isSupported())  {  for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	newTypes[i]  =  unitField.getValue(iChronology);	  newTypes[i]    =    unitField.getField(iChronology);    	non-compiled	[CE]  	6	None	replace
24	[BUG]  [BUGGY]  int[]  iValues  =  newValues.toArray(newTypes,  i);  [CE]  [FE]            AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  int[]  iValues  =  newValues.toArray(newTypes,  i);  [BUGGY]      if  (unitField.isSupported())  {  for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	int[]  iValues  =  newValues.toArray(newTypes,  i);	  int[]    iValues    =    newValues.toArray(newValues,    i);    	non-compiled	[CE]  	21	None	replace
25	[BUG]  [BUGGY]  iChronology  =  newChronology.withField(newValues[i]);  [CE]  [FE]                AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  iChronology  =  newChronology.withField(newValues[i]);  [BUGGY]      for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	iChronology  =  newChronology.withField(newValues[i]);	  iChronology    =    newChronology.withField(unitField);    	non-compiled	[CE]  	27	None	replace
26	[BUG]  [BUGGY]  newTypes[i]  =  fieldType.getDurationType().getField(iChronology);  [CE]  [FE]            AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  newTypes[i]  =  fieldType.getDurationType().getField(iChronology);  [BUGGY]      if  (unitField.isSupported())  {  for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	newTypes[i]  =  fieldType.getDurationType().getField(iChronology);	  newTypes[i]    =    unitField.getField(iChronology);    	non-compiled	[CE]  	6	None	replace
27	[BUG]  [BUGGY]  int[]  iValues  =  newValues[newTypes.length  +  1];  [CE]  [FE]                AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  int[]  iValues  =  newValues[newTypes.length  +  1];  [BUGGY]      if  (unitField.isSupported())  {  for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	int[]  iValues  =  newValues[newTypes.length  +  1];	  int[]    iValues    =    newValues[iTypes.length    +    1];    	non-compiled	[CE]  	14	None	replace
28	[BUG]  [BUGGY]  int[]  newValues  =  unitField.toArray(newValues,  i);  [CE]  [FE]            AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  int[]  newValues  =  unitField.toArray(newValues,  i);  [BUGGY]      if  (unitField.isSupported())  {  for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	int[]  newValues  =  unitField.toArray(newValues,  i);	  int[]    newValues    =    unitField.toArray(newValues);    	non-compiled	[CE]  	8	None	replace
29	[BUG]  [BUGGY]  if(unitField  ==  null  &&  unitField.isSupported())  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  if(unitField  ==  null  &&  unitField.isSupported())  {  [BUGGY]      for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	if(unitField  ==  null  &&  unitField.isSupported())  {	  if(unitField!=    null    &&    unitField.isSupported())    {    	non-compiled	[CE]  	24	None	replace
30	[BUG]  [BUGGY]  int[]  newValues  =  newTypes[iTypes.length  +  1];  [CE]  [FE]                AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  int[]  newValues  =  newTypes[iTypes.length  +  1];  [BUGGY]      if  (unitField.isSupported())  {  for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	int[]  newValues  =  newTypes[iTypes.length  +  1];	  int[]    newValues    =    newTypes[i    +    1];    	non-compiled	[CE]  	18	None	replace
31	[BUG]  [BUGGY]  int[]  iValues  =  newValues.toArray(unitField);  [CE]  [FE]            AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  int[]  iValues  =  newValues.toArray(unitField);  [BUGGY]      if  (unitField.isSupported())  {  for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	int[]  iValues  =  newValues.toArray(unitField);	  int[]    iValues    =    unitField.toArray(newValues);    	non-compiled	[CE]  	23	None	replace
32	[BUG]  [BUGGY]  newTypes[index]  =  fieldType.getValue(iChronology);  [CE]  [FE]                AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  newTypes[index]  =  fieldType.getValue(iChronology);  [BUGGY]      for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	newTypes[index]  =  fieldType.getValue(iChronology);	  newTypes[index]    =    unitField.getValue(iChronology);    	non-compiled	[CE]  	16	None	replace
33	[BUG]  [BUGGY]  int[]  iValues  =  newValues[i  *  1];  [CE]  [FE]              AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  int[]  iValues  =  newValues[i  *  1];  [BUGGY]      if  (unitField.isSupported())  {  for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	int[]  iValues  =  newValues[i  *  1];	  int[]    iValues    =    newValues[i    +    1];    	non-compiled	[CE]  	13	None	replace
34	[BUG]  [BUGGY]  iChronology  =  iChronology.withUTC(newValues[i]);  [CE]  [FE]              AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  iChronology  =  iChronology.withUTC(newValues[i]);  [BUGGY]      if  (unitField.isSupported())  {  for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	iChronology  =  iChronology.withUTC(newValues[i]);	  iChronology    =    newChronology.withUTC(newValues[i]);    	non-compiled	[CE]  	17	None	replace
35	[BUG]  [BUGGY]  if(unitField!=  null  &&  unitField.isSupported()  &&  unitField.isUnknownType())  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  if(unitField!=  null  &&  unitField.isSupported()  &&  unitField.isUnknownType())  {  [BUGGY]      for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	if(unitField!=  null  &&  unitField.isSupported()  &&  unitField.isUnknownType())  {	  if(unitField.isSupported()    &&    unitField.isUnknownType())    {    	non-compiled	[CE]  	1	None	replace
36	[BUG]  [BUGGY]  iChronology  =  iChronology.withField(unitField);  [CE]  [FE]                AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  iChronology  =  iChronology.withField(unitField);  [BUGGY]      for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	iChronology  =  iChronology.withField(unitField);	  iChronology    =    newChronology.withField(unitField);    	non-compiled	[CE]  	27	None	replace
37	[BUG]  [BUGGY]  if(unitField.isSupported()  ||  unitField.isUnknown()  ||  newValues[i]  ==  null)  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  if(unitField.isSupported()  ||  unitField.isUnknown()  ||  newValues[i]  ==  null)  {  [BUGGY]      for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	if(unitField.isSupported()  ||  unitField.isUnknown()  ||  newValues[i]  ==  null)  {	  if(unitField.isSupported()    ||    unitField.isUnknown()    ||    newValues[0]    ==    null)    {    	non-compiled	[CE]  	25	None	replace
38	[BUG]  [BUGGY]  if(unitField.isInitialized()  ||  unitField.isUnknown())  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      throw  new  IllegalArgumentException(     "The  field  type  must  not  be  null     ");  }  int  index  =  indexOf(fieldType);  if  (index  ==  -1)  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes.length  +  1];  int[]  newValues  =  new  int[newTypes.length];  int  i  =  0;  DurationField  unitField  =  fieldType.getDurationType().getField(iChronology);      [BUGGY]  if(unitField.isInitialized()  ||  unitField.isUnknown())  {  [BUGGY]      for  (;  i  <  iTypes.length;  i++)  {  DateTimeFieldType  loopType  =  iTypes[i];  DurationField  loopUnitField  =  loopType.getDurationType().getField(iChronology);  if  (loopUnitField.isSupported())  {  int  compare  =  unitField.compareTo(loopUnitField);  if  (compare  >  0)  {  break;  }  else  if  (compare  ==  0)  {  DurationField  rangeField  =  fieldType.getRangeDurationType().getField(iChronology);  DurationField  loopRangeField  =  loopType.getRangeDurationType().getField(iChronology);  [CLASS]  Partial  Property  [METHOD]  with  [RETURN_TYPE]  Partial  DateTimeFieldType  fieldType  int  value  [VARIABLES]  boolean  DateTimeFieldType[]  iTypes  newTypes  types  Partial  iPartial  newPartial  partial  DateTimeFieldType  fieldType  loopType  int[]  iValues  newValues  values  Chronology  chrono  chronology  iChronology  newChronology  DurationField  loopRangeField  loopUnitField  rangeField  unitField  long  serialVersionUID  DateTimeFormatter[]  iFormatter  int  compare  fieldIndex  i  iFieldIndex  index  value  	projects/Time4/src/main/java/org/joda/time/Partial.java	0.2773500981126146	438	438	1	replace	if(unitField.isInitialized()  ||  unitField.isUnknown())  {	  if(unitField.isInitialized()    ||    unitField.isSupported())    {    	non-compiled	[CE]  	3	None	replace
