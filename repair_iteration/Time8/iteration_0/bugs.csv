bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < 0 || minutesOffset > 59) { [BUGGY] throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); [BUGGY] } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetHoursMinutes [RETURN_TYPE] DateTimeZone  int hoursOffset int minutesOffset [VARIABLES] Set cAvailableIDs ArithmeticException ex boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	1.0	280	280	1	replace	
2	[BUG] [BUGGY] [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < 0 || minutesOffset > 59) { [BUGGY] [BUGGY] throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetHoursMinutes [RETURN_TYPE] DateTimeZone  int hoursOffset int minutesOffset [VARIABLES] Set cAvailableIDs ArithmeticException ex boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	1.0	280	280	1	add	
3	[BUG] [BUGGY] return DateTimeZone.UTC; [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] if (id.equals("UTC")) { return DateTimeZone.UTC; } DateTimeZone zone = cProvider.getZone(id); if (zone != null) { return zone; } if (id.startsWith("+") || id.startsWith("-")) { int offset = parseOffset(id); if (offset == 0L) { [BUGGY] return DateTimeZone.UTC; [BUGGY] } else { id = printOffset(offset); return fixedOffsetZone(id, offset); } } throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); } [CLASS] DateTimeZone 1 Stub [METHOD] forID [RETURN_TYPE] DateTimeZone  String id [VARIABLES] Set cAvailableIDs boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.7071067811865475	218	218	1	replace	
4	[BUG] [BUGGY] [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] if (id.equals("UTC")) { return DateTimeZone.UTC; } DateTimeZone zone = cProvider.getZone(id); if (zone != null) { return zone; } if (id.startsWith("+") || id.startsWith("-")) { int offset = parseOffset(id); if (offset == 0L) { [BUGGY] [BUGGY] return DateTimeZone.UTC; } else { id = printOffset(offset); return fixedOffsetZone(id, offset); } } throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); } [CLASS] DateTimeZone 1 Stub [METHOD] forID [RETURN_TYPE] DateTimeZone  String id [VARIABLES] Set cAvailableIDs boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.7071067811865475	218	218	1	add	
5	[BUG] [BUGGY] if (hoursOffset == 0 && minutesOffset == 0) { [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { [BUGGY] if (hoursOffset == 0 && minutesOffset == 0) { [BUGGY] return DateTimeZone.UTC; } if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetHoursMinutes [RETURN_TYPE] DateTimeZone  int hoursOffset int minutesOffset [VARIABLES] Set cAvailableIDs ArithmeticException ex boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.7071067811865475	273	273	1	replace	
6	[BUG] [BUGGY] [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { [BUGGY] [BUGGY] if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetHoursMinutes [RETURN_TYPE] DateTimeZone  int hoursOffset int minutesOffset [VARIABLES] Set cAvailableIDs ArithmeticException ex boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.7071067811865475	273	273	1	add	
7	[BUG] [BUGGY] return DateTimeZone.UTC; [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { [BUGGY] return DateTimeZone.UTC; [BUGGY] } if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetHoursMinutes [RETURN_TYPE] DateTimeZone  int hoursOffset int minutesOffset [VARIABLES] Set cAvailableIDs ArithmeticException ex boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.7071067811865475	274	274	1	replace	
8	[BUG] [BUGGY] [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { [BUGGY] [BUGGY] return DateTimeZone.UTC; } if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetHoursMinutes [RETURN_TYPE] DateTimeZone  int hoursOffset int minutesOffset [VARIABLES] Set cAvailableIDs ArithmeticException ex boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.7071067811865475	274	274	1	add	
9	[BUG] [BUGGY] if (hoursOffset < -23 || hoursOffset > 23) { [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } [BUGGY] if (hoursOffset < -23 || hoursOffset > 23) { [BUGGY] throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetHoursMinutes [RETURN_TYPE] DateTimeZone  int hoursOffset int minutesOffset [VARIABLES] Set cAvailableIDs ArithmeticException ex boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.7071067811865475	276	276	1	replace	
10	[BUG] [BUGGY] [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } [BUGGY] [BUGGY] if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetHoursMinutes [RETURN_TYPE] DateTimeZone  int hoursOffset int minutesOffset [VARIABLES] Set cAvailableIDs ArithmeticException ex boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.7071067811865475	276	276	1	add	
11	[BUG] [BUGGY] if (minutesOffset < 0 || minutesOffset > 59) { [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } [BUGGY] if (minutesOffset < 0 || minutesOffset > 59) { [BUGGY] throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; } [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetHoursMinutes [RETURN_TYPE] DateTimeZone  int hoursOffset int minutesOffset [VARIABLES] Set cAvailableIDs ArithmeticException ex boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.7071067811865475	279	279	1	replace	
12	[BUG] [BUGGY] [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } [BUGGY] [BUGGY] if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; } [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetHoursMinutes [RETURN_TYPE] DateTimeZone  int hoursOffset int minutesOffset [VARIABLES] Set cAvailableIDs ArithmeticException ex boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.7071067811865475	279	279	1	add	
13	[BUG] [BUGGY] int offset = 0; [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } [BUGGY] int offset = 0; [BUGGY] try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetHoursMinutes [RETURN_TYPE] DateTimeZone  int hoursOffset int minutesOffset [VARIABLES] Set cAvailableIDs ArithmeticException ex boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.7071067811865475	282	282	1	replace	
14	[BUG] [BUGGY] [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } [BUGGY] [BUGGY] int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetHoursMinutes [RETURN_TYPE] DateTimeZone  int hoursOffset int minutesOffset [VARIABLES] Set cAvailableIDs ArithmeticException ex boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.7071067811865475	282	282	1	add	
15	[BUG] [BUGGY] int hoursInMinutes = hoursOffset * 60; [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] return DateTimeZone.UTC; } if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { [BUGGY] int hoursInMinutes = hoursOffset * 60; [BUGGY] if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); } return forOffsetMillis(offset); [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetHoursMinutes [RETURN_TYPE] DateTimeZone  int hoursOffset int minutesOffset [VARIABLES] Set cAvailableIDs ArithmeticException ex boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.7071067811865475	284	284	1	replace	
16	[BUG] [BUGGY] [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] return DateTimeZone.UTC; } if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { [BUGGY] [BUGGY] int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); } return forOffsetMillis(offset); [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetHoursMinutes [RETURN_TYPE] DateTimeZone  int hoursOffset int minutesOffset [VARIABLES] Set cAvailableIDs ArithmeticException ex boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.7071067811865475	284	284	1	add	
17	[BUG] [BUGGY] if (hoursInMinutes < 0) { [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] } if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; [BUGGY] if (hoursInMinutes < 0) { [BUGGY] minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); } return forOffsetMillis(offset); } [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetHoursMinutes [RETURN_TYPE] DateTimeZone  int hoursOffset int minutesOffset [VARIABLES] Set cAvailableIDs ArithmeticException ex boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.7071067811865475	285	285	1	replace	
18	[BUG] [BUGGY] [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] } if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; [BUGGY] [BUGGY] if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); } return forOffsetMillis(offset); } [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetHoursMinutes [RETURN_TYPE] DateTimeZone  int hoursOffset int minutesOffset [VARIABLES] Set cAvailableIDs ArithmeticException ex boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.7071067811865475	285	285	1	add	
19	[BUG] [BUGGY] minutesOffset = hoursInMinutes + minutesOffset; [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { [BUGGY] minutesOffset = hoursInMinutes + minutesOffset; [BUGGY] } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); } return forOffsetMillis(offset); } [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetHoursMinutes [RETURN_TYPE] DateTimeZone  int hoursOffset int minutesOffset [VARIABLES] Set cAvailableIDs ArithmeticException ex boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.7071067811865475	288	288	1	replace	
20	[BUG] [BUGGY] [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { [BUGGY] [BUGGY] minutesOffset = hoursInMinutes + minutesOffset; } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); } return forOffsetMillis(offset); } [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetHoursMinutes [RETURN_TYPE] DateTimeZone  int hoursOffset int minutesOffset [VARIABLES] Set cAvailableIDs ArithmeticException ex boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.7071067811865475	288	288	1	add	
21	[BUG] [BUGGY] offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; } [BUGGY] offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); [BUGGY] } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); } return forOffsetMillis(offset); } [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetHoursMinutes [RETURN_TYPE] DateTimeZone  int hoursOffset int minutesOffset [VARIABLES] Set cAvailableIDs ArithmeticException ex boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.7071067811865475	290	290	1	replace	
22	[BUG] [BUGGY] [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; } [BUGGY] [BUGGY] offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); } return forOffsetMillis(offset); } [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetHoursMinutes [RETURN_TYPE] DateTimeZone  int hoursOffset int minutesOffset [VARIABLES] Set cAvailableIDs ArithmeticException ex boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.7071067811865475	290	290	1	add	
23	[BUG] [BUGGY] } [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); [BUGGY] } [BUGGY] return forOffsetMillis(offset); } [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetHoursMinutes [RETURN_TYPE] DateTimeZone  int hoursOffset int minutesOffset [VARIABLES] Set cAvailableIDs ArithmeticException ex boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.7071067811865475	293	293	1	replace	
24	[BUG] [BUGGY] [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); [BUGGY] [BUGGY] } return forOffsetMillis(offset); } [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetHoursMinutes [RETURN_TYPE] DateTimeZone  int hoursOffset int minutesOffset [VARIABLES] Set cAvailableIDs ArithmeticException ex boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.7071067811865475	293	293	1	add	
25	[BUG] [BUGGY] return forOffsetMillis(offset); [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); } [BUGGY] return forOffsetMillis(offset); [BUGGY] } [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetHoursMinutes [RETURN_TYPE] DateTimeZone  int hoursOffset int minutesOffset [VARIABLES] Set cAvailableIDs ArithmeticException ex boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.7071067811865475	294	294	1	replace	
26	[BUG] [BUGGY] [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); } [BUGGY] [BUGGY] return forOffsetMillis(offset); } [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetHoursMinutes [RETURN_TYPE] DateTimeZone  int hoursOffset int minutesOffset [VARIABLES] Set cAvailableIDs ArithmeticException ex boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.7071067811865475	294	294	1	add	
27	[BUG] [BUGGY] if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) { [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] public static DateTimeZone forOffsetMillis(int millisOffset) { [BUGGY] if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) { [BUGGY] throw new IllegalArgumentException("Millis out of range: " + millisOffset); } String id = printOffset(millisOffset); return fixedOffsetZone(id, millisOffset); } [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetMillis [RETURN_TYPE] DateTimeZone  int millisOffset [VARIABLES] Set cAvailableIDs boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset millisOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.5773502691896258	304	304	1	replace	
28	[BUG] [BUGGY] [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] public static DateTimeZone forOffsetMillis(int millisOffset) { [BUGGY] [BUGGY] if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) { throw new IllegalArgumentException("Millis out of range: " + millisOffset); } String id = printOffset(millisOffset); return fixedOffsetZone(id, millisOffset); } [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetMillis [RETURN_TYPE] DateTimeZone  int millisOffset [VARIABLES] Set cAvailableIDs boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset millisOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.5773502691896258	304	304	1	add	
29	[BUG] [BUGGY] String id = printOffset(millisOffset); [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] public static DateTimeZone forOffsetMillis(int millisOffset) { if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) { throw new IllegalArgumentException("Millis out of range: " + millisOffset); } [BUGGY] String id = printOffset(millisOffset); [BUGGY] return fixedOffsetZone(id, millisOffset); } [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetMillis [RETURN_TYPE] DateTimeZone  int millisOffset [VARIABLES] Set cAvailableIDs boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset millisOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.5773502691896258	307	307	1	replace	
30	[BUG] [BUGGY] [FE] IllegalArgumentException testForOffsetHoursMinutes_int_int [CONTEXT] public static DateTimeZone forOffsetMillis(int millisOffset) { if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) { throw new IllegalArgumentException("Millis out of range: " + millisOffset); } [BUGGY] [BUGGY] String id = printOffset(millisOffset); return fixedOffsetZone(id, millisOffset); } [CLASS] DateTimeZone 1 Stub [METHOD] forOffsetMillis [RETURN_TYPE] DateTimeZone  int millisOffset [VARIABLES] Set cAvailableIDs boolean NameProvider cNameProvider String iID id DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache long serialVersionUID DateTimeZone UTC cDefault temp zone int MAX_MILLIS hoursInMinutes hoursOffset millisOffset minutesOffset offset Provider cProvider  	projects/Time8/src/main/java/org/joda/time/DateTimeZone.java	0.5773502691896258	307	307	1	add	
