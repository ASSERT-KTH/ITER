bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] Node lhs = thenOp.getFirstChild(); [FE] AssertionFailedError [CONTEXT] boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch); boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch); if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) { Node thenOp = getBlockExpression(thenBranch).getFirstChild(); Node elseOp = getBlockExpression(elseBranch).getFirstChild(); if (thenOp.getType() == elseOp.getType()) {  if (NodeUtil.isAssignmentOp(thenOp)) { [BUGGY] Node lhs = thenOp.getFirstChild(); [BUGGY] if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&     !mayEffectMutableState(lhs)) { n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	776	776	1	replace	
2	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch); boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch); if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) { Node thenOp = getBlockExpression(thenBranch).getFirstChild(); Node elseOp = getBlockExpression(elseBranch).getFirstChild(); if (thenOp.getType() == elseOp.getType()) {  if (NodeUtil.isAssignmentOp(thenOp)) { [BUGGY] [BUGGY] Node lhs = thenOp.getFirstChild(); if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&     !mayEffectMutableState(lhs)) { n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	776	776	1	add	
3	[BUG] [BUGGY] if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization  // evaluates LHS before cond] [FE] AssertionFailedError [CONTEXT] boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch); boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch); if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) { Node thenOp = getBlockExpression(thenBranch).getFirstChild(); Node elseOp = getBlockExpression(elseBranch).getFirstChild(); if (thenOp.getType() == elseOp.getType()) {  if (NodeUtil.isAssignmentOp(thenOp)) { Node lhs = thenOp.getFirstChild(); [BUGGY] if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&    // if LHS has side effects, don't proceed [since the optimization       // evaluates LHS before cond] [BUGGY]     !mayEffectMutableState(lhs)) { n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	777	779	1	replace	
4	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch); boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch); if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) { Node thenOp = getBlockExpression(thenBranch).getFirstChild(); Node elseOp = getBlockExpression(elseBranch).getFirstChild(); if (thenOp.getType() == elseOp.getType()) {  if (NodeUtil.isAssignmentOp(thenOp)) { Node lhs = thenOp.getFirstChild(); [BUGGY] [BUGGY] if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&    // if LHS has side effects, don't proceed [since the optimization       // evaluates LHS before cond]     !mayEffectMutableState(lhs)) { n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	777	779	1	add	
5	[BUG] [BUGGY] n.removeChild(cond); [FE] AssertionFailedError [CONTEXT] if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&     !mayEffectMutableState(lhs)) { [BUGGY] n.removeChild(cond); [BUGGY] Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); Node assign = new Node(thenOp.getType(), assignName, hookNode) .srcref(thenOp); Node expr = NodeUtil.newExpr(assign); parent.replaceChild(n, expr); [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	784	784	1	replace	
6	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&     !mayEffectMutableState(lhs)) { [BUGGY] [BUGGY] n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); Node assign = new Node(thenOp.getType(), assignName, hookNode) .srcref(thenOp); Node expr = NodeUtil.newExpr(assign); parent.replaceChild(n, expr); [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	784	784	1	add	
7	[BUG] [BUGGY] Node assignName = thenOp.removeFirstChild(); [FE] AssertionFailedError [CONTEXT] if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&     !mayEffectMutableState(lhs)) { n.removeChild(cond); [BUGGY] Node assignName = thenOp.removeFirstChild(); [BUGGY] Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); Node assign = new Node(thenOp.getType(), assignName, hookNode) .srcref(thenOp); Node expr = NodeUtil.newExpr(assign); parent.replaceChild(n, expr); reportCodeChange(); [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	785	785	1	replace	
8	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&     !mayEffectMutableState(lhs)) { n.removeChild(cond); [BUGGY] [BUGGY] Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); Node assign = new Node(thenOp.getType(), assignName, hookNode) .srcref(thenOp); Node expr = NodeUtil.newExpr(assign); parent.replaceChild(n, expr); reportCodeChange(); [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	785	785	1	add	
9	[BUG] [BUGGY] Node thenExpr = thenOp.removeFirstChild(); [FE] AssertionFailedError [CONTEXT] if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&     !mayEffectMutableState(lhs)) { n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); [BUGGY] Node thenExpr = thenOp.removeFirstChild(); [BUGGY] Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); Node assign = new Node(thenOp.getType(), assignName, hookNode) .srcref(thenOp); Node expr = NodeUtil.newExpr(assign); parent.replaceChild(n, expr); reportCodeChange();  [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	786	786	1	replace	
10	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&     !mayEffectMutableState(lhs)) { n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); [BUGGY] [BUGGY] Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); Node assign = new Node(thenOp.getType(), assignName, hookNode) .srcref(thenOp); Node expr = NodeUtil.newExpr(assign); parent.replaceChild(n, expr); reportCodeChange();  [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	786	786	1	add	
11	[BUG] [BUGGY] Node elseExpr = elseOp.getLastChild(); [FE] AssertionFailedError [CONTEXT] if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&     !mayEffectMutableState(lhs)) { n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); [BUGGY] Node elseExpr = elseOp.getLastChild(); [BUGGY] elseOp.removeChild(elseExpr); Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); Node assign = new Node(thenOp.getType(), assignName, hookNode) .srcref(thenOp); Node expr = NodeUtil.newExpr(assign); parent.replaceChild(n, expr); reportCodeChange(); return expr; [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	787	787	1	replace	
12	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&     !mayEffectMutableState(lhs)) { n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); [BUGGY] [BUGGY] Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); Node assign = new Node(thenOp.getType(), assignName, hookNode) .srcref(thenOp); Node expr = NodeUtil.newExpr(assign); parent.replaceChild(n, expr); reportCodeChange(); return expr; [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	787	787	1	add	
13	[BUG] [BUGGY] elseOp.removeChild(elseExpr); [FE] AssertionFailedError [CONTEXT]     !mayEffectMutableState(lhs)) { n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); [BUGGY] elseOp.removeChild(elseExpr); [BUGGY]  Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); Node assign = new Node(thenOp.getType(), assignName, hookNode) .srcref(thenOp); Node expr = NodeUtil.newExpr(assign); parent.replaceChild(n, expr); reportCodeChange(); return expr; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	788	788	1	replace	
14	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]     !mayEffectMutableState(lhs)) { n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); [BUGGY] [BUGGY] elseOp.removeChild(elseExpr); Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); Node assign = new Node(thenOp.getType(), assignName, hookNode) .srcref(thenOp); Node expr = NodeUtil.newExpr(assign); parent.replaceChild(n, expr); reportCodeChange(); return expr; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	788	788	1	add	
15	[BUG] [BUGGY] Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); [FE] AssertionFailedError [CONTEXT]   !mayEffectMutableState(lhs)) { n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); [BUGGY] Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); [BUGGY] Node assign = new Node(thenOp.getType(), assignName, hookNode) .srcref(thenOp); Node expr = NodeUtil.newExpr(assign); parent.replaceChild(n, expr); reportCodeChange(); return expr; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	790	790	1	replace	
16	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]   !mayEffectMutableState(lhs)) { n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); [BUGGY] [BUGGY] Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); Node assign = new Node(thenOp.getType(), assignName, hookNode) .srcref(thenOp); Node expr = NodeUtil.newExpr(assign); parent.replaceChild(n, expr); reportCodeChange(); return expr; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	790	790	1	add	
17	[BUG] [BUGGY] Node assign = new Node(thenOp.getType(), assignName, hookNode)  .srcref(thenOp); [FE] AssertionFailedError [CONTEXT]  !mayEffectMutableState(lhs)) { n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); [BUGGY] Node assign = new Node(thenOp.getType(), assignName, hookNode)        .srcref(thenOp); [BUGGY] .srcref(thenOp); Node expr = NodeUtil.newExpr(assign); parent.replaceChild(n, expr); reportCodeChange(); return expr; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	791	792	1	replace	
18	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  !mayEffectMutableState(lhs)) { n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); [BUGGY] [BUGGY] Node assign = new Node(thenOp.getType(), assignName, hookNode)        .srcref(thenOp); .srcref(thenOp); Node expr = NodeUtil.newExpr(assign); parent.replaceChild(n, expr); reportCodeChange(); return expr; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	791	792	1	add	
19	[BUG] [BUGGY] Node expr = NodeUtil.newExpr(assign); [FE] AssertionFailedError [CONTEXT] n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); Node assign = new Node(thenOp.getType(), assignName, hookNode) .srcref(thenOp); [BUGGY] Node expr = NodeUtil.newExpr(assign); [BUGGY] parent.replaceChild(n, expr); reportCodeChange(); return expr; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	793	793	1	replace	
20	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); Node assign = new Node(thenOp.getType(), assignName, hookNode) .srcref(thenOp); [BUGGY] [BUGGY] Node expr = NodeUtil.newExpr(assign); parent.replaceChild(n, expr); reportCodeChange(); return expr; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	793	793	1	add	
21	[BUG] [BUGGY] parent.replaceChild(n, expr); [FE] AssertionFailedError [CONTEXT] n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); Node assign = new Node(thenOp.getType(), assignName, hookNode) .srcref(thenOp); Node expr = NodeUtil.newExpr(assign); [BUGGY] parent.replaceChild(n, expr); [BUGGY] reportCodeChange(); return expr; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	794	794	1	replace	
22	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); Node assign = new Node(thenOp.getType(), assignName, hookNode) .srcref(thenOp); Node expr = NodeUtil.newExpr(assign); [BUGGY] [BUGGY] parent.replaceChild(n, expr); reportCodeChange(); return expr; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	794	794	1	add	
23	[BUG] [BUGGY] reportCodeChange(); [FE] AssertionFailedError [CONTEXT] Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); Node assign = new Node(thenOp.getType(), assignName, hookNode) .srcref(thenOp); Node expr = NodeUtil.newExpr(assign); parent.replaceChild(n, expr); [BUGGY] reportCodeChange(); [BUGGY]  return expr; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	795	795	1	replace	
24	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); Node assign = new Node(thenOp.getType(), assignName, hookNode) .srcref(thenOp); Node expr = NodeUtil.newExpr(assign); parent.replaceChild(n, expr); [BUGGY] [BUGGY] reportCodeChange(); return expr; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	795	795	1	add	
25	[BUG] [BUGGY] return expr; [FE] AssertionFailedError [CONTEXT] Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); Node assign = new Node(thenOp.getType(), assignName, hookNode) .srcref(thenOp); Node expr = NodeUtil.newExpr(assign); parent.replaceChild(n, expr); reportCodeChange(); [BUGGY] return expr; [BUGGY] } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	797	797	1	replace	
26	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); Node assign = new Node(thenOp.getType(), assignName, hookNode) .srcref(thenOp); Node expr = NodeUtil.newExpr(assign); parent.replaceChild(n, expr); reportCodeChange(); [BUGGY] [BUGGY] return expr; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5773502691896258	797	797	1	add	
27	[BUG] [BUGGY] if (NodeUtil.isAssignmentOp(thenOp)) { [FE] AssertionFailedError [CONTEXT] } boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch); boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch); if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) { Node thenOp = getBlockExpression(thenBranch).getFirstChild(); Node elseOp = getBlockExpression(elseBranch).getFirstChild(); if (thenOp.getType() == elseOp.getType()) {  [BUGGY] if (NodeUtil.isAssignmentOp(thenOp)) { [BUGGY] Node lhs = thenOp.getFirstChild(); if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&     !mayEffectMutableState(lhs)) { n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5	775	775	1	replace	
28	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch); boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch); if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) { Node thenOp = getBlockExpression(thenBranch).getFirstChild(); Node elseOp = getBlockExpression(elseBranch).getFirstChild(); if (thenOp.getType() == elseOp.getType()) {  [BUGGY] [BUGGY] if (NodeUtil.isAssignmentOp(thenOp)) { Node lhs = thenOp.getFirstChild(); if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&     !mayEffectMutableState(lhs)) { n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.5	775	775	1	add	
29	[BUG] [BUGGY] Node thenOp = getBlockExpression(thenBranch).getFirstChild(); [FE] AssertionFailedError [CONTEXT] .srcref(n)); parent.replaceChild(n, returnNode); reportCodeChange(); return returnNode; } boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch); boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch); if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) { [BUGGY] Node thenOp = getBlockExpression(thenBranch).getFirstChild(); [BUGGY] Node elseOp = getBlockExpression(elseBranch).getFirstChild(); if (thenOp.getType() == elseOp.getType()) {  if (NodeUtil.isAssignmentOp(thenOp)) { Node lhs = thenOp.getFirstChild(); if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&     [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4472135954999579	771	771	1	replace	
30	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] .srcref(n)); parent.replaceChild(n, returnNode); reportCodeChange(); return returnNode; } boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch); boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch); if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) { [BUGGY] [BUGGY] Node thenOp = getBlockExpression(thenBranch).getFirstChild(); Node elseOp = getBlockExpression(elseBranch).getFirstChild(); if (thenOp.getType() == elseOp.getType()) {  if (NodeUtil.isAssignmentOp(thenOp)) { Node lhs = thenOp.getFirstChild(); if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&     [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4472135954999579	771	771	1	add	
31	[BUG] [BUGGY] Node elseOp = getBlockExpression(elseBranch).getFirstChild(); [FE] AssertionFailedError [CONTEXT] parent.replaceChild(n, returnNode); reportCodeChange(); return returnNode; } boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch); boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch); if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) { Node thenOp = getBlockExpression(thenBranch).getFirstChild(); [BUGGY] Node elseOp = getBlockExpression(elseBranch).getFirstChild(); [BUGGY] if (thenOp.getType() == elseOp.getType()) {  if (NodeUtil.isAssignmentOp(thenOp)) { Node lhs = thenOp.getFirstChild(); if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&     !mayEffectMutableState(lhs)) { [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4472135954999579	772	772	1	replace	
32	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] parent.replaceChild(n, returnNode); reportCodeChange(); return returnNode; } boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch); boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch); if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) { Node thenOp = getBlockExpression(thenBranch).getFirstChild(); [BUGGY] [BUGGY] Node elseOp = getBlockExpression(elseBranch).getFirstChild(); if (thenOp.getType() == elseOp.getType()) {  if (NodeUtil.isAssignmentOp(thenOp)) { Node lhs = thenOp.getFirstChild(); if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&     !mayEffectMutableState(lhs)) { [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4472135954999579	772	772	1	add	
33	[BUG] [BUGGY] if (thenOp.getType() == elseOp.getType()) { [FE] AssertionFailedError [CONTEXT] reportCodeChange(); return returnNode; } boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch); boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch); if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) { Node thenOp = getBlockExpression(thenBranch).getFirstChild(); Node elseOp = getBlockExpression(elseBranch).getFirstChild(); [BUGGY] if (thenOp.getType() == elseOp.getType()) { [BUGGY]  if (NodeUtil.isAssignmentOp(thenOp)) { Node lhs = thenOp.getFirstChild(); if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&     !mayEffectMutableState(lhs)) {  [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4472135954999579	773	773	1	replace	
34	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] reportCodeChange(); return returnNode; } boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch); boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch); if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) { Node thenOp = getBlockExpression(thenBranch).getFirstChild(); Node elseOp = getBlockExpression(elseBranch).getFirstChild(); [BUGGY] [BUGGY] if (thenOp.getType() == elseOp.getType()) {  if (NodeUtil.isAssignmentOp(thenOp)) { Node lhs = thenOp.getFirstChild(); if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&     !mayEffectMutableState(lhs)) {  [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.4472135954999579	773	773	1	add	
35	[BUG] [BUGGY] Preconditions.checkState(isFoldableExpressBlock(n)); [FE] AssertionFailedError [CONTEXT] private Node getBlockExpression(Node n) { [BUGGY] Preconditions.checkState(isFoldableExpressBlock(n)); [BUGGY] return n.getFirstChild(); } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] getBlockExpression [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node n CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.31622776601683794	963	963	1	replace	
36	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private Node getBlockExpression(Node n) { [BUGGY] [BUGGY] Preconditions.checkState(isFoldableExpressBlock(n)); return n.getFirstChild(); } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] getBlockExpression [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node n CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.31622776601683794	963	963	1	add	
37	[BUG] [BUGGY] return n.getFirstChild(); [FE] AssertionFailedError [CONTEXT] private Node getBlockExpression(Node n) { Preconditions.checkState(isFoldableExpressBlock(n)); [BUGGY] return n.getFirstChild(); [BUGGY] } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] getBlockExpression [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node n CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.31622776601683794	964	964	1	replace	
38	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private Node getBlockExpression(Node n) { Preconditions.checkState(isFoldableExpressBlock(n)); [BUGGY] [BUGGY] return n.getFirstChild(); } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] getBlockExpression [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node n CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.31622776601683794	964	964	1	add	
39	[BUG] [BUGGY] tryRemoveRepeatedStatements(n); [FE] AssertionFailedError [CONTEXT] } } } return n; }    [BUGGY] tryRemoveRepeatedStatements(n); [BUGGY]    if (cond.isNot() && !consumesDanglingElse(elseBranch)) { n.replaceChild(cond, cond.removeFirstChild()); n.removeChild(thenBranch); n.addChildToBack(thenBranch); reportCodeChange(); return n; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.25	736	736	1	replace	
40	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } } } return n; }    [BUGGY] [BUGGY] tryRemoveRepeatedStatements(n);   if (cond.isNot() && !consumesDanglingElse(elseBranch)) { n.replaceChild(cond, cond.removeFirstChild()); n.removeChild(thenBranch); n.addChildToBack(thenBranch); reportCodeChange(); return n; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.25	736	736	1	add	
41	[BUG] [BUGGY] if (cond.isNot() && !consumesDanglingElse(elseBranch)) { [FE] AssertionFailedError [CONTEXT] return n; }    tryRemoveRepeatedStatements(n);   [BUGGY] if (cond.isNot() && !consumesDanglingElse(elseBranch)) { [BUGGY] n.replaceChild(cond, cond.removeFirstChild()); n.removeChild(thenBranch); n.addChildToBack(thenBranch); reportCodeChange(); return n; }  if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) { Node thenExpr = getBlockReturnExpression(thenBranch); [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.25	740	740	1	replace	
42	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] return n; }    tryRemoveRepeatedStatements(n);   [BUGGY] [BUGGY] if (cond.isNot() && !consumesDanglingElse(elseBranch)) { n.replaceChild(cond, cond.removeFirstChild()); n.removeChild(thenBranch); n.addChildToBack(thenBranch); reportCodeChange(); return n; }  if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) { Node thenExpr = getBlockReturnExpression(thenBranch); [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.25	740	740	1	add	
43	[BUG] [BUGGY] if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) { [FE] AssertionFailedError [CONTEXT]  if (cond.isNot() && !consumesDanglingElse(elseBranch)) { n.replaceChild(cond, cond.removeFirstChild()); n.removeChild(thenBranch); n.addChildToBack(thenBranch); reportCodeChange(); return n; }  [BUGGY] if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) { [BUGGY] Node thenExpr = getBlockReturnExpression(thenBranch); Node elseExpr = getBlockReturnExpression(elseBranch); n.removeChild(cond); thenExpr.detachFromParent(); elseExpr.detachFromParent();    Node returnNode = IR.returnNode( [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.25	749	749	1	replace	
44	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  if (cond.isNot() && !consumesDanglingElse(elseBranch)) { n.replaceChild(cond, cond.removeFirstChild()); n.removeChild(thenBranch); n.addChildToBack(thenBranch); reportCodeChange(); return n; }  [BUGGY] [BUGGY] if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) { Node thenExpr = getBlockReturnExpression(thenBranch); Node elseExpr = getBlockReturnExpression(elseBranch); n.removeChild(cond); thenExpr.detachFromParent(); elseExpr.detachFromParent();    Node returnNode = IR.returnNode( [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.25	749	749	1	add	
45	[BUG] [BUGGY] boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch); [FE] AssertionFailedError [CONTEXT]   Node returnNode = IR.returnNode( IR.hook(cond, thenExpr, elseExpr) .srcref(n)); parent.replaceChild(n, returnNode); reportCodeChange(); return returnNode; } [BUGGY] boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch); [BUGGY] boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch); if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) { Node thenOp = getBlockExpression(thenBranch).getFirstChild(); Node elseOp = getBlockExpression(elseBranch).getFirstChild(); if (thenOp.getType() == elseOp.getType()) {  if (NodeUtil.isAssignmentOp(thenOp)) { Node lhs = thenOp.getFirstChild(); if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.25	767	767	1	replace	
46	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]   Node returnNode = IR.returnNode( IR.hook(cond, thenExpr, elseExpr) .srcref(n)); parent.replaceChild(n, returnNode); reportCodeChange(); return returnNode; } [BUGGY] [BUGGY] boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch); boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch); if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) { Node thenOp = getBlockExpression(thenBranch).getFirstChild(); Node elseOp = getBlockExpression(elseBranch).getFirstChild(); if (thenOp.getType() == elseOp.getType()) {  if (NodeUtil.isAssignmentOp(thenOp)) { Node lhs = thenOp.getFirstChild(); if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.25	767	767	1	add	
47	[BUG] [BUGGY] boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch); [FE] AssertionFailedError [CONTEXT]  Node returnNode = IR.returnNode( IR.hook(cond, thenExpr, elseExpr) .srcref(n)); parent.replaceChild(n, returnNode); reportCodeChange(); return returnNode; } boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch); [BUGGY] boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch); [BUGGY]  if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) { Node thenOp = getBlockExpression(thenBranch).getFirstChild(); Node elseOp = getBlockExpression(elseBranch).getFirstChild(); if (thenOp.getType() == elseOp.getType()) {  if (NodeUtil.isAssignmentOp(thenOp)) { Node lhs = thenOp.getFirstChild(); if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&  [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.25	768	768	1	replace	
48	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  Node returnNode = IR.returnNode( IR.hook(cond, thenExpr, elseExpr) .srcref(n)); parent.replaceChild(n, returnNode); reportCodeChange(); return returnNode; } boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch); [BUGGY] [BUGGY] boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch); if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) { Node thenOp = getBlockExpression(thenBranch).getFirstChild(); Node elseOp = getBlockExpression(elseBranch).getFirstChild(); if (thenOp.getType() == elseOp.getType()) {  if (NodeUtil.isAssignmentOp(thenOp)) { Node lhs = thenOp.getFirstChild(); if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&  [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.25	768	768	1	add	
49	[BUG] [BUGGY] if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) { [FE] AssertionFailedError [CONTEXT] IR.hook(cond, thenExpr, elseExpr) .srcref(n)); parent.replaceChild(n, returnNode); reportCodeChange(); return returnNode; } boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch); boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch); [BUGGY] if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) { [BUGGY] Node thenOp = getBlockExpression(thenBranch).getFirstChild(); Node elseOp = getBlockExpression(elseBranch).getFirstChild(); if (thenOp.getType() == elseOp.getType()) {  if (NodeUtil.isAssignmentOp(thenOp)) { Node lhs = thenOp.getFirstChild(); if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&    [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.25	770	770	1	replace	
50	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] IR.hook(cond, thenExpr, elseExpr) .srcref(n)); parent.replaceChild(n, returnNode); reportCodeChange(); return returnNode; } boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch); boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch); [BUGGY] [BUGGY] if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) { Node thenOp = getBlockExpression(thenBranch).getFirstChild(); Node elseOp = getBlockExpression(elseBranch).getFirstChild(); if (thenOp.getType() == elseOp.getType()) {  if (NodeUtil.isAssignmentOp(thenOp)) { Node lhs = thenOp.getFirstChild(); if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&    [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node  Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE  	projects/Closure132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	0.25	770	770	1	add	
