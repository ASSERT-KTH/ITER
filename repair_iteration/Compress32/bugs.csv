bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] currEntry.setGroupId(Integer.parseInt(val)); [FE] NumberFormatException [CONTEXT]   for (Entry<String, String> ent : headers.entrySet()){ String key = ent.getKey(); String val = ent.getValue(); if ("path".equals(key)){ currEntry.setName(val); } else if ("linkpath".equals(key)){ currEntry.setLinkName(val); } else if ("gid".equals(key)){ [BUGGY] currEntry.setGroupId(Integer.parseInt(val)); [BUGGY] } else if ("gname".equals(key)){ currEntry.setGroupName(val); } else if ("uid".equals(key)){ currEntry.setUserId(Integer.parseInt(val)); } else if ("uname".equals(key)){ currEntry.setUserName(val); } else if ("size".equals(key)){ currEntry.setSize(Long.parseLong(val)); } else if ("mtime".equals(key)){ currEntry.setModTime((long) (Double.parseDouble(val) * 1000)); [CLASS] TarArchiveInputStream [METHOD] applyPaxHeadersToCurrentEntry [RETURN_TYPE] void  String> headers [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest Entry ent boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	1.0	501	501	1	replace	
2	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT]   for (Entry<String, String> ent : headers.entrySet()){ String key = ent.getKey(); String val = ent.getValue(); if ("path".equals(key)){ currEntry.setName(val); } else if ("linkpath".equals(key)){ currEntry.setLinkName(val); } else if ("gid".equals(key)){ [BUGGY] [BUGGY] currEntry.setGroupId(Integer.parseInt(val)); } else if ("gname".equals(key)){ currEntry.setGroupName(val); } else if ("uid".equals(key)){ currEntry.setUserId(Integer.parseInt(val)); } else if ("uname".equals(key)){ currEntry.setUserName(val); } else if ("size".equals(key)){ currEntry.setSize(Long.parseLong(val)); } else if ("mtime".equals(key)){ currEntry.setModTime((long) (Double.parseDouble(val) * 1000)); [CLASS] TarArchiveInputStream [METHOD] applyPaxHeadersToCurrentEntry [RETURN_TYPE] void  String> headers [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest Entry ent boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	1.0	501	501	1	add	
3	[BUG] [BUGGY] paxHeaders(); [FE] NumberFormatException [CONTEXT] if (longNameData == null) {    return null; } currEntry.setName(zipEncoding.decode(longNameData)); } if (currEntry.isPaxHeader()){ // Process Pax headers [BUGGY] paxHeaders(); [BUGGY] } if (currEntry.isGNUSparse()){ // Process sparse files readGNUSparse(); }      [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding IOException ioe int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.7071067811865475	311	311	1	replace	
4	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] if (longNameData == null) {    return null; } currEntry.setName(zipEncoding.decode(longNameData)); } if (currEntry.isPaxHeader()){ // Process Pax headers [BUGGY] [BUGGY] paxHeaders(); } if (currEntry.isGNUSparse()){ // Process sparse files readGNUSparse(); }      [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding IOException ioe int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.7071067811865475	311	311	1	add	
5	[BUG] [BUGGY] Map<String, String> headers = parsePaxHeaders(this); [FE] NumberFormatException [CONTEXT] private void paxHeaders() throws IOException{ [BUGGY] Map<String, String> headers = parsePaxHeaders(this); [BUGGY] getNextEntry(); // Get the actual file entry applyPaxHeadersToCurrentEntry(headers); } [CLASS] TarArchiveInputStream [METHOD] paxHeaders [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map headers int SMALL_BUFFER_SIZE blockSize length markLimit readNow recordSize long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.7071067811865475	429	429	1	replace	
6	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] private void paxHeaders() throws IOException{ [BUGGY] [BUGGY] Map<String, String> headers = parsePaxHeaders(this); getNextEntry(); // Get the actual file entry applyPaxHeadersToCurrentEntry(headers); } [CLASS] TarArchiveInputStream [METHOD] paxHeaders [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map headers int SMALL_BUFFER_SIZE blockSize length markLimit readNow recordSize long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.7071067811865475	429	429	1	add	
7	[BUG] [BUGGY] getNextEntry(); // Get the actual file entry applyPaxHeadersToCurrentEntry(headers); [FE] NumberFormatException [CONTEXT] private void paxHeaders() throws IOException{ Map<String, String> headers = parsePaxHeaders(this); [BUGGY] getNextEntry(); // Get the actual file entry  applyPaxHeadersToCurrentEntry(headers); [BUGGY] applyPaxHeadersToCurrentEntry(headers); } [CLASS] TarArchiveInputStream [METHOD] paxHeaders [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map headers int SMALL_BUFFER_SIZE blockSize length markLimit readNow recordSize long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.7071067811865475	430	431	1	replace	
8	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] private void paxHeaders() throws IOException{ Map<String, String> headers = parsePaxHeaders(this); [BUGGY] [BUGGY] getNextEntry(); // Get the actual file entry  applyPaxHeadersToCurrentEntry(headers); applyPaxHeadersToCurrentEntry(headers); } [CLASS] TarArchiveInputStream [METHOD] paxHeaders [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map headers int SMALL_BUFFER_SIZE blockSize length markLimit readNow recordSize long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.7071067811865475	430	431	1	add	
9	[BUG] [BUGGY] applyPaxHeadersToCurrentEntry(headers); [FE] NumberFormatException [CONTEXT] private void paxHeaders() throws IOException{ Map<String, String> headers = parsePaxHeaders(this); getNextEntry(); // Get the actual file entry [BUGGY] applyPaxHeadersToCurrentEntry(headers); [BUGGY] } [CLASS] TarArchiveInputStream [METHOD] paxHeaders [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map headers int SMALL_BUFFER_SIZE blockSize length markLimit readNow recordSize long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.7071067811865475	431	431	1	replace	
10	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] private void paxHeaders() throws IOException{ Map<String, String> headers = parsePaxHeaders(this); getNextEntry(); // Get the actual file entry [BUGGY] [BUGGY] applyPaxHeadersToCurrentEntry(headers); } [CLASS] TarArchiveInputStream [METHOD] paxHeaders [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map headers int SMALL_BUFFER_SIZE blockSize length markLimit readNow recordSize long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.7071067811865475	431	431	1	add	
11	[BUG] [BUGGY] for (Entry<String, String> ent : headers.entrySet()){ [FE] NumberFormatException [CONTEXT]           [BUGGY] for (Entry<String, String> ent : headers.entrySet()){ [BUGGY] String key = ent.getKey(); String val = ent.getValue(); if ("path".equals(key)){ currEntry.setName(val); } else if ("linkpath".equals(key)){ currEntry.setLinkName(val); } else if ("gid".equals(key)){ currEntry.setGroupId(Integer.parseInt(val)); } else if ("gname".equals(key)){ currEntry.setGroupName(val); [CLASS] TarArchiveInputStream [METHOD] applyPaxHeadersToCurrentEntry [RETURN_TYPE] void  String> headers [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest Entry ent boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.7071067811865475	493	493	1	replace	
12	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT]           [BUGGY] [BUGGY] for (Entry<String, String> ent : headers.entrySet()){ String key = ent.getKey(); String val = ent.getValue(); if ("path".equals(key)){ currEntry.setName(val); } else if ("linkpath".equals(key)){ currEntry.setLinkName(val); } else if ("gid".equals(key)){ currEntry.setGroupId(Integer.parseInt(val)); } else if ("gname".equals(key)){ currEntry.setGroupName(val); [CLASS] TarArchiveInputStream [METHOD] applyPaxHeadersToCurrentEntry [RETURN_TYPE] void  String> headers [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest Entry ent boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.7071067811865475	493	493	1	add	
13	[BUG] [BUGGY] String key = ent.getKey(); [FE] NumberFormatException [CONTEXT]          for (Entry<String, String> ent : headers.entrySet()){ [BUGGY] String key = ent.getKey(); [BUGGY] String val = ent.getValue(); if ("path".equals(key)){ currEntry.setName(val); } else if ("linkpath".equals(key)){ currEntry.setLinkName(val); } else if ("gid".equals(key)){ currEntry.setGroupId(Integer.parseInt(val)); } else if ("gname".equals(key)){ currEntry.setGroupName(val); } else if ("uid".equals(key)){ [CLASS] TarArchiveInputStream [METHOD] applyPaxHeadersToCurrentEntry [RETURN_TYPE] void  String> headers [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest Entry ent boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.7071067811865475	494	494	1	replace	
14	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT]          for (Entry<String, String> ent : headers.entrySet()){ [BUGGY] [BUGGY] String key = ent.getKey(); String val = ent.getValue(); if ("path".equals(key)){ currEntry.setName(val); } else if ("linkpath".equals(key)){ currEntry.setLinkName(val); } else if ("gid".equals(key)){ currEntry.setGroupId(Integer.parseInt(val)); } else if ("gname".equals(key)){ currEntry.setGroupName(val); } else if ("uid".equals(key)){ [CLASS] TarArchiveInputStream [METHOD] applyPaxHeadersToCurrentEntry [RETURN_TYPE] void  String> headers [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest Entry ent boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.7071067811865475	494	494	1	add	
15	[BUG] [BUGGY] String val = ent.getValue(); [FE] NumberFormatException [CONTEXT]         for (Entry<String, String> ent : headers.entrySet()){ String key = ent.getKey(); [BUGGY] String val = ent.getValue(); [BUGGY] if ("path".equals(key)){ currEntry.setName(val); } else if ("linkpath".equals(key)){ currEntry.setLinkName(val); } else if ("gid".equals(key)){ currEntry.setGroupId(Integer.parseInt(val)); } else if ("gname".equals(key)){ currEntry.setGroupName(val); } else if ("uid".equals(key)){ currEntry.setUserId(Integer.parseInt(val)); [CLASS] TarArchiveInputStream [METHOD] applyPaxHeadersToCurrentEntry [RETURN_TYPE] void  String> headers [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest Entry ent boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.7071067811865475	495	495	1	replace	
16	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT]         for (Entry<String, String> ent : headers.entrySet()){ String key = ent.getKey(); [BUGGY] [BUGGY] String val = ent.getValue(); if ("path".equals(key)){ currEntry.setName(val); } else if ("linkpath".equals(key)){ currEntry.setLinkName(val); } else if ("gid".equals(key)){ currEntry.setGroupId(Integer.parseInt(val)); } else if ("gname".equals(key)){ currEntry.setGroupName(val); } else if ("uid".equals(key)){ currEntry.setUserId(Integer.parseInt(val)); [CLASS] TarArchiveInputStream [METHOD] applyPaxHeadersToCurrentEntry [RETURN_TYPE] void  String> headers [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest Entry ent boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.7071067811865475	495	495	1	add	
17	[BUG] [BUGGY] if ("path".equals(key)){ [FE] NumberFormatException [CONTEXT]        for (Entry<String, String> ent : headers.entrySet()){ String key = ent.getKey(); String val = ent.getValue(); [BUGGY] if ("path".equals(key)){ [BUGGY] currEntry.setName(val); } else if ("linkpath".equals(key)){ currEntry.setLinkName(val); } else if ("gid".equals(key)){ currEntry.setGroupId(Integer.parseInt(val)); } else if ("gname".equals(key)){ currEntry.setGroupName(val); } else if ("uid".equals(key)){ currEntry.setUserId(Integer.parseInt(val)); } else if ("uname".equals(key)){ [CLASS] TarArchiveInputStream [METHOD] applyPaxHeadersToCurrentEntry [RETURN_TYPE] void  String> headers [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest Entry ent boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.7071067811865475	496	496	1	replace	
18	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT]        for (Entry<String, String> ent : headers.entrySet()){ String key = ent.getKey(); String val = ent.getValue(); [BUGGY] [BUGGY] if ("path".equals(key)){ currEntry.setName(val); } else if ("linkpath".equals(key)){ currEntry.setLinkName(val); } else if ("gid".equals(key)){ currEntry.setGroupId(Integer.parseInt(val)); } else if ("gname".equals(key)){ currEntry.setGroupName(val); } else if ("uid".equals(key)){ currEntry.setUserId(Integer.parseInt(val)); } else if ("uname".equals(key)){ [CLASS] TarArchiveInputStream [METHOD] applyPaxHeadersToCurrentEntry [RETURN_TYPE] void  String> headers [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest Entry ent boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.7071067811865475	496	496	1	add	
19	[BUG] [BUGGY] } else if ("linkpath".equals(key)){ [FE] NumberFormatException [CONTEXT]      for (Entry<String, String> ent : headers.entrySet()){ String key = ent.getKey(); String val = ent.getValue(); if ("path".equals(key)){ currEntry.setName(val); [BUGGY] } else if ("linkpath".equals(key)){ [BUGGY] currEntry.setLinkName(val); } else if ("gid".equals(key)){ currEntry.setGroupId(Integer.parseInt(val)); } else if ("gname".equals(key)){ currEntry.setGroupName(val); } else if ("uid".equals(key)){ currEntry.setUserId(Integer.parseInt(val)); } else if ("uname".equals(key)){ currEntry.setUserName(val); } else if ("size".equals(key)){ [CLASS] TarArchiveInputStream [METHOD] applyPaxHeadersToCurrentEntry [RETURN_TYPE] void  String> headers [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest Entry ent boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.7071067811865475	498	498	1	replace	
20	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT]      for (Entry<String, String> ent : headers.entrySet()){ String key = ent.getKey(); String val = ent.getValue(); if ("path".equals(key)){ currEntry.setName(val); [BUGGY] [BUGGY] } else if ("linkpath".equals(key)){ currEntry.setLinkName(val); } else if ("gid".equals(key)){ currEntry.setGroupId(Integer.parseInt(val)); } else if ("gname".equals(key)){ currEntry.setGroupName(val); } else if ("uid".equals(key)){ currEntry.setUserId(Integer.parseInt(val)); } else if ("uname".equals(key)){ currEntry.setUserName(val); } else if ("size".equals(key)){ [CLASS] TarArchiveInputStream [METHOD] applyPaxHeadersToCurrentEntry [RETURN_TYPE] void  String> headers [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest Entry ent boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.7071067811865475	498	498	1	add	
21	[BUG] [BUGGY] } else if ("gid".equals(key)){ [FE] NumberFormatException [CONTEXT]    for (Entry<String, String> ent : headers.entrySet()){ String key = ent.getKey(); String val = ent.getValue(); if ("path".equals(key)){ currEntry.setName(val); } else if ("linkpath".equals(key)){ currEntry.setLinkName(val); [BUGGY] } else if ("gid".equals(key)){ [BUGGY] currEntry.setGroupId(Integer.parseInt(val)); } else if ("gname".equals(key)){ currEntry.setGroupName(val); } else if ("uid".equals(key)){ currEntry.setUserId(Integer.parseInt(val)); } else if ("uname".equals(key)){ currEntry.setUserName(val); } else if ("size".equals(key)){ currEntry.setSize(Long.parseLong(val)); } else if ("mtime".equals(key)){ [CLASS] TarArchiveInputStream [METHOD] applyPaxHeadersToCurrentEntry [RETURN_TYPE] void  String> headers [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest Entry ent boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.7071067811865475	500	500	1	replace	
22	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT]    for (Entry<String, String> ent : headers.entrySet()){ String key = ent.getKey(); String val = ent.getValue(); if ("path".equals(key)){ currEntry.setName(val); } else if ("linkpath".equals(key)){ currEntry.setLinkName(val); [BUGGY] [BUGGY] } else if ("gid".equals(key)){ currEntry.setGroupId(Integer.parseInt(val)); } else if ("gname".equals(key)){ currEntry.setGroupName(val); } else if ("uid".equals(key)){ currEntry.setUserId(Integer.parseInt(val)); } else if ("uname".equals(key)){ currEntry.setUserName(val); } else if ("size".equals(key)){ currEntry.setSize(Long.parseLong(val)); } else if ("mtime".equals(key)){ [CLASS] TarArchiveInputStream [METHOD] applyPaxHeadersToCurrentEntry [RETURN_TYPE] void  String> headers [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest Entry ent boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.7071067811865475	500	500	1	add	
23	[BUG] [BUGGY] return getNextTarEntry(); [FE] NumberFormatException [CONTEXT] public ArchiveEntry getNextEntry() throws IOException { [BUGGY] return getNextTarEntry(); [BUGGY] } [CLASS] TarArchiveInputStream [METHOD] getNextEntry [RETURN_TYPE] ArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding key keyword val value int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5	558	558	1	replace	
24	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] public ArchiveEntry getNextEntry() throws IOException { [BUGGY] [BUGGY] return getNextTarEntry(); } [CLASS] TarArchiveInputStream [METHOD] getNextEntry [RETURN_TYPE] ArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding key keyword val value int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5	558	558	1	add	
25	[BUG] [BUGGY] if (entrySize - entryOffset > Integer.MAX_VALUE) { [FE] NumberFormatException [CONTEXT] public int available() throws IOException { [BUGGY] if (entrySize - entryOffset > Integer.MAX_VALUE) { [BUGGY] return Integer.MAX_VALUE; } return (int) (entrySize - entryOffset); } [CLASS] TarArchiveInputStream [METHOD] available [RETURN_TYPE] int  [VARIABLES] byte[] SMALL_BUF boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding int SMALL_BUFFER_SIZE blockSize recordSize long entryOffset entrySize TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	181	181	1	replace	
26	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] public int available() throws IOException { [BUGGY] [BUGGY] if (entrySize - entryOffset > Integer.MAX_VALUE) { return Integer.MAX_VALUE; } return (int) (entrySize - entryOffset); } [CLASS] TarArchiveInputStream [METHOD] available [RETURN_TYPE] int  [VARIABLES] byte[] SMALL_BUF boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding int SMALL_BUFFER_SIZE blockSize recordSize long entryOffset entrySize TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	181	181	1	add	
27	[BUG] [BUGGY] return (int) (entrySize - entryOffset); [FE] NumberFormatException [CONTEXT] public int available() throws IOException { if (entrySize - entryOffset > Integer.MAX_VALUE) { return Integer.MAX_VALUE; } [BUGGY] return (int) (entrySize - entryOffset); [BUGGY] } [CLASS] TarArchiveInputStream [METHOD] available [RETURN_TYPE] int  [VARIABLES] byte[] SMALL_BUF boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding int SMALL_BUFFER_SIZE blockSize recordSize long entryOffset entrySize TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	184	184	1	replace	
28	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] public int available() throws IOException { if (entrySize - entryOffset > Integer.MAX_VALUE) { return Integer.MAX_VALUE; } [BUGGY] [BUGGY] return (int) (entrySize - entryOffset); } [CLASS] TarArchiveInputStream [METHOD] available [RETURN_TYPE] int  [VARIABLES] byte[] SMALL_BUF boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding int SMALL_BUFFER_SIZE blockSize recordSize long entryOffset entrySize TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	184	184	1	add	
29	[BUG] [BUGGY] Map<String, String> headers = new HashMap<String, String>(); [FE] NumberFormatException [CONTEXT] Map<String, String> parsePaxHeaders(InputStream i) throws IOException { [BUGGY] Map<String, String> headers = new HashMap<String, String>(); [BUGGY]  while(true){ // get length int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){ // End of length string  ByteArrayOutputStream coll = new ByteArrayOutputStream(); [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	435	435	1	replace	
30	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] Map<String, String> parsePaxHeaders(InputStream i) throws IOException { [BUGGY] [BUGGY] Map<String, String> headers = new HashMap<String, String>();  while(true){ // get length int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){ // End of length string  ByteArrayOutputStream coll = new ByteArrayOutputStream(); [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	435	435	1	add	
31	[BUG] [BUGGY] int len = 0; [FE] NumberFormatException [CONTEXT] Map<String, String> parsePaxHeaders(InputStream i) throws IOException { Map<String, String> headers = new HashMap<String, String>();  while(true){ // get length int ch; [BUGGY] int len = 0; [BUGGY] int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){ // End of length string  ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword String keyword = coll.toString(CharsetNames.UTF_8); [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	439	439	1	replace	
32	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] Map<String, String> parsePaxHeaders(InputStream i) throws IOException { Map<String, String> headers = new HashMap<String, String>();  while(true){ // get length int ch; [BUGGY] [BUGGY] int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){ // End of length string  ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword String keyword = coll.toString(CharsetNames.UTF_8); [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	439	439	1	add	
33	[BUG] [BUGGY] int read = 0; [FE] NumberFormatException [CONTEXT] Map<String, String> parsePaxHeaders(InputStream i) throws IOException { Map<String, String> headers = new HashMap<String, String>();  while(true){ // get length int ch; int len = 0; [BUGGY] int read = 0; [BUGGY] while((ch = i.read()) != -1) { read++; if (ch == ' '){ // End of length string  ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword String keyword = coll.toString(CharsetNames.UTF_8);  [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	440	440	1	replace	
34	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] Map<String, String> parsePaxHeaders(InputStream i) throws IOException { Map<String, String> headers = new HashMap<String, String>();  while(true){ // get length int ch; int len = 0; [BUGGY] [BUGGY] int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){ // End of length string  ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword String keyword = coll.toString(CharsetNames.UTF_8);  [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	440	440	1	add	
35	[BUG] [BUGGY] while((ch = i.read()) != -1) { [FE] NumberFormatException [CONTEXT] Map<String, String> parsePaxHeaders(InputStream i) throws IOException { Map<String, String> headers = new HashMap<String, String>();  while(true){ // get length int ch; int len = 0; int read = 0; [BUGGY] while((ch = i.read()) != -1) { [BUGGY] read++; if (ch == ' '){ // End of length string  ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	441	441	1	replace	
36	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] Map<String, String> parsePaxHeaders(InputStream i) throws IOException { Map<String, String> headers = new HashMap<String, String>();  while(true){ // get length int ch; int len = 0; int read = 0; [BUGGY] [BUGGY] while((ch = i.read()) != -1) { read++; if (ch == ' '){ // End of length string  ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	441	441	1	add	
37	[BUG] [BUGGY] read++; [FE] NumberFormatException [CONTEXT] Map<String, String> parsePaxHeaders(InputStream i) throws IOException { Map<String, String> headers = new HashMap<String, String>();  while(true){ // get length int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { [BUGGY] read++; [BUGGY] if (ch == ' '){ // End of length string  ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; byte[] rest = new byte[restLen]; [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	442	442	1	replace	
38	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] Map<String, String> parsePaxHeaders(InputStream i) throws IOException { Map<String, String> headers = new HashMap<String, String>();  while(true){ // get length int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { [BUGGY] [BUGGY] read++; if (ch == ' '){ // End of length string  ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; byte[] rest = new byte[restLen]; [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	442	442	1	add	
39	[BUG] [BUGGY] if (ch == ' '){ // End of length string  // Get keyword   ByteArrayOutputStream coll = new ByteArrayOutputStream(); [FE] NumberFormatException [CONTEXT] Map<String, String> parsePaxHeaders(InputStream i) throws IOException { Map<String, String> headers = new HashMap<String, String>();  while(true){ // get length int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; [BUGGY] if (ch == ' '){ // End of length string     // Get keyword          ByteArrayOutputStream coll = new ByteArrayOutputStream(); [BUGGY]  ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; byte[] rest = new byte[restLen]; int got = IOUtils.readFully(i, rest); [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	443	445	1	replace	
40	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] Map<String, String> parsePaxHeaders(InputStream i) throws IOException { Map<String, String> headers = new HashMap<String, String>();  while(true){ // get length int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; [BUGGY] [BUGGY] if (ch == ' '){ // End of length string     // Get keyword          ByteArrayOutputStream coll = new ByteArrayOutputStream();  ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; byte[] rest = new byte[restLen]; int got = IOUtils.readFully(i, rest); [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	443	445	1	add	
41	[BUG] [BUGGY] ByteArrayOutputStream coll = new ByteArrayOutputStream(); [FE] NumberFormatException [CONTEXT] Map<String, String> headers = new HashMap<String, String>();  while(true){ // get length int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){ // End of length string  [BUGGY] ByteArrayOutputStream coll = new ByteArrayOutputStream(); [BUGGY] while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; byte[] rest = new byte[restLen]; int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	445	445	1	replace	
42	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] Map<String, String> headers = new HashMap<String, String>();  while(true){ // get length int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){ // End of length string  [BUGGY] [BUGGY] ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; byte[] rest = new byte[restLen]; int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	445	445	1	add	
43	[BUG] [BUGGY] while((ch = i.read()) != -1) { [FE] NumberFormatException [CONTEXT]  while(true){ // get length int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){ // End of length string  ByteArrayOutputStream coll = new ByteArrayOutputStream(); [BUGGY] while((ch = i.read()) != -1) { [BUGGY] read++; if (ch == '='){ // end of keyword String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; byte[] rest = new byte[restLen]; int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	446	446	1	replace	
44	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT]  while(true){ // get length int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){ // End of length string  ByteArrayOutputStream coll = new ByteArrayOutputStream(); [BUGGY] [BUGGY] while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; byte[] rest = new byte[restLen]; int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	446	446	1	add	
45	[BUG] [BUGGY] read++; [FE] NumberFormatException [CONTEXT] while(true){ // get length int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){ // End of length string  ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { [BUGGY] read++; [BUGGY] if (ch == '='){ // end of keyword String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; byte[] rest = new byte[restLen]; int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	447	447	1	replace	
46	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] while(true){ // get length int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){ // End of length string  ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { [BUGGY] [BUGGY] read++; if (ch == '='){ // end of keyword String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; byte[] rest = new byte[restLen]; int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	447	447	1	add	
47	[BUG] [BUGGY] if (ch == '='){ // end of keyword  String keyword = coll.toString(CharsetNames.UTF_8); [FE] NumberFormatException [CONTEXT] int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){ // End of length string  ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; [BUGGY] if (ch == '='){ // end of keyword       String keyword = coll.toString(CharsetNames.UTF_8); [BUGGY] String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; byte[] rest = new byte[restLen]; int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	448	449	1	replace	
48	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){ // End of length string  ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; [BUGGY] [BUGGY] if (ch == '='){ // end of keyword       String keyword = coll.toString(CharsetNames.UTF_8); String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; byte[] rest = new byte[restLen]; int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	448	449	1	add	
49	[BUG] [BUGGY] String keyword = coll.toString(CharsetNames.UTF_8); [FE] NumberFormatException [CONTEXT] int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){ // End of length string  ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword [BUGGY] String keyword = coll.toString(CharsetNames.UTF_8); [BUGGY]  final int restLen = len - read; byte[] rest = new byte[restLen]; int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	449	449	1	replace	
50	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){ // End of length string  ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword [BUGGY] [BUGGY] String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; byte[] rest = new byte[restLen]; int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	449	449	1	add	
51	[BUG] [BUGGY] final int restLen = len - read; [FE] NumberFormatException [CONTEXT] while((ch = i.read()) != -1) { read++; if (ch == ' '){ // End of length string  ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword String keyword = coll.toString(CharsetNames.UTF_8);  [BUGGY] final int restLen = len - read; [BUGGY] byte[] rest = new byte[restLen]; int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); }  [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	451	451	1	replace	
52	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] while((ch = i.read()) != -1) { read++; if (ch == ' '){ // End of length string  ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword String keyword = coll.toString(CharsetNames.UTF_8);  [BUGGY] [BUGGY] final int restLen = len - read; byte[] rest = new byte[restLen]; int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); }  [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	451	451	1	add	
53	[BUG] [BUGGY] byte[] rest = new byte[restLen]; [FE] NumberFormatException [CONTEXT] read++; if (ch == ' '){ // End of length string  ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; [BUGGY] byte[] rest = new byte[restLen]; [BUGGY] int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); }  String value = new String(rest, 0, [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	452	452	1	replace	
54	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] read++; if (ch == ' '){ // End of length string  ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; [BUGGY] [BUGGY] byte[] rest = new byte[restLen]; int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); }  String value = new String(rest, 0, [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	452	452	1	add	
55	[BUG] [BUGGY] int got = IOUtils.readFully(i, rest); [FE] NumberFormatException [CONTEXT] if (ch == ' '){ // End of length string  ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; byte[] rest = new byte[restLen]; [BUGGY] int got = IOUtils.readFully(i, rest); [BUGGY] if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); }  String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8); [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	453	453	1	replace	
56	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] if (ch == ' '){ // End of length string  ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; byte[] rest = new byte[restLen]; [BUGGY] [BUGGY] int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); }  String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8); [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	453	453	1	add	
57	[BUG] [BUGGY] if (got != restLen) { [FE] NumberFormatException [CONTEXT]  ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; byte[] rest = new byte[restLen]; int got = IOUtils.readFully(i, rest); [BUGGY] if (got != restLen) { [BUGGY] throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); }  String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8); headers.put(keyword, value); [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	454	454	1	replace	
58	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT]  ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; byte[] rest = new byte[restLen]; int got = IOUtils.readFully(i, rest); [BUGGY] [BUGGY] if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); }  String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8); headers.put(keyword, value); [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	454	454	1	add	
59	[BUG] [BUGGY] String value = new String(rest, 0,    restLen - 1, CharsetNames.UTF_8); [FE] NumberFormatException [CONTEXT] byte[] rest = new byte[restLen]; int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); }  [BUGGY] String value = new String(rest, 0,              restLen - 1, CharsetNames.UTF_8); [BUGGY] restLen - 1, CharsetNames.UTF_8); headers.put(keyword, value); break; } coll.write((byte) ch); } break; // Processed single header } len *= 10; len += ch - '0'; [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	462	463	1	replace	
60	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] byte[] rest = new byte[restLen]; int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); }  [BUGGY] [BUGGY] String value = new String(rest, 0,              restLen - 1, CharsetNames.UTF_8); restLen - 1, CharsetNames.UTF_8); headers.put(keyword, value); break; } coll.write((byte) ch); } break; // Processed single header } len *= 10; len += ch - '0'; [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	462	463	1	add	
61	[BUG] [BUGGY] headers.put(keyword, value); [FE] NumberFormatException [CONTEXT] if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); }  String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8); [BUGGY] headers.put(keyword, value); [BUGGY] break; } coll.write((byte) ch); } break; // Processed single header } len *= 10; len += ch - '0'; } if (ch == -1){ // EOF [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	464	464	1	replace	
62	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); }  String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8); [BUGGY] [BUGGY] headers.put(keyword, value); break; } coll.write((byte) ch); } break; // Processed single header } len *= 10; len += ch - '0'; } if (ch == -1){ // EOF [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	464	464	1	add	
63	[BUG] [BUGGY] break; [FE] NumberFormatException [CONTEXT] throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); }  String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8); headers.put(keyword, value); [BUGGY] break; [BUGGY] } coll.write((byte) ch); } break; // Processed single header } len *= 10; len += ch - '0'; } if (ch == -1){ // EOF break; [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	465	465	1	replace	
64	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); }  String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8); headers.put(keyword, value); [BUGGY] [BUGGY] break; } coll.write((byte) ch); } break; // Processed single header } len *= 10; len += ch - '0'; } if (ch == -1){ // EOF break; [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	465	465	1	add	
65	[BUG] [BUGGY] coll.write((byte) ch); [FE] NumberFormatException [CONTEXT] + restLen + " bytes, read " + got); }  String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8); headers.put(keyword, value); break; } [BUGGY] coll.write((byte) ch); [BUGGY] } break; // Processed single header } len *= 10; len += ch - '0'; } if (ch == -1){ // EOF break; } } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	467	467	1	replace	
66	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] + restLen + " bytes, read " + got); }  String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8); headers.put(keyword, value); break; } [BUGGY] [BUGGY] coll.write((byte) ch); } break; // Processed single header } len *= 10; len += ch - '0'; } if (ch == -1){ // EOF break; } } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	467	467	1	add	
67	[BUG] [BUGGY] len *= 10; [FE] NumberFormatException [CONTEXT]  String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8); headers.put(keyword, value); break; } coll.write((byte) ch); } break; // Processed single header } [BUGGY] len *= 10; [BUGGY] len += ch - '0'; } if (ch == -1){ // EOF break; } } return headers; } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	471	471	1	replace	
68	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT]  String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8); headers.put(keyword, value); break; } coll.write((byte) ch); } break; // Processed single header } [BUGGY] [BUGGY] len *= 10; len += ch - '0'; } if (ch == -1){ // EOF break; } } return headers; } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	471	471	1	add	
69	[BUG] [BUGGY] len += ch - '0'; [FE] NumberFormatException [CONTEXT] String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8); headers.put(keyword, value); break; } coll.write((byte) ch); } break; // Processed single header } len *= 10; [BUGGY] len += ch - '0'; [BUGGY] } if (ch == -1){ // EOF break; } } return headers; } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	472	472	1	replace	
70	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8); headers.put(keyword, value); break; } coll.write((byte) ch); } break; // Processed single header } len *= 10; [BUGGY] [BUGGY] len += ch - '0'; } if (ch == -1){ // EOF break; } } return headers; } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	472	472	1	add	
71	[BUG] [BUGGY] if (ch == -1){ // EOF break; [FE] NumberFormatException [CONTEXT] headers.put(keyword, value); break; } coll.write((byte) ch); } break; // Processed single header } len *= 10; len += ch - '0'; } [BUGGY] if (ch == -1){ // EOF    break; [BUGGY] break; } } return headers; } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	474	475	1	replace	
72	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] headers.put(keyword, value); break; } coll.write((byte) ch); } break; // Processed single header } len *= 10; len += ch - '0'; } [BUGGY] [BUGGY] if (ch == -1){ // EOF    break; break; } } return headers; } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	474	475	1	add	
73	[BUG] [BUGGY] break; [FE] NumberFormatException [CONTEXT] break; } coll.write((byte) ch); } break; // Processed single header } len *= 10; len += ch - '0'; } if (ch == -1){ // EOF [BUGGY] break; [BUGGY] } } return headers; } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	475	475	1	replace	
74	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] break; } coll.write((byte) ch); } break; // Processed single header } len *= 10; len += ch - '0'; } if (ch == -1){ // EOF [BUGGY] [BUGGY] break; } } return headers; } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	475	475	1	add	
75	[BUG] [BUGGY] } [FE] NumberFormatException [CONTEXT] coll.write((byte) ch); } break; // Processed single header } len *= 10; len += ch - '0'; } if (ch == -1){ // EOF break; } [BUGGY] } [BUGGY] return headers; } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	477	477	1	replace	
76	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] coll.write((byte) ch); } break; // Processed single header } len *= 10; len += ch - '0'; } if (ch == -1){ // EOF break; } [BUGGY] [BUGGY] } return headers; } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	477	477	1	add	
77	[BUG] [BUGGY] return headers; [FE] NumberFormatException [CONTEXT] } break; // Processed single header } len *= 10; len += ch - '0'; } if (ch == -1){ // EOF break; } } [BUGGY] return headers; [BUGGY] } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	478	478	1	replace	
78	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] } break; // Processed single header } len *= 10; len += ch - '0'; } if (ch == -1){ // EOF break; } } [BUGGY] [BUGGY] return headers; } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	478	478	1	add	
79	[BUG] [BUGGY] if (currEntry == null) { [FE] NumberFormatException [CONTEXT] public int read(byte[] buf, int offset, int numToRead) throws IOException { int totalRead = 0; if (hasHitEOF || entryOffset >= entrySize) { return -1; } [BUGGY] if (currEntry == null) { [BUGGY] throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	608	608	1	replace	
80	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] public int read(byte[] buf, int offset, int numToRead) throws IOException { int totalRead = 0; if (hasHitEOF || entryOffset >= entrySize) { return -1; } [BUGGY] [BUGGY] if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	608	608	1	add	
81	[BUG] [BUGGY] numToRead = Math.min(numToRead, available()); [FE] NumberFormatException [CONTEXT] int totalRead = 0; if (hasHitEOF || entryOffset >= entrySize) { return -1; } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } [BUGGY] numToRead = Math.min(numToRead, available()); [BUGGY]  totalRead = is.read(buf, offset, numToRead); if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } hasHitEOF = true; } else { count(totalRead); [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	612	612	1	replace	
82	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] int totalRead = 0; if (hasHitEOF || entryOffset >= entrySize) { return -1; } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } [BUGGY] [BUGGY] numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } hasHitEOF = true; } else { count(totalRead); [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	612	612	1	add	
83	[BUG] [BUGGY] totalRead = is.read(buf, offset, numToRead); [FE] NumberFormatException [CONTEXT] if (hasHitEOF || entryOffset >= entrySize) { return -1; } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); [BUGGY] totalRead = is.read(buf, offset, numToRead); [BUGGY]  if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } hasHitEOF = true; } else { count(totalRead); entryOffset += totalRead; } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	614	614	1	replace	
84	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] if (hasHitEOF || entryOffset >= entrySize) { return -1; } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); [BUGGY] [BUGGY] totalRead = is.read(buf, offset, numToRead); if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } hasHitEOF = true; } else { count(totalRead); entryOffset += totalRead; } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	614	614	1	add	
85	[BUG] [BUGGY] if (totalRead == -1) { [FE] NumberFormatException [CONTEXT] } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); [BUGGY] if (totalRead == -1) { [BUGGY] if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } hasHitEOF = true; } else { count(totalRead); entryOffset += totalRead; } return totalRead; [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	616	616	1	replace	
86	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); [BUGGY] [BUGGY] if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } hasHitEOF = true; } else { count(totalRead); entryOffset += totalRead; } return totalRead; [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	616	616	1	add	
87	[BUG] [BUGGY] count(totalRead); [FE] NumberFormatException [CONTEXT] if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } hasHitEOF = true; } else { [BUGGY] count(totalRead); [BUGGY] entryOffset += totalRead; } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	622	622	1	replace	
88	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } hasHitEOF = true; } else { [BUGGY] [BUGGY] count(totalRead); entryOffset += totalRead; } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	622	622	1	add	
89	[BUG] [BUGGY] entryOffset += totalRead; [FE] NumberFormatException [CONTEXT] if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } hasHitEOF = true; } else { count(totalRead); [BUGGY] entryOffset += totalRead; [BUGGY] } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	623	623	1	replace	
90	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } hasHitEOF = true; } else { count(totalRead); [BUGGY] [BUGGY] entryOffset += totalRead; } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	623	623	1	add	
91	[BUG] [BUGGY] return totalRead; [FE] NumberFormatException [CONTEXT] if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } hasHitEOF = true; } else { count(totalRead); entryOffset += totalRead; } [BUGGY] return totalRead; [BUGGY] } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	626	626	1	replace	
92	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } hasHitEOF = true; } else { count(totalRead); entryOffset += totalRead; } [BUGGY] [BUGGY] return totalRead; } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.4472135954999579	626	626	1	add	
93	[BUG] [BUGGY] long numRecords = (this.entrySize / this.recordSize) + 1; [FE] NumberFormatException [CONTEXT] private void skipRecordPadding() throws IOException { if (this.entrySize > 0 && this.entrySize % this.recordSize != 0) { [BUGGY] long numRecords = (this.entrySize / this.recordSize) + 1; [BUGGY] long padding = (numRecords * this.recordSize) - this.entrySize; long skipped = IOUtils.skip(is, padding); count(skipped); } } [CLASS] TarArchiveInputStream [METHOD] skipRecordPadding [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	333	333	1	replace	
94	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] private void skipRecordPadding() throws IOException { if (this.entrySize > 0 && this.entrySize % this.recordSize != 0) { [BUGGY] [BUGGY] long numRecords = (this.entrySize / this.recordSize) + 1; long padding = (numRecords * this.recordSize) - this.entrySize; long skipped = IOUtils.skip(is, padding); count(skipped); } } [CLASS] TarArchiveInputStream [METHOD] skipRecordPadding [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	333	333	1	add	
95	[BUG] [BUGGY] long padding = (numRecords * this.recordSize) - this.entrySize; [FE] NumberFormatException [CONTEXT] private void skipRecordPadding() throws IOException { if (this.entrySize > 0 && this.entrySize % this.recordSize != 0) { long numRecords = (this.entrySize / this.recordSize) + 1; [BUGGY] long padding = (numRecords * this.recordSize) - this.entrySize; [BUGGY] long skipped = IOUtils.skip(is, padding); count(skipped); } } [CLASS] TarArchiveInputStream [METHOD] skipRecordPadding [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	334	334	1	replace	
96	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] private void skipRecordPadding() throws IOException { if (this.entrySize > 0 && this.entrySize % this.recordSize != 0) { long numRecords = (this.entrySize / this.recordSize) + 1; [BUGGY] [BUGGY] long padding = (numRecords * this.recordSize) - this.entrySize; long skipped = IOUtils.skip(is, padding); count(skipped); } } [CLASS] TarArchiveInputStream [METHOD] skipRecordPadding [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	334	334	1	add	
97	[BUG] [BUGGY] long skipped = IOUtils.skip(is, padding); [FE] NumberFormatException [CONTEXT] private void skipRecordPadding() throws IOException { if (this.entrySize > 0 && this.entrySize % this.recordSize != 0) { long numRecords = (this.entrySize / this.recordSize) + 1; long padding = (numRecords * this.recordSize) - this.entrySize; [BUGGY] long skipped = IOUtils.skip(is, padding); [BUGGY] count(skipped); } } [CLASS] TarArchiveInputStream [METHOD] skipRecordPadding [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	335	335	1	replace	
98	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] private void skipRecordPadding() throws IOException { if (this.entrySize > 0 && this.entrySize % this.recordSize != 0) { long numRecords = (this.entrySize / this.recordSize) + 1; long padding = (numRecords * this.recordSize) - this.entrySize; [BUGGY] [BUGGY] long skipped = IOUtils.skip(is, padding); count(skipped); } } [CLASS] TarArchiveInputStream [METHOD] skipRecordPadding [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	335	335	1	add	
99	[BUG] [BUGGY] count(skipped); [FE] NumberFormatException [CONTEXT] private void skipRecordPadding() throws IOException { if (this.entrySize > 0 && this.entrySize % this.recordSize != 0) { long numRecords = (this.entrySize / this.recordSize) + 1; long padding = (numRecords * this.recordSize) - this.entrySize; long skipped = IOUtils.skip(is, padding); [BUGGY] count(skipped); [BUGGY] } } [CLASS] TarArchiveInputStream [METHOD] skipRecordPadding [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	336	336	1	replace	
100	[BUG] [BUGGY] [FE] NumberFormatException [CONTEXT] private void skipRecordPadding() throws IOException { if (this.entrySize > 0 && this.entrySize % this.recordSize != 0) { long numRecords = (this.entrySize / this.recordSize) + 1; long padding = (numRecords * this.recordSize) - this.entrySize; long skipped = IOUtils.skip(is, padding); [BUGGY] [BUGGY] count(skipped); } } [CLASS] TarArchiveInputStream [METHOD] skipRecordPadding [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress32/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	336	336	1	add	
