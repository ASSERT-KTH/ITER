bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
2	[BUG] [BUGGY] double u1u1 = u1.getNormSq(); [FE] AssertionError [CONTEXT] public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {  [BUGGY] double u1u1 = u1.getNormSq(); [BUGGY] double u2u2 = u2.getNormSq(); double v1v1 = v1.getNormSq(); double v2v2 = v2.getNormSq(); if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) { throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); }  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);  [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	316	316	1	replace	
3	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {  [BUGGY] [BUGGY] double u1u1 = u1.getNormSq(); double u2u2 = u2.getNormSq(); double v1v1 = v1.getNormSq(); double v2v2 = v2.getNormSq(); if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) { throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); }  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);  [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	316	316	1	add	
4	[BUG] [BUGGY] double u2u2 = u2.getNormSq(); [FE] AssertionError [CONTEXT] public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {  double u1u1 = u1.getNormSq(); [BUGGY] double u2u2 = u2.getNormSq(); [BUGGY] double v1v1 = v1.getNormSq(); double v2v2 = v2.getNormSq(); if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) { throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); }  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);   [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	317	317	1	replace	
5	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {  double u1u1 = u1.getNormSq(); [BUGGY] [BUGGY] double u2u2 = u2.getNormSq(); double v1v1 = v1.getNormSq(); double v2v2 = v2.getNormSq(); if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) { throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); }  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);   [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	317	317	1	add	
6	[BUG] [BUGGY] double v1v1 = v1.getNormSq(); [FE] AssertionError [CONTEXT] public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {  double u1u1 = u1.getNormSq(); double u2u2 = u2.getNormSq(); [BUGGY] double v1v1 = v1.getNormSq(); [BUGGY] double v2v2 = v2.getNormSq(); if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) { throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); }  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);  double u1u2 = u1.dotProduct(u2); [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	318	318	1	replace	
7	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {  double u1u1 = u1.getNormSq(); double u2u2 = u2.getNormSq(); [BUGGY] [BUGGY] double v1v1 = v1.getNormSq(); double v2v2 = v2.getNormSq(); if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) { throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); }  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);  double u1u2 = u1.dotProduct(u2); [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	318	318	1	add	
8	[BUG] [BUGGY] double v2v2 = v2.getNormSq(); [FE] AssertionError [CONTEXT] public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {  double u1u1 = u1.getNormSq(); double u2u2 = u2.getNormSq(); double v1v1 = v1.getNormSq(); [BUGGY] double v2v2 = v2.getNormSq(); [BUGGY] if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) { throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); }  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);  double u1u2 = u1.dotProduct(u2); double v1v2 = v1.dotProduct(v2); [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	319	319	1	replace	
9	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {  double u1u1 = u1.getNormSq(); double u2u2 = u2.getNormSq(); double v1v1 = v1.getNormSq(); [BUGGY] [BUGGY] double v2v2 = v2.getNormSq(); if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) { throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); }  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);  double u1u2 = u1.dotProduct(u2); double v1v2 = v1.dotProduct(v2); [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	319	319	1	add	
10	[BUG] [BUGGY] if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) { [FE] AssertionError [CONTEXT] public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {  double u1u1 = u1.getNormSq(); double u2u2 = u2.getNormSq(); double v1v1 = v1.getNormSq(); double v2v2 = v2.getNormSq(); [BUGGY] if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) { [BUGGY] throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); }  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);  double u1u2 = u1.dotProduct(u2); double v1v2 = v1.dotProduct(v2); double coeffU = u1u2 / u1u1; [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	320	320	1	replace	
11	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {  double u1u1 = u1.getNormSq(); double u2u2 = u2.getNormSq(); double v1v1 = v1.getNormSq(); double v2v2 = v2.getNormSq(); [BUGGY] [BUGGY] if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) { throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); }  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);  double u1u2 = u1.dotProduct(u2); double v1v2 = v1.dotProduct(v2); double coeffU = u1u2 / u1u1; [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	320	320	1	add	
12	[BUG] [BUGGY] v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1); [FE] AssertionError [CONTEXT]  double u1u1 = u1.getNormSq(); double u2u2 = u2.getNormSq(); double v1v1 = v1.getNormSq(); double v2v2 = v2.getNormSq(); if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) { throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); }  [BUGGY] v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1); [BUGGY]   double u1u2 = u1.dotProduct(u2); double v1v2 = v1.dotProduct(v2); double coeffU = u1u2 / u1u1; double coeffV = v1v2 / u1u1; double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha= coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	325	325	1	replace	
13	[BUG] [BUGGY] [FE] AssertionError [CONTEXT]  double u1u1 = u1.getNormSq(); double u2u2 = u2.getNormSq(); double v1v1 = v1.getNormSq(); double v2v2 = v2.getNormSq(); if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) { throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); }  [BUGGY] [BUGGY] v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);  double u1u2 = u1.dotProduct(u2); double v1v2 = v1.dotProduct(v2); double coeffU = u1u2 / u1u1; double coeffV = v1v2 / u1u1; double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha= coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	325	325	1	add	
14	[BUG] [BUGGY] double u1u2 = u1.dotProduct(u2); [FE] AssertionError [CONTEXT] double v1v1 = v1.getNormSq(); double v2v2 = v2.getNormSq(); if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) { throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); }  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);  [BUGGY] double u1u2 = u1.dotProduct(u2); [BUGGY] double v1v2 = v1.dotProduct(v2); double coeffU = u1u2 / u1u1; double coeffV = v1v2 / u1u1; double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha= coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  Vector3D uRef= u1; Vector3D vRef= v1; [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	328	328	1	replace	
15	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] double v1v1 = v1.getNormSq(); double v2v2 = v2.getNormSq(); if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) { throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); }  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);  [BUGGY] [BUGGY] double u1u2 = u1.dotProduct(u2); double v1v2 = v1.dotProduct(v2); double coeffU = u1u2 / u1u1; double coeffV = v1v2 / u1u1; double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha= coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  Vector3D uRef= u1; Vector3D vRef= v1; [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	328	328	1	add	
16	[BUG] [BUGGY] double v1v2 = v1.dotProduct(v2); [FE] AssertionError [CONTEXT] double v2v2 = v2.getNormSq(); if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) { throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); }  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);  double u1u2 = u1.dotProduct(u2); [BUGGY] double v1v2 = v1.dotProduct(v2); [BUGGY] double coeffU = u1u2 / u1u1; double coeffV = v1v2 / u1u1; double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha= coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  Vector3D uRef= u1; Vector3D vRef= v1; Vector3D v1Su1 = v1.subtract(u1); [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	329	329	1	replace	
17	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] double v2v2 = v2.getNormSq(); if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) { throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); }  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);  double u1u2 = u1.dotProduct(u2); [BUGGY] [BUGGY] double v1v2 = v1.dotProduct(v2); double coeffU = u1u2 / u1u1; double coeffV = v1v2 / u1u1; double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha= coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  Vector3D uRef= u1; Vector3D vRef= v1; Vector3D v1Su1 = v1.subtract(u1); [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	329	329	1	add	
18	[BUG] [BUGGY] double coeffU = u1u2 / u1u1; [FE] AssertionError [CONTEXT] if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) { throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); }  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);  double u1u2 = u1.dotProduct(u2); double v1v2 = v1.dotProduct(v2); [BUGGY] double coeffU = u1u2 / u1u1; [BUGGY] double coeffV = v1v2 / u1u1; double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha= coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  Vector3D uRef= u1; Vector3D vRef= v1; Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	330	330	1	replace	
19	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) { throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); }  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);  double u1u2 = u1.dotProduct(u2); double v1v2 = v1.dotProduct(v2); [BUGGY] [BUGGY] double coeffU = u1u2 / u1u1; double coeffV = v1v2 / u1u1; double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha= coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  Vector3D uRef= u1; Vector3D vRef= v1; Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	330	330	1	add	
20	[BUG] [BUGGY] double coeffV = v1v2 / u1u1; [FE] AssertionError [CONTEXT] throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); }  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);  double u1u2 = u1.dotProduct(u2); double v1v2 = v1.dotProduct(v2); double coeffU = u1u2 / u1u1; [BUGGY] double coeffV = v1v2 / u1u1; [BUGGY] double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha= coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  Vector3D uRef= u1; Vector3D vRef= v1; Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); Vector3D k = v1Su1.crossProduct(v2Su2); [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	331	331	1	replace	
21	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); }  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);  double u1u2 = u1.dotProduct(u2); double v1v2 = v1.dotProduct(v2); double coeffU = u1u2 / u1u1; [BUGGY] [BUGGY] double coeffV = v1v2 / u1u1; double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha= coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  Vector3D uRef= u1; Vector3D vRef= v1; Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); Vector3D k = v1Su1.crossProduct(v2Su2); [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	331	331	1	add	
22	[BUG] [BUGGY] double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); [FE] AssertionError [CONTEXT] }  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);  double u1u2 = u1.dotProduct(u2); double v1v2 = v1.dotProduct(v2); double coeffU = u1u2 / u1u1; double coeffV = v1v2 / u1u1; [BUGGY] double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); [BUGGY] double alpha= coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  Vector3D uRef= u1; Vector3D vRef= v1; Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); Vector3D k = v1Su1.crossProduct(v2Su2); Vector3D u3= u1.crossProduct(u2); [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	332	332	1	replace	
23	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] }  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);  double u1u2 = u1.dotProduct(u2); double v1v2 = v1.dotProduct(v2); double coeffU = u1u2 / u1u1; double coeffV = v1v2 / u1u1; [BUGGY] [BUGGY] double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha= coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  Vector3D uRef= u1; Vector3D vRef= v1; Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); Vector3D k = v1Su1.crossProduct(v2Su2); Vector3D u3= u1.crossProduct(u2); [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	332	332	1	add	
24	[BUG] [BUGGY] double alpha= coeffU - beta * coeffV; [FE] AssertionError [CONTEXT]  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);  double u1u2 = u1.dotProduct(u2); double v1v2 = v1.dotProduct(v2); double coeffU = u1u2 / u1u1; double coeffV = v1v2 / u1u1; double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); [BUGGY] double alpha= coeffU - beta * coeffV; [BUGGY] v2 = new Vector3D(alpha, v1, beta, v2);  Vector3D uRef= u1; Vector3D vRef= v1; Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); Vector3D k = v1Su1.crossProduct(v2Su2); Vector3D u3= u1.crossProduct(u2); double c = k.dotProduct(u3); [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	333	333	1	replace	
25	[BUG] [BUGGY] [FE] AssertionError [CONTEXT]  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);  double u1u2 = u1.dotProduct(u2); double v1v2 = v1.dotProduct(v2); double coeffU = u1u2 / u1u1; double coeffV = v1v2 / u1u1; double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); [BUGGY] [BUGGY] double alpha= coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  Vector3D uRef= u1; Vector3D vRef= v1; Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); Vector3D k = v1Su1.crossProduct(v2Su2); Vector3D u3= u1.crossProduct(u2); double c = k.dotProduct(u3); [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	333	333	1	add	
26	[BUG] [BUGGY] v2 = new Vector3D(alpha, v1, beta, v2); [FE] AssertionError [CONTEXT]  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);  double u1u2 = u1.dotProduct(u2); double v1v2 = v1.dotProduct(v2); double coeffU = u1u2 / u1u1; double coeffV = v1v2 / u1u1; double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha= coeffU - beta * coeffV; [BUGGY] v2 = new Vector3D(alpha, v1, beta, v2); [BUGGY]   Vector3D uRef= u1; Vector3D vRef= v1; Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); Vector3D k = v1Su1.crossProduct(v2Su2); Vector3D u3= u1.crossProduct(u2); double c = k.dotProduct(u3); if (c == 0) { [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	334	334	1	replace	
27	[BUG] [BUGGY] [FE] AssertionError [CONTEXT]  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);  double u1u2 = u1.dotProduct(u2); double v1v2 = v1.dotProduct(v2); double coeffU = u1u2 / u1u1; double coeffV = v1v2 / u1u1; double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha= coeffU - beta * coeffV; [BUGGY] [BUGGY] v2 = new Vector3D(alpha, v1, beta, v2);  Vector3D uRef= u1; Vector3D vRef= v1; Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); Vector3D k = v1Su1.crossProduct(v2Su2); Vector3D u3= u1.crossProduct(u2); double c = k.dotProduct(u3); if (c == 0) { [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	334	334	1	add	
28	[BUG] [BUGGY] Vector3D uRef= u1; [FE] AssertionError [CONTEXT]  double u1u2 = u1.dotProduct(u2); double v1v2 = v1.dotProduct(v2); double coeffU = u1u2 / u1u1; double coeffV = v1v2 / u1u1; double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha= coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  [BUGGY] Vector3D uRef= u1; [BUGGY] Vector3D vRef= v1; Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); Vector3D k = v1Su1.crossProduct(v2Su2); Vector3D u3= u1.crossProduct(u2); double c = k.dotProduct(u3); if (c == 0) {   Vector3D v3 = Vector3D.crossProduct(v1, v2); [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	337	337	1	replace	
29	[BUG] [BUGGY] [FE] AssertionError [CONTEXT]  double u1u2 = u1.dotProduct(u2); double v1v2 = v1.dotProduct(v2); double coeffU = u1u2 / u1u1; double coeffV = v1v2 / u1u1; double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha= coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  [BUGGY] [BUGGY] Vector3D uRef= u1; Vector3D vRef= v1; Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); Vector3D k = v1Su1.crossProduct(v2Su2); Vector3D u3= u1.crossProduct(u2); double c = k.dotProduct(u3); if (c == 0) {   Vector3D v3 = Vector3D.crossProduct(v1, v2); [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	337	337	1	add	
30	[BUG] [BUGGY] Vector3D vRef= v1; [FE] AssertionError [CONTEXT] double u1u2 = u1.dotProduct(u2); double v1v2 = v1.dotProduct(v2); double coeffU = u1u2 / u1u1; double coeffV = v1v2 / u1u1; double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha= coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  Vector3D uRef= u1; [BUGGY] Vector3D vRef= v1; [BUGGY] Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); Vector3D k = v1Su1.crossProduct(v2Su2); Vector3D u3= u1.crossProduct(u2); double c = k.dotProduct(u3); if (c == 0) {   Vector3D v3 = Vector3D.crossProduct(v1, v2); Vector3D v3Su3 = v3.subtract(u3); [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	338	338	1	replace	
31	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] double u1u2 = u1.dotProduct(u2); double v1v2 = v1.dotProduct(v2); double coeffU = u1u2 / u1u1; double coeffV = v1v2 / u1u1; double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha= coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  Vector3D uRef= u1; [BUGGY] [BUGGY] Vector3D vRef= v1; Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); Vector3D k = v1Su1.crossProduct(v2Su2); Vector3D u3= u1.crossProduct(u2); double c = k.dotProduct(u3); if (c == 0) {   Vector3D v3 = Vector3D.crossProduct(v1, v2); Vector3D v3Su3 = v3.subtract(u3); [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	338	338	1	add	
32	[BUG] [BUGGY] Vector3D v1Su1 = v1.subtract(u1); [FE] AssertionError [CONTEXT] double v1v2 = v1.dotProduct(v2); double coeffU = u1u2 / u1u1; double coeffV = v1v2 / u1u1; double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha= coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  Vector3D uRef= u1; Vector3D vRef= v1; [BUGGY] Vector3D v1Su1 = v1.subtract(u1); [BUGGY] Vector3D v2Su2 = v2.subtract(u2); Vector3D k = v1Su1.crossProduct(v2Su2); Vector3D u3= u1.crossProduct(u2); double c = k.dotProduct(u3); if (c == 0) {   Vector3D v3 = Vector3D.crossProduct(v1, v2); Vector3D v3Su3 = v3.subtract(u3); k = v1Su1.crossProduct(v3Su3); [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	339	339	1	replace	
33	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] double v1v2 = v1.dotProduct(v2); double coeffU = u1u2 / u1u1; double coeffV = v1v2 / u1u1; double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha= coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  Vector3D uRef= u1; Vector3D vRef= v1; [BUGGY] [BUGGY] Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); Vector3D k = v1Su1.crossProduct(v2Su2); Vector3D u3= u1.crossProduct(u2); double c = k.dotProduct(u3); if (c == 0) {   Vector3D v3 = Vector3D.crossProduct(v1, v2); Vector3D v3Su3 = v3.subtract(u3); k = v1Su1.crossProduct(v3Su3); [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	339	339	1	add	
34	[BUG] [BUGGY] Vector3D v2Su2 = v2.subtract(u2); [FE] AssertionError [CONTEXT] double coeffU = u1u2 / u1u1; double coeffV = v1v2 / u1u1; double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha= coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  Vector3D uRef= u1; Vector3D vRef= v1; Vector3D v1Su1 = v1.subtract(u1); [BUGGY] Vector3D v2Su2 = v2.subtract(u2); [BUGGY] Vector3D k = v1Su1.crossProduct(v2Su2); Vector3D u3= u1.crossProduct(u2); double c = k.dotProduct(u3); if (c == 0) {   Vector3D v3 = Vector3D.crossProduct(v1, v2); Vector3D v3Su3 = v3.subtract(u3); k = v1Su1.crossProduct(v3Su3); Vector3D u2Prime = u1.crossProduct(u3); [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	340	340	1	replace	
35	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] double coeffU = u1u2 / u1u1; double coeffV = v1v2 / u1u1; double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha= coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  Vector3D uRef= u1; Vector3D vRef= v1; Vector3D v1Su1 = v1.subtract(u1); [BUGGY] [BUGGY] Vector3D v2Su2 = v2.subtract(u2); Vector3D k = v1Su1.crossProduct(v2Su2); Vector3D u3= u1.crossProduct(u2); double c = k.dotProduct(u3); if (c == 0) {   Vector3D v3 = Vector3D.crossProduct(v1, v2); Vector3D v3Su3 = v3.subtract(u3); k = v1Su1.crossProduct(v3Su3); Vector3D u2Prime = u1.crossProduct(u3); [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	340	340	1	add	
36	[BUG] [BUGGY] Vector3D k = v1Su1.crossProduct(v2Su2); [FE] AssertionError [CONTEXT] double coeffV = v1v2 / u1u1; double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha= coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  Vector3D uRef= u1; Vector3D vRef= v1; Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); [BUGGY] Vector3D k = v1Su1.crossProduct(v2Su2); [BUGGY] Vector3D u3= u1.crossProduct(u2); double c = k.dotProduct(u3); if (c == 0) {   Vector3D v3 = Vector3D.crossProduct(v1, v2); Vector3D v3Su3 = v3.subtract(u3); k = v1Su1.crossProduct(v3Su3); Vector3D u2Prime = u1.crossProduct(u3); c = k.dotProduct(u2Prime); [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	341	341	1	replace	
37	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] double coeffV = v1v2 / u1u1; double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha= coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  Vector3D uRef= u1; Vector3D vRef= v1; Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); [BUGGY] [BUGGY] Vector3D k = v1Su1.crossProduct(v2Su2); Vector3D u3= u1.crossProduct(u2); double c = k.dotProduct(u3); if (c == 0) {   Vector3D v3 = Vector3D.crossProduct(v1, v2); Vector3D v3Su3 = v3.subtract(u3); k = v1Su1.crossProduct(v3Su3); Vector3D u2Prime = u1.crossProduct(u3); c = k.dotProduct(u2Prime); [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	341	341	1	add	
38	[BUG] [BUGGY] Vector3D u3= u1.crossProduct(u2); [FE] AssertionError [CONTEXT] double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha= coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  Vector3D uRef= u1; Vector3D vRef= v1; Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); Vector3D k = v1Su1.crossProduct(v2Su2); [BUGGY] Vector3D u3= u1.crossProduct(u2); [BUGGY] double c = k.dotProduct(u3); if (c == 0) {   Vector3D v3 = Vector3D.crossProduct(v1, v2); Vector3D v3Su3 = v3.subtract(u3); k = v1Su1.crossProduct(v3Su3); Vector3D u2Prime = u1.crossProduct(u3); c = k.dotProduct(u2Prime);  [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	342	342	1	replace	
39	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] double beta = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha= coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  Vector3D uRef= u1; Vector3D vRef= v1; Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); Vector3D k = v1Su1.crossProduct(v2Su2); [BUGGY] [BUGGY] Vector3D u3= u1.crossProduct(u2); double c = k.dotProduct(u3); if (c == 0) {   Vector3D v3 = Vector3D.crossProduct(v1, v2); Vector3D v3Su3 = v3.subtract(u3); k = v1Su1.crossProduct(v3Su3); Vector3D u2Prime = u1.crossProduct(u3); c = k.dotProduct(u2Prime);  [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	342	342	1	add	
40	[BUG] [BUGGY] double c = k.dotProduct(u3); [FE] AssertionError [CONTEXT] double alpha= coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  Vector3D uRef= u1; Vector3D vRef= v1; Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); Vector3D k = v1Su1.crossProduct(v2Su2); Vector3D u3= u1.crossProduct(u2); [BUGGY] double c = k.dotProduct(u3); [BUGGY] if (c == 0) {   Vector3D v3 = Vector3D.crossProduct(v1, v2); Vector3D v3Su3 = v3.subtract(u3); k = v1Su1.crossProduct(v3Su3); Vector3D u2Prime = u1.crossProduct(u3); c = k.dotProduct(u2Prime); if (c == 0) { [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	343	343	1	replace	
41	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] double alpha= coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  Vector3D uRef= u1; Vector3D vRef= v1; Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); Vector3D k = v1Su1.crossProduct(v2Su2); Vector3D u3= u1.crossProduct(u2); [BUGGY] [BUGGY] double c = k.dotProduct(u3); if (c == 0) {   Vector3D v3 = Vector3D.crossProduct(v1, v2); Vector3D v3Su3 = v3.subtract(u3); k = v1Su1.crossProduct(v3Su3); Vector3D u2Prime = u1.crossProduct(u3); c = k.dotProduct(u2Prime); if (c == 0) { [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	343	343	1	add	
42	[BUG] [BUGGY] if (c == 0) { [FE] AssertionError [CONTEXT] v2 = new Vector3D(alpha, v1, beta, v2);  Vector3D uRef= u1; Vector3D vRef= v1; Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); Vector3D k = v1Su1.crossProduct(v2Su2); Vector3D u3= u1.crossProduct(u2); double c = k.dotProduct(u3); [BUGGY] if (c == 0) { [BUGGY]   Vector3D v3 = Vector3D.crossProduct(v1, v2); Vector3D v3Su3 = v3.subtract(u3); k = v1Su1.crossProduct(v3Su3); Vector3D u2Prime = u1.crossProduct(u3); c = k.dotProduct(u2Prime); if (c == 0) {  [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	344	344	1	replace	
43	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] v2 = new Vector3D(alpha, v1, beta, v2);  Vector3D uRef= u1; Vector3D vRef= v1; Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); Vector3D k = v1Su1.crossProduct(v2Su2); Vector3D u3= u1.crossProduct(u2); double c = k.dotProduct(u3); [BUGGY] [BUGGY] if (c == 0) {   Vector3D v3 = Vector3D.crossProduct(v1, v2); Vector3D v3Su3 = v3.subtract(u3); k = v1Su1.crossProduct(v3Su3); Vector3D u2Prime = u1.crossProduct(u3); c = k.dotProduct(u2Prime); if (c == 0) {  [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	344	344	1	add	
44	[BUG] [BUGGY] c = FastMath.sqrt(c); [FE] AssertionError [CONTEXT]  uRef = u2; vRef = v2; } }  [BUGGY] c = FastMath.sqrt(c); [BUGGY] double inv = 1.0 / (c + c); q1 = inv * k.getX(); q2 = inv * k.getY(); q3 = inv * k.getZ();  k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2, uRef.getZ() * q1 - uRef.getX() * q3, uRef.getX() * q2 - uRef.getY() * q1); q0 = vRef.dotProduct(k) / (2 * k.getNormSq()); [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	378	378	1	replace	
45	[BUG] [BUGGY] [FE] AssertionError [CONTEXT]  uRef = u2; vRef = v2; } }  [BUGGY] [BUGGY] c = FastMath.sqrt(c); double inv = 1.0 / (c + c); q1 = inv * k.getX(); q2 = inv * k.getY(); q3 = inv * k.getZ();  k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2, uRef.getZ() * q1 - uRef.getX() * q3, uRef.getX() * q2 - uRef.getY() * q1); q0 = vRef.dotProduct(k) / (2 * k.getNormSq()); [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	378	378	1	add	
46	[BUG] [BUGGY] double inv = 1.0 / (c + c); [FE] AssertionError [CONTEXT]  uRef = u2; vRef = v2; } }  c = FastMath.sqrt(c); [BUGGY] double inv = 1.0 / (c + c); [BUGGY] q1 = inv * k.getX(); q2 = inv * k.getY(); q3 = inv * k.getZ();  k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2, uRef.getZ() * q1 - uRef.getX() * q3, uRef.getX() * q2 - uRef.getY() * q1); q0 = vRef.dotProduct(k) / (2 * k.getNormSq());  [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	379	379	1	replace	
47	[BUG] [BUGGY] [FE] AssertionError [CONTEXT]  uRef = u2; vRef = v2; } }  c = FastMath.sqrt(c); [BUGGY] [BUGGY] double inv = 1.0 / (c + c); q1 = inv * k.getX(); q2 = inv * k.getY(); q3 = inv * k.getZ();  k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2, uRef.getZ() * q1 - uRef.getX() * q3, uRef.getX() * q2 - uRef.getY() * q1); q0 = vRef.dotProduct(k) / (2 * k.getNormSq());  [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	379	379	1	add	
48	[BUG] [BUGGY] q1 = inv * k.getX(); [FE] AssertionError [CONTEXT] uRef = u2; vRef = v2; } }  c = FastMath.sqrt(c); double inv = 1.0 / (c + c); [BUGGY] q1 = inv * k.getX(); [BUGGY] q2 = inv * k.getY(); q3 = inv * k.getZ();  k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2, uRef.getZ() * q1 - uRef.getX() * q3, uRef.getX() * q2 - uRef.getY() * q1); q0 = vRef.dotProduct(k) / (2 * k.getNormSq()); } [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	380	380	1	replace	
49	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] uRef = u2; vRef = v2; } }  c = FastMath.sqrt(c); double inv = 1.0 / (c + c); [BUGGY] [BUGGY] q1 = inv * k.getX(); q2 = inv * k.getY(); q3 = inv * k.getZ();  k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2, uRef.getZ() * q1 - uRef.getX() * q3, uRef.getX() * q2 - uRef.getY() * q1); q0 = vRef.dotProduct(k) / (2 * k.getNormSq()); } [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	380	380	1	add	
50	[BUG] [BUGGY] q2 = inv * k.getY(); [FE] AssertionError [CONTEXT] vRef = v2; } }  c = FastMath.sqrt(c); double inv = 1.0 / (c + c); q1 = inv * k.getX(); [BUGGY] q2 = inv * k.getY(); [BUGGY] q3 = inv * k.getZ();  k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2, uRef.getZ() * q1 - uRef.getX() * q3, uRef.getX() * q2 - uRef.getY() * q1); q0 = vRef.dotProduct(k) / (2 * k.getNormSq()); } [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	381	381	1	replace	
51	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] vRef = v2; } }  c = FastMath.sqrt(c); double inv = 1.0 / (c + c); q1 = inv * k.getX(); [BUGGY] [BUGGY] q2 = inv * k.getY(); q3 = inv * k.getZ();  k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2, uRef.getZ() * q1 - uRef.getX() * q3, uRef.getX() * q2 - uRef.getY() * q1); q0 = vRef.dotProduct(k) / (2 * k.getNormSq()); } [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	381	381	1	add	
52	[BUG] [BUGGY] q3 = inv * k.getZ(); [FE] AssertionError [CONTEXT] } }  c = FastMath.sqrt(c); double inv = 1.0 / (c + c); q1 = inv * k.getX(); q2 = inv * k.getY(); [BUGGY] q3 = inv * k.getZ(); [BUGGY]   k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2, uRef.getZ() * q1 - uRef.getX() * q3, uRef.getX() * q2 - uRef.getY() * q1); q0 = vRef.dotProduct(k) / (2 * k.getNormSq()); } [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	382	382	1	replace	
53	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] } }  c = FastMath.sqrt(c); double inv = 1.0 / (c + c); q1 = inv * k.getX(); q2 = inv * k.getY(); [BUGGY] [BUGGY] q3 = inv * k.getZ();  k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2, uRef.getZ() * q1 - uRef.getX() * q3, uRef.getX() * q2 - uRef.getY() * q1); q0 = vRef.dotProduct(k) / (2 * k.getNormSq()); } [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	382	382	1	add	
54	[BUG] [BUGGY] k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,  uRef.getZ() * q1 - uRef.getX() * q3,   uRef.getX() * q2 - uRef.getY() * q1); [FE] AssertionError [CONTEXT] }  c = FastMath.sqrt(c); double inv = 1.0 / (c + c); q1 = inv * k.getX(); q2 = inv * k.getY(); q3 = inv * k.getZ();  [BUGGY] k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,     uRef.getZ() * q1 - uRef.getX() * q3,          uRef.getX() * q2 - uRef.getY() * q1); [BUGGY] uRef.getZ() * q1 - uRef.getX() * q3, uRef.getX() * q2 - uRef.getY() * q1); q0 = vRef.dotProduct(k) / (2 * k.getNormSq()); } [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	385	387	1	replace	
55	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] }  c = FastMath.sqrt(c); double inv = 1.0 / (c + c); q1 = inv * k.getX(); q2 = inv * k.getY(); q3 = inv * k.getZ();  [BUGGY] [BUGGY] k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,     uRef.getZ() * q1 - uRef.getX() * q3,          uRef.getX() * q2 - uRef.getY() * q1); uRef.getZ() * q1 - uRef.getX() * q3, uRef.getX() * q2 - uRef.getY() * q1); q0 = vRef.dotProduct(k) / (2 * k.getNormSq()); } [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	385	387	1	add	
56	[BUG] [BUGGY] q0 = vRef.dotProduct(k) / (2 * k.getNormSq()); [FE] AssertionError [CONTEXT] c = FastMath.sqrt(c); double inv = 1.0 / (c + c); q1 = inv * k.getX(); q2 = inv * k.getY(); q3 = inv * k.getZ();  k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2, uRef.getZ() * q1 - uRef.getX() * q3, uRef.getX() * q2 - uRef.getY() * q1); [BUGGY] q0 = vRef.dotProduct(k) / (2 * k.getNormSq()); [BUGGY]  } [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	388	388	1	replace	
57	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] c = FastMath.sqrt(c); double inv = 1.0 / (c + c); q1 = inv * k.getX(); q2 = inv * k.getY(); q3 = inv * k.getZ();  k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2, uRef.getZ() * q1 - uRef.getX() * q3, uRef.getX() * q2 - uRef.getY() * q1); [BUGGY] [BUGGY] q0 = vRef.dotProduct(k) / (2 * k.getNormSq()); } [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	388	388	1	add	
58	[BUG] [BUGGY] } [FE] AssertionError [CONTEXT] q1 = inv * k.getX(); q2 = inv * k.getY(); q3 = inv * k.getZ();  k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2, uRef.getZ() * q1 - uRef.getX() * q3, uRef.getX() * q2 - uRef.getY() * q1); q0 = vRef.dotProduct(k) / (2 * k.getNormSq()); [BUGGY] } [BUGGY]  [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	390	390	1	replace	
59	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] q1 = inv * k.getX(); q2 = inv * k.getY(); q3 = inv * k.getZ();  k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2, uRef.getZ() * q1 - uRef.getX() * q3, uRef.getX() * q2 - uRef.getY() * q1); q0 = vRef.dotProduct(k) / (2 * k.getNormSq()); [BUGGY] [BUGGY] } [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Vector3D)  Vector3D u1 Vector3D u2 Vector3D v1 Vector3D v2 [VARIABLES] boolean Rotation IDENTITY Vector3D k u1 u2 u2Prime u3 uRef v1 v1Su1 v2 v2Su2 v3 v3Su3 vRef double alpha angle beta c coeff coeffU coeffV det halfAngle inv norm q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	390	390	1	add	
60	[BUG] [BUGGY] return q0; [FE] AssertionError [CONTEXT] public double getQ0() { [BUGGY] return q0; [BUGGY] } [CLASS] Rotation [METHOD] getQ0 [RETURN_TYPE] double  [VARIABLES] boolean Rotation IDENTITY composed r1 r2 r3 double alpha alpha1 alpha2 alpha3 angle beta c coeff coeffU coeffV det dot halfAngle inv norm normProduct q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	481	481	1	replace	
61	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public double getQ0() { [BUGGY] [BUGGY] return q0; } [CLASS] Rotation [METHOD] getQ0 [RETURN_TYPE] double  [VARIABLES] boolean Rotation IDENTITY composed r1 r2 r3 double alpha alpha1 alpha2 alpha3 angle beta c coeff coeffU coeffV det dot halfAngle inv norm normProduct q0 q1 q2 q3 s threshold u1u1 u1u2 u2u2 v1v1 v1v2 v2v2 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.7071067811865475	481	481	1	add	
62	[BUG] [BUGGY] boolean needsNormalization) { [FE] AssertionError [CONTEXT] public Rotation(double q0, double q1, double q2, double q3, [BUGGY] boolean needsNormalization) { [BUGGY]  if (needsNormalization) {  double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3); q0 *= inv; q1 *= inv; q2 *= inv; q3 *= inv; }  [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Rotation(double,double,double,double,boolean)  double q0 double q1 double q2 double q3 boolean needsNormalization [VARIABLES] boolean needsNormalization Rotation IDENTITY double inv q0 q1 q2 q3 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.2773500981126146	134	134	1	replace	
63	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public Rotation(double q0, double q1, double q2, double q3, [BUGGY] [BUGGY] boolean needsNormalization) { if (needsNormalization) {  double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3); q0 *= inv; q1 *= inv; q2 *= inv; q3 *= inv; }  [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Rotation(double,double,double,double,boolean)  double q0 double q1 double q2 double q3 boolean needsNormalization [VARIABLES] boolean needsNormalization Rotation IDENTITY double inv q0 q1 q2 q3 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.2773500981126146	134	134	1	add	
64	[BUG] [BUGGY] if (needsNormalization) { [FE] AssertionError [CONTEXT] public Rotation(double q0, double q1, double q2, double q3, boolean needsNormalization) { [BUGGY] if (needsNormalization) { [BUGGY]  double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3); q0 *= inv; q1 *= inv; q2 *= inv; q3 *= inv; } this.q0 = q0; this.q1 = q1; [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Rotation(double,double,double,double,boolean)  double q0 double q1 double q2 double q3 boolean needsNormalization [VARIABLES] boolean needsNormalization Rotation IDENTITY double inv q0 q1 q2 q3 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.2773500981126146	136	136	1	replace	
65	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public Rotation(double q0, double q1, double q2, double q3, boolean needsNormalization) { [BUGGY] [BUGGY] if (needsNormalization) {  double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3); q0 *= inv; q1 *= inv; q2 *= inv; q3 *= inv; } this.q0 = q0; this.q1 = q1; [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Rotation(double,double,double,double,boolean)  double q0 double q1 double q2 double q3 boolean needsNormalization [VARIABLES] boolean needsNormalization Rotation IDENTITY double inv q0 q1 q2 q3 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.2773500981126146	136	136	1	add	
66	[BUG] [BUGGY] this.q0 = q0; [FE] AssertionError [CONTEXT] if (needsNormalization) {  double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3); q0 *= inv; q1 *= inv; q2 *= inv; q3 *= inv; } [BUGGY] this.q0 = q0; [BUGGY] this.q1 = q1; this.q2 = q2; this.q3 = q3; } [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Rotation(double,double,double,double,boolean)  double q0 double q1 double q2 double q3 boolean needsNormalization [VARIABLES] boolean needsNormalization Rotation IDENTITY double inv q0 q1 q2 q3 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.2773500981126146	145	145	1	replace	
67	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] if (needsNormalization) {  double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3); q0 *= inv; q1 *= inv; q2 *= inv; q3 *= inv; } [BUGGY] [BUGGY] this.q0 = q0; this.q1 = q1; this.q2 = q2; this.q3 = q3; } [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Rotation(double,double,double,double,boolean)  double q0 double q1 double q2 double q3 boolean needsNormalization [VARIABLES] boolean needsNormalization Rotation IDENTITY double inv q0 q1 q2 q3 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.2773500981126146	145	145	1	add	
68	[BUG] [BUGGY] this.q1 = q1; [FE] AssertionError [CONTEXT] if (needsNormalization) {  double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3); q0 *= inv; q1 *= inv; q2 *= inv; q3 *= inv; } this.q0 = q0; [BUGGY] this.q1 = q1; [BUGGY] this.q2 = q2; this.q3 = q3; } [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Rotation(double,double,double,double,boolean)  double q0 double q1 double q2 double q3 boolean needsNormalization [VARIABLES] boolean needsNormalization Rotation IDENTITY double inv q0 q1 q2 q3 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.2773500981126146	146	146	1	replace	
69	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] if (needsNormalization) {  double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3); q0 *= inv; q1 *= inv; q2 *= inv; q3 *= inv; } this.q0 = q0; [BUGGY] [BUGGY] this.q1 = q1; this.q2 = q2; this.q3 = q3; } [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Rotation(double,double,double,double,boolean)  double q0 double q1 double q2 double q3 boolean needsNormalization [VARIABLES] boolean needsNormalization Rotation IDENTITY double inv q0 q1 q2 q3 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.2773500981126146	146	146	1	add	
70	[BUG] [BUGGY] this.q2 = q2; [FE] AssertionError [CONTEXT]  double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3); q0 *= inv; q1 *= inv; q2 *= inv; q3 *= inv; } this.q0 = q0; this.q1 = q1; [BUGGY] this.q2 = q2; [BUGGY] this.q3 = q3; } [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Rotation(double,double,double,double,boolean)  double q0 double q1 double q2 double q3 boolean needsNormalization [VARIABLES] boolean needsNormalization Rotation IDENTITY double inv q0 q1 q2 q3 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.2773500981126146	147	147	1	replace	
71	[BUG] [BUGGY] [FE] AssertionError [CONTEXT]  double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3); q0 *= inv; q1 *= inv; q2 *= inv; q3 *= inv; } this.q0 = q0; this.q1 = q1; [BUGGY] [BUGGY] this.q2 = q2; this.q3 = q3; } [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Rotation(double,double,double,double,boolean)  double q0 double q1 double q2 double q3 boolean needsNormalization [VARIABLES] boolean needsNormalization Rotation IDENTITY double inv q0 q1 q2 q3 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.2773500981126146	147	147	1	add	
72	[BUG] [BUGGY] this.q3 = q3; [FE] AssertionError [CONTEXT] double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3); q0 *= inv; q1 *= inv; q2 *= inv; q3 *= inv; } this.q0 = q0; this.q1 = q1; this.q2 = q2; [BUGGY] this.q3 = q3; [BUGGY]  } [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Rotation(double,double,double,double,boolean)  double q0 double q1 double q2 double q3 boolean needsNormalization [VARIABLES] boolean needsNormalization Rotation IDENTITY double inv q0 q1 q2 q3 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.2773500981126146	148	148	1	replace	
73	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3); q0 *= inv; q1 *= inv; q2 *= inv; q3 *= inv; } this.q0 = q0; this.q1 = q1; this.q2 = q2; [BUGGY] [BUGGY] this.q3 = q3; } [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Rotation(double,double,double,double,boolean)  double q0 double q1 double q2 double q3 boolean needsNormalization [VARIABLES] boolean needsNormalization Rotation IDENTITY double inv q0 q1 q2 q3 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.2773500981126146	148	148	1	add	
74	[BUG] [BUGGY] } [FE] AssertionError [CONTEXT] q1 *= inv; q2 *= inv; q3 *= inv; } this.q0 = q0; this.q1 = q1; this.q2 = q2; this.q3 = q3; [BUGGY] } [BUGGY]  [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Rotation(double,double,double,double,boolean)  double q0 double q1 double q2 double q3 boolean needsNormalization [VARIABLES] boolean needsNormalization Rotation IDENTITY double inv q0 q1 q2 q3 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.2773500981126146	150	150	1	replace	
75	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] q1 *= inv; q2 *= inv; q3 *= inv; } this.q0 = q0; this.q1 = q1; this.q2 = q2; this.q3 = q3; [BUGGY] [BUGGY] } [CLASS] Rotation [METHOD] <init> [RETURN_TYPE] Rotation(double,double,double,double,boolean)  double q0 double q1 double q2 double q3 boolean needsNormalization [VARIABLES] boolean needsNormalization Rotation IDENTITY double inv q0 q1 q2 q3 long serialVersionUID  	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.2773500981126146	150	150	1	add	
76	[BUG] [BUGGY] public static final Rotation IDENTITY = new Rotation(1.0, 0.0, 0.0, 0.0, false); [FE] AssertionError [CONTEXT] [BUGGY] public static final Rotation IDENTITY = new Rotation(1.0, 0.0, 0.0, 0.0, false); [BUGGY]  [CLASS] Rotation  [VARIABLES] 	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.2773500981126146	98	98	1	replace	
77	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] [BUGGY] [BUGGY] public static final Rotation IDENTITY = new Rotation(1.0, 0.0, 0.0, 0.0, false); [CLASS] Rotation  [VARIABLES] 	projects/Math52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java	0.2773500981126146	98	98	1	add	
