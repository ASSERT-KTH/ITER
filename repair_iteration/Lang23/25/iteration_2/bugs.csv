bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  if(stripCustom!=  null)  {  if(!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FE);  }  [CE]  ';'  expected  [FE]            junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(stripCustom!=  null)  {  if(!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FE);  }  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(stripCustom!=  null)  {  if(!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FE);  }	      if(!stripCustom.isEmpty())    {    for(int    i    =    start;    i    <    fmtCount;    i++)    {    stripCustom.append(END_FE);    }    	non-compiled	[CE]  ';'  expected	7	None	replace
2	[BUG]  [BUGGY]  if(stripCustom  ==  null)  {  if(!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FE);  }  [CE]  ';'  expected  [FE]              junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(stripCustom  ==  null)  {  if(!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FE);  }  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(stripCustom  ==  null)  {  if(!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FE);  }	      if(!stripCustom.isEmpty())    {    for(int    i    =    start;    i    <    fmtCount;    i++)    {    stripCustom.append(END_FE);    }    	non-compiled	[CE]  ';'  expected	7	None	replace
3	[BUG]  [BUGGY]  ||!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FE);  }  [CE]  illegal  start  of  expression  [FE]                junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  ||!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FE);  }  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	||!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FE);  }	      if(!stripCustom.isEmpty())    {    for(int    i    =    start;    i    <    fmtCount;    i++)    {    stripCustom.append(END_FE);    }    	non-compiled	[CE]  illegal  start  of  expression	7	None	replace
4	[BUG]  [BUGGY]  if(c[pos.getIndex()  ]  ==  END_FE  ||  c[pos.getIndex()  ]  ==  END_FE)  {  [CE]  ';'  expected  [FE]        junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(c[pos.getIndex()  ]  ==  END_FE  ||  c[pos.getIndex()  ]  ==  END_FE)  {  [BUGGY]    throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(c[pos.getIndex()  ]  ==  END_FE  ||  c[pos.getIndex()  ]  ==  END_FE)  {	  if(c[pos.getIndex()    ]    ==    END_FE)    {    	non-compiled	[CE]  ';'  expected	10	None	replace
5	[BUG]  [BUGGY]  if(c[pos.getIndex()  ]  ==  START_FE)  {  [CE]  ';'  expected  [FE]          junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(c[pos.getIndex()  ]  ==  START_FE)  {  [BUGGY]    throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(c[pos.getIndex()  ]  ==  START_FE)  {	  if(c[pos.getIndex()    ]    ==    END_FE)    {    	non-compiled	[CE]  ';'  expected	10	None	replace
6	[BUG]  [BUGGY]  if(pos.getIndex()  ==  END_FE)  {  [CE]  ';'  expected  [FE]            junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(pos.getIndex()  ==  END_FE)  {  [BUGGY]    throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(pos.getIndex()  ==  END_FE)  {	  if(pos.getIndex()    >=    END_FE)    {    	non-compiled	[CE]  ';'  expected	3	None	replace
7	[BUG]  [BUGGY]  if(pos.getIndex()  >=  0)  {  [CE]  ';'  expected  [FE]              junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(pos.getIndex()  >=  0)  {  [BUGGY]    throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(pos.getIndex()  >=  0)  {	  if(pos.getIndex()    >=    END_FE)    {    	non-compiled	[CE]  ';'  expected	3	None	replace
8	[BUG]  [BUGGY]  if(pos.getIndex()!=  END_FE)  {  [CE]  ';'  expected  [FE]                junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(pos.getIndex()!=  END_FE)  {  [BUGGY]    throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(pos.getIndex()!=  END_FE)  {	  if(pos.getIndex()    >=    END_FE)    {    	non-compiled	[CE]  ';'  expected	3	None	replace
9	[BUG]  [BUGGY]  if(stripCustom!=  null)  {  if(!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  ++i)  {  stripCustom.append(START_FMT);  }  [CE]  ';'  expected  [FE]                junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(stripCustom!=  null)  {  if(!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  ++i)  {  stripCustom.append(START_FMT);  }  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(stripCustom!=  null)  {  if(!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  ++i)  {  stripCustom.append(START_FMT);  }	      if(!stripCustom.isEmpty())    {    for(int    i    =    start;    i    <    fmtCount;    ++i)    {    stripCustom.append(START_FMT);    }    	non-compiled	[CE]  ';'  expected	9	None	replace
10	[BUG]  [BUGGY]  ||!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  ++i)  {  stripCustom.append(START_FMT);  }  [CE]  illegal  start  of  expression  [FE]                  junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  ||!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  ++i)  {  stripCustom.append(START_FMT);  }  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	||!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  ++i)  {  stripCustom.append(START_FMT);  }	      if(!stripCustom.isEmpty())    {    for(int    i    =    start;    i    <    fmtCount;    ++i)    {    stripCustom.append(START_FMT);    }    	non-compiled	[CE]  illegal  start  of  expression	9	None	replace
11	[BUG]  [BUGGY]  if(!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  ++i)  {  stripCustom.append(END_FE);  }  [CE]  ';'  expected  [FE]                    junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  ++i)  {  stripCustom.append(END_FE);  }  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  ++i)  {  stripCustom.append(END_FE);  }	      if(!stripCustom.isEmpty())    {    for(int    i    =    start;    i    <    fmtCount;    ++i)    {    stripCustom.append(START_FMT);    }    	non-compiled	[CE]  ';'  expected	9	None	replace
12	[BUG]  [BUGGY]  if(c[pos.getIndex()]  >=  END_FE)  {  [CE]  ';'  expected  [FE]        junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(c[pos.getIndex()]  >=  END_FE)  {  [BUGGY]    throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(c[pos.getIndex()]  >=  END_FE)  {	  if(c[pos.getIndex()    +    1]!=    END_FE)    {    	non-compiled	[CE]  ';'  expected	16	None	replace
13	[BUG]  [BUGGY]  char[]  c  =  stripCustom.toCharArray();  [CE]  ';'  expected  [FE]        junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  char[]  c  =  stripCustom.toCharArray();  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	char[]  c  =  stripCustom.toCharArray();	      char[]    c    =    pattern.toCharArray();    	non-compiled	[CE]  ';'  expected	17	None	replace
14	[BUG]  [BUGGY]  char[]  c  =  toPattern.toCharArray();  [CE]  ';'  expected  [FE]          junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  char[]  c  =  toPattern.toCharArray();  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	char[]  c  =  toPattern.toCharArray();	      char[]    c    =    pattern.toCharArray();    	non-compiled	[CE]  ';'  expected	17	None	replace
15	[BUG]  [BUGGY]  if(stripCustom!=  null)  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FMT);  }  [CE]  ';'  expected  [FE]          junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(stripCustom!=  null)  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FMT);  }  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(stripCustom!=  null)  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FMT);  }	      if(stripCustom!=    null)    {    for(int    i    =    start;    i    <    fmtCount;    i++)    {    stripCustom.append(START_FMT);    }    	non-compiled	[CE]  ';'  expected	6	None	replace
16	[BUG]  [BUGGY]  if(format  ==  null)  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FE);  }  [CE]  ';'  expected  [FE]            junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(format  ==  null)  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FE);  }  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(format  ==  null)  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FE);  }	      if(stripCustom!=    null)    {    for(int    i    =    start;    i    <    fmtCount;    i++)    {    stripCustom.append(START_FMT);    }    	non-compiled	[CE]  ';'  expected	6	None	replace
17	[BUG]  [BUGGY]  char[]  c  =  pattern.toString();  [CE]  ';'  expected  [FE]          junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  char[]  c  =  pattern.toString();  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	char[]  c  =  pattern.toString();	      char[]    c    =    pattern.toPattern();    	non-compiled	[CE]  ';'  expected	18	None	replace
18	[BUG]  [BUGGY]  char[]  c  =  pattern.toPattern(start);  [CE]  ';'  expected  [FE]            junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  char[]  c  =  pattern.toPattern(start);  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	char[]  c  =  pattern.toPattern(start);	      char[]    c    =    pattern.toPattern();    	non-compiled	[CE]  ';'  expected	18	None	replace
19	[BUG]  [BUGGY]  char  c  =  pattern.charAt(i  +  1);  [CE]  ';'  expected  [FE]              junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  char  c  =  pattern.charAt(i  +  1);  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	char  c  =  pattern.charAt(i  +  1);	      char    c    =    pattern.charAt(i);    	non-compiled	[CE]  ';'  expected	14	None	replace
20	[BUG]  [BUGGY]  char  c  =  pattern.charAt(start);  [CE]  ';'  expected  [FE]                junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  char  c  =  pattern.charAt(start);  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	char  c  =  pattern.charAt(start);	      char    c    =    pattern.charAt(i);    	non-compiled	[CE]  ';'  expected	14	None	replace
21	[BUG]  [BUGGY]  char  c  =  this.pattern.charAt(i);  [CE]  ';'  expected  [FE]                  junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  char  c  =  this.pattern.charAt(i);  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	char  c  =  this.pattern.charAt(i);	      char    c    =    pattern.charAt(i);    	non-compiled	[CE]  ';'  expected	14	None	replace
22	[BUG]  [BUGGY]  ArrayList  <  String>  foundFormats  =  new  ArrayList  <  String>(foundDescriptions.size()  +  1);  [CE]  ';'  expected  [FE]        junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  ArrayList  <  String>  foundFormats  =  new  ArrayList  <  String>(foundDescriptions.size()  +  1);  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	ArrayList  <  String>  foundFormats  =  new  ArrayList  <  String>(foundDescriptions.size()  +  1);	      ArrayList    <    String>    foundFormats    =    new    ArrayList    <    String>(foundDescriptions.size());    	non-compiled	[CE]  ';'  expected	11	None	replace
23	[BUG]  [BUGGY]  ArrayList  <  String>  foundFormats  =  new  ArrayList  <  String>(foundDescriptions.size()  -  1);  [CE]  ';'  expected  [FE]          junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  ArrayList  <  String>  foundFormats  =  new  ArrayList  <  String>(foundDescriptions.size()  -  1);  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	ArrayList  <  String>  foundFormats  =  new  ArrayList  <  String>(foundDescriptions.size()  -  1);	      ArrayList    <    String>    foundFormats    =    new    ArrayList    <    String>(foundDescriptions.size());    	non-compiled	[CE]  ';'  expected	11	None	replace
24	[BUG]  [BUGGY]  List  <  String>  foundFormats  =  new  ArrayList  <  String>(foundDescriptions.size());  [CE]  ';'  expected  [FE]            junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  List  <  String>  foundFormats  =  new  ArrayList  <  String>(foundDescriptions.size());  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	List  <  String>  foundFormats  =  new  ArrayList  <  String>(foundDescriptions.size());	      ArrayList    <    String>    foundFormats    =    new    ArrayList    <    String>(foundDescriptions.size());    	non-compiled	[CE]  ';'  expected	11	None	replace
25	[BUG]  [BUGGY]  if(!foundDescriptions.isEmpty())  {  if(stripCustom!=  null)  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FE);  }  [CE]  ';'  expected  [FE]              junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(!foundDescriptions.isEmpty())  {  if(stripCustom!=  null)  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FE);  }  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(!foundDescriptions.isEmpty())  {  if(stripCustom!=  null)  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FE);  }	      if(stripCustom!=    null)    {    for(int    i    =    start;    i    <    fmtCount;    i++)    {    stripCustom.append(END_FE);    }    	non-compiled	[CE]  ';'  expected	8	None	replace
26	[BUG]  [BUGGY]  if(stripCustom  ==  null)  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FE);  }  [CE]  ';'  expected  [FE]                junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(stripCustom  ==  null)  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FE);  }  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(stripCustom  ==  null)  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FE);  }	      if(stripCustom!=    null)    {    for(int    i    =    start;    i    <    fmtCount;    i++)    {    stripCustom.append(END_FE);    }    	non-compiled	[CE]  ';'  expected	8	None	replace
27	[BUG]  [BUGGY]  if(!foundDescriptions.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FE);  }  [CE]  ';'  expected  [FE]                  junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(!foundDescriptions.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FE);  }  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(!foundDescriptions.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FE);  }	      if(stripCustom!=    null)    {    for(int    i    =    start;    i    <    fmtCount;    i++)    {    stripCustom.append(END_FE);    }    	non-compiled	[CE]  ';'  expected	8	None	replace
28	[BUG]  [BUGGY]  ArrayList  foundFormats  =  new  ArrayList(foundDescriptions.size());  [CE]  ';'  expected  [FE]                junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  ArrayList  foundFormats  =  new  ArrayList(foundDescriptions.size());  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	ArrayList  foundFormats  =  new  ArrayList(foundDescriptions.size());	      ArrayList    foundFormats    =    new    ArrayList();    	non-compiled	[CE]  ';'  expected	15	None	replace
29	[BUG]  [BUGGY]  ArrayList  foundFormats  =  new  ArrayList(fmtCount);  [CE]  ';'  expected  [FE]                  junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  ArrayList  foundFormats  =  new  ArrayList(fmtCount);  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	ArrayList  foundFormats  =  new  ArrayList(fmtCount);	      ArrayList    foundFormats    =    new    ArrayList();    	non-compiled	[CE]  ';'  expected	15	None	replace
30	[BUG]  [BUGGY]  List  foundFormats  =  new  ArrayList();  [CE]  ';'  expected  [FE]                    junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  List  foundFormats  =  new  ArrayList();  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	List  foundFormats  =  new  ArrayList();	      ArrayList    foundFormats    =    new    ArrayList();    	non-compiled	[CE]  ';'  expected	15	None	replace
31	[BUG]  [BUGGY]  if(stripCustom!=  null)  {  if(!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(START_FMT);  }  [CE]  ';'  expected  [FE]        junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(stripCustom!=  null)  {  if(!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(START_FMT);  }  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(stripCustom!=  null)  {  if(!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(START_FMT);  }	      if(!stripCustom.isEmpty())    {    for(int    i    =    start;    i    <    fmtCount;    i++)    {    stripCustom.append(START_FMT);    }    	non-compiled	[CE]  ';'  expected	5	None	replace
32	[BUG]  [BUGGY]  if(stripCustom  ==  null)  {  if(!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(START_FMT);  }  [CE]  ';'  expected  [FE]          junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(stripCustom  ==  null)  {  if(!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(START_FMT);  }  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(stripCustom  ==  null)  {  if(!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(START_FMT);  }	      if(!stripCustom.isEmpty())    {    for(int    i    =    start;    i    <    fmtCount;    i++)    {    stripCustom.append(START_FMT);    }    	non-compiled	[CE]  ';'  expected	5	None	replace
33	[BUG]  [BUGGY]  ||!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(START_FMT);  }  [CE]  illegal  start  of  expression  [FE]            junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  ||!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(START_FMT);  }  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	||!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(START_FMT);  }	      if(!stripCustom.isEmpty())    {    for(int    i    =    start;    i    <    fmtCount;    i++)    {    stripCustom.append(START_FMT);    }    	non-compiled	[CE]  illegal  start  of  expression	5	None	replace
34	[BUG]  [BUGGY]  if(p[pos.getIndex()]  ==  END_FE)  {  [CE]  ';'  expected  [FE]          junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(p[pos.getIndex()]  ==  END_FE)  {  [BUGGY]    throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(p[pos.getIndex()]  ==  END_FE)  {	  if(c[pos.getIndex()    -    1]    ==    END_FE)    {    	non-compiled	[CE]  ';'  expected	2	None	replace
35	[BUG]  [BUGGY]  ArrayList  <  String>  foundFormats  =  new  ArrayList  <  String>(fmtCount);  [CE]  ';'  expected  [FE]            junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  ArrayList  <  String>  foundFormats  =  new  ArrayList  <  String>(fmtCount);  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	ArrayList  <  String>  foundFormats  =  new  ArrayList  <  String>(fmtCount);	      ArrayList    <    String>    foundFormats    =    new    ArrayList    <    String>();    	non-compiled	[CE]  ';'  expected	13	None	replace
36	[BUG]  [BUGGY]  List  <  String>  foundFormats  =  new  ArrayList  <  String>();  [CE]  ';'  expected  [FE]              junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  List  <  String>  foundFormats  =  new  ArrayList  <  String>();  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	List  <  String>  foundFormats  =  new  ArrayList  <  String>();	      ArrayList    <    String>    foundFormats    =    new    ArrayList    <    String>();    	non-compiled	[CE]  ';'  expected	13	None	replace
37	[BUG]  [BUGGY]  char[]  c  =  it.getValue();  [CE]  ';'  expected  [FE]            junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  char[]  c  =  it.getValue();  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	char[]  c  =  it.getValue();	      char[]    c    =    it.next();    	non-compiled	[CE]  ';'  expected	19	None	replace
38	[BUG]  [BUGGY]  char[]  c  =  it.getCurrentIndex();  [CE]  ';'  expected  [FE]              junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  char[]  c  =  it.getCurrentIndex();  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	char[]  c  =  it.getCurrentIndex();	      char[]    c    =    it.next();    	non-compiled	[CE]  ';'  expected	19	None	replace
39	[BUG]  [BUGGY]  char[]  c  =  it.next()  +  1;  [CE]  ';'  expected  [FE]                junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  char[]  c  =  it.next()  +  1;  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	char[]  c  =  it.next()  +  1;	      char[]    c    =    it.next();    	non-compiled	[CE]  ';'  expected	19	None	replace
40	[BUG]  [BUGGY]  char  c  =  pattern.charAt(pos  +  1);  [CE]  ';'  expected  [FE]          junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  char  c  =  pattern.charAt(pos  +  1);  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	char  c  =  pattern.charAt(pos  +  1);	      char    c    =    pattern.charAt(pos);    	non-compiled	[CE]  ';'  expected	12	None	replace
41	[BUG]  [BUGGY]  char  c  =  pattern.charAt(0);  [CE]  ';'  expected  [FE]            junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  char  c  =  pattern.charAt(0);  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	char  c  =  pattern.charAt(0);	      char    c    =    pattern.charAt(pos);    	non-compiled	[CE]  ';'  expected	12	None	replace
42	[BUG]  [BUGGY]  char[]  c  =  it.getCurrent();  [CE]  ';'  expected  [FE]            junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  char[]  c  =  it.getCurrent();  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	char[]  c  =  it.getCurrent();	      char[]    c    =    it.next();    	non-compiled	[CE]  ';'  expected	19	None	replace
43	[BUG]  [BUGGY]  if(format  ==  null)  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FMT);  }  [CE]  ';'  expected  [FE]          junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(format  ==  null)  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FMT);  }  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(format  ==  null)  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FMT);  }	      if(stripCustom!=    null)    {    for(int    i    =    start;    i    <    fmtCount;    i++)    {    stripCustom.append(START_FMT);    }    	non-compiled	[CE]  ';'  expected	6	None	replace
44	[BUG]  [BUGGY]  if(format  ==  null)  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(START_FMT);  }  [CE]  ';'  expected  [FE]            junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(format  ==  null)  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(START_FMT);  }  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(format  ==  null)  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(START_FMT);  }	      if(stripCustom!=    null)    {    for(int    i    =    start;    i    <    fmtCount;    i++)    {    stripCustom.append(START_FMT);    }    	non-compiled	[CE]  ';'  expected	6	None	replace
45	[BUG]  [BUGGY]  if(stripCustom  ==  null)  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FMT);  }  [CE]  ';'  expected  [FE]              junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(stripCustom  ==  null)  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FMT);  }  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(stripCustom  ==  null)  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FMT);  }	      if(stripCustom!=    null)    {    for(int    i    =    start;    i    <    fmtCount;    i++)    {    stripCustom.append(START_FMT);    }    	non-compiled	[CE]  ';'  expected	6	None	replace
46	[BUG]  [BUGGY]  ArrayList  <  String>  foundFormats  =  new  ArrayList  <  String>(foundDescriptions.size()  +  2);  [CE]  ';'  expected  [FE]        junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  ArrayList  <  String>  foundFormats  =  new  ArrayList  <  String>(foundDescriptions.size()  +  2);  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	ArrayList  <  String>  foundFormats  =  new  ArrayList  <  String>(foundDescriptions.size()  +  2);	      ArrayList    <    String>    foundFormats    =    new    ArrayList    <    String>(foundDescriptions.size());    	non-compiled	[CE]  ';'  expected	11	None	replace
47	[BUG]  [BUGGY]  if(start  ==  0)  {  for(int  i  =  start;  i  <  =  0;  i++)  {  stripCustom.append(DUMMY_PATTERN[i]);  }  [CE]  illegal  start  of  expression  [FE]              junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(start  ==  0)  {  for(int  i  =  start;  i  <  =  0;  i++)  {  stripCustom.append(DUMMY_PATTERN[i]);  }  [BUGGY]    throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(start  ==  0)  {  for(int  i  =  start;  i  <  =  0;  i++)  {  stripCustom.append(DUMMY_PATTERN[i]);  }	      	non-compiled	[CE]  illegal  start  of  expression	4	None	replace
48	[BUG]  [BUGGY]  if(start  ==  0)  {  for(int  i  =  start;  i  <  =  0;  i++)  {  stripCustom.append(END_FE);  }  [CE]  illegal  start  of  expression  [FE]                junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(start  ==  0)  {  for(int  i  =  start;  i  <  =  0;  i++)  {  stripCustom.append(END_FE);  }  [BUGGY]    throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(start  ==  0)  {  for(int  i  =  start;  i  <  =  0;  i++)  {  stripCustom.append(END_FE);  }	      	non-compiled	[CE]  illegal  start  of  expression	4	None	replace
49	[BUG]  [BUGGY]  if(start  ==  0)  {  for(int  i  =  start;  i  <  =  0;  i++)  {  stripCustom.append(DUMMY_PATTERN);  }  [CE]  illegal  start  of  expression  [FE]                  junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(start  ==  0)  {  for(int  i  =  start;  i  <  =  0;  i++)  {  stripCustom.append(DUMMY_PATTERN);  }  [BUGGY]    throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(start  ==  0)  {  for(int  i  =  start;  i  <  =  0;  i++)  {  stripCustom.append(DUMMY_PATTERN);  }	      	non-compiled	[CE]  illegal  start  of  expression	4	None	replace
50	[BUG]  [BUGGY]  if(start  >=  0)  {  for(int  i  =  start;  i  <  =  0;  i++)  {  stripCustom.append(DUMMY_PATTERN[i]);  }  [CE]  illegal  start  of  expression  [FE]                    junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(start  >=  0)  {  for(int  i  =  start;  i  <  =  0;  i++)  {  stripCustom.append(DUMMY_PATTERN[i]);  }  [BUGGY]    throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(start  >=  0)  {  for(int  i  =  start;  i  <  =  0;  i++)  {  stripCustom.append(DUMMY_PATTERN[i]);  }	      	non-compiled	[CE]  illegal  start  of  expression	4	None	replace
51	[BUG]  [BUGGY]  if(!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  0;  i++)  {  stripCustom.append(END_FE);  }  [CE]  ';'  expected  [FE]            junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  0;  i++)  {  stripCustom.append(END_FE);  }  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  0;  i++)  {  stripCustom.append(END_FE);  }	      if(!stripCustom.isEmpty())    {    for(int    i    =    start;    i    <    fmtCount;    i++)    {    stripCustom.append(END_FE);    }    	non-compiled	[CE]  ';'  expected	7	None	replace
52	[BUG]  [BUGGY]  char  c  =  toPattern.charAt(pos);  [CE]  ';'  expected  [FE]          junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  char  c  =  toPattern.charAt(pos);  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	char  c  =  toPattern.charAt(pos);	      char    c    =    pattern.charAt(pos);    	non-compiled	[CE]  ';'  expected	12	None	replace
53	[BUG]  [BUGGY]  if(pos.getIndex()!=  0)  {  [CE]  ';'  expected  [FE]            junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(pos.getIndex()!=  0)  {  [BUGGY]    throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(pos.getIndex()!=  0)  {	  if(pos.getIndex()    >=    END_FE)    {    	non-compiled	[CE]  ';'  expected	3	None	replace
54	[BUG]  [BUGGY]  if(c[pos.getIndex()  ]  ==  QUOTE)  {  [CE]  ';'  expected  [FE]        junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(c[pos.getIndex()  ]  ==  QUOTE)  {  [BUGGY]    throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(c[pos.getIndex()  ]  ==  QUOTE)  {	  if(c[pos.getIndex()    ]    ==    END_FE)    {    	non-compiled	[CE]  ';'  expected	10	None	replace
55	[BUG]  [BUGGY]  if(c[pos.getIndex()  -  start]  ==  END_FE)  {  [CE]  ';'  expected  [FE]          junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(c[pos.getIndex()  -  start]  ==  END_FE)  {  [BUGGY]    throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(c[pos.getIndex()  -  start]  ==  END_FE)  {	  if(c[pos.getIndex()    ]    ==    END_FE)    {    	non-compiled	[CE]  ';'  expected	10	None	replace
56	[BUG]  [BUGGY]  if(c[pos.getIndex()  -  1)  {  [CE]  ']'  expected  [FE]            junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(c[pos.getIndex()  -  1)  {  [BUGGY]    throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(c[pos.getIndex()  -  1)  {	  if(c[pos.getIndex()    ]    ==    END_FE)    {    	non-compiled	[CE]  ']'  expected	10	None	replace
57	[BUG]  [BUGGY]  if(stripCustom!=  null)  {  for(int  i  =  start;  i  <  0;  i++)  {  stripCustom.append(END_FE);  }  [CE]  ';'  expected  [FE]              junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(stripCustom!=  null)  {  for(int  i  =  start;  i  <  0;  i++)  {  stripCustom.append(END_FE);  }  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(stripCustom!=  null)  {  for(int  i  =  start;  i  <  0;  i++)  {  stripCustom.append(END_FE);  }	      if(stripCustom!=    null)    {    for(int    i    =    start;    i    <    fmtCount;    i++)    {    stripCustom.append(END_FE);    }    	non-compiled	[CE]  ';'  expected	8	None	replace
58	[BUG]  [BUGGY]  if(c[pos.getIndex()  +  1]  ==  END_FE)  {  [CE]  ';'  expected  [FE]          junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(c[pos.getIndex()  +  1]  ==  END_FE)  {  [BUGGY]    throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(c[pos.getIndex()  +  1]  ==  END_FE)  {	  if(c[pos.getIndex()    -    1]    ==    END_FE)    {    	non-compiled	[CE]  ';'  expected	2	None	replace
59	[BUG]  [BUGGY]  if(c[pos.getIndex()  1]  ==  QUOTE)  {  [CE]  ']'  expected  [FE]            junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(c[pos.getIndex()  1]  ==  QUOTE)  {  [BUGGY]    throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(c[pos.getIndex()  1]  ==  QUOTE)  {	  if(c[pos.getIndex()    -    1]    ==    END_FE)    {    	non-compiled	[CE]  ']'  expected	2	None	replace
60	[BUG]  [BUGGY]  if(c[pos.getIndex()]  ==  END_FMT)  {  [CE]  ';'  expected  [FE]              junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(c[pos.getIndex()]  ==  END_FMT)  {  [BUGGY]    throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(c[pos.getIndex()]  ==  END_FMT)  {	  if(c[pos.getIndex()    -    1]    ==    END_FE)    {    	non-compiled	[CE]  ';'  expected	2	None	replace
61	[BUG]  [BUGGY]  ArrayList  foundFormats  =  new  ArrayList  <  String>();  [CE]  ';'  expected  [FE]                junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  ArrayList  foundFormats  =  new  ArrayList  <  String>();  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	ArrayList  foundFormats  =  new  ArrayList  <  String>();	      ArrayList    foundFormats    =    new    ArrayList();    	non-compiled	[CE]  ';'  expected	15	None	replace
62	[BUG]  [BUGGY]  ArrayList  foundFormats  =  new  ArrayList(foundDescriptions.length);  [CE]  ';'  expected  [FE]                  junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  ArrayList  foundFormats  =  new  ArrayList(foundDescriptions.length);  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	ArrayList  foundFormats  =  new  ArrayList(foundDescriptions.length);	      ArrayList    foundFormats    =    new    ArrayList();    	non-compiled	[CE]  ';'  expected	15	None	replace
63	[BUG]  [BUGGY]  if(stripCustom!=  null)  {  for(int  i  =  start;  i  <  fmtCount;  ++i)  {  stripCustom.append(START_FMT);  }  [CE]  ';'  expected  [FE]                junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(stripCustom!=  null)  {  for(int  i  =  start;  i  <  fmtCount;  ++i)  {  stripCustom.append(START_FMT);  }  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(stripCustom!=  null)  {  for(int  i  =  start;  i  <  fmtCount;  ++i)  {  stripCustom.append(START_FMT);  }	      if(!stripCustom.isEmpty())    {    for(int    i    =    start;    i    <    fmtCount;    ++i)    {    stripCustom.append(START_FMT);    }    	non-compiled	[CE]  ';'  expected	9	None	replace
64	[BUG]  [BUGGY]  if(!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  ++i)  {  stripCustom.append(END_FMT);  }  [CE]  ';'  expected  [FE]                  junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  ++i)  {  stripCustom.append(END_FMT);  }  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  ++i)  {  stripCustom.append(END_FMT);  }	      if(!stripCustom.isEmpty())    {    for(int    i    =    start;    i    <    fmtCount;    ++i)    {    stripCustom.append(START_FMT);    }    	non-compiled	[CE]  ';'  expected	9	None	replace
65	[BUG]  [BUGGY]  if(stripCustom!=  null)  {  for(int  i  =  start;  i  <  fmtCount;  ++i)  {  stripCustom.append(END_FMT);  }  [CE]  ';'  expected  [FE]                    junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(stripCustom!=  null)  {  for(int  i  =  start;  i  <  fmtCount;  ++i)  {  stripCustom.append(END_FMT);  }  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(stripCustom!=  null)  {  for(int  i  =  start;  i  <  fmtCount;  ++i)  {  stripCustom.append(END_FMT);  }	      if(!stripCustom.isEmpty())    {    for(int    i    =    start;    i    <    fmtCount;    ++i)    {    stripCustom.append(START_FMT);    }    	non-compiled	[CE]  ';'  expected	9	None	replace
66	[BUG]  [BUGGY]  ArrayList  <  String>  foundFormats  =  new  ArrayList  <  String>(8);  [CE]  ';'  expected  [FE]            junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  ArrayList  <  String>  foundFormats  =  new  ArrayList  <  String>(8);  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	ArrayList  <  String>  foundFormats  =  new  ArrayList  <  String>(8);	      ArrayList    <    String>    foundFormats    =    new    ArrayList    <    String>();    	non-compiled	[CE]  ';'  expected	13	None	replace
67	[BUG]  [BUGGY]  if(!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FMT);  }  [CE]  ';'  expected  [FE]        junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FMT);  }  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(!stripCustom.isEmpty())  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FMT);  }	      if(!stripCustom.isEmpty())    {    for(int    i    =    start;    i    <    fmtCount;    i++)    {    stripCustom.append(START_FMT);    }    	non-compiled	[CE]  ';'  expected	5	None	replace
68	[BUG]  [BUGGY]  char[]  c  =  this.pattern.toCharArray();  [CE]  ';'  expected  [FE]        junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  char[]  c  =  this.pattern.toCharArray();  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	char[]  c  =  this.pattern.toCharArray();	      char[]    c    =    pattern.toCharArray();    	non-compiled	[CE]  ';'  expected	17	None	replace
69	[BUG]  [BUGGY]  char[]  c  =  format.toCharArray();  [CE]  ';'  expected  [FE]          junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  char[]  c  =  format.toCharArray();  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	char[]  c  =  format.toCharArray();	      char[]    c    =    pattern.toCharArray();    	non-compiled	[CE]  ';'  expected	17	None	replace
70	[BUG]  [BUGGY]  if(pos.getIndex()  >  END_FE)  {  [CE]  ';'  expected  [FE]            junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(pos.getIndex()  >  END_FE)  {  [BUGGY]    throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(pos.getIndex()  >  END_FE)  {	  if(pos.getIndex()    >=    END_FE)    {    	non-compiled	[CE]  ';'  expected	3	None	replace
71	[BUG]  [BUGGY]  if(pos.getIndex()  <  0)  {  [CE]  ';'  expected  [FE]              junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(pos.getIndex()  <  0)  {  [BUGGY]    throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(pos.getIndex()  <  0)  {	  if(pos.getIndex()    >=    END_FE)    {    	non-compiled	[CE]  ';'  expected	3	None	replace
72	[BUG]  [BUGGY]  if(c  ==  null)  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FE);  }  [CE]  ';'  expected  [FE]              junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(c  ==  null)  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FE);  }  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(c  ==  null)  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FE);  }	      if(stripCustom!=    null)    {    for(int    i    =    start;    i    <    fmtCount;    i++)    {    stripCustom.append(END_FE);    }    	non-compiled	[CE]  ';'  expected	8	None	replace
73	[BUG]  [BUGGY]  if(c!=  null)  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FE);  }  [CE]  ';'  expected  [FE]                junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(c!=  null)  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FE);  }  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(c!=  null)  {  for(int  i  =  start;  i  <  fmtCount;  i++)  {  stripCustom.append(END_FE);  }	      if(stripCustom!=    null)    {    for(int    i    =    start;    i    <    fmtCount;    i++)    {    stripCustom.append(END_FE);    }    	non-compiled	[CE]  ';'  expected	8	None	replace
74	[BUG]  [BUGGY]  char[]  c  =  iterator.next();  [CE]  ';'  expected  [FE]            junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  char[]  c  =  iterator.next();  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	char[]  c  =  iterator.next();	      char[]    c    =    it.next();    	non-compiled	[CE]  ';'  expected	19	None	replace
75	[BUG]  [BUGGY]  char[]  c  =  it.getImplicitPrototype();  [CE]  ';'  expected  [FE]              junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  char[]  c  =  it.getImplicitPrototype();  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	char[]  c  =  it.getImplicitPrototype();	      char[]    c    =    it.next();    	non-compiled	[CE]  ';'  expected	19	None	replace
76	[BUG]  [BUGGY]  if(c[pos.getIndex()  1]!=  END_FE)  {  [CE]  ']'  expected  [FE]        junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(c[pos.getIndex()  1]!=  END_FE)  {  [BUGGY]    throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(c[pos.getIndex()  1]!=  END_FE)  {	  if(c[pos.getIndex()    -    1]!=    END_FE)    {    	non-compiled	[CE]  ']'  expected	1	None	replace
77	[BUG]  [BUGGY]  if(c[pos.getIndex()  1]  ==  END_FE)  {  [CE]  ']'  expected  [FE]          junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(c[pos.getIndex()  1]  ==  END_FE)  {  [BUGGY]    throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(c[pos.getIndex()  1]  ==  END_FE)  {	  if(c[pos.getIndex()    -    1]!=    END_FE)    {    	non-compiled	[CE]  ']'  expected	1	None	replace
78	[BUG]  [BUGGY]  if(c[pos.getIndex()  -  1)  ==  END_FE)  {  [CE]  ']'  expected  [FE]        junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(c[pos.getIndex()  -  1)  ==  END_FE)  {  [BUGGY]    throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(c[pos.getIndex()  -  1)  ==  END_FE)  {	  if(c[pos.getIndex()    ]    ==    END_FE)    {    	non-compiled	[CE]  ']'  expected	10	None	replace
79	[BUG]  [BUGGY]  char  c  =  this.pattern.charAt(pos);  [CE]  ';'  expected  [FE]          junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  char  c  =  this.pattern.charAt(pos);  [BUGGY]    if  (c[pos.getIndex()]  !=  END_FE)  {  throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	char  c  =  this.pattern.charAt(pos);	      char    c    =    pattern.charAt(pos);    	non-compiled	[CE]  ';'  expected	12	None	replace
80	[BUG]  [BUGGY]  if(stripCustom!=  null)  {  stripCustom.append(END_FE);  }  else  {  stripCustom.append(c[pos.getIndex()  -  1]);  }  [CE]  ';'  expected  [FE]              junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(stripCustom!=  null)  {  stripCustom.append(END_FE);  }  else  {  stripCustom.append(c[pos.getIndex()  -  1]);  }  [BUGGY]    throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(stripCustom!=  null)  {  stripCustom.append(END_FE);  }  else  {  stripCustom.append(c[pos.getIndex()  -  1]);  }	      	non-compiled	[CE]  ';'  expected	4	None	replace
81	[BUG]  [BUGGY]  if(stripCustom!=  null)  {  for(int  i  =  start;  i  <  c.length;  ++i)  {  stripCustom.append(END_FE);  }  [CE]  ';'  expected  [FE]                junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(stripCustom!=  null)  {  for(int  i  =  start;  i  <  c.length;  ++i)  {  stripCustom.append(END_FE);  }  [BUGGY]    throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(stripCustom!=  null)  {  for(int  i  =  start;  i  <  c.length;  ++i)  {  stripCustom.append(END_FE);  }	      	non-compiled	[CE]  ';'  expected	4	None	replace
82	[BUG]  [BUGGY]  if(stripCustom!=  null)  {  stripCustom.append(END_FE).append(';');  }  [CE]  ';'  expected  [FE]                  junit.framework.AssertionFailedError:  registry    [CONTEXT]    next(pos));  format  =  getFormat(formatDescription);  if  (format  ==  null)  {  stripCustom.append(START_FMT).append(formatDescription);  }  }  foundFormats.add(format);  foundDescriptions.add(format  ==  null  ?  null  :  formatDescription);  Validate.isTrue(foundFormats.size()  ==  fmtCount);  Validate.isTrue(foundDescriptions.size()  ==  fmtCount);    [BUGGY]  if(stripCustom!=  null)  {  stripCustom.append(END_FE).append(';');  }  [BUGGY]    throw  new  IllegalArgumentException(     "Unreadable  format  element  at  position     "  +  start);  }  default:  stripCustom.append(c[pos.getIndex()]);  next(pos);  }  }  super.applyPattern(stripCustom.toString());  [CLASS]  ExtendedMessageFormat  [METHOD]  applyPattern  [RETURN_TYPE]  void  String  pattern  [VARIABLES]  StringBuilder  stripCustom  Format[]  origFormats  ArrayList  foundDescriptions  foundFormats  String  DUMMY_PATTERN  ESCAPED_QUOTE  formatDescription  pattern  toPattern  long  serialVersionUID  int  fmtCount  i  index  start  char[]  c  Format  f  format  boolean  char  END_FE  QUOTE  START_FE  START_FMT  Iterator  it  Map  registry  ParsePosition  pos  	projects/Lang23/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java	0.4472135954999579	184	184	1	replace	if(stripCustom!=  null)  {  stripCustom.append(END_FE).append(';');  }	      	non-compiled	[CE]  ';'  expected	4	None	replace
