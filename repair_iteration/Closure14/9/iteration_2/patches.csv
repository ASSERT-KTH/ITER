bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  edgeAnnotations,  null);  [CE]  non-static  variable  edgeAnnotations  cannot  be  referenced  from  a  static  context  [FE]                AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  edgeAnnotations,  null);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFollowNode(fromNode,  parent,  cfa,  edgeAnnotations,  null);	  return    computeFollowNode(fromNode,    parent,    cfa,    exceptionHandler,    null);    	non-compiled	[CE]  non-static  variable  edgeAnnotations  cannot  be  referenced  from  a  static  context	153	None	replace
2	[BUG]  [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  nodePriorities,  null);  [CE]  non-static  variable  nodePriorities  cannot  be  referenced  from  a  static  context  [FE]                  AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  nodePriorities,  null);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFollowNode(fromNode,  parent,  cfa,  nodePriorities,  null);	  return    computeFollowNode(fromNode,    parent,    cfa,    exceptionHandler,    null);    	non-compiled	[CE]  non-static  variable  nodePriorities  cannot  be  referenced  from  a  static  context	153	None	replace
3	[BUG]  [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  endNode,  null);  [CE]  cannot  find  symbol  endNode  [FE]                    AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  endNode,  null);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFollowNode(fromNode,  parent,  cfa,  endNode,  null);	  return    computeFollowNode(fromNode,    parent,    cfa,    exceptionHandler,    null);    	non-compiled	[CE]  cannot  find  symbol  endNode	153	None	replace
4	[BUG]  [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  astPositionCounter,  null);  [CE]  non-static  variable  astPositionCounter  cannot  be  referenced  from  a  static  context  [FE]                      AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  astPositionCounter,  null);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFollowNode(fromNode,  parent,  cfa,  astPositionCounter,  null);	  return    computeFollowNode(fromNode,    parent,    cfa,    exceptionHandler,    null);    	non-compiled	[CE]  non-static  variable  astPositionCounter  cannot  be  referenced  from  a  static  context	153	None	replace
5	[BUG]  [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  deflt,  null);  [CE]  cannot  find  symbol  deflt  [FE]                        AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  deflt,  null);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFollowNode(fromNode,  parent,  cfa,  deflt,  null);	  return    computeFollowNode(fromNode,    parent,    cfa,    exceptionHandler,    null);    	non-compiled	[CE]  cannot  find  symbol  deflt	153	None	replace
6	[BUG]  [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  curHandler,  null);  [CE]  cannot  find  symbol  curHandler  [FE]                          AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  curHandler,  null);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFollowNode(fromNode,  parent,  cfa,  curHandler,  null);	  return    computeFollowNode(fromNode,    parent,    cfa,    exceptionHandler,    null);    	non-compiled	[CE]  cannot  find  symbol  curHandler	153	None	replace
7	[BUG]  [BUGGY]  [FE]  StackOverflowError  [FE]                      StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  Node  nextSibling  =  parent.getFirstChild();  return  computeFollowNode(fromNode,  node,  cfa);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	add	Node  nextSibling  =  parent.getFirstChild();  return  computeFollowNode(fromNode,  node,  cfa);	  return    computeFollowNode(fromNode,    node,    cfa);    Node    nextSibling    =    parent.getLastChild();    return    computeFollowNode(fromNode,    node,    cfa);    	compilable	  [FE]  StackOverflowError  	48	12	replace
8	[BUG]  [BUGGY]  Node  nextSibling  =  parent.getFirstChild();  return  computeFollowNode(fromNode,  node,  cfa);  [FE]  StackOverflowError  [FE]                      StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  Node  nextSibling  =  parent.getFirstChild();  return  computeFollowNode(fromNode,  node,  cfa);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	Node  nextSibling  =  parent.getFirstChild();  return  computeFollowNode(fromNode,  node,  cfa);	  return    computeFollowNode(fromNode,    node,    cfa);    Node    nextSibling    =    parent.getLastChild();    return    computeFollowNode(fromNode,    node,    cfa);    	compilable	  [FE]  StackOverflowError  	48	12	replace
9	[BUG]  [BUGGY]  [FE]  StackOverflowError  [FE]                        StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  Node  nextSibling  =  parent.getLastChild();  return  computeFollowNode(fromNode,  node,  cfa);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	add	Node  nextSibling  =  parent.getLastChild();  return  computeFollowNode(fromNode,  node,  cfa);	  return    computeFollowNode(fromNode,    node,    cfa);    Node    nextSibling    =    parent.getLastChild();    return    computeFollowNode(fromNode,    node,    cfa);    	compilable	  [FE]  StackOverflowError  	48	12	replace
10	[BUG]  [BUGGY]  Node  nextSibling  =  parent.getLastChild();  return  computeFollowNode(fromNode,  node,  cfa);  [FE]  StackOverflowError  [FE]                        StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  Node  nextSibling  =  parent.getLastChild();  return  computeFollowNode(fromNode,  node,  cfa);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	Node  nextSibling  =  parent.getLastChild();  return  computeFollowNode(fromNode,  node,  cfa);	  return    computeFollowNode(fromNode,    node,    cfa);    Node    nextSibling    =    parent.getLastChild();    return    computeFollowNode(fromNode,    node,    cfa);    	compilable	  [FE]  StackOverflowError  	48	12	replace
11	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                          StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  Node  nextSibling  =  parent.getFirstChild();  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	add	Node  nextSibling  =  parent.getFirstChild();	  return    computeFollowNode(fromNode,    node,    cfa);    Node    nextSibling    =    parent.getLastChild();    return    computeFollowNode(fromNode,    node,    cfa);    	compilable	  [FE]  AssertionFailedError  	48	3	replace
12	[BUG]  [BUGGY]  Node  nextSibling  =  parent.getFirstChild();  [FE]  AssertionFailedError  [FE]                          StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  Node  nextSibling  =  parent.getFirstChild();  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	Node  nextSibling  =  parent.getFirstChild();	  return    computeFollowNode(fromNode,    node,    cfa);    Node    nextSibling    =    parent.getLastChild();    return    computeFollowNode(fromNode,    node,    cfa);    	compilable	  [FE]  AssertionFailedError  	48	3	replace
13	[BUG]  [BUGGY]  Node  nextSibling  =  cfa.getLastChild();  return  computeFollowNode(fromNode,  parent,  cfa);  [CE]  cannot  find  symbol  [FE]                            StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  Node  nextSibling  =  cfa.getLastChild();  return  computeFollowNode(fromNode,  parent,  cfa);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	Node  nextSibling  =  cfa.getLastChild();  return  computeFollowNode(fromNode,  parent,  cfa);	  return    computeFollowNode(fromNode,    node,    cfa);    Node    nextSibling    =    parent.getLastChild();    return    computeFollowNode(fromNode,    node,    cfa);    	non-compiled	[CE]  cannot  find  symbol	48	None	replace
14	[BUG]  [BUGGY]  Node  nextSibling  =  cfa.getLastChild();  return  computeFollowNode(fromNode,  node,  cfa);  [CE]  cannot  find  symbol  [FE]                              StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  Node  nextSibling  =  cfa.getLastChild();  return  computeFollowNode(fromNode,  node,  cfa);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	Node  nextSibling  =  cfa.getLastChild();  return  computeFollowNode(fromNode,  node,  cfa);	  return    computeFollowNode(fromNode,    node,    cfa);    Node    nextSibling    =    parent.getLastChild();    return    computeFollowNode(fromNode,    node,    cfa);    	non-compiled	[CE]  cannot  find  symbol	48	None	replace
15	[BUG]  [BUGGY]  nextSibling  =  nextSibling.getLastChild();  return  computeFollowNode(fromNode,  parent,  cfa);  [CE]  cannot  find  symbol  nextSibling  [FE]                                StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  nextSibling  =  nextSibling.getLastChild();  return  computeFollowNode(fromNode,  parent,  cfa);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	nextSibling  =  nextSibling.getLastChild();  return  computeFollowNode(fromNode,  parent,  cfa);	  return    computeFollowNode(fromNode,    node,    cfa);    Node    nextSibling    =    parent.getLastChild();    return    computeFollowNode(fromNode,    node,    cfa);    	non-compiled	[CE]  cannot  find  symbol  nextSibling	48	None	replace
16	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                                  StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  Node  nextSibling  =  parent.getLastChild();  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	add	Node  nextSibling  =  parent.getLastChild();	  return    computeFollowNode(fromNode,    node,    cfa);    Node    nextSibling    =    parent.getLastChild();    return    computeFollowNode(fromNode,    node,    cfa);    	compilable	  [FE]  AssertionFailedError  	48	3	replace
17	[BUG]  [BUGGY]  Node  nextSibling  =  parent.getLastChild();  [FE]  AssertionFailedError  [FE]                                  StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  Node  nextSibling  =  parent.getLastChild();  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	Node  nextSibling  =  parent.getLastChild();	  return    computeFollowNode(fromNode,    node,    cfa);    Node    nextSibling    =    parent.getLastChild();    return    computeFollowNode(fromNode,    node,    cfa);    	compilable	  [FE]  AssertionFailedError  	48	3	replace
18	[BUG]  [BUGGY]  return  computeFallThrough(cfa.createEdge(fromNode,  Branch.UNCOND,  lastJump));  [CE]  cannot  find  symbol  lastJump  [FE]                        AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFallThrough(cfa.createEdge(fromNode,  Branch.UNCOND,  lastJump));  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFallThrough(cfa.createEdge(fromNode,  Branch.UNCOND,  lastJump));	  return    computeFallThrough(cfa.createEdge(fromNode,    Branch.UNCOND,    nextSibling));    	non-compiled	[CE]  cannot  find  symbol  lastJump	66	None	replace
19	[BUG]  [BUGGY]  return  computeFallThrough(cfa.createEdge(fromNode,  Branch.UNCOND,  secondNode));  [CE]  cannot  find  symbol  secondNode  [FE]                          AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFallThrough(cfa.createEdge(fromNode,  Branch.UNCOND,  secondNode));  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFallThrough(cfa.createEdge(fromNode,  Branch.UNCOND,  secondNode));	  return    computeFallThrough(cfa.createEdge(fromNode,    Branch.UNCOND,    nextSibling));    	non-compiled	[CE]  cannot  find  symbol  secondNode	66	None	replace
20	[BUG]  [BUGGY]  return  computeFallThrough(cfa.createEdge(fromNode,  Branch.UNCOND,  endNode));  [CE]  cannot  find  symbol  endNode  [FE]                            AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFallThrough(cfa.createEdge(fromNode,  Branch.UNCOND,  endNode));  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFallThrough(cfa.createEdge(fromNode,  Branch.UNCOND,  endNode));	  return    computeFallThrough(cfa.createEdge(fromNode,    Branch.UNCOND,    nextSibling));    	non-compiled	[CE]  cannot  find  symbol  endNode	66	None	replace
21	[BUG]  [BUGGY]  return  computeFallThroughNode(fromNode,  parent,  cfa,  nodePriorities);  [CE]  non-static  variable  nodePriorities  cannot  be  referenced  from  a  static  context  [FE]                          AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFallThroughNode(fromNode,  parent,  cfa,  nodePriorities);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFallThroughNode(fromNode,  parent,  cfa,  nodePriorities);	  return    computeFallThroughNode(fromNode,    parent,    cfa,    edgeAnnotations);    	non-compiled	[CE]  non-static  variable  nodePriorities  cannot  be  referenced  from  a  static  context	34	None	replace
22	[BUG]  [BUGGY]  return  computeFallThroughNode(fromNode,  parent,  cfa,  edges);  [CE]  cannot  find  symbol  edges  [FE]                            AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFallThroughNode(fromNode,  parent,  cfa,  edges);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFallThroughNode(fromNode,  parent,  cfa,  edges);	  return    computeFallThroughNode(fromNode,    parent,    cfa,    edgeAnnotations);    	non-compiled	[CE]  cannot  find  symbol  edges	34	None	replace
23	[BUG]  [BUGGY]  return  computeFallThroughNode(fromNode,  parent,  cfa,  shouldTraverseFunctions);  [CE]  non-static  variable  shouldTraverseFunctions  cannot  be  referenced  from  a  static  context  [FE]                              AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFallThroughNode(fromNode,  parent,  cfa,  shouldTraverseFunctions);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFallThroughNode(fromNode,  parent,  cfa,  shouldTraverseFunctions);	  return    computeFallThroughNode(fromNode,    parent,    cfa,    edgeAnnotations);    	non-compiled	[CE]  non-static  variable  shouldTraverseFunctions  cannot  be  referenced  from  a  static  context	34	None	replace
24	[BUG]  [BUGGY]  return  computeFallThroughNode(fromNode,  parent,  cfa,  firstNode);  [CE]  cannot  find  symbol  firstNode  [FE]                                AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFallThroughNode(fromNode,  parent,  cfa,  firstNode);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFallThroughNode(fromNode,  parent,  cfa,  firstNode);	  return    computeFallThroughNode(fromNode,    parent,    cfa,    edgeAnnotations);    	non-compiled	[CE]  cannot  find  symbol  firstNode	34	None	replace
25	[BUG]  [BUGGY]  return  computeFallThroughNode(fromNode,  parent,  cfa,  this.edgeAnnotations);  [CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context  [FE]                                  AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFallThroughNode(fromNode,  parent,  cfa,  this.edgeAnnotations);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFallThroughNode(fromNode,  parent,  cfa,  this.edgeAnnotations);	  return    computeFallThroughNode(fromNode,    parent,    cfa,    edgeAnnotations);    	non-compiled	[CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context	34	None	replace
26	[BUG]  [BUGGY]  return  computeFallThroughNode(fromNode,  parent,  cfa,  this.shouldTraverseFunctions);  [CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context  [FE]                                    AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFallThroughNode(fromNode,  parent,  cfa,  this.shouldTraverseFunctions);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFallThroughNode(fromNode,  parent,  cfa,  this.shouldTraverseFunctions);	  return    computeFallThroughNode(fromNode,    parent,    cfa,    edgeAnnotations);    	non-compiled	[CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context	34	None	replace
27	[BUG]  [BUGGY]  return  computeFallThrough(cfa,  parent,  node,  finallyNode);  [CE]  cannot  find  symbol  finallyNode  [FE]                  AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFallThrough(cfa,  parent,  node,  finallyNode);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFallThrough(cfa,  parent,  node,  finallyNode);	  return    computeFallThrough(cfa,    parent,    node,    pn);    	non-compiled	[CE]  cannot  find  symbol  finallyNode	166	None	replace
28	[BUG]  [BUGGY]  return  computeFallThrough(cfa,  parent,  node,  firstNode);  [CE]  cannot  find  symbol  firstNode  [FE]                    AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFallThrough(cfa,  parent,  node,  firstNode);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFallThrough(cfa,  parent,  node,  firstNode);	  return    computeFallThrough(cfa,    parent,    node,    pn);    	non-compiled	[CE]  cannot  find  symbol  firstNode	166	None	replace
29	[BUG]  [BUGGY]  return  computeFallThrough(cfa,  parent,  node,  cfa);  [CE]  method  computeFallThrough  in  class  ControlFlowAnalysis  cannot  be  applied  to  given  types;  [FE]                      AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFallThrough(cfa,  parent,  node,  cfa);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFallThrough(cfa,  parent,  node,  cfa);	  return    computeFallThrough(cfa,    parent,    node,    pn);    	non-compiled	[CE]  method  computeFallThrough  in  class  ControlFlowAnalysis  cannot  be  applied  to  given  types;	166	None	replace
30	[BUG]  [BUGGY]  return  computeFallThrough(cfa,  parent,  node,  toNode);  [CE]  cannot  find  symbol  toNode  [FE]                        AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFallThrough(cfa,  parent,  node,  toNode);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFallThrough(cfa,  parent,  node,  toNode);	  return    computeFallThrough(cfa,    parent,    node,    pn);    	non-compiled	[CE]  cannot  find  symbol  toNode	166	None	replace
31	[BUG]  [BUGGY]  return  computeFallThrough(cfa,  parent,  node,  curHandler);  [CE]  cannot  find  symbol  curHandler  [FE]                          AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFallThrough(cfa,  parent,  node,  curHandler);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFallThrough(cfa,  parent,  node,  curHandler);	  return    computeFallThrough(cfa,    parent,    node,    pn);    	non-compiled	[CE]  cannot  find  symbol  curHandler	166	None	replace
32	[BUG]  [BUGGY]  return  computeFallThrough(cfa,  parent,  node,  fromNode);  [CE]  method  computeFallThrough  in  class  ControlFlowAnalysis  cannot  be  applied  to  given  types;  [FE]                            AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFallThrough(cfa,  parent,  node,  fromNode);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFallThrough(cfa,  parent,  node,  fromNode);	  return    computeFallThrough(cfa,    parent,    node,    pn);    	non-compiled	[CE]  method  computeFallThrough  in  class  ControlFlowAnalysis  cannot  be  applied  to  given  types;	166	None	replace
33	[BUG]  [BUGGY]  return  computeFallThrough(cfa,  parent,  node,  this);  [CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context  [FE]                              AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFallThrough(cfa,  parent,  node,  this);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFallThrough(cfa,  parent,  node,  this);	  return    computeFallThrough(cfa,    parent,    node,    pn);    	non-compiled	[CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context	166	None	replace
34	[BUG]  [BUGGY]  return  computeFollowNode(fromNode,  parent,  node,  cfa.cloneTree());  [CE]  cannot  find  symbol  [FE]                              AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(fromNode,  parent,  node,  cfa.cloneTree());  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFollowNode(fromNode,  parent,  node,  cfa.cloneTree());	  return    computeFollowNode(fromNode,    parent,    cfa,    node.cloneTree());    	non-compiled	[CE]  cannot  find  symbol	33	None	replace
35	[BUG]  [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  finallyNode.cloneTree());  [CE]  cannot  find  symbol  finallyNode  [FE]                                AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  finallyNode.cloneTree());  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFollowNode(fromNode,  parent,  cfa,  finallyNode.cloneTree());	  return    computeFollowNode(fromNode,    parent,    cfa,    node.cloneTree());    	non-compiled	[CE]  cannot  find  symbol  finallyNode	33	None	replace
36	[BUG]  [BUGGY]  return  computeFollowNode(fromNode,  node,  parent,  cfa.cloneTree());  [CE]  cannot  find  symbol  [FE]                                  AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(fromNode,  node,  parent,  cfa.cloneTree());  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFollowNode(fromNode,  node,  parent,  cfa.cloneTree());	  return    computeFollowNode(fromNode,    parent,    cfa,    node.cloneTree());    	non-compiled	[CE]  cannot  find  symbol	33	None	replace
37	[BUG]  [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  node.cloneTree(),  astPositionCounter);  [CE]  non-static  variable  astPositionCounter  cannot  be  referenced  from  a  static  context  [FE]                                    AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  node.cloneTree(),  astPositionCounter);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFollowNode(fromNode,  parent,  cfa,  node.cloneTree(),  astPositionCounter);	  return    computeFollowNode(fromNode,    parent,    cfa,    node.cloneTree());    	non-compiled	[CE]  non-static  variable  astPositionCounter  cannot  be  referenced  from  a  static  context	33	None	replace
38	[BUG]  [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  node.cloneTree(),  finallyNode);  [CE]  cannot  find  symbol  finallyNode  [FE]                                      AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  node.cloneTree(),  finallyNode);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFollowNode(fromNode,  parent,  cfa,  node.cloneTree(),  finallyNode);	  return    computeFollowNode(fromNode,    parent,    cfa,    node.cloneTree());    	non-compiled	[CE]  cannot  find  symbol  finallyNode	33	None	replace
39	[BUG]  [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  node.cloneTree(),  edgeAnnotations);  [CE]  non-static  variable  edgeAnnotations  cannot  be  referenced  from  a  static  context  [FE]                                        AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  node.cloneTree(),  edgeAnnotations);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFollowNode(fromNode,  parent,  cfa,  node.cloneTree(),  edgeAnnotations);	  return    computeFollowNode(fromNode,    parent,    cfa,    node.cloneTree());    	non-compiled	[CE]  non-static  variable  edgeAnnotations  cannot  be  referenced  from  a  static  context	33	None	replace
40	[BUG]  [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  nextSibling.cloneTree());  [CE]  cannot  find  symbol  nextSibling  [FE]                                          AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  nextSibling.cloneTree());  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFollowNode(fromNode,  parent,  cfa,  nextSibling.cloneTree());	  return    computeFollowNode(fromNode,    parent,    cfa,    node.cloneTree());    	non-compiled	[CE]  cannot  find  symbol  nextSibling	33	None	replace
41	[BUG]  [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  node.cloneTree(),  nextSibling);  [CE]  cannot  find  symbol  nextSibling  [FE]                                            AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  node.cloneTree(),  nextSibling);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFollowNode(fromNode,  parent,  cfa,  node.cloneTree(),  nextSibling);	  return    computeFollowNode(fromNode,    parent,    cfa,    node.cloneTree());    	non-compiled	[CE]  cannot  find  symbol  nextSibling	33	None	replace
42	[BUG]  [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  node.cloneTree(),  astPositionCount);  [CE]  cannot  find  symbol  astPositionCount  [FE]                                              AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  node.cloneTree(),  astPositionCount);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFollowNode(fromNode,  parent,  cfa,  node.cloneTree(),  astPositionCount);	  return    computeFollowNode(fromNode,    parent,    cfa,    node.cloneTree());    	non-compiled	[CE]  cannot  find  symbol  astPositionCount	33	None	replace
43	[BUG]  [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  finallyNode,  exceptionHandler);  [CE]  cannot  find  symbol  finallyNode  [FE]                        AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  finallyNode,  exceptionHandler);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFollowNode(fromNode,  parent,  cfa,  finallyNode,  exceptionHandler);	  return    computeFollowNode(fromNode,    parent,    cfa,    node,    exceptionHandler);    	non-compiled	[CE]  cannot  find  symbol  finallyNode	163	None	replace
44	[BUG]  [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  firstNode,  exceptionHandler);  [CE]  cannot  find  symbol  firstNode  [FE]                          AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  firstNode,  exceptionHandler);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFollowNode(fromNode,  parent,  cfa,  firstNode,  exceptionHandler);	  return    computeFollowNode(fromNode,    parent,    cfa,    node,    exceptionHandler);    	non-compiled	[CE]  cannot  find  symbol  firstNode	163	None	replace
45	[BUG]  [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  nodePriorities,  exceptionHandler);  [CE]  non-static  variable  nodePriorities  cannot  be  referenced  from  a  static  context  [FE]                            AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  nodePriorities,  exceptionHandler);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFollowNode(fromNode,  parent,  cfa,  nodePriorities,  exceptionHandler);	  return    computeFollowNode(fromNode,    parent,    cfa,    node,    exceptionHandler);    	non-compiled	[CE]  non-static  variable  nodePriorities  cannot  be  referenced  from  a  static  context	163	None	replace
46	[BUG]  [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  nextSibling,  exceptionHandler);  [CE]  cannot  find  symbol  nextSibling  [FE]                              AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  nextSibling,  exceptionHandler);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFollowNode(fromNode,  parent,  cfa,  nextSibling,  exceptionHandler);	  return    computeFollowNode(fromNode,    parent,    cfa,    node,    exceptionHandler);    	non-compiled	[CE]  cannot  find  symbol  nextSibling	163	None	replace
47	[BUG]  [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  endNode,  exceptionHandler);  [CE]  cannot  find  symbol  endNode  [FE]                                AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  endNode,  exceptionHandler);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFollowNode(fromNode,  parent,  cfa,  endNode,  exceptionHandler);	  return    computeFollowNode(fromNode,    parent,    cfa,    node,    exceptionHandler);    	non-compiled	[CE]  cannot  find  symbol  endNode	163	None	replace
48	[BUG]  [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  lastJump,  node);  [CE]  cannot  find  symbol  lastJump  [FE]                                  AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  lastJump,  node);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFollowNode(fromNode,  parent,  cfa,  lastJump,  node);	  return    computeFollowNode(fromNode,    parent,    cfa,    node,    exceptionHandler);    	non-compiled	[CE]  cannot  find  symbol  lastJump	163	None	replace
49	[BUG]  [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  null,  node);  [CE]  no  suitable  method  found  for  computeFollowNode(Node,Node,ControlFlowAnalysis,<null>,Node)  [FE]                                    AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(fromNode,  parent,  cfa,  null,  node);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFollowNode(fromNode,  parent,  cfa,  null,  node);	  return    computeFollowNode(fromNode,    parent,    cfa,    node,    exceptionHandler);    	non-compiled	[CE]  no  suitable  method  found  for  computeFollowNode(Node,Node,ControlFlowAnalysis,<null>,Node)	163	None	replace
50	[BUG]  [BUGGY]  return  computeFollowNode(parent,  fromNode,  cfa);  Node  parent  =  cfa.getParent();  [CE]  variable  parent  is  already  defined  in  method  computeFollowNode(Node,Node,ControlFlowAnalysis)  [FE]    AssertionFailedError    [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(parent,  fromNode,  cfa);  Node  parent  =  cfa.getParent();  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return    computeFollowNode(parent,    fromNode,    cfa);    Node  parent  =  cfa.getParent();	  	non-compiled	[CE]  variable  parent  is  already  defined  in  method  computeFollowNode(Node,Node,ControlFlowAnalysis)	87	None	add
51	[BUG]  [BUGGY]  return  computeFollowNode(parent,  fromNode,  cfa);  Node  parent  =  cfa.getParent();  return  computeFollowNode(parent,  fromNode,  cfa);  [CE]  variable  parent  is  already  defined  in  method  computeFollowNode(Node,Node,ControlFlowAnalysis)  [FE]      AssertionFailedError    [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(parent,  fromNode,  cfa);  Node  parent  =  cfa.getParent();  return  computeFollowNode(parent,  fromNode,  cfa);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return    computeFollowNode(parent,    fromNode,    cfa);    Node  parent  =  cfa.getParent();  return  computeFollowNode(parent,  fromNode,  cfa);	  	non-compiled	[CE]  variable  parent  is  already  defined  in  method  computeFollowNode(Node,Node,ControlFlowAnalysis)	87	None	add
52	[BUG]  [BUGGY]  return  computeFollowNode(parent,  fromNode,  cfa);  AssertionFailedError  <  Node>  parent  =  cfa.getParent();  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(parent,  fromNode,  cfa);  AssertionFailedError  <  Node>  parent  =  cfa.getParent();  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return    computeFollowNode(parent,    fromNode,    cfa);    AssertionFailedError  <  Node>  parent  =  cfa.getParent();	  	non-compiled	[CE]  cannot  find  symbol	87	None	add
53	[BUG]  [BUGGY]  return  computeFollowNode(parent,  fromNode,  cfa);  return  computeFollowNode(parent,  fromNode,  cfa);  [CE]  unreachable  statement  [FE]          AssertionFailedError    [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(parent,  fromNode,  cfa);  return  computeFollowNode(parent,  fromNode,  cfa);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return    computeFollowNode(parent,    fromNode,    cfa);    return  computeFollowNode(parent,  fromNode,  cfa);	  	non-compiled	[CE]  unreachable  statement	87	None	add
54	[BUG]  [BUGGY]  return  computeFollowNode(parent,  fromNode,  cfa);  Node  nextSibling  =  parent.getFirstChild();  return  computeFollowNode(fromNode,  parent,  cfa);  [CE]  unreachable  statement  [FE]            AssertionFailedError    [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(parent,  fromNode,  cfa);  Node  nextSibling  =  parent.getFirstChild();  return  computeFollowNode(fromNode,  parent,  cfa);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return    computeFollowNode(parent,    fromNode,    cfa);    Node  nextSibling  =  parent.getFirstChild();  return  computeFollowNode(fromNode,  parent,  cfa);	  	non-compiled	[CE]  unreachable  statement	87	None	add
55	[BUG]  [BUGGY]  return  computeFollowNode(parent,  fromNode,  cfa);  Node  nextSibling  =  parent.getLastChild();  return  computeFollowNode(fromNode,  parent,  cfa);  [CE]  unreachable  statement  [FE]              AssertionFailedError    [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(parent,  fromNode,  cfa);  Node  nextSibling  =  parent.getLastChild();  return  computeFollowNode(fromNode,  parent,  cfa);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return    computeFollowNode(parent,    fromNode,    cfa);    Node  nextSibling  =  parent.getLastChild();  return  computeFollowNode(fromNode,  parent,  cfa);	  	non-compiled	[CE]  unreachable  statement	87	None	add
56	[BUG]  [BUGGY]  return  computeFollowNode(parent,  fromNode,  cfa);  Node  nextSibling  =  parent.getLastChild();  return  computeFollowNode(parent,  fromNode,  cfa);  [CE]  unreachable  statement  [FE]                AssertionFailedError    [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(parent,  fromNode,  cfa);  Node  nextSibling  =  parent.getLastChild();  return  computeFollowNode(parent,  fromNode,  cfa);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return    computeFollowNode(parent,    fromNode,    cfa);    Node  nextSibling  =  parent.getLastChild();  return  computeFollowNode(parent,  fromNode,  cfa);	  	non-compiled	[CE]  unreachable  statement	87	None	add
57	[BUG]  [BUGGY]  return  computeFollowNode(parent,  fromNode,  cfa);  Node  nextSibling  =  parent.getFirstChild();  return  computeFollowNode(parent,  fromNode,  cfa);  [CE]  unreachable  statement  [FE]                  AssertionFailedError    [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(parent,  fromNode,  cfa);  Node  nextSibling  =  parent.getFirstChild();  return  computeFollowNode(parent,  fromNode,  cfa);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return    computeFollowNode(parent,    fromNode,    cfa);    Node  nextSibling  =  parent.getFirstChild();  return  computeFollowNode(parent,  fromNode,  cfa);	  	non-compiled	[CE]  unreachable  statement	87	None	add
58	[BUG]  [BUGGY]  return  computeFollowNode(parent,  fromNode,  cfa);  Node  nextSibling  =  parent.getFirstChild();  [CE]  unreachable  statement  [FE]                    AssertionFailedError    [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(parent,  fromNode,  cfa);  Node  nextSibling  =  parent.getFirstChild();  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return    computeFollowNode(parent,    fromNode,    cfa);    Node  nextSibling  =  parent.getFirstChild();	  	non-compiled	[CE]  unreachable  statement	87	None	add
59	[BUG]  [BUGGY]  return  computeFollowNode(parent,  fromNode,  cfa);  Node  parent  =  node.getParent();  [CE]  variable  parent  is  already  defined  in  method  computeFollowNode(Node,Node,ControlFlowAnalysis)  [FE]                      AssertionFailedError    [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFollowNode(parent,  fromNode,  cfa);  Node  parent  =  node.getParent();  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return    computeFollowNode(parent,    fromNode,    cfa);    Node  parent  =  node.getParent();	  	non-compiled	[CE]  variable  parent  is  already  defined  in  method  computeFollowNode(Node,Node,ControlFlowAnalysis)	87	None	add
60	[BUG]  [BUGGY]  for(Node  n  =  node.getFirstChild();  n!=  null;  n  =  n.getNext())  {  if(next.getType()  ==  Token.VAR)  {  return  computeFollowNode(fromNode,  parent,  cf  [CE]  ')'  expected  [FE]          AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  for(Node  n  =  node.getFirstChild();  n!=  null;  n  =  n.getNext())  {  if(next.getType()  ==  Token.VAR)  {  return  computeFollowNode(fromNode,  parent,  cf  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	for(Node  n  =  node.getFirstChild();  n!=  null;  n  =  n.getNext())  {  if(next.getType()  ==  Token.VAR)  {  return  computeFollowNode(fromNode,  parent,  cf	          for(Node    n    =    fromNode.getFirstChild();    n!=    null;    n    =    n.getNext())    {    if(next.getType()    ==    Token.VAR)    {    return    computeFollowNode(fromNode,    parent,    cf    	non-compiled	[CE]  ')'  expected	126	None	replace
61	[BUG]  [BUGGY]  for(Node  n  =  parent.getFirstChild();  n!=  null;  n  =  n.getNext())  {  if(next.getType()  ==  Token.VAR)  {  return  computeFollowNode(fromNode,  parent,  cf  [CE]  ')'  expected  [FE]            AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  for(Node  n  =  parent.getFirstChild();  n!=  null;  n  =  n.getNext())  {  if(next.getType()  ==  Token.VAR)  {  return  computeFollowNode(fromNode,  parent,  cf  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	for(Node  n  =  parent.getFirstChild();  n!=  null;  n  =  n.getNext())  {  if(next.getType()  ==  Token.VAR)  {  return  computeFollowNode(fromNode,  parent,  cf	          for(Node    n    =    fromNode.getFirstChild();    n!=    null;    n    =    n.getNext())    {    if(next.getType()    ==    Token.VAR)    {    return    computeFollowNode(fromNode,    parent,    cf    	non-compiled	[CE]  ')'  expected	126	None	replace
62	[BUG]  [BUGGY]  for(Node  n  =  node.getFirstChild();  n!=  null;  n  =  n.getNext())  {  if(next.getType()  ==  Token.VAR)  {  return  computeFollowNode(fromNode,  parent,  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  for(Node  n  =  node.getFirstChild();  n!=  null;  n  =  n.getNext())  {  if(next.getType()  ==  Token.VAR)  {  return  computeFollowNode(fromNode,  parent,  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	for(Node  n  =  node.getFirstChild();  n!=  null;  n  =  n.getNext())  {  if(next.getType()  ==  Token.VAR)  {  return  computeFollowNode(fromNode,  parent,	          for(Node    n    =    fromNode.getFirstChild();    n!=    null;    n    =    n.getNext())    {    if(next.getType()    ==    Token.VAR)    {    return    computeFollowNode(fromNode,    parent,    cf    	non-compiled	[CE]  illegal  start  of  expression	126	None	replace
63	[BUG]  [BUGGY]  for(Node  n  =  node.getFirstChild();  n!=  null;  n  =  n.getNext())  {  if(parent.getType()  ==  Token.VAR)  {  return  computeFollowNode(fromNode,  parent,  cf  [CE]  ')'  expected  [FE]                AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  for(Node  n  =  node.getFirstChild();  n!=  null;  n  =  n.getNext())  {  if(parent.getType()  ==  Token.VAR)  {  return  computeFollowNode(fromNode,  parent,  cf  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	for(Node  n  =  node.getFirstChild();  n!=  null;  n  =  n.getNext())  {  if(parent.getType()  ==  Token.VAR)  {  return  computeFollowNode(fromNode,  parent,  cf	          for(Node    n    =    fromNode.getFirstChild();    n!=    null;    n    =    n.getNext())    {    if(next.getType()    ==    Token.VAR)    {    return    computeFollowNode(fromNode,    parent,    cf    	non-compiled	[CE]  ')'  expected	126	None	replace
64	[BUG]  [BUGGY]  for(Node  n  =  fromNode.getFirstChild();  n!=  null;  n  =  n.getNext())  {  if(next.getType()  ==  Token.VAR)  {  return  computeFollowNode(fromNode,  parent,  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  for(Node  n  =  fromNode.getFirstChild();  n!=  null;  n  =  n.getNext())  {  if(next.getType()  ==  Token.VAR)  {  return  computeFollowNode(fromNode,  parent,  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	for(Node  n  =  fromNode.getFirstChild();  n!=  null;  n  =  n.getNext())  {  if(next.getType()  ==  Token.VAR)  {  return  computeFollowNode(fromNode,  parent,	          for(Node    n    =    fromNode.getFirstChild();    n!=    null;    n    =    n.getNext())    {    if(next.getType()    ==    Token.VAR)    {    return    computeFollowNode(fromNode,    parent,    cf    	non-compiled	[CE]  illegal  start  of  expression	126	None	replace
65	[BUG]  [BUGGY]  for(Node  n  =  node.getFirstChild();  n!=  null;  n  =  n.getNext())  {  if(next.getType()  ==  Token.FUNCTION)  {  return  computeFollowNode(fromNode,  parent,  cf  [CE]  ')'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  for(Node  n  =  node.getFirstChild();  n!=  null;  n  =  n.getNext())  {  if(next.getType()  ==  Token.FUNCTION)  {  return  computeFollowNode(fromNode,  parent,  cf  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	for(Node  n  =  node.getFirstChild();  n!=  null;  n  =  n.getNext())  {  if(next.getType()  ==  Token.FUNCTION)  {  return  computeFollowNode(fromNode,  parent,  cf	          for(Node    n    =    fromNode.getFirstChild();    n!=    null;    n    =    n.getNext())    {    if(next.getType()    ==    Token.VAR)    {    return    computeFollowNode(fromNode,    parent,    cf    	non-compiled	[CE]  ')'  expected	126	None	replace
66	[BUG]  [BUGGY]  for(Node  n  =  parent.getFirstChild();  n!=  null;  n  =  n.getNext())  {  if(next.getType()  ==  Token.VAR)  {  return  computeFollowNode(fromNode,  parent,  [CE]  illegal  start  of  expression  [FE]                      AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  for(Node  n  =  parent.getFirstChild();  n!=  null;  n  =  n.getNext())  {  if(next.getType()  ==  Token.VAR)  {  return  computeFollowNode(fromNode,  parent,  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	for(Node  n  =  parent.getFirstChild();  n!=  null;  n  =  n.getNext())  {  if(next.getType()  ==  Token.VAR)  {  return  computeFollowNode(fromNode,  parent,	          for(Node    n    =    fromNode.getFirstChild();    n!=    null;    n    =    n.getNext())    {    if(next.getType()    ==    Token.VAR)    {    return    computeFollowNode(fromNode,    parent,    cf    	non-compiled	[CE]  illegal  start  of  expression	126	None	replace
67	[BUG]  [BUGGY]  for(Node  n  =  fromNode.getLastChild();  n!=  null;  n  =  n.getNext())  {  if(next.getType()  ==  Token.VAR)  {  return  computeFollowNode(fromNode,  parent,  [CE]  illegal  start  of  expression  [FE]                        AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  for(Node  n  =  fromNode.getLastChild();  n!=  null;  n  =  n.getNext())  {  if(next.getType()  ==  Token.VAR)  {  return  computeFollowNode(fromNode,  parent,  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	for(Node  n  =  fromNode.getLastChild();  n!=  null;  n  =  n.getNext())  {  if(next.getType()  ==  Token.VAR)  {  return  computeFollowNode(fromNode,  parent,	          for(Node    n    =    fromNode.getFirstChild();    n!=    null;    n    =    n.getNext())    {    if(next.getType()    ==    Token.VAR)    {    return    computeFollowNode(fromNode,    parent,    cf    	non-compiled	[CE]  illegal  start  of  expression	126	None	replace
68	[BUG]  [BUGGY]  return  computeFilledNode(fromNode,  parent,  cfa,  edgeAnnotations);  [CE]  non-static  variable  edgeAnnotations  cannot  be  referenced  from  a  static  context  [FE]            StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFilledNode(fromNode,  parent,  cfa,  edgeAnnotations);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFilledNode(fromNode,  parent,  cfa,  edgeAnnotations);	  return    computeFilledNode(fromNode,    parent,    cfa);    	non-compiled	[CE]  non-static  variable  edgeAnnotations  cannot  be  referenced  from  a  static  context	3	None	replace
69	[BUG]  [BUGGY]  return  computeFilledNode(fromNode,  parent,  cfa,  finallyNode);  [CE]  cannot  find  symbol  finallyNode  [FE]              StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFilledNode(fromNode,  parent,  cfa,  finallyNode);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFilledNode(fromNode,  parent,  cfa,  finallyNode);	  return    computeFilledNode(fromNode,    parent,    cfa);    	non-compiled	[CE]  cannot  find  symbol  finallyNode	3	None	replace
70	[BUG]  [BUGGY]  return  computeFilledNode(fromNode,  parent,  cfa.cloneTree());  [CE]  cannot  find  symbol  [FE]                StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFilledNode(fromNode,  parent,  cfa.cloneTree());  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFilledNode(fromNode,  parent,  cfa.cloneTree());	  return    computeFilledNode(fromNode,    parent,    cfa);    	non-compiled	[CE]  cannot  find  symbol	3	None	replace
71	[BUG]  [BUGGY]  return  computeFillNode(fromNode,  parent,  cfa);  [CE]  cannot  find  symbol  [FE]                  StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFillNode(fromNode,  parent,  cfa);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFillNode(fromNode,  parent,  cfa);	  return    computeFilledNode(fromNode,    parent,    cfa);    	non-compiled	[CE]  cannot  find  symbol	3	None	replace
72	[BUG]  [BUGGY]  return  computeFallThroughNode(fromNode,  parent,  node,  cfa);  [CE]  cannot  find  symbol  [FE]                                      AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFallThroughNode(fromNode,  parent,  node,  cfa);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFallThroughNode(fromNode,  parent,  node,  cfa);	  return    computeFallThroughNode(fromNode,    parent,    node);    	non-compiled	[CE]  cannot  find  symbol	40	None	replace
73	[BUG]  [BUGGY]  return  computeFallThroughNode(fromNode,  node,  parent);  [CE]  cannot  find  symbol  [FE]                                        AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFallThroughNode(fromNode,  node,  parent);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFallThroughNode(fromNode,  node,  parent);	  return    computeFallThroughNode(fromNode,    parent,    node);    	non-compiled	[CE]  cannot  find  symbol	40	None	replace
74	[BUG]  [BUGGY]  return  computeFallThroughNode(fromNode,  cfa,  node);  [CE]  cannot  find  symbol  [FE]                                          AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFallThroughNode(fromNode,  cfa,  node);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFallThroughNode(fromNode,  cfa,  node);	  return    computeFallThroughNode(fromNode,    parent,    node);    	non-compiled	[CE]  cannot  find  symbol	40	None	replace
75	[BUG]  [BUGGY]  return  computeFallThroughNode(fromNode,  parent,  cfa.node);  [CE]  cannot  find  symbol  node  [FE]                                            AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFallThroughNode(fromNode,  parent,  cfa.node);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFallThroughNode(fromNode,  parent,  cfa.node);	  return    computeFallThroughNode(fromNode,    parent,    node);    	non-compiled	[CE]  cannot  find  symbol  node	40	None	replace
76	[BUG]  [BUGGY]  return  computeFunctionThroughNode(fromNode,  parent,  cfa);  [CE]  cannot  find  symbol  [FE]                                              AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFunctionThroughNode(fromNode,  parent,  cfa);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFunctionThroughNode(fromNode,  parent,  cfa);	  return    computeFallThroughNode(fromNode,    parent,    node);    	non-compiled	[CE]  cannot  find  symbol	40	None	replace
77	[BUG]  [BUGGY]  return  computeFallThroughNode(fromNode,  parent,  node,  edgeAnnotations);  [CE]  non-static  variable  edgeAnnotations  cannot  be  referenced  from  a  static  context  [FE]                                                AssertionFailedError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFallThroughNode(fromNode,  parent,  node,  edgeAnnotations);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFallThroughNode(fromNode,  parent,  node,  edgeAnnotations);	  return    computeFallThroughNode(fromNode,    parent,    node);    	non-compiled	[CE]  non-static  variable  edgeAnnotations  cannot  be  referenced  from  a  static  context	40	None	replace
78	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  Node  nextSibling  =  parent.getFirstChild();  if(nextSibling!=  null)  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	add	Node  nextSibling  =  parent.getFirstChild();  if(nextSibling!=  null)  {  return  computeFollowNode(fromNode,  parent,  cfa);  }	  return    computeFollowNode(fromNode,    node,    cfa);    Node    nextSibling    =    parent.getFirstChild();    if(nextSibling!=    null)    {    return    computeFollowNode(fromNode,    parent,    cfa);    }    	compilable	  [FE]  AssertionFailedError  	46	3	replace
79	[BUG]  [BUGGY]  Node  nextSibling  =  parent.getFirstChild();  if(nextSibling!=  null)  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  [FE]  AssertionFailedError  [FE]                  StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  Node  nextSibling  =  parent.getFirstChild();  if(nextSibling!=  null)  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	Node  nextSibling  =  parent.getFirstChild();  if(nextSibling!=  null)  {  return  computeFollowNode(fromNode,  parent,  cfa);  }	  return    computeFollowNode(fromNode,    node,    cfa);    Node    nextSibling    =    parent.getFirstChild();    if(nextSibling!=    null)    {    return    computeFollowNode(fromNode,    parent,    cfa);    }    	compilable	  [FE]  AssertionFailedError  	46	3	replace
80	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                    StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  Node  nextSibling  =  parent.getFirstChild();  if(nextSibling  ==  null)  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	add	Node  nextSibling  =  parent.getFirstChild();  if(nextSibling  ==  null)  {  return  computeFollowNode(fromNode,  parent,  cfa);  }	  return    computeFollowNode(fromNode,    node,    cfa);    Node    nextSibling    =    parent.getFirstChild();    if(nextSibling!=    null)    {    return    computeFollowNode(fromNode,    parent,    cfa);    }    	compilable	  [FE]  AssertionFailedError  	46	3	replace
81	[BUG]  [BUGGY]  Node  nextSibling  =  parent.getFirstChild();  if(nextSibling  ==  null)  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  [FE]  AssertionFailedError  [FE]                    StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  Node  nextSibling  =  parent.getFirstChild();  if(nextSibling  ==  null)  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	Node  nextSibling  =  parent.getFirstChild();  if(nextSibling  ==  null)  {  return  computeFollowNode(fromNode,  parent,  cfa);  }	  return    computeFollowNode(fromNode,    node,    cfa);    Node    nextSibling    =    parent.getFirstChild();    if(nextSibling!=    null)    {    return    computeFollowNode(fromNode,    parent,    cfa);    }    	compilable	  [FE]  AssertionFailedError  	46	3	replace
82	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                      StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  Node  nextSibling  =  parent.getLastChild();  if(nextSibling!=  null)  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	add	Node  nextSibling  =  parent.getLastChild();  if(nextSibling!=  null)  {  return  computeFollowNode(fromNode,  parent,  cfa);  }	  return    computeFollowNode(fromNode,    node,    cfa);    Node    nextSibling    =    parent.getFirstChild();    if(nextSibling!=    null)    {    return    computeFollowNode(fromNode,    parent,    cfa);    }    	compilable	  [FE]  AssertionFailedError  	46	3	replace
83	[BUG]  [BUGGY]  Node  nextSibling  =  parent.getLastChild();  if(nextSibling!=  null)  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  [FE]  AssertionFailedError  [FE]                      StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  Node  nextSibling  =  parent.getLastChild();  if(nextSibling!=  null)  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	Node  nextSibling  =  parent.getLastChild();  if(nextSibling!=  null)  {  return  computeFollowNode(fromNode,  parent,  cfa);  }	  return    computeFollowNode(fromNode,    node,    cfa);    Node    nextSibling    =    parent.getFirstChild();    if(nextSibling!=    null)    {    return    computeFollowNode(fromNode,    parent,    cfa);    }    	compilable	  [FE]  AssertionFailedError  	46	3	replace
84	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                        StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  Node  nextSibling  =  parent.getLastChild();  if(nextSibling  ==  null)  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	add	Node  nextSibling  =  parent.getLastChild();  if(nextSibling  ==  null)  {  return  computeFollowNode(fromNode,  parent,  cfa);  }	  return    computeFollowNode(fromNode,    node,    cfa);    Node    nextSibling    =    parent.getFirstChild();    if(nextSibling!=    null)    {    return    computeFollowNode(fromNode,    parent,    cfa);    }    	compilable	  [FE]  AssertionFailedError  	46	3	replace
85	[BUG]  [BUGGY]  Node  nextSibling  =  parent.getLastChild();  if(nextSibling  ==  null)  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  [FE]  AssertionFailedError  [FE]                        StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  Node  nextSibling  =  parent.getLastChild();  if(nextSibling  ==  null)  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	Node  nextSibling  =  parent.getLastChild();  if(nextSibling  ==  null)  {  return  computeFollowNode(fromNode,  parent,  cfa);  }	  return    computeFollowNode(fromNode,    node,    cfa);    Node    nextSibling    =    parent.getFirstChild();    if(nextSibling!=    null)    {    return    computeFollowNode(fromNode,    parent,    cfa);    }    	compilable	  [FE]  AssertionFailedError  	46	3	replace
86	[BUG]  [BUGGY]  Node  nextSibling  =  cfa.getLastChild();  [CE]  cannot  find  symbol  [FE]                          StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  Node  nextSibling  =  cfa.getLastChild();  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	Node  nextSibling  =  cfa.getLastChild();	  return    computeFollowNode(fromNode,    node,    cfa);    Node    nextSibling    =    parent.getFirstChild();    if(nextSibling!=    null)    {    return    computeFollowNode(fromNode,    parent,    cfa);    }    	non-compiled	[CE]  cannot  find  symbol	46	None	replace
87	[BUG]  [BUGGY]  return  computeFallThrough(cfa,  fromNode,  node);  [CE]  method  computeFallThrough  in  class  ControlFlowAnalysis  cannot  be  applied  to  given  types;  [FE]          StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFallThrough(cfa,  fromNode,  node);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFallThrough(cfa,  fromNode,  node);	  return    computeFallThrough(cfa,    node);    	non-compiled	[CE]  method  computeFallThrough  in  class  ControlFlowAnalysis  cannot  be  applied  to  given  types;	144	None	replace
88	[BUG]  [BUGGY]  return  computeFallThrough(fromNode,  parent,  node);  [CE]  method  computeFallThrough  in  class  ControlFlowAnalysis  cannot  be  applied  to  given  types;  [FE]            StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFallThrough(fromNode,  parent,  node);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFallThrough(fromNode,  parent,  node);	  return    computeFallThrough(cfa,    node);    	non-compiled	[CE]  method  computeFallThrough  in  class  ControlFlowAnalysis  cannot  be  applied  to  given  types;	144	None	replace
89	[BUG]  [BUGGY]  return  computeFallThrough(node,  cfa);  [CE]  method  computeFallThrough  in  class  ControlFlowAnalysis  cannot  be  applied  to  given  types;  [FE]              StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFallThrough(node,  cfa);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFallThrough(node,  cfa);	  return    computeFallThrough(cfa,    node);    	non-compiled	[CE]  method  computeFallThrough  in  class  ControlFlowAnalysis  cannot  be  applied  to  given  types;	144	None	replace
90	[BUG]  [BUGGY]  return  computeFallThrough(fromNode,  node);  [CE]  method  computeFallThrough  in  class  ControlFlowAnalysis  cannot  be  applied  to  given  types;  [FE]                StackOverflowError      [CONTEXT]      }  else  {  return  computeFollowNode(fromNode,  parent,  cfa);  }  }  else  if  (parent.getLastChild()  ==  node){  if  (cfa  !=  null)  {  for  (Node  finallyNode  :  cfa.finallyMap.get(parent))  {  cfa.createEdge(fromNode,  Branch.UNCOND,  finallyNode);  }  }      [BUGGY]  return  computeFallThrough(fromNode,  node);  [BUGGY]      }  }    Node  nextSibling  =  node.getNext();  while  (nextSibling  !=  null  &&  nextSibling.isFunction())  {  nextSibling  =  nextSibling.getNext();  [CLASS]  ControlFlowAnalysis  1  AstControlFlowGraph  1  2  [METHOD]  computeFollowNode  [RETURN_TYPE]  Node  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [VARIABLES]  Multimap  finallyMap  AbstractCompiler  compiler  ControlFlowAnalysis  cfa  boolean  edgeAnnotations  shouldTraverseFunctions  ControlFlowGraph  cfg  Node  body  child  collection  cond  cur  curHandler  deflt  elseBlock  entry  externs  finallyNode  forNode  fromNode  init  item  iter  lastJump  n  next  nextSibling  node  parent  previous  root  thenBlock  value  Map  astPosition  nodePriorities  priorities  Deque  exceptionHandler  int  astPositionCounter  priorityCounter  Comparator  priorityComparator  	projects/Closure14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java	0.5	770	770	3	replace	return  computeFallThrough(fromNode,  node);	  return    computeFallThrough(cfa,    node);    	non-compiled	[CE]  method  computeFallThrough  in  class  ControlFlowAnalysis  cannot  be  applied  to  given  types;	144	None	replace
