bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] return NodeUtil.mayHaveSideEffects(cArg)? CanInlineResult.NO : CanInlineResult.AFTER_PREPARATION; [FE] AssertionFailedError [CONTEXT] } }  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); while (cArg != null || fnParam != null) {  if (fnParam != null) { if (cArg != null) { if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { [BUGGY] return NodeUtil.mayHaveSideEffects(cArg)? CanInlineResult.NO : CanInlineResult.AFTER_PREPARATION; [BUGGY] }    if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount( block, fnParam.getString()) > 1) { return CanInlineResult.NO; } } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceDirectly [RETURN_TYPE] FunctionInjector$CanInlineResult  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set allNamesToAlias knownConstants namesToAlias needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.5	731	731	2	replace	
2	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } }  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); while (cArg != null || fnParam != null) {  if (fnParam != null) { if (cArg != null) { if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { [BUGGY] [BUGGY] return NodeUtil.mayHaveSideEffects(cArg)? CanInlineResult.NO : CanInlineResult.AFTER_PREPARATION; }    if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount( block, fnParam.getString()) > 1) { return CanInlineResult.NO; } } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceDirectly [RETURN_TYPE] FunctionInjector$CanInlineResult  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set allNamesToAlias knownConstants namesToAlias needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.5	731	731	2	add	
3	[BUG] [BUGGY] } else if (type == DecompositionType.DECOMPOSABLE) { [FE] AssertionFailedError [CONTEXT] return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT; } else { Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); if (expressionRoot != null) { ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); DecompositionType type = decomposer.canExposeExpression( callNode); if (type == DecompositionType.MOVABLE) { return CallSiteType.EXPRESSION; [BUGGY] } else if (type == DecompositionType.DECOMPOSABLE) { [BUGGY] return CallSiteType.DECOMPOSABLE_EXPRESSION; } else { Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE); } } } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] classifyCallSite [RETURN_TYPE] FunctionInjector$CallSiteType  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler DecompositionType type boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier ExpressionDecomposer decomposer int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.47140452079103173	425	425	2	replace	
4	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT; } else { Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); if (expressionRoot != null) { ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); DecompositionType type = decomposer.canExposeExpression( callNode); if (type == DecompositionType.MOVABLE) { return CallSiteType.EXPRESSION; [BUGGY] [BUGGY] } else if (type == DecompositionType.DECOMPOSABLE) { return CallSiteType.DECOMPOSABLE_EXPRESSION; } else { Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE); } } } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] classifyCallSite [RETURN_TYPE] FunctionInjector$CallSiteType  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler DecompositionType type boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier ExpressionDecomposer decomposer int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.47140452079103173	425	425	2	add	
5	[BUG] [BUGGY] return CallSiteType.DECOMPOSABLE_EXPRESSION; [FE] AssertionFailedError [CONTEXT] } else { Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); if (expressionRoot != null) { ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); DecompositionType type = decomposer.canExposeExpression( callNode); if (type == DecompositionType.MOVABLE) { return CallSiteType.EXPRESSION; } else if (type == DecompositionType.DECOMPOSABLE) { [BUGGY] return CallSiteType.DECOMPOSABLE_EXPRESSION; [BUGGY] } else { Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE); } } } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] classifyCallSite [RETURN_TYPE] FunctionInjector$CallSiteType  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler DecompositionType type boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier ExpressionDecomposer decomposer int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.47140452079103173	426	426	2	replace	
6	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } else { Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); if (expressionRoot != null) { ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); DecompositionType type = decomposer.canExposeExpression( callNode); if (type == DecompositionType.MOVABLE) { return CallSiteType.EXPRESSION; } else if (type == DecompositionType.DECOMPOSABLE) { [BUGGY] [BUGGY] return CallSiteType.DECOMPOSABLE_EXPRESSION; } else { Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE); } } } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] classifyCallSite [RETURN_TYPE] FunctionInjector$CallSiteType  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler DecompositionType type boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier ExpressionDecomposer decomposer int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.47140452079103173	426	426	2	add	
7	[BUG] [BUGGY] ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); [FE] AssertionFailedError [CONTEXT] && !NodeUtil.isConstantName(parent) && grandParent.isVar() && grandParent.hasOneChild()) {    return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT; } else { Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); if (expressionRoot != null) { [BUGGY] ExpressionDecomposer decomposer = new ExpressionDecomposer(   compiler, safeNameIdSupplier, knownConstants); [BUGGY] compiler, safeNameIdSupplier, knownConstants); DecompositionType type = decomposer.canExposeExpression( callNode); if (type == DecompositionType.MOVABLE) { return CallSiteType.EXPRESSION; } else if (type == DecompositionType.DECOMPOSABLE) { return CallSiteType.DECOMPOSABLE_EXPRESSION; } else { Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE); } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] classifyCallSite [RETURN_TYPE] FunctionInjector$CallSiteType  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler DecompositionType type boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier ExpressionDecomposer decomposer int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.3244428422615251	419	420	2	replace	
8	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] && !NodeUtil.isConstantName(parent) && grandParent.isVar() && grandParent.hasOneChild()) {    return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT; } else { Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); if (expressionRoot != null) { [BUGGY] [BUGGY] ExpressionDecomposer decomposer = new ExpressionDecomposer(   compiler, safeNameIdSupplier, knownConstants); compiler, safeNameIdSupplier, knownConstants); DecompositionType type = decomposer.canExposeExpression( callNode); if (type == DecompositionType.MOVABLE) { return CallSiteType.EXPRESSION; } else if (type == DecompositionType.DECOMPOSABLE) { return CallSiteType.DECOMPOSABLE_EXPRESSION; } else { Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE); } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] classifyCallSite [RETURN_TYPE] FunctionInjector$CallSiteType  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler DecompositionType type boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier ExpressionDecomposer decomposer int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.3244428422615251	419	420	2	add	
9	[BUG] [BUGGY] DecompositionType type = decomposer.canExposeExpression( callNode); [FE] AssertionFailedError [CONTEXT] && grandParent.hasOneChild()) {    return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT; } else { Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); if (expressionRoot != null) { ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); [BUGGY] DecompositionType type = decomposer.canExposeExpression(   callNode); [BUGGY] callNode); if (type == DecompositionType.MOVABLE) { return CallSiteType.EXPRESSION; } else if (type == DecompositionType.DECOMPOSABLE) { return CallSiteType.DECOMPOSABLE_EXPRESSION; } else { Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE); } } } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] classifyCallSite [RETURN_TYPE] FunctionInjector$CallSiteType  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler DecompositionType type boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier ExpressionDecomposer decomposer int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.3244428422615251	421	422	2	replace	
10	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] && grandParent.hasOneChild()) {    return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT; } else { Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); if (expressionRoot != null) { ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); [BUGGY] [BUGGY] DecompositionType type = decomposer.canExposeExpression(   callNode); callNode); if (type == DecompositionType.MOVABLE) { return CallSiteType.EXPRESSION; } else if (type == DecompositionType.DECOMPOSABLE) { return CallSiteType.DECOMPOSABLE_EXPRESSION; } else { Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE); } } } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] classifyCallSite [RETURN_TYPE] FunctionInjector$CallSiteType  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler DecompositionType type boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier ExpressionDecomposer decomposer int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.3244428422615251	421	422	2	add	
11	[BUG] [BUGGY] if (type == DecompositionType.MOVABLE) { [FE] AssertionFailedError [CONTEXT]   return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT; } else { Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); if (expressionRoot != null) { ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); DecompositionType type = decomposer.canExposeExpression( callNode); [BUGGY] if (type == DecompositionType.MOVABLE) { [BUGGY] return CallSiteType.EXPRESSION; } else if (type == DecompositionType.DECOMPOSABLE) { return CallSiteType.DECOMPOSABLE_EXPRESSION; } else { Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE); } } } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] classifyCallSite [RETURN_TYPE] FunctionInjector$CallSiteType  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler DecompositionType type boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier ExpressionDecomposer decomposer int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.3244428422615251	423	423	2	replace	
12	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]   return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT; } else { Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); if (expressionRoot != null) { ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); DecompositionType type = decomposer.canExposeExpression( callNode); [BUGGY] [BUGGY] if (type == DecompositionType.MOVABLE) { return CallSiteType.EXPRESSION; } else if (type == DecompositionType.DECOMPOSABLE) { return CallSiteType.DECOMPOSABLE_EXPRESSION; } else { Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE); } } } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] classifyCallSite [RETURN_TYPE] FunctionInjector$CallSiteType  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler DecompositionType type boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier ExpressionDecomposer decomposer int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.3244428422615251	423	423	2	add	
13	[BUG] [BUGGY] return CallSiteType.EXPRESSION; [FE] AssertionFailedError [CONTEXT]  return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT; } else { Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); if (expressionRoot != null) { ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); DecompositionType type = decomposer.canExposeExpression( callNode); if (type == DecompositionType.MOVABLE) { [BUGGY] return CallSiteType.EXPRESSION; [BUGGY] } else if (type == DecompositionType.DECOMPOSABLE) { return CallSiteType.DECOMPOSABLE_EXPRESSION; } else { Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE); } } } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] classifyCallSite [RETURN_TYPE] FunctionInjector$CallSiteType  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler DecompositionType type boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier ExpressionDecomposer decomposer int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.3244428422615251	424	424	2	replace	
14	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT; } else { Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); if (expressionRoot != null) { ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); DecompositionType type = decomposer.canExposeExpression( callNode); if (type == DecompositionType.MOVABLE) { [BUGGY] [BUGGY] return CallSiteType.EXPRESSION; } else if (type == DecompositionType.DECOMPOSABLE) { return CallSiteType.DECOMPOSABLE_EXPRESSION; } else { Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE); } } } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] classifyCallSite [RETURN_TYPE] FunctionInjector$CallSiteType  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler DecompositionType type boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier ExpressionDecomposer decomposer int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.3244428422615251	424	424	2	add	
15	[BUG] [BUGGY] return new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); [FE] AssertionFailedError [CONTEXT] private ExpressionDecomposer getDecomposer() { [BUGGY] return new ExpressionDecomposer(  compiler, safeNameIdSupplier, knownConstants); [BUGGY] compiler, safeNameIdSupplier, knownConstants); } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] getDecomposer [RETURN_TYPE] ExpressionDecomposer  [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.3244428422615251	437	438	2	replace	
16	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private ExpressionDecomposer getDecomposer() { [BUGGY] [BUGGY] return new ExpressionDecomposer(  compiler, safeNameIdSupplier, knownConstants); compiler, safeNameIdSupplier, knownConstants); } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] getDecomposer [RETURN_TYPE] ExpressionDecomposer  [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.3244428422615251	437	438	2	add	
17	[BUG] [BUGGY] Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); [FE] AssertionFailedError [CONTEXT] } else if (parent.isName() && !NodeUtil.isConstantName(parent) && grandParent.isVar() && grandParent.hasOneChild()) {    return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT; } else { [BUGGY] Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); [BUGGY] if (expressionRoot != null) { ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); DecompositionType type = decomposer.canExposeExpression( callNode); if (type == DecompositionType.MOVABLE) { return CallSiteType.EXPRESSION; } else if (type == DecompositionType.DECOMPOSABLE) { return CallSiteType.DECOMPOSABLE_EXPRESSION; } else { [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] classifyCallSite [RETURN_TYPE] FunctionInjector$CallSiteType  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler DecompositionType type boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier ExpressionDecomposer decomposer int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.3086066999241838	417	417	2	replace	
18	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } else if (parent.isName() && !NodeUtil.isConstantName(parent) && grandParent.isVar() && grandParent.hasOneChild()) {    return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT; } else { [BUGGY] [BUGGY] Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); if (expressionRoot != null) { ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); DecompositionType type = decomposer.canExposeExpression( callNode); if (type == DecompositionType.MOVABLE) { return CallSiteType.EXPRESSION; } else if (type == DecompositionType.DECOMPOSABLE) { return CallSiteType.DECOMPOSABLE_EXPRESSION; } else { [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] classifyCallSite [RETURN_TYPE] FunctionInjector$CallSiteType  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler DecompositionType type boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier ExpressionDecomposer decomposer int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.3086066999241838	417	417	2	add	
19	[BUG] [BUGGY] if (expressionRoot != null) { [FE] AssertionFailedError [CONTEXT] } else if (parent.isName() && !NodeUtil.isConstantName(parent) && grandParent.isVar() && grandParent.hasOneChild()) {    return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT; } else { Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); [BUGGY] if (expressionRoot != null) { [BUGGY] ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); DecompositionType type = decomposer.canExposeExpression( callNode); if (type == DecompositionType.MOVABLE) { return CallSiteType.EXPRESSION; } else if (type == DecompositionType.DECOMPOSABLE) { return CallSiteType.DECOMPOSABLE_EXPRESSION; } else { Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE); [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] classifyCallSite [RETURN_TYPE] FunctionInjector$CallSiteType  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler DecompositionType type boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier ExpressionDecomposer decomposer int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.3086066999241838	418	418	2	replace	
20	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } else if (parent.isName() && !NodeUtil.isConstantName(parent) && grandParent.isVar() && grandParent.hasOneChild()) {    return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT; } else { Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); [BUGGY] [BUGGY] if (expressionRoot != null) { ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); DecompositionType type = decomposer.canExposeExpression( callNode); if (type == DecompositionType.MOVABLE) { return CallSiteType.EXPRESSION; } else if (type == DecompositionType.DECOMPOSABLE) { return CallSiteType.DECOMPOSABLE_EXPRESSION; } else { Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE); [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] classifyCallSite [RETURN_TYPE] FunctionInjector$CallSiteType  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler DecompositionType type boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier ExpressionDecomposer decomposer int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.3086066999241838	418	418	2	add	
21	[BUG] [BUGGY] CallSiteType callSiteType = classifyCallSite(callNode); [FE] AssertionFailedError [CONTEXT] void maybePrepareCall(Node callNode) { [BUGGY] CallSiteType callSiteType = classifyCallSite(callNode); [BUGGY] callSiteType.prepare(this, callNode); } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] maybePrepareCall [RETURN_TYPE] void  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.30151134457776363	446	446	2	replace	
22	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] void maybePrepareCall(Node callNode) { [BUGGY] [BUGGY] CallSiteType callSiteType = classifyCallSite(callNode); callSiteType.prepare(this, callNode); } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] maybePrepareCall [RETURN_TYPE] void  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.30151134457776363	446	446	2	add	
23	[BUG] [BUGGY] callSiteType.prepare(this, callNode); [FE] AssertionFailedError [CONTEXT] void maybePrepareCall(Node callNode) { CallSiteType callSiteType = classifyCallSite(callNode); [BUGGY] callSiteType.prepare(this, callNode); [BUGGY] } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] maybePrepareCall [RETURN_TYPE] void  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.30151134457776363	447	447	2	replace	
24	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] void maybePrepareCall(Node callNode) { CallSiteType callSiteType = classifyCallSite(callNode); [BUGGY] [BUGGY] callSiteType.prepare(this, callNode); } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] maybePrepareCall [RETURN_TYPE] void  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.30151134457776363	447	447	2	add	
25	[BUG] [BUGGY] } [FE] AssertionFailedError [CONTEXT] void maybePrepareCall(Node callNode) { CallSiteType callSiteType = classifyCallSite(callNode); callSiteType.prepare(this, callNode); [BUGGY] } [BUGGY]  [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] maybePrepareCall [RETURN_TYPE] void  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.30151134457776363	448	448	2	replace	
26	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] void maybePrepareCall(Node callNode) { CallSiteType callSiteType = classifyCallSite(callNode); callSiteType.prepare(this, callNode); [BUGGY] [BUGGY] } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] maybePrepareCall [RETURN_TYPE] void  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.30151134457776363	448	448	2	add	
27	[BUG] [BUGGY] return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT; [FE] AssertionFailedError [CONTEXT] } else if (parent.isName() && !NodeUtil.isConstantName(parent) && grandParent.isVar() && grandParent.hasOneChild()) {    [BUGGY] return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT; [BUGGY] } else { Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); if (expressionRoot != null) { ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); DecompositionType type = decomposer.canExposeExpression( callNode); if (type == DecompositionType.MOVABLE) { return CallSiteType.EXPRESSION; } else if (type == DecompositionType.DECOMPOSABLE) { [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] classifyCallSite [RETURN_TYPE] FunctionInjector$CallSiteType  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler DecompositionType type boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier ExpressionDecomposer decomposer int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.21320071635561041	415	415	2	replace	
28	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } else if (parent.isName() && !NodeUtil.isConstantName(parent) && grandParent.isVar() && grandParent.hasOneChild()) {    [BUGGY] [BUGGY] return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT; } else { Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); if (expressionRoot != null) { ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); DecompositionType type = decomposer.canExposeExpression( callNode); if (type == DecompositionType.MOVABLE) { return CallSiteType.EXPRESSION; } else if (type == DecompositionType.DECOMPOSABLE) { [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] classifyCallSite [RETURN_TYPE] FunctionInjector$CallSiteType  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler DecompositionType type boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier ExpressionDecomposer decomposer int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.21320071635561041	415	415	2	add	
29	[BUG] [BUGGY] } else if (parent.isName() && !NodeUtil.isConstantName(parent) && grandParent.isVar() [FE] AssertionFailedError [CONTEXT]  if (NodeUtil.isExprCall(parent)) {  return CallSiteType.SIMPLE_CALL; } else if (NodeUtil.isExprAssign(grandParent) && !NodeUtil.isVarOrSimpleAssignLhs(callNode, parent) && parent.getFirstChild().isName() && !NodeUtil.isConstantName(parent.getFirstChild())) {  return CallSiteType.SIMPLE_ASSIGNMENT; [BUGGY] } else if (parent.isName()  && !NodeUtil.isConstantName(parent)    && grandParent.isVar() [BUGGY] && !NodeUtil.isConstantName(parent) && grandParent.isVar() && grandParent.hasOneChild()) {    return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT; } else { Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); if (expressionRoot != null) { [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] classifyCallSite [RETURN_TYPE] FunctionInjector$CallSiteType  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler DecompositionType type boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier ExpressionDecomposer decomposer int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.20851441405707477	408	410	2	replace	
30	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  if (NodeUtil.isExprCall(parent)) {  return CallSiteType.SIMPLE_CALL; } else if (NodeUtil.isExprAssign(grandParent) && !NodeUtil.isVarOrSimpleAssignLhs(callNode, parent) && parent.getFirstChild().isName() && !NodeUtil.isConstantName(parent.getFirstChild())) {  return CallSiteType.SIMPLE_ASSIGNMENT; [BUGGY] [BUGGY] } else if (parent.isName()  && !NodeUtil.isConstantName(parent)    && grandParent.isVar() && !NodeUtil.isConstantName(parent) && grandParent.isVar() && grandParent.hasOneChild()) {    return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT; } else { Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); if (expressionRoot != null) { [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] classifyCallSite [RETURN_TYPE] FunctionInjector$CallSiteType  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler DecompositionType type boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier ExpressionDecomposer decomposer int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.20851441405707477	408	410	2	add	
31	[BUG] [BUGGY] if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { [FE] AssertionFailedError [CONTEXT] Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode)); } }  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); while (cArg != null || fnParam != null) {  if (fnParam != null) { if (cArg != null) { [BUGGY] if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { [BUGGY] return NodeUtil.mayHaveSideEffects(cArg)? CanInlineResult.NO : CanInlineResult.AFTER_PREPARATION; }    if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount( block, fnParam.getString()) > 1) { return CanInlineResult.NO; } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceDirectly [RETURN_TYPE] FunctionInjector$CanInlineResult  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set allNamesToAlias knownConstants namesToAlias needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.20203050891044214	730	730	2	replace	
32	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode)); } }  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); while (cArg != null || fnParam != null) {  if (fnParam != null) { if (cArg != null) { [BUGGY] [BUGGY] if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return NodeUtil.mayHaveSideEffects(cArg)? CanInlineResult.NO : CanInlineResult.AFTER_PREPARATION; }    if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount( block, fnParam.getString()) > 1) { return CanInlineResult.NO; } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceDirectly [RETURN_TYPE] FunctionInjector$CanInlineResult  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set allNamesToAlias knownConstants namesToAlias needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.20203050891044214	730	730	2	add	
33	[BUG] [BUGGY] if (cArg != null) { [FE] AssertionFailedError [CONTEXT]  Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode)); } }  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); while (cArg != null || fnParam != null) {  if (fnParam != null) { [BUGGY] if (cArg != null) { [BUGGY] if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return NodeUtil.mayHaveSideEffects(cArg)? CanInlineResult.NO : CanInlineResult.AFTER_PREPARATION; }    if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount( block, fnParam.getString()) > 1) { return CanInlineResult.NO; [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceDirectly [RETURN_TYPE] FunctionInjector$CanInlineResult  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set allNamesToAlias knownConstants namesToAlias needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.19802950859533489	729	729	2	replace	
34	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode)); } }  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); while (cArg != null || fnParam != null) {  if (fnParam != null) { [BUGGY] [BUGGY] if (cArg != null) { if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return NodeUtil.mayHaveSideEffects(cArg)? CanInlineResult.NO : CanInlineResult.AFTER_PREPARATION; }    if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount( block, fnParam.getString()) > 1) { return CanInlineResult.NO; [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceDirectly [RETURN_TYPE] FunctionInjector$CanInlineResult  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set allNamesToAlias knownConstants namesToAlias needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.19802950859533489	729	729	2	add	
35	[BUG] [BUGGY] } else if (NodeUtil.isExprAssign(grandParent) && !NodeUtil.isVarOrSimpleAssignLhs(callNode, parent) && parent.getFirstChild().isName() [FE] AssertionFailedError [CONTEXT] private CallSiteType classifyCallSite(Node callNode) { Node parent = callNode.getParent(); Node grandParent = parent.getParent();  if (NodeUtil.isExprCall(parent)) {  return CallSiteType.SIMPLE_CALL; [BUGGY] } else if (NodeUtil.isExprAssign(grandParent)  && !NodeUtil.isVarOrSimpleAssignLhs(callNode, parent)    && parent.getFirstChild().isName() [BUGGY] && !NodeUtil.isVarOrSimpleAssignLhs(callNode, parent) && parent.getFirstChild().isName() && !NodeUtil.isConstantName(parent.getFirstChild())) {  return CallSiteType.SIMPLE_ASSIGNMENT; } else if (parent.isName() && !NodeUtil.isConstantName(parent) && grandParent.isVar() && grandParent.hasOneChild()) {  [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] classifyCallSite [RETURN_TYPE] FunctionInjector$CallSiteType  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler DecompositionType type boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier ExpressionDecomposer decomposer int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.19069251784911848	402	404	2	replace	
36	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private CallSiteType classifyCallSite(Node callNode) { Node parent = callNode.getParent(); Node grandParent = parent.getParent();  if (NodeUtil.isExprCall(parent)) {  return CallSiteType.SIMPLE_CALL; [BUGGY] [BUGGY] } else if (NodeUtil.isExprAssign(grandParent)  && !NodeUtil.isVarOrSimpleAssignLhs(callNode, parent)    && parent.getFirstChild().isName() && !NodeUtil.isVarOrSimpleAssignLhs(callNode, parent) && parent.getFirstChild().isName() && !NodeUtil.isConstantName(parent.getFirstChild())) {  return CallSiteType.SIMPLE_ASSIGNMENT; } else if (parent.isName() && !NodeUtil.isConstantName(parent) && grandParent.isVar() && grandParent.hasOneChild()) {  [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] classifyCallSite [RETURN_TYPE] FunctionInjector$CallSiteType  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler DecompositionType type boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier ExpressionDecomposer decomposer int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.19069251784911848	402	404	2	add	
37	[BUG] [BUGGY] if (fnParam != null) { [FE] AssertionFailedError [CONTEXT] } else {  Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode)); } }  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); while (cArg != null || fnParam != null) {  [BUGGY] if (fnParam != null) { [BUGGY] if (cArg != null) { if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return NodeUtil.mayHaveSideEffects(cArg)? CanInlineResult.NO : CanInlineResult.AFTER_PREPARATION; }    if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount( block, fnParam.getString()) > 1) { [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceDirectly [RETURN_TYPE] FunctionInjector$CanInlineResult  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set allNamesToAlias knownConstants namesToAlias needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.1796053020267749	728	728	2	replace	
38	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } else {  Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode)); } }  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); while (cArg != null || fnParam != null) {  [BUGGY] [BUGGY] if (fnParam != null) { if (cArg != null) { if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return NodeUtil.mayHaveSideEffects(cArg)? CanInlineResult.NO : CanInlineResult.AFTER_PREPARATION; }    if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount( block, fnParam.getString()) > 1) { [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceDirectly [RETURN_TYPE] FunctionInjector$CanInlineResult  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set allNamesToAlias knownConstants namesToAlias needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.1796053020267749	728	728	2	add	
39	[BUG] [BUGGY] return CanInlineResult.AFTER_PREPARATION; [FE] AssertionFailedError [CONTEXT] return CanInlineResult.NO; } if (!callMeetsBlockInliningRequirements( t, callNode, fnNode, namesToAlias)) { return CanInlineResult.NO; } if (callSiteType == CallSiteType.DECOMPOSABLE_EXPRESSION || callSiteType == CallSiteType.EXPRESSION) { [BUGGY] return CanInlineResult.AFTER_PREPARATION; [BUGGY] } else { return CanInlineResult.YES; } } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceAsStatementBlock [RETURN_TYPE] FunctionInjector$CanInlineResult  NodeTraversal t Node callNode Node fnNode String> namesToAlias [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set knownConstants namesToAlias needAliases NodeTraversal t InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.16666666666666666	599	599	2	replace	
40	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] return CanInlineResult.NO; } if (!callMeetsBlockInliningRequirements( t, callNode, fnNode, namesToAlias)) { return CanInlineResult.NO; } if (callSiteType == CallSiteType.DECOMPOSABLE_EXPRESSION || callSiteType == CallSiteType.EXPRESSION) { [BUGGY] [BUGGY] return CanInlineResult.AFTER_PREPARATION; } else { return CanInlineResult.YES; } } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceAsStatementBlock [RETURN_TYPE] FunctionInjector$CanInlineResult  NodeTraversal t Node callNode Node fnNode String> namesToAlias [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set knownConstants namesToAlias needAliases NodeTraversal t InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.16666666666666666	599	599	2	add	
41	[BUG] [BUGGY] return true; [FE] AssertionFailedError [CONTEXT] referencesUsingBlockInlining;       if (referenceCount == 1 && isRemovable && referencesUsingDirectInlining == 1) { [BUGGY] return true; [BUGGY] } int callCost = estimateCallCost(fnNode, referencesThis); int overallCallCost = callCost * referenceCount; int costDeltaDirect = inlineCostDelta( fnNode, namesToAlias, InliningMode.DIRECT); int costDeltaBlock = inlineCostDelta( fnNode, namesToAlias, InliningMode.BLOCK);  [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] inliningLowersCost [RETURN_TYPE] boolean  JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES Set allNamesToAlias knownConstants namesToAlias needAliases CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Reference ref Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue int COMMA_COST NAME_COST_ESTIMATE PAREN_COST callCost costDeltaBlock costDeltaDirect overallCallCost referenceCount referencesUsingBlockInlining referencesUsingDirectInlining JSModuleGraph moduleGraph AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis checkModules containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop isRemovable needsDefaultReturnResult referencesArguments referencesThis InliningMode BLOCK DIRECT mode JSModule fnModule module Collection refs Supplier safeNameIdSupplier  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.15713484026367722	805	805	2	replace	
42	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] referencesUsingBlockInlining;       if (referenceCount == 1 && isRemovable && referencesUsingDirectInlining == 1) { [BUGGY] [BUGGY] return true; } int callCost = estimateCallCost(fnNode, referencesThis); int overallCallCost = callCost * referenceCount; int costDeltaDirect = inlineCostDelta( fnNode, namesToAlias, InliningMode.DIRECT); int costDeltaBlock = inlineCostDelta( fnNode, namesToAlias, InliningMode.BLOCK);  [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] inliningLowersCost [RETURN_TYPE] boolean  JSModule fnModule Node fnNode Reference> refs String> namesToAlias boolean isRemovable boolean referencesThis [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES Set allNamesToAlias knownConstants namesToAlias needAliases CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Reference ref Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue int COMMA_COST NAME_COST_ESTIMATE PAREN_COST callCost costDeltaBlock costDeltaDirect overallCallCost referenceCount referencesUsingBlockInlining referencesUsingDirectInlining JSModuleGraph moduleGraph AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis checkModules containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop isRemovable needsDefaultReturnResult referencesArguments referencesThis InliningMode BLOCK DIRECT mode JSModule fnModule module Collection refs Supplier safeNameIdSupplier  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.15713484026367722	805	805	2	add	
43	[BUG] [BUGGY] Node returnNode = block.getFirstChild(); [FE] AssertionFailedError [CONTEXT] if (!block.hasChildren()) { Node srcLocation = block; newExpression = NodeUtil.newUndefinedNode(srcLocation); } else { [BUGGY] Node returnNode = block.getFirstChild(); [BUGGY] Preconditions.checkArgument(returnNode.isReturn());  Node safeReturnNode = returnNode.cloneTree(); Node inlineResult = FunctionArgumentInjector.inject( null, safeReturnNode, null, argMap); Preconditions.checkArgument(safeReturnNode == inlineResult); newExpression = safeReturnNode.removeFirstChild(); } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] inlineReturnValue [RETURN_TYPE] Node  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT Node block callNode callParentNode fnNode inlineResult n newExpression returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier Map argMap int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.15249857033260467	274	274	2	replace	
44	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (!block.hasChildren()) { Node srcLocation = block; newExpression = NodeUtil.newUndefinedNode(srcLocation); } else { [BUGGY] [BUGGY] Node returnNode = block.getFirstChild(); Preconditions.checkArgument(returnNode.isReturn());  Node safeReturnNode = returnNode.cloneTree(); Node inlineResult = FunctionArgumentInjector.inject( null, safeReturnNode, null, argMap); Preconditions.checkArgument(safeReturnNode == inlineResult); newExpression = safeReturnNode.removeFirstChild(); } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] inlineReturnValue [RETURN_TYPE] Node  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT Node block callNode callParentNode fnNode inlineResult n newExpression returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier Map argMap int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.15249857033260467	274	274	2	add	
45	[BUG] [BUGGY] Preconditions.checkArgument(returnNode.isReturn()); [FE] AssertionFailedError [CONTEXT] if (!block.hasChildren()) { Node srcLocation = block; newExpression = NodeUtil.newUndefinedNode(srcLocation); } else { Node returnNode = block.getFirstChild(); [BUGGY] Preconditions.checkArgument(returnNode.isReturn()); [BUGGY]   Node safeReturnNode = returnNode.cloneTree(); Node inlineResult = FunctionArgumentInjector.inject( null, safeReturnNode, null, argMap); Preconditions.checkArgument(safeReturnNode == inlineResult); newExpression = safeReturnNode.removeFirstChild(); } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] inlineReturnValue [RETURN_TYPE] Node  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT Node block callNode callParentNode fnNode inlineResult n newExpression returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier Map argMap int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.15249857033260467	275	275	2	replace	
46	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (!block.hasChildren()) { Node srcLocation = block; newExpression = NodeUtil.newUndefinedNode(srcLocation); } else { Node returnNode = block.getFirstChild(); [BUGGY] [BUGGY] Preconditions.checkArgument(returnNode.isReturn());  Node safeReturnNode = returnNode.cloneTree(); Node inlineResult = FunctionArgumentInjector.inject( null, safeReturnNode, null, argMap); Preconditions.checkArgument(safeReturnNode == inlineResult); newExpression = safeReturnNode.removeFirstChild(); } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] inlineReturnValue [RETURN_TYPE] Node  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT Node block callNode callParentNode fnNode inlineResult n newExpression returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier Map argMap int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.15249857033260467	275	275	2	add	
47	[BUG] [BUGGY] Node safeReturnNode = returnNode.cloneTree(); [FE] AssertionFailedError [CONTEXT] if (!block.hasChildren()) { Node srcLocation = block; newExpression = NodeUtil.newUndefinedNode(srcLocation); } else { Node returnNode = block.getFirstChild(); Preconditions.checkArgument(returnNode.isReturn());  [BUGGY] Node safeReturnNode = returnNode.cloneTree(); [BUGGY] Node inlineResult = FunctionArgumentInjector.inject( null, safeReturnNode, null, argMap); Preconditions.checkArgument(safeReturnNode == inlineResult); newExpression = safeReturnNode.removeFirstChild(); } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] inlineReturnValue [RETURN_TYPE] Node  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT Node block callNode callParentNode fnNode inlineResult n newExpression returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier Map argMap int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.15249857033260467	278	278	2	replace	
48	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (!block.hasChildren()) { Node srcLocation = block; newExpression = NodeUtil.newUndefinedNode(srcLocation); } else { Node returnNode = block.getFirstChild(); Preconditions.checkArgument(returnNode.isReturn());  [BUGGY] [BUGGY] Node safeReturnNode = returnNode.cloneTree(); Node inlineResult = FunctionArgumentInjector.inject( null, safeReturnNode, null, argMap); Preconditions.checkArgument(safeReturnNode == inlineResult); newExpression = safeReturnNode.removeFirstChild(); } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] inlineReturnValue [RETURN_TYPE] Node  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT Node block callNode callParentNode fnNode inlineResult n newExpression returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier Map argMap int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.15249857033260467	278	278	2	add	
49	[BUG] [BUGGY] Node inlineResult = FunctionArgumentInjector.inject( null, safeReturnNode, null, argMap); [FE] AssertionFailedError [CONTEXT] if (!block.hasChildren()) { Node srcLocation = block; newExpression = NodeUtil.newUndefinedNode(srcLocation); } else { Node returnNode = block.getFirstChild(); Preconditions.checkArgument(returnNode.isReturn());  Node safeReturnNode = returnNode.cloneTree(); [BUGGY] Node inlineResult = FunctionArgumentInjector.inject(   null, safeReturnNode, null, argMap); [BUGGY] null, safeReturnNode, null, argMap); Preconditions.checkArgument(safeReturnNode == inlineResult); newExpression = safeReturnNode.removeFirstChild(); } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] inlineReturnValue [RETURN_TYPE] Node  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT Node block callNode callParentNode fnNode inlineResult n newExpression returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier Map argMap int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.15249857033260467	279	280	2	replace	
50	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (!block.hasChildren()) { Node srcLocation = block; newExpression = NodeUtil.newUndefinedNode(srcLocation); } else { Node returnNode = block.getFirstChild(); Preconditions.checkArgument(returnNode.isReturn());  Node safeReturnNode = returnNode.cloneTree(); [BUGGY] [BUGGY] Node inlineResult = FunctionArgumentInjector.inject(   null, safeReturnNode, null, argMap); null, safeReturnNode, null, argMap); Preconditions.checkArgument(safeReturnNode == inlineResult); newExpression = safeReturnNode.removeFirstChild(); } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] inlineReturnValue [RETURN_TYPE] Node  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT Node block callNode callParentNode fnNode inlineResult n newExpression returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier Map argMap int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.15249857033260467	279	280	2	add	
