bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] return CanInlineResult.NO; [FE] AssertionFailedError [CONTEXT] } }  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); while (cArg != null || fnParam != null) {  if (fnParam != null) { if (cArg != null) { if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { [BUGGY] return CanInlineResult.NO; [BUGGY] }    if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount( block, fnParam.getString()) > 1) { return CanInlineResult.NO; } } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceDirectly [RETURN_TYPE] FunctionInjector$CanInlineResult  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set allNamesToAlias knownConstants namesToAlias needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.7905694150420948	731	731	5	replace	
2	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } }  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); while (cArg != null || fnParam != null) {  if (fnParam != null) { if (cArg != null) { if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { [BUGGY] [BUGGY] return CanInlineResult.NO; }    if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount( block, fnParam.getString()) > 1) { return CanInlineResult.NO; } } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceDirectly [RETURN_TYPE] FunctionInjector$CanInlineResult  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set allNamesToAlias knownConstants namesToAlias needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.7905694150420948	731	731	5	add	
3	[BUG] [BUGGY] if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { [FE] AssertionFailedError [CONTEXT] Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode)); } }  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); while (cArg != null || fnParam != null) {  if (fnParam != null) { if (cArg != null) { [BUGGY] if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { [BUGGY] return CanInlineResult.NO; }    if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount( block, fnParam.getString()) > 1) { return CanInlineResult.NO; } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceDirectly [RETURN_TYPE] FunctionInjector$CanInlineResult  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set allNamesToAlias knownConstants namesToAlias needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.3194382824999699	730	730	5	replace	
4	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode)); } }  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); while (cArg != null || fnParam != null) {  if (fnParam != null) { if (cArg != null) { [BUGGY] [BUGGY] if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return CanInlineResult.NO; }    if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount( block, fnParam.getString()) > 1) { return CanInlineResult.NO; } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceDirectly [RETURN_TYPE] FunctionInjector$CanInlineResult  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set allNamesToAlias knownConstants namesToAlias needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.3194382824999699	730	730	5	add	
5	[BUG] [BUGGY] if (cArg != null) { [FE] AssertionFailedError [CONTEXT]  Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode)); } }  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); while (cArg != null || fnParam != null) {  if (fnParam != null) { [BUGGY] if (cArg != null) { [BUGGY] if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return CanInlineResult.NO; }    if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount( block, fnParam.getString()) > 1) { return CanInlineResult.NO; [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceDirectly [RETURN_TYPE] FunctionInjector$CanInlineResult  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set allNamesToAlias knownConstants namesToAlias needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.31311214554257477	729	729	5	replace	
6	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode)); } }  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); while (cArg != null || fnParam != null) {  if (fnParam != null) { [BUGGY] [BUGGY] if (cArg != null) { if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return CanInlineResult.NO; }    if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount( block, fnParam.getString()) > 1) { return CanInlineResult.NO; [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceDirectly [RETURN_TYPE] FunctionInjector$CanInlineResult  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set allNamesToAlias knownConstants namesToAlias needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.31311214554257477	729	729	5	add	
7	[BUG] [BUGGY] } else if (type == DecompositionType.DECOMPOSABLE) { [FE] AssertionFailedError [CONTEXT] return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT; } else { Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); if (expressionRoot != null) { ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); DecompositionType type = decomposer.canExposeExpression( callNode); if (type == DecompositionType.MOVABLE) { return CallSiteType.EXPRESSION; [BUGGY] } else if (type == DecompositionType.DECOMPOSABLE) { [BUGGY] return CallSiteType.DECOMPOSABLE_EXPRESSION; } else { Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE); } } } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] classifyCallSite [RETURN_TYPE] FunctionInjector$CallSiteType  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler DecompositionType type boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier ExpressionDecomposer decomposer int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.29814239699997197	425	425	5	replace	
8	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT; } else { Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); if (expressionRoot != null) { ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); DecompositionType type = decomposer.canExposeExpression( callNode); if (type == DecompositionType.MOVABLE) { return CallSiteType.EXPRESSION; [BUGGY] [BUGGY] } else if (type == DecompositionType.DECOMPOSABLE) { return CallSiteType.DECOMPOSABLE_EXPRESSION; } else { Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE); } } } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] classifyCallSite [RETURN_TYPE] FunctionInjector$CallSiteType  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler DecompositionType type boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier ExpressionDecomposer decomposer int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.29814239699997197	425	425	5	add	
9	[BUG] [BUGGY] return CallSiteType.DECOMPOSABLE_EXPRESSION; [FE] AssertionFailedError [CONTEXT] } else { Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); if (expressionRoot != null) { ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); DecompositionType type = decomposer.canExposeExpression( callNode); if (type == DecompositionType.MOVABLE) { return CallSiteType.EXPRESSION; } else if (type == DecompositionType.DECOMPOSABLE) { [BUGGY] return CallSiteType.DECOMPOSABLE_EXPRESSION; [BUGGY] } else { Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE); } } } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] classifyCallSite [RETURN_TYPE] FunctionInjector$CallSiteType  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler DecompositionType type boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier ExpressionDecomposer decomposer int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.29814239699997197	426	426	5	replace	
10	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } else { Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); if (expressionRoot != null) { ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); DecompositionType type = decomposer.canExposeExpression( callNode); if (type == DecompositionType.MOVABLE) { return CallSiteType.EXPRESSION; } else if (type == DecompositionType.DECOMPOSABLE) { [BUGGY] [BUGGY] return CallSiteType.DECOMPOSABLE_EXPRESSION; } else { Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE); } } } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] classifyCallSite [RETURN_TYPE] FunctionInjector$CallSiteType  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler DecompositionType type boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier ExpressionDecomposer decomposer int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.29814239699997197	426	426	5	add	
11	[BUG] [BUGGY] if (fnParam != null) { [FE] AssertionFailedError [CONTEXT] } else {  Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode)); } }  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); while (cArg != null || fnParam != null) {  [BUGGY] if (fnParam != null) { [BUGGY] if (cArg != null) { if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return CanInlineResult.NO; }    if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount( block, fnParam.getString()) > 1) { [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceDirectly [RETURN_TYPE] FunctionInjector$CanInlineResult  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set allNamesToAlias knownConstants namesToAlias needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.2839809171235324	728	728	5	replace	
12	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } else {  Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode)); } }  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); while (cArg != null || fnParam != null) {  [BUGGY] [BUGGY] if (fnParam != null) { if (cArg != null) { if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return CanInlineResult.NO; }    if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount( block, fnParam.getString()) > 1) { [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceDirectly [RETURN_TYPE] FunctionInjector$CanInlineResult  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set allNamesToAlias knownConstants namesToAlias needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.2839809171235324	728	728	5	add	
13	[BUG] [BUGGY] Preconditions.checkState(block.hasOneChild()); [FE] AssertionFailedError [CONTEXT] Node callNode, Node fnNode) { if (!isDirectCallNodeReplacementPossible(fnNode)) { return CanInlineResult.NO; } Node block = fnNode.getLastChild(); boolean hasSideEffects = false; if (block.hasChildren()) { [BUGGY] Preconditions.checkState(block.hasOneChild()); [BUGGY] Node stmt = block.getFirstChild(); if (stmt.isReturn()) { hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); } }  Node cArg = callNode.getFirstChild().getNext();    [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceDirectly [RETURN_TYPE] FunctionInjector$CanInlineResult  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set allNamesToAlias knownConstants namesToAlias needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.22473328748774737	699	699	5	replace	
14	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] Node callNode, Node fnNode) { if (!isDirectCallNodeReplacementPossible(fnNode)) { return CanInlineResult.NO; } Node block = fnNode.getLastChild(); boolean hasSideEffects = false; if (block.hasChildren()) { [BUGGY] [BUGGY] Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); if (stmt.isReturn()) { hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); } }  Node cArg = callNode.getFirstChild().getNext();    [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceDirectly [RETURN_TYPE] FunctionInjector$CanInlineResult  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set allNamesToAlias knownConstants namesToAlias needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.22473328748774737	699	699	5	add	
15	[BUG] [BUGGY] Node stmt = block.getFirstChild(); [FE] AssertionFailedError [CONTEXT] Node callNode, Node fnNode) { if (!isDirectCallNodeReplacementPossible(fnNode)) { return CanInlineResult.NO; } Node block = fnNode.getLastChild(); boolean hasSideEffects = false; if (block.hasChildren()) { Preconditions.checkState(block.hasOneChild()); [BUGGY] Node stmt = block.getFirstChild(); [BUGGY] if (stmt.isReturn()) { hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); } }  Node cArg = callNode.getFirstChild().getNext();     [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceDirectly [RETURN_TYPE] FunctionInjector$CanInlineResult  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set allNamesToAlias knownConstants namesToAlias needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.22473328748774737	700	700	5	replace	
16	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] Node callNode, Node fnNode) { if (!isDirectCallNodeReplacementPossible(fnNode)) { return CanInlineResult.NO; } Node block = fnNode.getLastChild(); boolean hasSideEffects = false; if (block.hasChildren()) { Preconditions.checkState(block.hasOneChild()); [BUGGY] [BUGGY] Node stmt = block.getFirstChild(); if (stmt.isReturn()) { hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); } }  Node cArg = callNode.getFirstChild().getNext();     [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceDirectly [RETURN_TYPE] FunctionInjector$CanInlineResult  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set allNamesToAlias knownConstants namesToAlias needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.22473328748774737	700	700	5	add	
17	[BUG] [BUGGY] if (stmt.isReturn()) { [FE] AssertionFailedError [CONTEXT] if (!isDirectCallNodeReplacementPossible(fnNode)) { return CanInlineResult.NO; } Node block = fnNode.getLastChild(); boolean hasSideEffects = false; if (block.hasChildren()) { Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); [BUGGY] if (stmt.isReturn()) { [BUGGY] hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); } }  Node cArg = callNode.getFirstChild().getNext();    if (!callNode.getFirstChild().isName()) { [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceDirectly [RETURN_TYPE] FunctionInjector$CanInlineResult  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set allNamesToAlias knownConstants namesToAlias needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.22473328748774737	701	701	5	replace	
18	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (!isDirectCallNodeReplacementPossible(fnNode)) { return CanInlineResult.NO; } Node block = fnNode.getLastChild(); boolean hasSideEffects = false; if (block.hasChildren()) { Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); [BUGGY] [BUGGY] if (stmt.isReturn()) { hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); } }  Node cArg = callNode.getFirstChild().getNext();    if (!callNode.getFirstChild().isName()) { [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceDirectly [RETURN_TYPE] FunctionInjector$CanInlineResult  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set allNamesToAlias knownConstants namesToAlias needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.22473328748774737	701	701	5	add	
19	[BUG] [BUGGY] hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); [FE] AssertionFailedError [CONTEXT] return CanInlineResult.NO; } Node block = fnNode.getLastChild(); boolean hasSideEffects = false; if (block.hasChildren()) { Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); if (stmt.isReturn()) { [BUGGY] hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); [BUGGY] } }  Node cArg = callNode.getFirstChild().getNext();    if (!callNode.getFirstChild().isName()) { if (NodeUtil.isFunctionObjectCall(callNode)) { [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceDirectly [RETURN_TYPE] FunctionInjector$CanInlineResult  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set allNamesToAlias knownConstants namesToAlias needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.22473328748774737	702	702	5	replace	
20	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] return CanInlineResult.NO; } Node block = fnNode.getLastChild(); boolean hasSideEffects = false; if (block.hasChildren()) { Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); if (stmt.isReturn()) { [BUGGY] [BUGGY] hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); } }  Node cArg = callNode.getFirstChild().getNext();    if (!callNode.getFirstChild().isName()) { if (NodeUtil.isFunctionObjectCall(callNode)) { [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceDirectly [RETURN_TYPE] FunctionInjector$CanInlineResult  Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set allNamesToAlias knownConstants namesToAlias needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.22473328748774737	702	702	5	add	
21	[BUG] [BUGGY] return new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); [FE] AssertionFailedError [CONTEXT] private ExpressionDecomposer getDecomposer() { [BUGGY] return new ExpressionDecomposer(  compiler, safeNameIdSupplier, knownConstants); [BUGGY] compiler, safeNameIdSupplier, knownConstants); } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] getDecomposer [RETURN_TYPE] ExpressionDecomposer  [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.21693045781865616	437	438	5	replace	
22	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private ExpressionDecomposer getDecomposer() { [BUGGY] [BUGGY] return new ExpressionDecomposer(  compiler, safeNameIdSupplier, knownConstants); compiler, safeNameIdSupplier, knownConstants); } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] getDecomposer [RETURN_TYPE] ExpressionDecomposer  [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.21693045781865616	437	438	5	add	
23	[BUG] [BUGGY] CallSiteType callSiteType = classifyCallSite(callNode); [FE] AssertionFailedError [CONTEXT] void maybePrepareCall(Node callNode) { [BUGGY] CallSiteType callSiteType = classifyCallSite(callNode); [BUGGY] callSiteType.prepare(this, callNode); } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] maybePrepareCall [RETURN_TYPE] void  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.21693045781865616	446	446	5	replace	
24	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] void maybePrepareCall(Node callNode) { [BUGGY] [BUGGY] CallSiteType callSiteType = classifyCallSite(callNode); callSiteType.prepare(this, callNode); } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] maybePrepareCall [RETURN_TYPE] void  Node callNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions referencesArguments referencesThis Set knownConstants needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block callNode callParentNode expressionRoot fnNode grandParent inlineResult n newExpression parent returnNode safeReturnNode srcLocation thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST  	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.21693045781865616	446	446	5	add	
25	[BUG] [BUGGY] callSiteType.prepare(this, callNode); [FE] AssertionFailedError [CONTEXT]    void maybePrepareCall(Node callNode) { CallSiteType callSiteType = classifyCallSite(callNode); [BUGGY] callSiteType.prepare(this, callNode); [BUGGY] }     [CLASS] 	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.21693045781865616	447	447	5	replace	
26	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]    void maybePrepareCall(Node callNode) { CallSiteType callSiteType = classifyCallSite(callNode); [BUGGY] [BUGGY] callSiteType.prepare(this, callNode); }     [CLASS] 	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.21693045781865616	447	447	5	add	
27	[BUG] [BUGGY] } [FE] AssertionFailedError [CONTEXT]   void maybePrepareCall(Node callNode) { CallSiteType callSiteType = classifyCallSite(callNode); callSiteType.prepare(this, callNode); [BUGGY] } [BUGGY]      [CLASS] 	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.21693045781865616	448	448	5	replace	
28	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]   void maybePrepareCall(Node callNode) { CallSiteType callSiteType = classifyCallSite(callNode); callSiteType.prepare(this, callNode); [BUGGY] [BUGGY] }      [CLASS] 	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.21693045781865616	448	448	5	add	
29	[BUG] [BUGGY] Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); [FE] AssertionFailedError [CONTEXT] Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode)); } }  [BUGGY] Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); [BUGGY] while (cArg != null || fnParam != null) {  if (fnParam != null) { if (cArg != null) { if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { [CLASS] 	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.20851441405707477	725	725	5	replace	
30	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode)); } }  [BUGGY] [BUGGY] Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); while (cArg != null || fnParam != null) {  if (fnParam != null) { if (cArg != null) { if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { [CLASS] 	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.20851441405707477	725	725	5	add	
31	[BUG] [BUGGY] while (cArg != null || fnParam != null) { [FE] AssertionFailedError [CONTEXT] } }  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); [BUGGY] while (cArg != null || fnParam != null) { [BUGGY]  if (fnParam != null) { if (cArg != null) { if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return CanInlineResult.NO; [CLASS] 	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.20851441405707477	726	726	5	replace	
32	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } }  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); [BUGGY] [BUGGY] while (cArg != null || fnParam != null) {  if (fnParam != null) { if (cArg != null) { if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return CanInlineResult.NO; [CLASS] 	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.20851441405707477	726	726	5	add	
33	[BUG] [BUGGY] ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); [FE] AssertionFailedError [CONTEXT]  return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT; } else { Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); if (expressionRoot != null) { [BUGGY] ExpressionDecomposer decomposer = new ExpressionDecomposer(   compiler, safeNameIdSupplier, knownConstants); [BUGGY] compiler, safeNameIdSupplier, knownConstants); DecompositionType type = decomposer.canExposeExpression( callNode); if (type == DecompositionType.MOVABLE) { return CallSiteType.EXPRESSION; [CLASS] 	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.20519567041703082	419	420	5	replace	
34	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT; } else { Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); if (expressionRoot != null) { [BUGGY] [BUGGY] ExpressionDecomposer decomposer = new ExpressionDecomposer(   compiler, safeNameIdSupplier, knownConstants); compiler, safeNameIdSupplier, knownConstants); DecompositionType type = decomposer.canExposeExpression( callNode); if (type == DecompositionType.MOVABLE) { return CallSiteType.EXPRESSION; [CLASS] 	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.20519567041703082	419	420	5	add	
35	[BUG] [BUGGY] DecompositionType type = decomposer.canExposeExpression( callNode); [FE] AssertionFailedError [CONTEXT] } else { Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); if (expressionRoot != null) { ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); [BUGGY] DecompositionType type = decomposer.canExposeExpression(   callNode); [BUGGY] callNode); if (type == DecompositionType.MOVABLE) { return CallSiteType.EXPRESSION; } else if (type == DecompositionType.DECOMPOSABLE) { return CallSiteType.DECOMPOSABLE_EXPRESSION; [CLASS] 	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.20519567041703082	421	422	5	replace	
36	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } else { Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); if (expressionRoot != null) { ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); [BUGGY] [BUGGY] DecompositionType type = decomposer.canExposeExpression(   callNode); callNode); if (type == DecompositionType.MOVABLE) { return CallSiteType.EXPRESSION; } else if (type == DecompositionType.DECOMPOSABLE) { return CallSiteType.DECOMPOSABLE_EXPRESSION; [CLASS] 	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.20519567041703082	421	422	5	add	
37	[BUG] [BUGGY] if (type == DecompositionType.MOVABLE) { [FE] AssertionFailedError [CONTEXT] if (expressionRoot != null) { ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); DecompositionType type = decomposer.canExposeExpression( callNode); [BUGGY] if (type == DecompositionType.MOVABLE) { [BUGGY] return CallSiteType.EXPRESSION; } else if (type == DecompositionType.DECOMPOSABLE) { return CallSiteType.DECOMPOSABLE_EXPRESSION; } else { Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE); [CLASS] 	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.20519567041703082	423	423	5	replace	
38	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (expressionRoot != null) { ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); DecompositionType type = decomposer.canExposeExpression( callNode); [BUGGY] [BUGGY] if (type == DecompositionType.MOVABLE) { return CallSiteType.EXPRESSION; } else if (type == DecompositionType.DECOMPOSABLE) { return CallSiteType.DECOMPOSABLE_EXPRESSION; } else { Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE); [CLASS] 	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.20519567041703082	423	423	5	add	
39	[BUG] [BUGGY] return CallSiteType.EXPRESSION; [FE] AssertionFailedError [CONTEXT] ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); DecompositionType type = decomposer.canExposeExpression( callNode); if (type == DecompositionType.MOVABLE) { [BUGGY] return CallSiteType.EXPRESSION; [BUGGY] } else if (type == DecompositionType.DECOMPOSABLE) { return CallSiteType.DECOMPOSABLE_EXPRESSION; } else { Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE); } [CLASS] 	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.20519567041703082	424	424	5	replace	
40	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, safeNameIdSupplier, knownConstants); DecompositionType type = decomposer.canExposeExpression( callNode); if (type == DecompositionType.MOVABLE) { [BUGGY] [BUGGY] return CallSiteType.EXPRESSION; } else if (type == DecompositionType.DECOMPOSABLE) { return CallSiteType.DECOMPOSABLE_EXPRESSION; } else { Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE); } [CLASS] 	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.20519567041703082	424	424	5	add	
41	[BUG] [BUGGY] return CanInlineResult.AFTER_PREPARATION; [FE] AssertionFailedError [CONTEXT] return CanInlineResult.NO; } if (callSiteType == CallSiteType.DECOMPOSABLE_EXPRESSION || callSiteType == CallSiteType.EXPRESSION) { [BUGGY] return CanInlineResult.AFTER_PREPARATION; [BUGGY] } else { return CanInlineResult.YES; } }  [CLASS] 	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.20519567041703082	599	599	5	replace	
42	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] return CanInlineResult.NO; } if (callSiteType == CallSiteType.DECOMPOSABLE_EXPRESSION || callSiteType == CallSiteType.EXPRESSION) { [BUGGY] [BUGGY] return CanInlineResult.AFTER_PREPARATION; } else { return CanInlineResult.YES; } }  [CLASS] 	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.20519567041703082	599	599	5	add	
43	[BUG] [BUGGY] return canInlineReferenceDirectly(callNode, fnNode); [FE] AssertionFailedError [CONTEXT]  return CanInlineResult.NO; } if (mode == InliningMode.DIRECT) { [BUGGY] return canInlineReferenceDirectly(callNode, fnNode); [BUGGY] } else { return canInlineReferenceAsStatementBlock( t, callNode, fnNode, needAliases); } } [CLASS] 	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.20498001542269695	208	208	5	replace	
44	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  return CanInlineResult.NO; } if (mode == InliningMode.DIRECT) { [BUGGY] [BUGGY] return canInlineReferenceDirectly(callNode, fnNode); } else { return canInlineReferenceAsStatementBlock( t, callNode, fnNode, needAliases); } } [CLASS] 	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.20498001542269695	208	208	5	add	
45	[BUG] [BUGGY] if (!isDirectCallNodeReplacementPossible(fnNode)) { [FE] AssertionFailedError [CONTEXT]    private CanInlineResult canInlineReferenceDirectly( Node callNode, Node fnNode) { [BUGGY] if (!isDirectCallNodeReplacementPossible(fnNode)) { [BUGGY] return CanInlineResult.NO; } Node block = fnNode.getLastChild();  [CLASS] 	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.20498001542269695	691	691	5	replace	
46	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]    private CanInlineResult canInlineReferenceDirectly( Node callNode, Node fnNode) { [BUGGY] [BUGGY] if (!isDirectCallNodeReplacementPossible(fnNode)) { return CanInlineResult.NO; } Node block = fnNode.getLastChild();  [CLASS] 	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.20498001542269695	691	691	5	add	
47	[BUG] [BUGGY] Node block = fnNode.getLastChild(); [FE] AssertionFailedError [CONTEXT] Node callNode, Node fnNode) { if (!isDirectCallNodeReplacementPossible(fnNode)) { return CanInlineResult.NO; } [BUGGY] Node block = fnNode.getLastChild(); [BUGGY]  boolean hasSideEffects = false; if (block.hasChildren()) { Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); [CLASS] 	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.20498001542269695	695	695	5	replace	
48	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] Node callNode, Node fnNode) { if (!isDirectCallNodeReplacementPossible(fnNode)) { return CanInlineResult.NO; } [BUGGY] [BUGGY] Node block = fnNode.getLastChild(); boolean hasSideEffects = false; if (block.hasChildren()) { Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); [CLASS] 	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.20498001542269695	695	695	5	add	
49	[BUG] [BUGGY] boolean hasSideEffects = false; [FE] AssertionFailedError [CONTEXT] return CanInlineResult.NO; } Node block = fnNode.getLastChild(); [BUGGY] boolean hasSideEffects = false; [BUGGY] if (block.hasChildren()) { Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); if (stmt.isReturn()) { hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); [CLASS] 	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.20498001542269695	697	697	5	replace	
50	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] return CanInlineResult.NO; } Node block = fnNode.getLastChild(); [BUGGY] [BUGGY] boolean hasSideEffects = false; if (block.hasChildren()) { Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); if (stmt.isReturn()) { hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); [CLASS] 	projects/Closure115/src/com/google/javascript/jscomp/FunctionInjector.java	0.20498001542269695	697	697	5	add	
