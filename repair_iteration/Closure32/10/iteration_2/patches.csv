bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  if(token  ==  null  ||  token.length()  ==  0)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  null  ||  token.length()  ==  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  null  ||  token.length()  ==  0)  {	  if(token    ==    null)    {    	non-compiled	[CE]  	26	None	replace
2	[BUG]  [BUGGY]  if(buffer.length()  >  0)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(buffer.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(buffer.length()  >  0)  {	  if(buffer.length()    ==    0)    {    	non-compiled	[CE]  	34	None	replace
3	[BUG]  [BUGGY]  if(buffer.length()  ==  0  ||  buffer.charAt(buffer.length()  -  1)!='')  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(buffer.length()  ==  0  ||  buffer.charAt(buffer.length()  -  1)!='')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(buffer.length()  ==  0  ||  buffer.charAt(buffer.length()  -  1)!='')  {	  if(buffer.length()    ==    0)    {    	non-compiled	[CE]  	34	None	replace
4	[BUG]  [BUGGY]  if(buffer.length()  <=  0)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(buffer.length()  <=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(buffer.length()  <=  0)  {	  if(buffer.length()    ==    0)    {    	non-compiled	[CE]  	34	None	replace
5	[BUG]  [BUGGY]  if(buffer.length()  ==  0  ||  buffer.charAt(buffer.length()  -  1)!=  'n')  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(buffer.length()  ==  0  ||  buffer.charAt(buffer.length()  -  1)!=  'n')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(buffer.length()  ==  0  ||  buffer.charAt(buffer.length()  -  1)!=  'n')  {	  if(buffer.length()    ==    0)    {    	non-compiled	[CE]  	34	None	replace
6	[BUG]  [BUGGY]  if(buffer.length()  ==  0  ||  token.charAt(buffer.length()  -  1)!='')  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(buffer.length()  ==  0  ||  token.charAt(buffer.length()  -  1)!='')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(buffer.length()  ==  0  ||  token.charAt(buffer.length()  -  1)!='')  {	  if(buffer.length()    ==    0)    {    	non-compiled	[CE]  	34	None	replace
7	[BUG]  [BUGGY]  if(token.length()  >  0)  {  [CE]  [FE]            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token.length()  >  0)  {	  if(token.length()    ==    0)    {    	non-compiled	[CE]  	33	None	replace
8	[BUG]  [BUGGY]  if(token.length()  ==  0  ||  token.charAt(token.length()  -  1)!='')  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token.length()  ==  0  ||  token.charAt(token.length()  -  1)!='')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token.length()  ==  0  ||  token.charAt(token.length()  -  1)!='')  {	  if(token.length()    ==    0)    {    	non-compiled	[CE]  	33	None	replace
9	[BUG]  [BUGGY]  if(token.length()  <=  0)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token.length()  <=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token.length()  <=  0)  {	  if(token.length()    ==    0)    {    	non-compiled	[CE]  	33	None	replace
10	[BUG]  [BUGGY]  if(token  ==  null  ||  toString(token)!=  null)  {  [CE]  [FE]            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  null  ||  toString(token)!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  null  ||  toString(token)!=  null)  {	  if(line    ==    null    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	22	None	replace
11	[BUG]  [BUGGY]  if(line  ==  null  &&  toString(token)!=  null)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  ==  null  &&  toString(token)!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  ==  null  &&  toString(token)!=  null)  {	  if(line    ==    null    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	22	None	replace
12	[BUG]  [BUGGY]  if(token  ==  JsDocToken.VALUE_NULL  ||  token!=  JsDocToken.VALUE_NULL)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  JsDocToken.VALUE_NULL  ||  token!=  JsDocToken.VALUE_NULL)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  JsDocToken.VALUE_NULL  ||  token!=  JsDocToken.VALUE_NULL)  {	  if(line    ==    null    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	22	None	replace
13	[BUG]  [BUGGY]  if(token  ==  JsDocToken.START_OBJECT  ||  token!=  JsDocToken.END_OBJECT)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  JsDocToken.START_OBJECT  ||  token!=  JsDocToken.END_OBJECT)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  JsDocToken.START_OBJECT  ||  token!=  JsDocToken.END_OBJECT)  {	  if(line    ==    null    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	22	None	replace
14	[BUG]  [BUGGY]  if(token  ==  JsDocToken.FIELD_NAME)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  JsDocToken.FIELD_NAME)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  JsDocToken.FIELD_NAME)  {	  if(line    ==    null    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	22	None	replace
15	[BUG]  [BUGGY]  if(token  ==  JsDocToken.FIELD_NAME  ||  token!=  JsDocToken.FIELD_NAME)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  JsDocToken.FIELD_NAME  ||  token!=  JsDocToken.FIELD_NAME)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  JsDocToken.FIELD_NAME  ||  token!=  JsDocToken.FIELD_NAME)  {	  if(line    ==    null    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	22	None	replace
16	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText(toString(token)))  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText(toString(token)))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder.markText(toString(token)))  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.markText(token))    {    	non-compiled	[CE]  	8	None	replace
17	[BUG]  [BUGGY]  if(jsdocBuilder  ==  null  &&  jsdocBuilder.markText(token))  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder  ==  null  &&  jsdocBuilder.markText(token))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder  ==  null  &&  jsdocBuilder.markText(token))  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.markText(token))    {    	non-compiled	[CE]  	8	None	replace
18	[BUG]  [BUGGY]  if(token!=  null  &&  jsdocBuilder.markText(token))  {  [CE]  [FE]                            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  jsdocBuilder.markText(token))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  jsdocBuilder.markText(token))  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.markText(token))    {    	non-compiled	[CE]  	8	None	replace
19	[BUG]  [BUGGY]  if(jsdocBuilder  ==  null  &&  jsdocBuilder.markText(toString(token)))  {  [CE]  [FE]                              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder  ==  null  &&  jsdocBuilder.markText(toString(token)))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder  ==  null  &&  jsdocBuilder.markText(toString(token)))  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.markText(token))    {    	non-compiled	[CE]  	8	None	replace
20	[BUG]  [BUGGY]  if(jsDocBuilder!=  null  &&  jsdocBuilder.markText(token))  {  [CE]  [FE]                                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsDocBuilder!=  null  &&  jsdocBuilder.markText(token))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsDocBuilder!=  null  &&  jsdocBuilder.markText(token))  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.markText(token))    {    	non-compiled	[CE]  	8	None	replace
21	[BUG]  [BUGGY]  if(line  ==  null  &&  line.length()  >  0)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  ==  null  &&  line.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  ==  null  &&  line.length()  >  0)  {	  if(line!=    null    ||    line.length()    >    0)    {    	non-compiled	[CE]  	17	None	replace
22	[BUG]  [BUGGY]  if(line!=  null  ||  line.length()  ==  0)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  null  ||  line.length()  ==  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  null  ||  line.length()  ==  0)  {	  if(line!=    null    ||    line.length()    >    0)    {    	non-compiled	[CE]  	17	None	replace
23	[BUG]  [BUGGY]  if(line  ==  null  ||  line.length()!=  0)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  ==  null  ||  line.length()!=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  ==  null  ||  line.length()!=  0)  {	  if(line!=    null    ||    line.length()    >    0)    {    	non-compiled	[CE]  	17	None	replace
24	[BUG]  [BUGGY]  if(line  ==  null  ||  line.length()  ==  0)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  ==  null  ||  line.length()  ==  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  ==  null  ||  line.length()  ==  0)  {	  if(line!=    null    ||    line.length()    >    0)    {    	non-compiled	[CE]  	17	None	replace
25	[BUG]  [BUGGY]  if(line  ==  null  ||  line.length()  <=  0)  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  ==  null  ||  line.length()  <=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  ==  null  ||  line.length()  <=  0)  {	  if(line!=    null    ||    line.length()    >    0)    {    	non-compiled	[CE]  	17	None	replace
26	[BUG]  [BUGGY]  if(builder!=  null  ||  builder.length()  ==  0)  {  [CE]  [FE]            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder!=  null  ||  builder.length()  ==  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder!=  null  ||  builder.length()  ==  0)  {	  if(builder!=    null    ||    builder.length()    >    0)    {    	non-compiled	[CE]  	48	None	replace
27	[BUG]  [BUGGY]  if(builder  ==  null  ||  builder.length()  >  0)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder  ==  null  ||  builder.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder  ==  null  ||  builder.length()  >  0)  {	  if(builder!=    null    ||    builder.length()    >    0)    {    	non-compiled	[CE]  	48	None	replace
28	[BUG]  [BUGGY]  if(builder!=  null  ||  builder.length()  <=  0)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder!=  null  ||  builder.length()  <=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder!=  null  ||  builder.length()  <=  0)  {	  if(builder!=    null    ||    builder.length()    >    0)    {    	non-compiled	[CE]  	48	None	replace
29	[BUG]  [BUGGY]  if(builder  ==  null  ||  builder.length()  <=  0)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder  ==  null  ||  builder.length()  <=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder  ==  null  ||  builder.length()  <=  0)  {	  if(builder!=    null    ||    builder.length()    >    0)    {    	non-compiled	[CE]  	48	None	replace
30	[BUG]  [BUGGY]  if(builder.length()  <=  0  ||  toString(token)!=  null)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder.length()  <=  0  ||  toString(token)!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder.length()  <=  0  ||  toString(token)!=  null)  {	  if(builder.length()    <=    0)    {    	non-compiled	[CE]  	32	None	replace
31	[BUG]  [BUGGY]  if(token!=  null  &&  token!=  JsDocToken.VALUE_NULL)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token!=  JsDocToken.VALUE_NULL)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token!=  JsDocToken.VALUE_NULL)  {	  if(line!=    null    &&    token!=    JsDocToken.VALUE_NULL)    {    	non-compiled	[CE]  	78	None	replace
32	[BUG]  [BUGGY]  if(token!=  JsDocToken.VALUE_NULL  ||  token!=  JsDocToken.VALUE_NULL)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.VALUE_NULL  ||  token!=  JsDocToken.VALUE_NULL)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.VALUE_NULL  ||  token!=  JsDocToken.VALUE_NULL)  {	  if(line!=    null    &&    token!=    JsDocToken.VALUE_NULL)    {    	non-compiled	[CE]  	78	None	replace
33	[BUG]  [BUGGY]  if(token!=  JsDocToken.VALUE_NUMBER_INT  ||  token!=  JsDocToken.VALUE_NULL)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.VALUE_NUMBER_INT  ||  token!=  JsDocToken.VALUE_NULL)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.VALUE_NUMBER_INT  ||  token!=  JsDocToken.VALUE_NULL)  {	  if(line!=    null    &&    token!=    JsDocToken.VALUE_NULL)    {    	non-compiled	[CE]  	78	None	replace
34	[BUG]  [BUGGY]  if(line  ==  null  &&  token!=  JsDocToken.VALUE_NULL)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  ==  null  &&  token!=  JsDocToken.VALUE_NULL)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  ==  null  &&  token!=  JsDocToken.VALUE_NULL)  {	  if(line!=    null    &&    token!=    JsDocToken.VALUE_NULL)    {    	non-compiled	[CE]  	78	None	replace
35	[BUG]  [BUGGY]  if(token!=  null  ||  token.length()!=  0)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  ||  token.length()!=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  ||  token.length()!=  0)  {	  if(token.length()!=    0)    {    	non-compiled	[CE]  	31	None	replace
36	[BUG]  [BUGGY]  if(token.length()  >=  0)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token.length()  >=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token.length()  >=  0)  {	  if(token.length()!=    0)    {    	non-compiled	[CE]  	31	None	replace
37	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  endLineno,  startCharno,  endCharno);  [CE]  [FE]                                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  endLineno,  startCharno,  endCharno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  endLineno,  startCharno,  endCharno);	  jsdocBuilder.markText(token,    line,    startLineno,    endCharno);    	non-compiled	[CE]  	14	None	replace
38	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  endCharno,  startLineno,  endCharno);  [CE]  [FE]                                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  endCharno,  startLineno,  endCharno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  endCharno,  startLineno,  endCharno);	  jsdocBuilder.markText(token,    line,    startLineno,    endCharno);    	non-compiled	[CE]  	14	None	replace
39	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  line,  endCharno,  startLineno);  [CE]  [FE]                                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  line,  endCharno,  startLineno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  line,  endCharno,  startLineno);	  jsdocBuilder.markText(token,    line,    startLineno,    endCharno);    	non-compiled	[CE]  	14	None	replace
40	[BUG]  [BUGGY]  if(endCharno!=  startLineno)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endCharno!=  startLineno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endCharno!=  startLineno)  {	  if(startLineno!=    endCharno)    {    	non-compiled	[CE]  	43	None	replace
41	[BUG]  [BUGGY]  jsdocBuilder.appendText(token);  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.appendText(token);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.appendText(token);	  jsdocBuilder.markText(token);    	non-compiled	[CE]  	10	None	replace
42	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  startLineno,  endCharno);  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  startLineno,  endCharno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  startLineno,  endCharno);	  jsdocBuilder.markText(token);    	non-compiled	[CE]  	10	None	replace
43	[BUG]  [BUGGY]  jsdocBuilder.append('  ');  [CE]  [FE]                            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.append('  ');  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.append('  ');	  jsdocBuilder.markText(token);    	non-compiled	[CE]  	10	None	replace
44	[BUG]  [BUGGY]  jsdocBuilder.appendText(toString(token));  [CE]  [FE]                              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.appendText(toString(token));  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.appendText(toString(token));	  jsdocBuilder.markText(token);    	non-compiled	[CE]  	10	None	replace
45	[BUG]  [BUGGY]  jsdocBuilder.append(token);  [CE]  [FE]                                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.append(token);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.append(token);	  jsdocBuilder.markText(token);    	non-compiled	[CE]  	10	None	replace
46	[BUG]  [BUGGY]  if(builder!=  null  ||  builder.length()  >=  0)  {  [CE]  [FE]            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder!=  null  ||  builder.length()  >=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder!=  null  ||  builder.length()  >=  0)  {	  if(builder!=    null    &&    builder.length()    >=    0)    {    	non-compiled	[CE]  	72	None	replace
47	[BUG]  [BUGGY]  if(builder!=  null  &&  token.length()  >  0)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder!=  null  &&  token.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder!=  null  &&  token.length()  >  0)  {	  if(token!=    null    &&    builder.length()    >    0)    {    	non-compiled	[CE]  	52	None	replace
48	[BUG]  [BUGGY]  if(token!=  null  ||  token.length()  >  0)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  ||  token.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  ||  token.length()  >  0)  {	  if(token!=    null    &&    builder.length()    >    0)    {    	non-compiled	[CE]  	52	None	replace
49	[BUG]  [BUGGY]  if(token!=  null  ||  builder.length()  >  0)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  ||  builder.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  ||  builder.length()  >  0)  {	  if(token!=    null    &&    builder.length()    >    0)    {    	non-compiled	[CE]  	52	None	replace
50	[BUG]  [BUGGY]  if(token!=  null  &&  builder.length()  ==  0)  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  builder.length()  ==  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  builder.length()  ==  0)  {	  if(token!=    null    &&    builder.length()    >    0)    {    	non-compiled	[CE]  	52	None	replace
51	[BUG]  [BUGGY]  if(stream.getLineno()  ==  0)  {  [CE]  [FE]            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(stream.getLineno()  ==  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(stream.getLineno()  ==  0)  {	  if(stream.getRemainingJSDocLine()    ==    0)    {    	non-compiled	[CE]  	68	None	replace
52	[BUG]  [BUGGY]  if(stream.getCharno()  ==  0)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(stream.getCharno()  ==  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(stream.getCharno()  ==  0)  {	  if(stream.getRemainingJSDocLine()    ==    0)    {    	non-compiled	[CE]  	68	None	replace
53	[BUG]  [BUGGY]  if(stream.getRemainingJSDocLine()  ==  0  ||  toString(token)!=  null)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(stream.getRemainingJSDocLine()  ==  0  ||  toString(token)!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(stream.getRemainingJSDocLine()  ==  0  ||  toString(token)!=  null)  {	  if(stream.getRemainingJSDocLine()    ==    0)    {    	non-compiled	[CE]  	68	None	replace
54	[BUG]  [BUGGY]  if(stream.getRemainingJSDocLine()  >=  0)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(stream.getRemainingJSDocLine()  >=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(stream.getRemainingJSDocLine()  >=  0)  {	  if(stream.getRemainingJSDocLine()    ==    0)    {    	non-compiled	[CE]  	68	None	replace
55	[BUG]  [BUGGY]  if(stream.getRemainingJSDocLine()  ==  0  ||  stream.getCharno()!=  endCharno)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(stream.getRemainingJSDocLine()  ==  0  ||  stream.getCharno()!=  endCharno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(stream.getRemainingJSDocLine()  ==  0  ||  stream.getCharno()!=  endCharno)  {	  if(stream.getRemainingJSDocLine()    ==    0)    {    	non-compiled	[CE]  	68	None	replace
56	[BUG]  [BUGGY]  if(jsDocBuilder!=  null  &&  jsdocBuilder.markText(toString(token)))  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsDocBuilder!=  null  &&  jsdocBuilder.markText(toString(token)))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsDocBuilder!=  null  &&  jsdocBuilder.markText(toString(token)))  {	  if(jsdocBuilder!=    null    ||    jsdocBuilder.markText(toString(token)))    {    	non-compiled	[CE]  	5	None	replace
57	[BUG]  [BUGGY]  if(jsdocBuilder  ==  null  ||  jsdocBuilder.markText(toString(token)))  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder  ==  null  ||  jsdocBuilder.markText(toString(token)))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder  ==  null  ||  jsdocBuilder.markText(toString(token)))  {	  if(jsdocBuilder!=    null    ||    jsdocBuilder.markText(toString(token)))    {    	non-compiled	[CE]  	5	None	replace
58	[BUG]  [BUGGY]  if(token!=  null  ||  jsdocBuilder.markText(toString(token)))  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  ||  jsdocBuilder.markText(toString(token)))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  ||  jsdocBuilder.markText(toString(token)))  {	  if(jsdocBuilder!=    null    ||    jsdocBuilder.markText(toString(token)))    {    	non-compiled	[CE]  	5	None	replace
59	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText(toString(Token.EMPTY)))  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText(toString(Token.EMPTY)))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder.markText(toString(Token.EMPTY)))  {	  if(jsdocBuilder!=    null    ||    jsdocBuilder.markText(toString(token)))    {    	non-compiled	[CE]  	5	None	replace
60	[BUG]  [BUGGY]  if(endCharno  >=  endLineno)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endCharno  >=  endLineno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endCharno  >=  endLineno)  {	  if(endCharno!=    startCharno)    {    	non-compiled	[CE]  	88	None	replace
61	[BUG]  [BUGGY]  if(token  ==  JsDocToken.VALUE_EMBEDDED_TOKEN)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  JsDocToken.VALUE_EMBEDDED_TOKEN)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  JsDocToken.VALUE_EMBEDDED_TOKEN)  {	  if(token    ==    NO_UNREAD_TOKEN)    {    	non-compiled	[CE]  	63	None	replace
62	[BUG]  [BUGGY]  if(token  ==  JsDocToken.VALUE_STRING)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  JsDocToken.VALUE_STRING)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  JsDocToken.VALUE_STRING)  {	  if(token    ==    NO_UNREAD_TOKEN)    {    	non-compiled	[CE]  	63	None	replace
63	[BUG]  [BUGGY]  if(token  ==  JsDocToken.VALUE_NULL)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  JsDocToken.VALUE_NULL)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  JsDocToken.VALUE_NULL)  {	  if(token    ==    NO_UNREAD_TOKEN)    {    	non-compiled	[CE]  	63	None	replace
64	[BUG]  [BUGGY]  if(line!=  startLineno)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  startLineno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  startLineno)  {	  if(line!=    endLineno)    {    	non-compiled	[CE]  	74	None	replace
65	[BUG]  [BUGGY]  if(token!=  JsDocToken.VALUE_EMBEDDED_TOKEN)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.VALUE_EMBEDDED_TOKEN)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.VALUE_EMBEDDED_TOKEN)  {	  if(token!=    JsDocToken.VALUE_NULL)    {    	non-compiled	[CE]  	29	None	replace
66	[BUG]  [BUGGY]  if(token!=  JsDocToken.VALUE_NUMBER_INT)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.VALUE_NUMBER_INT)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.VALUE_NUMBER_INT)  {	  if(token!=    JsDocToken.VALUE_NULL)    {    	non-compiled	[CE]  	29	None	replace
67	[BUG]  [BUGGY]  if(jsdocBuilder  ==  null  &&  jsdocBuilder.markText('  '))  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder  ==  null  &&  jsdocBuilder.markText('  '))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder  ==  null  &&  jsdocBuilder.markText('  '))  {	  if(jsdocBuilder!=    null    ||    jsdocBuilder.markText('    '))    {    	non-compiled	[CE]  	7	None	replace
68	[BUG]  [BUGGY]  if(jsDocBuilder!=  null  &&  jsdocBuilder.markText('  '))  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsDocBuilder!=  null  &&  jsdocBuilder.markText('  '))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsDocBuilder!=  null  &&  jsdocBuilder.markText('  '))  {	  if(jsdocBuilder!=    null    ||    jsdocBuilder.markText('    '))    {    	non-compiled	[CE]  	7	None	replace
69	[BUG]  [BUGGY]  if(jsdocBuilder  ==  null  ||  jsdocBuilder.markText('  '))  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder  ==  null  ||  jsdocBuilder.markText('  '))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder  ==  null  ||  jsdocBuilder.markText('  '))  {	  if(jsdocBuilder!=    null    ||    jsdocBuilder.markText('    '))    {    	non-compiled	[CE]  	7	None	replace
70	[BUG]  [BUGGY]  if(token!=  JsDocToken.START_OBJECT)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.START_OBJECT)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.START_OBJECT)  {	  if(token!=    JsDocToken.FIELD_NAME)    {    	non-compiled	[CE]  	28	None	replace
71	[BUG]  [BUGGY]  if(token!=  JsDocToken.VALUE_NUMBER_INT  ||  token!=  JsDocToken.FIELD_NAME)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.VALUE_NUMBER_INT  ||  token!=  JsDocToken.FIELD_NAME)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.VALUE_NUMBER_INT  ||  token!=  JsDocToken.FIELD_NAME)  {	  if(token!=    JsDocToken.FIELD_NAME)    {    	non-compiled	[CE]  	28	None	replace
72	[BUG]  [BUGGY]  if(endCharno  ==  -1)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endCharno  ==  -1)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endCharno  ==  -1)  {	  if(endCharno!=    0)    {    	non-compiled	[CE]  	58	None	replace
73	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  ||  builder.length()  <=  0)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  ||  builder.length()  <=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  ||  builder.length()  <=  0)  {	  if(jsdocBuilder!=    null    &&    builder.length()    <=    0)    {    	non-compiled	[CE]  	55	None	replace
74	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  lineno,  startCharno,  endCharno);  [CE]  [FE]                              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  lineno,  startCharno,  endCharno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  lineno,  startCharno,  endCharno);	  jsdocBuilder.markText(token,    startLineno,    endCharno,    endLineno);    	non-compiled	[CE]  	13	None	replace
75	[BUG]  [BUGGY]  jsdocBuilder.markText(multilineText,  startLineno,  endCharno,  endLineno);  [CE]  [FE]                                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(multilineText,  startLineno,  endCharno,  endLineno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(multilineText,  startLineno,  endCharno,  endLineno);	  jsdocBuilder.markText(token,    startLineno,    endCharno,    endLineno);    	non-compiled	[CE]  	13	None	replace
76	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  line,  endCharno,  endLineno);  [CE]  [FE]                                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  line,  endCharno,  endLineno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  line,  endCharno,  endLineno);	  jsdocBuilder.markText(token,    startLineno,    endCharno,    endLineno);    	non-compiled	[CE]  	13	None	replace
77	[BUG]  [BUGGY]  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno);  [CE]  [FE]                                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno);	  jsdocBuilder.markText(token,    startLineno,    endCharno,    endLineno);    	non-compiled	[CE]  	13	None	replace
78	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  lineno,  startCharno,  endLineno);  [CE]  [FE]                                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  lineno,  startCharno,  endLineno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  lineno,  startCharno,  endLineno);	  jsdocBuilder.markText(token,    startLineno,    endCharno,    endLineno);    	non-compiled	[CE]  	13	None	replace
79	[BUG]  [BUGGY]  if(line.length()  >=  0)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line.length()  >=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line.length()  >=  0)  {	  if(line.length()    ==    0)    {    	non-compiled	[CE]  	16	None	replace
80	[BUG]  [BUGGY]  if(startCharno  ==  endLineno)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(startCharno  ==  endLineno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(startCharno  ==  endLineno)  {	  if(endCharno    ==    endLineno)    {    	non-compiled	[CE]  	44	None	replace
81	[BUG]  [BUGGY]  jsdocBuilder.markText(line,  endLineno,  startCharno,  endLineno);  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(line,  endLineno,  startCharno,  endLineno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(line,  endLineno,  startCharno,  endLineno);	  jsdocBuilder.markText(line,    startLineno,    startCharno,    endLineno);    	non-compiled	[CE]  	67	None	replace
82	[BUG]  [BUGGY]  jsdocBuilder.markText(line,  startLineno,  endCharno,  endLineno);  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(line,  startLineno,  endCharno,  endLineno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(line,  startLineno,  endCharno,  endLineno);	  jsdocBuilder.markText(line,    startLineno,    startCharno,    endLineno);    	non-compiled	[CE]  	67	None	replace
83	[BUG]  [BUGGY]  jsdocBuilder.markText(line,  endCharno,  startLineno,  endLineno);  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(line,  endCharno,  startLineno,  endLineno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(line,  endCharno,  startLineno,  endLineno);	  jsdocBuilder.markText(line,    startLineno,    startCharno,    endLineno);    	non-compiled	[CE]  	67	None	replace
84	[BUG]  [BUGGY]  if(line.length()  <=  0  ||  line.charAt(line.length()  -  1)!='')  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line.length()  <=  0  ||  line.charAt(line.length()  -  1)!='')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line.length()  <=  0  ||  line.charAt(line.length()  -  1)!='')  {	  if(line.length()    <=    0)    {    	non-compiled	[CE]  	21	None	replace
85	[BUG]  [BUGGY]  if(line.length()  <  0)  {  [CE]  [FE]                            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line.length()  <  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line.length()  <  0)  {	  if(line.length()    <=    0)    {    	non-compiled	[CE]  	21	None	replace
86	[BUG]  [BUGGY]  if(line.length()  <=  0  ||  line.charAt(line.length()  -  1)  =='')  {  [CE]  [FE]                              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line.length()  <=  0  ||  line.charAt(line.length()  -  1)  =='')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line.length()  <=  0  ||  line.charAt(line.length()  -  1)  =='')  {	  if(line.length()    <=    0)    {    	non-compiled	[CE]  	21	None	replace
87	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  ||  jsdocBuilder.markText())  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  ||  jsdocBuilder.markText())  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  ||  jsdocBuilder.markText())  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.markText())    {    	non-compiled	[CE]  	81	None	replace
88	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText(endCharno))  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText(endCharno))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder.markText(endCharno))  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.markText())    {    	non-compiled	[CE]  	81	None	replace
89	[BUG]  [BUGGY]  if(jsdocBuilder  ==  null  &&  jsdocBuilder.markText())  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder  ==  null  &&  jsdocBuilder.markText())  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder  ==  null  &&  jsdocBuilder.markText())  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.markText())    {    	non-compiled	[CE]  	81	None	replace
90	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText(startLineno,  endCharno))  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText(startLineno,  endCharno))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder.markText(startLineno,  endCharno))  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.markText())    {    	non-compiled	[CE]  	81	None	replace
91	[BUG]  [BUGGY]  if(builder!=  null  &&  line.length()  >  0)  {  [CE]  [FE]            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder!=  null  &&  line.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder!=  null  &&  line.length()  >  0)  {	  if(line!=    null    &&    builder.length()    >    0)    {    	non-compiled	[CE]  	89	None	replace
92	[BUG]  [BUGGY]  if(line  ==  null  &&  builder.length()  >  0)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  ==  null  &&  builder.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  ==  null  &&  builder.length()  >  0)  {	  if(line!=    null    &&    builder.length()    >    0)    {    	non-compiled	[CE]  	89	None	replace
93	[BUG]  [BUGGY]  if(startCharno!=  endLineno)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(startCharno!=  endLineno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(startCharno!=  endLineno)  {	  if(endCharno!=    endLineno)    {    	non-compiled	[CE]  	46	None	replace
94	[BUG]  [BUGGY]  if(line  =='')  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  =='')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  =='')  {	  if(line    ==    endCharno)    {    	non-compiled	[CE]  	37	None	replace
95	[BUG]  [BUGGY]  if(endCharno  ==  line)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endCharno  ==  line)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endCharno  ==  line)  {	  if(line    ==    endCharno)    {    	non-compiled	[CE]  	37	None	replace
96	[BUG]  [BUGGY]  if(token!=  null  &&  token!=  null)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token!=  null)  {	  if(jsdocBuilder!=    null    &&    token!=    null)    {    	non-compiled	[CE]  	101	None	replace
97	[BUG]  [BUGGY]  if(token!=  null  &&  jsdocBuilder!=  null)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  jsdocBuilder!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  jsdocBuilder!=  null)  {	  if(jsdocBuilder!=    null    &&    token!=    null)    {    	non-compiled	[CE]  	101	None	replace
98	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  ||  token!=  null)  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  ||  token!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  ||  token!=  null)  {	  if(jsdocBuilder!=    null    &&    token!=    null)    {    	non-compiled	[CE]  	101	None	replace
99	[BUG]  [BUGGY]  if(token!=  null  &&  stream!=  null)  {  [CE]  [FE]                            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  stream!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  stream!=  null)  {	  if(jsdocBuilder!=    null    &&    token!=    null)    {    	non-compiled	[CE]  	101	None	replace
100	[BUG]  [BUGGY]  if(token!=  null  &&  stream.getCharno()  ==  endCharno)  {  [CE]  [FE]                              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  stream.getCharno()  ==  endCharno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  stream.getCharno()  ==  endCharno)  {	  if(jsdocBuilder!=    null    &&    token!=    null)    {    	non-compiled	[CE]  	101	None	replace
101	[BUG]  [BUGGY]  if(token.length()  ==  0  ||  toString(token)!=  null)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token.length()  ==  0  ||  toString(token)!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token.length()  ==  0  ||  toString(token)!=  null)  {	  if(builder.length()    ==    0    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	35	None	replace
102	[BUG]  [BUGGY]  if(toString.length()  ==  0  ||  builder.charAt(token)!=  null)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(toString.length()  ==  0  ||  builder.charAt(token)!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(toString.length()  ==  0  ||  builder.charAt(token)!=  null)  {	  if(builder.length()    ==    0    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	35	None	replace
103	[BUG]  [BUGGY]  if(token.length()  ==  0  ||  builder.charAt(token)!=  null)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token.length()  ==  0  ||  builder.charAt(token)!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token.length()  ==  0  ||  builder.charAt(token)!=  null)  {	  if(builder.length()    ==    0    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	35	None	replace
104	[BUG]  [BUGGY]  if(toString.length()  ==  0  ||  toString(token)!=  null)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(toString.length()  ==  0  ||  toString(token)!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(toString.length()  ==  0  ||  toString(token)!=  null)  {	  if(builder.length()    ==    0    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	35	None	replace
105	[BUG]  [BUGGY]  if(buffer.length()  ==  0  ||  toString(token)!=  null)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(buffer.length()  ==  0  ||  toString(token)!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(buffer.length()  ==  0  ||  toString(token)!=  null)  {	  if(builder.length()    ==    0    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	35	None	replace
106	[BUG]  [BUGGY]  if(line.length()  ==  0  ||  toString(token)!=  null)  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line.length()  ==  0  ||  toString(token)!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line.length()  ==  0  ||  toString(token)!=  null)  {	  if(builder.length()    ==    0    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	35	None	replace
107	[BUG]  [BUGGY]  if(token  ==  null  &&  token.length()  ==  0)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  null  &&  token.length()  ==  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  null  &&  token.length()  ==  0)  {	  if(token!=    null    ||    token.length()    ==    0)    {    	non-compiled	[CE]  	27	None	replace
108	[BUG]  [BUGGY]  if(token!=  null  ||  token.length()  <=  0)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  ||  token.length()  <=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  ||  token.length()  <=  0)  {	  if(token!=    null    ||    token.length()    ==    0)    {    	non-compiled	[CE]  	27	None	replace
109	[BUG]  [BUGGY]  if(token!=  null  ||  token.length()  >=  0)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  ||  token.length()  >=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  ||  token.length()  >=  0)  {	  if(token!=    null    ||    token.length()    ==    0)    {    	non-compiled	[CE]  	27	None	replace
110	[BUG]  [BUGGY]  if(endCharno!='')  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endCharno!='')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endCharno!='')  {	  if(endCharno    =='')    {    	non-compiled	[CE]  	47	None	replace
111	[BUG]  [BUGGY]  if(endCharno  ==''  ||  endCharno  ==  '-')  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endCharno  ==''  ||  endCharno  ==  '-')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endCharno  ==''  ||  endCharno  ==  '-')  {	  if(endCharno    =='')    {    	non-compiled	[CE]  	47	None	replace
112	[BUG]  [BUGGY]  if(endCharno  ==''  ||  endCharno  ==  endCharno)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endCharno  ==''  ||  endCharno  ==  endCharno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endCharno  ==''  ||  endCharno  ==  endCharno)  {	  if(endCharno    =='')    {    	non-compiled	[CE]  	47	None	replace
113	[BUG]  [BUGGY]  if(endCharno  ==  'n'  ||  endCharno  ==  'r')  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endCharno  ==  'n'  ||  endCharno  ==  'r')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endCharno  ==  'n'  ||  endCharno  ==  'r')  {	  if(endCharno    =='')    {    	non-compiled	[CE]  	47	None	replace
114	[BUG]  [BUGGY]  if(endCharno  ==''  ||  endCharno  =='')  {  [CE]  [FE]                            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endCharno  ==''  ||  endCharno  =='')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endCharno  ==''  ||  endCharno  =='')  {	  if(endCharno    =='')    {    	non-compiled	[CE]  	47	None	replace
115	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  ||  token!=  JsDocToken.VALUE_STRING)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  ||  token!=  JsDocToken.VALUE_STRING)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  ||  token!=  JsDocToken.VALUE_STRING)  {	  if(jsdocBuilder!=    null    &&    token!=    JsDocToken.VALUE_STRING)    {    	non-compiled	[CE]  	99	None	replace
116	[BUG]  [BUGGY]  if(token!=  null  &&  token!=  JsDocToken.VALUE_STRING)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token!=  JsDocToken.VALUE_STRING)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token!=  JsDocToken.VALUE_STRING)  {	  if(jsdocBuilder!=    null    &&    token!=    JsDocToken.VALUE_STRING)    {    	non-compiled	[CE]  	99	None	replace
117	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  token  ==  JsDocToken.VALUE_STRING)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  token  ==  JsDocToken.VALUE_STRING)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  token  ==  JsDocToken.VALUE_STRING)  {	  if(jsdocBuilder!=    null    &&    token!=    JsDocToken.VALUE_STRING)    {    	non-compiled	[CE]  	99	None	replace
118	[BUG]  [BUGGY]  if(token!=  JsDocToken.VALUE_STRING  &&  token!=  JsDocToken.FIELD_NAME)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.VALUE_STRING  &&  token!=  JsDocToken.FIELD_NAME)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.VALUE_STRING  &&  token!=  JsDocToken.FIELD_NAME)  {	  if(jsdocBuilder!=    null    &&    token!=    JsDocToken.VALUE_STRING)    {    	non-compiled	[CE]  	99	None	replace
119	[BUG]  [BUGGY]  if(jsdocBuilder  ==  null  &&  token!=  JsDocToken.VALUE_STRING)  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder  ==  null  &&  token!=  JsDocToken.VALUE_STRING)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder  ==  null  &&  token!=  JsDocToken.VALUE_STRING)  {	  if(jsdocBuilder!=    null    &&    token!=    JsDocToken.VALUE_STRING)    {    	non-compiled	[CE]  	99	None	replace
120	[BUG]  [BUGGY]  if(line!=  null  &&  line.length()!=  0)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  null  &&  line.length()!=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  null  &&  line.length()!=  0)  {	  if(line.length()!=    0)    {    	non-compiled	[CE]  	20	None	replace
121	[BUG]  [BUGGY]  if(line!=  null  ||  line.length()!=  0)  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  null  ||  line.length()!=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  null  ||  line.length()!=  0)  {	  if(line.length()!=    0)    {    	non-compiled	[CE]  	20	None	replace
122	[BUG]  [BUGGY]  if(builder!=  null  ||  builder.length()!=  0)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder!=  null  ||  builder.length()!=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder!=  null  ||  builder.length()!=  0)  {	  if(builder!=    null    &&    builder.length()!=    0)    {    	non-compiled	[CE]  	65	None	replace
123	[BUG]  [BUGGY]  if(token!=  JsDocToken.END_ARRAY)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.END_ARRAY)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.END_ARRAY)  {	  if(builder!=    null    &&    token!=    JsDocToken.END_ARRAY)    {    	non-compiled	[CE]  	103	None	replace
124	[BUG]  [BUGGY]  if(builder!=  null  &&  token!=  JsDocToken.START_ARRAY)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder!=  null  &&  token!=  JsDocToken.START_ARRAY)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder!=  null  &&  token!=  JsDocToken.START_ARRAY)  {	  if(builder!=    null    &&    token!=    JsDocToken.END_ARRAY)    {    	non-compiled	[CE]  	103	None	replace
125	[BUG]  [BUGGY]  if(token!=  null  &&  token!=  JsDocToken.END_ARRAY)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token!=  JsDocToken.END_ARRAY)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token!=  JsDocToken.END_ARRAY)  {	  if(builder!=    null    &&    token!=    JsDocToken.END_ARRAY)    {    	non-compiled	[CE]  	103	None	replace
126	[BUG]  [BUGGY]  if(token!=  JsDocToken.END_ARRAY  ||  token!=  JsDocToken.END_OBJECT)  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.END_ARRAY  ||  token!=  JsDocToken.END_OBJECT)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.END_ARRAY  ||  token!=  JsDocToken.END_OBJECT)  {	  if(builder!=    null    &&    token!=    JsDocToken.END_ARRAY)    {    	non-compiled	[CE]  	103	None	replace
127	[BUG]  [BUGGY]  if(token!=  null  &&  token.length()  <=  0)  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token.length()  <=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token.length()  <=  0)  {	  if(token!=    null    &&    token.length()    ==    0)    {    	non-compiled	[CE]  	97	None	replace
128	[BUG]  [BUGGY]  if(token!=  null  &&  token.length()  >=  0)  {  [CE]  [FE]                            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token.length()  >=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token.length()  >=  0)  {	  if(token!=    null    &&    token.length()    ==    0)    {    	non-compiled	[CE]  	97	None	replace
129	[BUG]  [BUGGY]  if(token!=  null  &&  token.charAt(0)  =='')  {  [CE]  [FE]                              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token.charAt(0)  =='')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token.charAt(0)  =='')  {	  if(token!=    null    &&    token.length()    ==    0)    {    	non-compiled	[CE]  	97	None	replace
130	[BUG]  [BUGGY]  if(endCharno  ==  lineno)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endCharno  ==  lineno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endCharno  ==  lineno)  {	  if(endCharno    ==    startCharno)    {    	non-compiled	[CE]  	36	None	replace
131	[BUG]  [BUGGY]  if(line  ==  null  ||  line.length()  >=  0)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  ==  null  ||  line.length()  >=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  ==  null  ||  line.length()  >=  0)  {	  if(line    ==    null    ||    line.length()    >    0)    {    	non-compiled	[CE]  	19	None	replace
132	[BUG]  [BUGGY]  if(jsdocBuilder.length()  >  0)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder.length()  >  0)  {	  if(builder.length()    >=    0)    {    	non-compiled	[CE]  	30	None	replace
133	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText('  ')||  jsdocBuilder.endCharno  ==  endCharno)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText('  ')||  jsdocBuilder.endCharno  ==  endCharno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder.markText('  ')||  jsdocBuilder.endCharno  ==  endCharno)  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.markText('    '))    {    	non-compiled	[CE]  	82	None	replace
134	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText( "   "))  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText( "   "))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder.markText( "   "))  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.markText('    '))    {    	non-compiled	[CE]  	82	None	replace
135	[BUG]  [BUGGY]  if(fileLevelJsDocBuilder!=  null  &&  fileLevelJsDocBuilder.length()  >  0)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(fileLevelJsDocBuilder!=  null  &&  fileLevelJsDocBuilder.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(fileLevelJsDocBuilder!=  null  &&  fileLevelJsDocBuilder.length()  >  0)  {	  if(jsdocBuilder!=    null    &&    fileLevelJsDocBuilder.length()    >    0)    {    	non-compiled	[CE]  	61	None	replace
136	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  ||  fileLevelJsDocBuilder.length()  >  0)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  ||  fileLevelJsDocBuilder.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  ||  fileLevelJsDocBuilder.length()  >  0)  {	  if(jsdocBuilder!=    null    &&    fileLevelJsDocBuilder.length()    >    0)    {    	non-compiled	[CE]  	61	None	replace
137	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  fileLevelJsDocBuilder.length()  ==  0)  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  fileLevelJsDocBuilder.length()  ==  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  fileLevelJsDocBuilder.length()  ==  0)  {	  if(jsdocBuilder!=    null    &&    fileLevelJsDocBuilder.length()    >    0)    {    	non-compiled	[CE]  	61	None	replace
138	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  fileLevelJsDocBuilder.length()  <=  0)  {  [CE]  [FE]                            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  fileLevelJsDocBuilder.length()  <=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  fileLevelJsDocBuilder.length()  <=  0)  {	  if(jsdocBuilder!=    null    &&    fileLevelJsDocBuilder.length()    >    0)    {    	non-compiled	[CE]  	61	None	replace
139	[BUG]  [BUGGY]  if(builder!=  null  &&  fileLevelJsDocBuilder.length()  >  0)  {  [CE]  [FE]                              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder!=  null  &&  fileLevelJsDocBuilder.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder!=  null  &&  fileLevelJsDocBuilder.length()  >  0)  {	  if(jsdocBuilder!=    null    &&    fileLevelJsDocBuilder.length()    >    0)    {    	non-compiled	[CE]  	61	None	replace
140	[BUG]  [BUGGY]  if(token!=  null  &&  fileLevelJsDocBuilder.length()  >  0)  {  [CE]  [FE]                                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  fileLevelJsDocBuilder.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  fileLevelJsDocBuilder.length()  >  0)  {	  if(jsdocBuilder!=    null    &&    fileLevelJsDocBuilder.length()    >    0)    {    	non-compiled	[CE]  	61	None	replace
141	[BUG]  [BUGGY]  if(startCharno  >=  endCharno)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(startCharno  >=  endCharno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(startCharno  >=  endCharno)  {	  if(endCharno    >=    0)    {    	non-compiled	[CE]  	59	None	replace
142	[BUG]  [BUGGY]  if(endCharno  ==  0  ||  endCharno  >=  endLineno)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endCharno  ==  0  ||  endCharno  >=  endLineno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endCharno  ==  0  ||  endCharno  >=  endLineno)  {	  if(endCharno    >=    0)    {    	non-compiled	[CE]  	59	None	replace
143	[BUG]  [BUGGY]  if(token!=  JsDocToken.VALUE_NUMBER_INT  ||  token!=  JsDocToken.VALUE_STRING)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.VALUE_NUMBER_INT  ||  token!=  JsDocToken.VALUE_STRING)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.VALUE_NUMBER_INT  ||  token!=  JsDocToken.VALUE_STRING)  {	  if(token!=    JsDocToken.VALUE_STRING)    {    	non-compiled	[CE]  	93	None	replace
144	[BUG]  [BUGGY]  if(token!=  JsDocToken.VALUE_STRING  ||  token!=  JsDocToken.FIELD_NAME)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.VALUE_STRING  ||  token!=  JsDocToken.FIELD_NAME)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.VALUE_STRING  ||  token!=  JsDocToken.FIELD_NAME)  {	  if(token!=    JsDocToken.VALUE_STRING)    {    	non-compiled	[CE]  	93	None	replace
145	[BUG]  [BUGGY]  if(token!=  JsDocToken.VALUE_STRING  ||  token!=  JsDocToken.VALUE_FIELD_NAME)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.VALUE_STRING  ||  token!=  JsDocToken.VALUE_FIELD_NAME)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.VALUE_STRING  ||  token!=  JsDocToken.VALUE_FIELD_NAME)  {	  if(token!=    JsDocToken.VALUE_STRING)    {    	non-compiled	[CE]  	93	None	replace
146	[BUG]  [BUGGY]  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  [CE]  [FE]                            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);	  jsdocBuilder.markText(line,    startLineno,    startCharno,    endLineno,    endCharno);    	non-compiled	[CE]  	12	None	replace
147	[BUG]  [BUGGY]  jsdocBuilder.markText(line,  endLineno,  startCharno,  endLineno,  endCharno);  [CE]  [FE]                              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(line,  endLineno,  startCharno,  endLineno,  endCharno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(line,  endLineno,  startCharno,  endLineno,  endCharno);	  jsdocBuilder.markText(line,    startLineno,    startCharno,    endLineno,    endCharno);    	non-compiled	[CE]  	12	None	replace
148	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  line,  startLineno,  endCharno,  endLineno);  [CE]  [FE]                                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  line,  startLineno,  endCharno,  endLineno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  line,  startLineno,  endCharno,  endLineno);	  jsdocBuilder.markText(line,    startLineno,    startCharno,    endLineno,    endCharno);    	non-compiled	[CE]  	12	None	replace
149	[BUG]  [BUGGY]  jsdocBuilder.markText(multilineText,  line,  startCharno,  endLineno,  endCharno);  [CE]  [FE]                                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(multilineText,  line,  startCharno,  endLineno,  endCharno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(multilineText,  line,  startCharno,  endLineno,  endCharno);	  jsdocBuilder.markText(line,    startLineno,    startCharno,    endLineno,    endCharno);    	non-compiled	[CE]  	12	None	replace
150	[BUG]  [BUGGY]  jsdocBuilder.markText(line,  startLineno,  endCharno,  endLineno,  endCharno);  [CE]  [FE]                                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(line,  startLineno,  endCharno,  endLineno,  endCharno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(line,  startLineno,  endCharno,  endLineno,  endCharno);	  jsdocBuilder.markText(line,    startLineno,    startCharno,    endLineno,    endCharno);    	non-compiled	[CE]  	12	None	replace
151	[BUG]  [BUGGY]  if(line  ==  startLineno)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  ==  startLineno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  ==  startLineno)  {	  if(line    ==    endLineno)    {    	non-compiled	[CE]  	71	None	replace
152	[BUG]  [BUGGY]  if(line  ==  line)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  ==  line)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  ==  line)  {	  if(line    ==    endLineno)    {    	non-compiled	[CE]  	71	None	replace
153	[BUG]  [BUGGY]  if(line  ==  null  &&  token!=  JsDocToken.VALUE_STRING)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  ==  null  &&  token!=  JsDocToken.VALUE_STRING)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  ==  null  &&  token!=  JsDocToken.VALUE_STRING)  {	  if(line!=    null    &&    token!=    JsDocToken.VALUE_STRING)    {    	non-compiled	[CE]  	76	None	replace
154	[BUG]  [BUGGY]  if(line!=  null  ||  token!=  JsDocToken.VALUE_STRING)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  null  ||  token!=  JsDocToken.VALUE_STRING)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  null  ||  token!=  JsDocToken.VALUE_STRING)  {	  if(line!=    null    &&    token!=    JsDocToken.VALUE_STRING)    {    	non-compiled	[CE]  	76	None	replace
155	[BUG]  [BUGGY]  if(line  ==  null  ||  token!=  JsDocToken.VALUE_STRING)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  ==  null  ||  token!=  JsDocToken.VALUE_STRING)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  ==  null  ||  token!=  JsDocToken.VALUE_STRING)  {	  if(line!=    null    &&    token!=    JsDocToken.VALUE_STRING)    {    	non-compiled	[CE]  	76	None	replace
156	[BUG]  [BUGGY]  if(line  ==  null  &&  token!=  JsDocToken.END_ARRAY)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  ==  null  &&  token!=  JsDocToken.END_ARRAY)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  ==  null  &&  token!=  JsDocToken.END_ARRAY)  {	  if(line!=    null    &&    token!=    JsDocToken.END_ARRAY)    {    	non-compiled	[CE]  	77	None	replace
157	[BUG]  [BUGGY]  if(line!=  null  &&  token!=  JsDocToken.START_ARRAY)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  null  &&  token!=  JsDocToken.START_ARRAY)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  null  &&  token!=  JsDocToken.START_ARRAY)  {	  if(line!=    null    &&    token!=    JsDocToken.END_ARRAY)    {    	non-compiled	[CE]  	77	None	replace
158	[BUG]  [BUGGY]  if(line!=  null  &&  token!=  JsDocToken.START_OBJECT)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  null  &&  token!=  JsDocToken.START_OBJECT)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  null  &&  token!=  JsDocToken.START_OBJECT)  {	  if(line!=    null    &&    token!=    JsDocToken.END_ARRAY)    {    	non-compiled	[CE]  	77	None	replace
159	[BUG]  [BUGGY]  if(token!=  JsDocToken.START_STRING)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.START_STRING)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.START_STRING)  {	  if(token!=    NO_UNREAD_TOKEN)    {    	non-compiled	[CE]  	62	None	replace
160	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  ||  jsdocBuilder.length()  >  0)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  ||  jsdocBuilder.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  ||  jsdocBuilder.length()  >  0)  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.length()    >    0)    {    	non-compiled	[CE]  	60	None	replace
161	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.length()  ==  0)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.length()  ==  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder.length()  ==  0)  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.length()    >    0)    {    	non-compiled	[CE]  	60	None	replace
162	[BUG]  [BUGGY]  if(jsdocBuilder  ==  null  &&  jsdocBuilder.length()  >  0)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder  ==  null  &&  jsdocBuilder.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder  ==  null  &&  jsdocBuilder.length()  >  0)  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.length()    >    0)    {    	non-compiled	[CE]  	60	None	replace
163	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.length()  <=  0)  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.length()  <=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder.length()  <=  0)  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.length()    >    0)    {    	non-compiled	[CE]  	60	None	replace
164	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.length()  >=  0)  {  [CE]  [FE]                            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.length()  >=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder.length()  >=  0)  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.length()    >    0)    {    	non-compiled	[CE]  	60	None	replace
165	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  ||  builder.length()  >=  0)  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  ||  builder.length()  >=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  ||  builder.length()  >=  0)  {	  if(jsdocBuilder!=    null    &&    builder.length()    >=    0)    {    	non-compiled	[CE]  	56	None	replace
166	[BUG]  [BUGGY]  if(token!=  null  ||  token.startsWith( "- "))  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  ||  token.startsWith( "- "))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  ||  token.startsWith( "- "))  {	  if(token!=    null    &&    token.startsWith(   "-   "))    {    	non-compiled	[CE]  	95	None	replace
167	[BUG]  [BUGGY]  if(token  ==  null  &&  token.startsWith( "- "))  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  null  &&  token.startsWith( "- "))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  null  &&  token.startsWith( "- "))  {	  if(token!=    null    &&    token.startsWith(   "-   "))    {    	non-compiled	[CE]  	95	None	replace
168	[BUG]  [BUGGY]  if(token!=  null  &&  token.startsWith( ".java "))  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token.startsWith( ".java "))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token.startsWith( ".java "))  {	  if(token!=    null    &&    token.startsWith(   "-   "))    {    	non-compiled	[CE]  	95	None	replace
169	[BUG]  [BUGGY]  if(token!=  null  &&  token.equals( "- "))  {  [CE]  [FE]                            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token.equals( "- "))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token.equals( "- "))  {	  if(token!=    null    &&    token.startsWith(   "-   "))    {    	non-compiled	[CE]  	95	None	replace
170	[BUG]  [BUGGY]  if(token!=  null  &&  token.startsWith( "n "))  {  [CE]  [FE]                              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token.startsWith( "n "))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token.startsWith( "n "))  {	  if(token!=    null    &&    token.startsWith(   "-   "))    {    	non-compiled	[CE]  	95	None	replace
171	[BUG]  [BUGGY]  if(line!=  null  &&  token.startsWith( "- "))  {  [CE]  [FE]                                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  null  &&  token.startsWith( "- "))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  null  &&  token.startsWith( "- "))  {	  if(token!=    null    &&    token.startsWith(   "-   "))    {    	non-compiled	[CE]  	95	None	replace
172	[BUG]  [BUGGY]  if(token!=  JsDocToken.VALUE_STRING  ||  token!=  JsDocToken.VALUE_STRING)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.VALUE_STRING  ||  token!=  JsDocToken.VALUE_STRING)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.VALUE_STRING  ||  token!=  JsDocToken.VALUE_STRING)  {	  if(builder!=    null    &&    token!=    JsDocToken.VALUE_STRING)    {    	non-compiled	[CE]  	102	None	replace
173	[BUG]  [BUGGY]  if(token!=  null  &&  line!=  null)  {  [CE]  [FE]            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  line!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  line!=  null)  {	  if(line!=    null    &&    token!=    null)    {    	non-compiled	[CE]  	75	None	replace
174	[BUG]  [BUGGY]  if(line  ==  null  &&  token!=  null)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  ==  null  &&  token!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  ==  null  &&  token!=  null)  {	  if(line!=    null    &&    token!=    null)    {    	non-compiled	[CE]  	75	None	replace
175	[BUG]  [BUGGY]  if(token!=  null  &&  stream.getRemainingJSDocLine()!=  null)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  stream.getRemainingJSDocLine()!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  stream.getRemainingJSDocLine()!=  null)  {	  if(line!=    null    &&    token!=    null)    {    	non-compiled	[CE]  	75	None	replace
176	[BUG]  [BUGGY]  if(line!=  null  ||  token!=  null)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  null  ||  token!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  null  ||  token!=  null)  {	  if(line!=    null    &&    token!=    null)    {    	non-compiled	[CE]  	75	None	replace
177	[BUG]  [BUGGY]  if(token  ==  null  ||  token!=  null)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  null  ||  token!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  null  ||  token!=  null)  {	  if(line    ==    null    ||    token!=    null)    {    	non-compiled	[CE]  	23	None	replace
178	[BUG]  [BUGGY]  if(token  ==  null  ||  line!=  null)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  null  ||  line!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  null  ||  line!=  null)  {	  if(line    ==    null    ||    token!=    null)    {    	non-compiled	[CE]  	23	None	replace
179	[BUG]  [BUGGY]  if(token  ==  null  ||  endCharno!=  endCharno)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  null  ||  endCharno!=  endCharno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  null  ||  endCharno!=  endCharno)  {	  if(line    ==    null    ||    token!=    null)    {    	non-compiled	[CE]  	23	None	replace
180	[BUG]  [BUGGY]  if(token  ==  null  ||  stream.getRemainingJSDocLine()!=  null)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  null  ||  stream.getRemainingJSDocLine()!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  null  ||  stream.getRemainingJSDocLine()!=  null)  {	  if(line    ==    null    ||    token!=    null)    {    	non-compiled	[CE]  	23	None	replace
181	[BUG]  [BUGGY]  if(token  ==  JsDocToken.VALUE_NUMBER_INT  ||  token!=  JsDocToken.VALUE_NUMBER_FLOAT)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  JsDocToken.VALUE_NUMBER_INT  ||  token!=  JsDocToken.VALUE_NUMBER_FLOAT)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  JsDocToken.VALUE_NUMBER_INT  ||  token!=  JsDocToken.VALUE_NUMBER_FLOAT)  {	  if(line    ==    null    ||    token!=    null)    {    	non-compiled	[CE]  	23	None	replace
182	[BUG]  [BUGGY]  if(token  ==  JsDocToken.VALUE_EMBEDDED_TOKEN  ||  token!=  JsDocToken.VALUE_EMBEDDED_TOKEN)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  JsDocToken.VALUE_EMBEDDED_TOKEN  ||  token!=  JsDocToken.VALUE_EMBEDDED_TOKEN)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  JsDocToken.VALUE_EMBEDDED_TOKEN  ||  token!=  JsDocToken.VALUE_EMBEDDED_TOKEN)  {	  if(line    ==    null    ||    token!=    null)    {    	non-compiled	[CE]  	23	None	replace
183	[BUG]  [BUGGY]  if(token  ==  JsDocToken.START_TOKEN)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  JsDocToken.START_TOKEN)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  JsDocToken.START_TOKEN)  {	  if(token!=    JsDocToken.START_TOKEN)    {    	non-compiled	[CE]  	94	None	replace
184	[BUG]  [BUGGY]  if(token!=  JsDocToken.START_TOKEN  ||  token!=  JsDocToken.START_TOKEN)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.START_TOKEN  ||  token!=  JsDocToken.START_TOKEN)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.START_TOKEN  ||  token!=  JsDocToken.START_TOKEN)  {	  if(token!=    JsDocToken.START_TOKEN)    {    	non-compiled	[CE]  	94	None	replace
185	[BUG]  [BUGGY]  if(token!=  JsDocToken.START_TOKEN  ||  token  ==  JsDocToken.START_TOKEN)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.START_TOKEN  ||  token  ==  JsDocToken.START_TOKEN)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.START_TOKEN  ||  token  ==  JsDocToken.START_TOKEN)  {	  if(token!=    JsDocToken.START_TOKEN)    {    	non-compiled	[CE]  	94	None	replace
186	[BUG]  [BUGGY]  if(token!=  JsDocToken.NO_UNREAD_TOKEN)  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.NO_UNREAD_TOKEN)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.NO_UNREAD_TOKEN)  {	  if(token!=    JsDocToken.START_TOKEN)    {    	non-compiled	[CE]  	94	None	replace
187	[BUG]  [BUGGY]  if(token!=  JsDocToken.START_TAKEN)  {  [CE]  [FE]                            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.START_TAKEN)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.START_TAKEN)  {	  if(token!=    JsDocToken.START_TOKEN)    {    	non-compiled	[CE]  	94	None	replace
188	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  ||!jsdocBuilder.markText(token))  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  ||!jsdocBuilder.markText(token))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  ||!jsdocBuilder.markText(token))  {	  if(jsdocBuilder    ==    null)    {    	non-compiled	[CE]  	6	None	replace
189	[BUG]  [BUGGY]  if(jsdocBuilder  ==  null  ||  jsdocBuilder.markText(token))  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder  ==  null  ||  jsdocBuilder.markText(token))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder  ==  null  ||  jsdocBuilder.markText(token))  {	  if(jsdocBuilder    ==    null)    {    	non-compiled	[CE]  	6	None	replace
190	[BUG]  [BUGGY]  if(line.length()  >  0  &&  toString(token)!=  null)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line.length()  >  0  &&  toString(token)!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line.length()  >  0  &&  toString(token)!=  null)  {	  if(line.length()    >    0    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	90	None	replace
191	[BUG]  [BUGGY]  if(token.length()  >  0  ||  toString(token)!=  null)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token.length()  >  0  ||  toString(token)!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token.length()  >  0  ||  toString(token)!=  null)  {	  if(line.length()    >    0    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	90	None	replace
192	[BUG]  [BUGGY]  if(toString(token)!=  null)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(toString(token)!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(toString(token)!=  null)  {	  if(line.length()    >    0    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	90	None	replace
193	[BUG]  [BUGGY]  if(line.length()  >=  0  ||  toString(token)!=  null)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line.length()  >=  0  ||  toString(token)!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line.length()  >=  0  ||  toString(token)!=  null)  {	  if(line.length()    >    0    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	90	None	replace
194	[BUG]  [BUGGY]  if(line.length()!=  0  ||  toString(token)!=  null)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line.length()!=  0  ||  toString(token)!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line.length()!=  0  ||  toString(token)!=  null)  {	  if(line.length()    >    0    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	90	None	replace
195	[BUG]  [BUGGY]  jsdocBuilder.markText(multilineText,  startLineno,  endCharno,  endCharno);  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(multilineText,  startLineno,  endCharno,  endCharno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(multilineText,  startLineno,  endCharno,  endCharno);	  jsdocBuilder.markText(token,    startLineno,    endCharno,    endCharno);    	non-compiled	[CE]  	84	None	replace
196	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  lineno,  endCharno,  endCharno);  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  lineno,  endCharno,  endCharno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  lineno,  endCharno,  endCharno);	  jsdocBuilder.markText(token,    startLineno,    endCharno,    endCharno);    	non-compiled	[CE]  	84	None	replace
197	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  line,  endCharno,  endCharno);  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  line,  endCharno,  endCharno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  line,  endCharno,  endCharno);	  jsdocBuilder.markText(token,    startLineno,    endCharno,    endCharno);    	non-compiled	[CE]  	84	None	replace
198	[BUG]  [BUGGY]  if(builder!=  null  &&  fileLevelJsDocBuilder!=  null)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder!=  null  &&  fileLevelJsDocBuilder!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder!=  null  &&  fileLevelJsDocBuilder!=  null)  {	  if(jsdocBuilder!=    null    &&    fileLevelJsDocBuilder!=    null)    {    	non-compiled	[CE]  	98	None	replace
199	[BUG]  [BUGGY]  if(token!=  null  &&  fileLevelJsDocBuilder!=  null)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  fileLevelJsDocBuilder!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  fileLevelJsDocBuilder!=  null)  {	  if(jsdocBuilder!=    null    &&    fileLevelJsDocBuilder!=    null)    {    	non-compiled	[CE]  	98	None	replace
200	[BUG]  [BUGGY]  if(line!=  null  &&  fileLevelJsDocBuilder!=  null)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  null  &&  fileLevelJsDocBuilder!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  null  &&  fileLevelJsDocBuilder!=  null)  {	  if(jsdocBuilder!=    null    &&    fileLevelJsDocBuilder!=    null)    {    	non-compiled	[CE]  	98	None	replace
201	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  ||  fileLevelJsDocBuilder!=  null)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  ||  fileLevelJsDocBuilder!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  ||  fileLevelJsDocBuilder!=  null)  {	  if(jsdocBuilder!=    null    &&    fileLevelJsDocBuilder!=    null)    {    	non-compiled	[CE]  	98	None	replace
202	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  fileLevelJsDocBuilder  ==  null)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  fileLevelJsDocBuilder  ==  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  fileLevelJsDocBuilder  ==  null)  {	  if(jsdocBuilder!=    null    &&    fileLevelJsDocBuilder!=    null)    {    	non-compiled	[CE]  	98	None	replace
203	[BUG]  [BUGGY]  if(fileLevelJsDocBuilder!=  null)  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(fileLevelJsDocBuilder!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(fileLevelJsDocBuilder!=  null)  {	  if(jsdocBuilder!=    null    &&    fileLevelJsDocBuilder!=    null)    {    	non-compiled	[CE]  	98	None	replace
204	[BUG]  [BUGGY]  if(token!=  null  ||  token.equals( "   "))  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  ||  token.equals( "   "))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  ||  token.equals( "   "))  {	  if(token!=    null    &&    token.equals(   "   "))    {    	non-compiled	[CE]  	92	None	replace
205	[BUG]  [BUGGY]  if(token!=  null  &&  token.equals( "n "))  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token.equals( "n "))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token.equals( "n "))  {	  if(token!=    null    &&    token.equals(   "   "))    {    	non-compiled	[CE]  	92	None	replace
206	[BUG]  [BUGGY]  if(token!=  null  &&  token.equals( "* "))  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token.equals( "* "))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token.equals( "* "))  {	  if(token!=    null    &&    token.equals(   "   "))    {    	non-compiled	[CE]  	92	None	replace
207	[BUG]  [BUGGY]  if(token!=  null  &&  token.equals( "_ "))  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token.equals( "_ "))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token.equals( "_ "))  {	  if(token!=    null    &&    token.equals(   "   "))    {    	non-compiled	[CE]  	92	None	replace
208	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  endLineno,  startCharno,  endLineno);  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  endLineno,  startCharno,  endLineno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  endLineno,  startCharno,  endLineno);	  jsdocBuilder.markText(token,    startLineno,    startCharno,    endLineno);    	non-compiled	[CE]  	11	None	replace
209	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  line,  startCharno,  endLineno);  [CE]  [FE]                            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  line,  startCharno,  endLineno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  line,  startCharno,  endLineno);	  jsdocBuilder.markText(token,    startLineno,    startCharno,    endLineno);    	non-compiled	[CE]  	11	None	replace
210	[BUG]  [BUGGY]  if(jsdocBuilder.length()  <=  0)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder.length()  <=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder.length()  <=  0)  {	  if(jsdocBuilder.length()    ==    0)    {    	non-compiled	[CE]  	66	None	replace
211	[BUG]  [BUGGY]  if(jsdocBuilder.length()!=  0)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder.length()!=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder.length()!=  0)  {	  if(jsdocBuilder.length()    ==    0)    {    	non-compiled	[CE]  	66	None	replace
212	[BUG]  [BUGGY]  if(jsdocBuilder.length()  >=  0)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder.length()  >=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder.length()  >=  0)  {	  if(jsdocBuilder.length()    ==    0)    {    	non-compiled	[CE]  	66	None	replace
213	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  null,  lineno,  startCharno,  endCharno);  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  null,  lineno,  startCharno,  endCharno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  null,  lineno,  startCharno,  endCharno);	  jsdocBuilder.markText(token,    null,    startLineno,    endCharno);    	non-compiled	[CE]  	85	None	replace
214	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  null,  endCharno,  startLineno);  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  null,  endCharno,  startLineno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  null,  endCharno,  startLineno);	  jsdocBuilder.markText(token,    null,    startLineno,    endCharno);    	non-compiled	[CE]  	85	None	replace
215	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  null,  endLineno,  startCharno);  [CE]  [FE]                            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  null,  endLineno,  startCharno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  null,  endLineno,  startCharno);	  jsdocBuilder.markText(token,    null,    startLineno,    endCharno);    	non-compiled	[CE]  	85	None	replace
216	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  null,  line,  endCharno);  [CE]  [FE]                              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  null,  line,  endCharno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  null,  line,  endCharno);	  jsdocBuilder.markText(token,    null,    startLineno,    endCharno);    	non-compiled	[CE]  	85	None	replace
217	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  ||  jsdocBuilder.isLineno())  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  ||  jsdocBuilder.isLineno())  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  ||  jsdocBuilder.isLineno())  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.isLineno())    {    	non-compiled	[CE]  	83	None	replace
218	[BUG]  [BUGGY]  if(jsdocBuilder  ==  null  &&  jsdocBuilder.isLineno())  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder  ==  null  &&  jsdocBuilder.isLineno())  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder  ==  null  &&  jsdocBuilder.isLineno())  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.isLineno())    {    	non-compiled	[CE]  	83	None	replace
219	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.isLineno()  ||  jsdocBuilder.isLineno())  {  [CE]  [FE]                            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.isLineno()  ||  jsdocBuilder.isLineno())  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder.isLineno()  ||  jsdocBuilder.isLineno())  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.isLineno())    {    	non-compiled	[CE]  	83	None	replace
220	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.isEndLineno())  {  [CE]  [FE]                              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.isEndLineno())  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder.isEndLineno())  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.isLineno())    {    	non-compiled	[CE]  	83	None	replace
221	[BUG]  [BUGGY]  if(line!=  null  &&  jsdocBuilder.isLineno())  {  [CE]  [FE]                                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  null  &&  jsdocBuilder.isLineno())  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  null  &&  jsdocBuilder.isLineno())  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.isLineno())    {    	non-compiled	[CE]  	83	None	replace
222	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.isText())  {  [CE]  [FE]                                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.isText())  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder.isText())  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.isLineno())    {    	non-compiled	[CE]  	83	None	replace
223	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  lineno,  startCharno,  endLineno,  endCharno);  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  lineno,  startCharno,  endLineno,  endCharno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  lineno,  startCharno,  endLineno,  endCharno);	  jsdocBuilder.markText(token,    startLineno,    startCharno,    endLineno,    endCharno);    	non-compiled	[CE]  	9	None	replace
224	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  endLineno,  startCharno,  endLineno,  endCharno);  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  endLineno,  startCharno,  endLineno,  endCharno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  endLineno,  startCharno,  endLineno,  endCharno);	  jsdocBuilder.markText(token,    startLineno,    startCharno,    endLineno,    endCharno);    	non-compiled	[CE]  	9	None	replace
225	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  line,  startCharno,  endLineno,  endCharno);  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  line,  startCharno,  endLineno,  endCharno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  line,  startCharno,  endLineno,  endCharno);	  jsdocBuilder.markText(token,    startLineno,    startCharno,    endLineno,    endCharno);    	non-compiled	[CE]  	9	None	replace
226	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  line,  endCharno,  startLineno,  endCharno);  [CE]  [FE]                            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  line,  endCharno,  startLineno,  endCharno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  line,  endCharno,  startLineno,  endCharno);	  jsdocBuilder.markText(token,    startLineno,    startCharno,    endLineno,    endCharno);    	non-compiled	[CE]  	9	None	replace
227	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  startLineno,  endCharno,  endLineno,  endCharno);  [CE]  [FE]                              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  startLineno,  endCharno,  endLineno,  endCharno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  startLineno,  endCharno,  endLineno,  endCharno);	  jsdocBuilder.markText(token,    startLineno,    startCharno,    endLineno,    endCharno);    	non-compiled	[CE]  	9	None	replace
228	[BUG]  [BUGGY]  if(token!=  null  ||  jsdocBuilder.markText(token))  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  ||  jsdocBuilder.markText(token))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  ||  jsdocBuilder.markText(token))  {	  if(jsdocBuilder!=    null    ||    jsdocBuilder.markText(token))    {    	non-compiled	[CE]  	4	None	replace
229	[BUG]  [BUGGY]  if(token  ==  null  ||  token.length()!=  0)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  null  ||  token.length()!=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  null  ||  token.length()!=  0)  {	  if(line    ==    null    ||    token.length()    ==    0)    {    	non-compiled	[CE]  	25	None	replace
230	[BUG]  [BUGGY]  if(token  ==  null  ||  token.length()  <=  0)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  null  ||  token.length()  <=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  null  ||  token.length()  <=  0)  {	  if(line    ==    null    ||    token.length()    ==    0)    {    	non-compiled	[CE]  	25	None	replace
231	[BUG]  [BUGGY]  if(token  ==  null  ||  token.length()  >=  0)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  null  ||  token.length()  >=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  null  ||  token.length()  >=  0)  {	  if(line    ==    null    ||    token.length()    ==    0)    {    	non-compiled	[CE]  	25	None	replace
232	[BUG]  [BUGGY]  if(stream.getLineno()!=  0)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(stream.getLineno()!=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(stream.getLineno()!=  0)  {	  if(stream.getRemainingJSDocLine()!=    0)    {    	non-compiled	[CE]  	69	None	replace
233	[BUG]  [BUGGY]  if(stream.getCharno()!=  0)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(stream.getCharno()!=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(stream.getCharno()!=  0)  {	  if(stream.getRemainingJSDocLine()!=    0)    {    	non-compiled	[CE]  	69	None	replace
234	[BUG]  [BUGGY]  if(stream.getRemainingJSDocLine()!=  endCharno)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(stream.getRemainingJSDocLine()!=  endCharno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(stream.getRemainingJSDocLine()!=  endCharno)  {	  if(stream.getRemainingJSDocLine()!=    0)    {    	non-compiled	[CE]  	69	None	replace
235	[BUG]  [BUGGY]  if(stream.getLineno()  >=  0)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(stream.getLineno()  >=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(stream.getLineno()  >=  0)  {	  if(stream.getRemainingJSDocLine()!=    0)    {    	non-compiled	[CE]  	69	None	replace
236	[BUG]  [BUGGY]  if(line  ==  null  &&  token.length()  ==  0)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  ==  null  &&  token.length()  ==  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  ==  null  &&  token.length()  ==  0)  {	  if(line!=    null    ||    token.length()    ==    0)    {    	non-compiled	[CE]  	24	None	replace
237	[BUG]  [BUGGY]  if(line!=  null  &&  token.length()  ==  0)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  null  &&  token.length()  ==  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  null  &&  token.length()  ==  0)  {	  if(line!=    null    ||    token.length()    ==    0)    {    	non-compiled	[CE]  	24	None	replace
238	[BUG]  [BUGGY]  if(jsdocBuilder  ==  null  ||  builder.length()  >  0)  {  [CE]  [FE]                            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder  ==  null  ||  builder.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder  ==  null  ||  builder.length()  >  0)  {	  if(jsdocBuilder    ==    null    &&    builder.length()    >    0)    {    	non-compiled	[CE]  	57	None	replace
239	[BUG]  [BUGGY]  if(token  ==  null  &&  token.length()  >  0)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  null  &&  token.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  null  &&  token.length()  >  0)  {	  if(token!=    null    &&    token.length()    >    0)    {    	non-compiled	[CE]  	91	None	replace
240	[BUG]  [BUGGY]  if(token!=  null  &&  token.length()  >  0  &&  stream.getCharno()  ==  endCharno)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token.length()  >  0  &&  stream.getCharno()  ==  endCharno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token.length()  >  0  &&  stream.getCharno()  ==  endCharno)  {	  if(token!=    null    &&    token.length()    >    0)    {    	non-compiled	[CE]  	91	None	replace
241	[BUG]  [BUGGY]  if(line!=  null  &&  line.length()  ==  0)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  null  &&  line.length()  ==  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  null  &&  line.length()  ==  0)  {	  if(line!=    null    &&    line.length()    >    0)    {    	non-compiled	[CE]  	18	None	replace
242	[BUG]  [BUGGY]  if(line!=  null  &&  line.length()  <=  0)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  null  &&  line.length()  <=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  null  &&  line.length()  <=  0)  {	  if(line!=    null    &&    line.length()    >    0)    {    	non-compiled	[CE]  	18	None	replace
243	[BUG]  [BUGGY]  if(token!=  null  &&  line.length()  >  0)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  line.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  line.length()  >  0)  {	  if(line!=    null    &&    line.length()    >    0)    {    	non-compiled	[CE]  	18	None	replace
244	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  ||  builder.length()  ==  0)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  ||  builder.length()  ==  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  ||  builder.length()  ==  0)  {	  if(jsdocBuilder!=    null    ||    builder.length()    >    0)    {    	non-compiled	[CE]  	53	None	replace
245	[BUG]  [BUGGY]  JsDocToken  token  =  stream.getInitializingJSDocLine();  [CE]  [FE]                                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  JsDocToken  token  =  stream.getInitializingJSDocLine();  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	JsDocToken  token  =  stream.getInitializingJSDocLine();	  JsDocToken    token    =    stream.getRemainingJSDocLine();    	non-compiled	[CE]  	15	None	replace
246	[BUG]  [BUGGY]  JsDocToken  token  =  stream.getCharno();  [CE]  [FE]                                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  JsDocToken  token  =  stream.getCharno();  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	JsDocToken  token  =  stream.getCharno();	  JsDocToken    token    =    stream.getRemainingJSDocLine();    	non-compiled	[CE]  	15	None	replace
247	[BUG]  [BUGGY]  JsDocToken  token  =  stream.getRemainingJSDoc();  [CE]  [FE]                                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  JsDocToken  token  =  stream.getRemainingJSDoc();  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	JsDocToken  token  =  stream.getRemainingJSDoc();	  JsDocToken    token    =    stream.getRemainingJSDocLine();    	non-compiled	[CE]  	15	None	replace
248	[BUG]  [BUGGY]  JsDocToken  token  =  stream.getInitializingJSDoc();  [CE]  [FE]                                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  JsDocToken  token  =  stream.getInitializingJSDoc();  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	JsDocToken  token  =  stream.getInitializingJSDoc();	  JsDocToken    token    =    stream.getRemainingJSDocLine();    	non-compiled	[CE]  	15	None	replace
249	[BUG]  [BUGGY]  JsDocToken  token  =  stream.getFirstJSDoc();  [CE]  [FE]                                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  JsDocToken  token  =  stream.getFirstJSDoc();  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	JsDocToken  token  =  stream.getFirstJSDoc();	  JsDocToken    token    =    stream.getRemainingJSDocLine();    	non-compiled	[CE]  	15	None	replace
250	[BUG]  [BUGGY]  JsDocToken  token  =  stream.getNext();  [CE]  [FE]                                            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  JsDocToken  token  =  stream.getNext();  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	JsDocToken  token  =  stream.getNext();	  JsDocToken    token    =    stream.getRemainingJSDocLine();    	non-compiled	[CE]  	15	None	replace
251	[BUG]  [BUGGY]  if(token!=  null  &&  token!=  JsDocToken.FIELD_NAME)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token!=  JsDocToken.FIELD_NAME)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token!=  JsDocToken.FIELD_NAME)  {	  if(line!=    null    &&    token!=    JsDocToken.FIELD_NAME)    {    	non-compiled	[CE]  	80	None	replace
252	[BUG]  [BUGGY]  if(line  ==  null  &&  token!=  JsDocToken.FIELD_NAME)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  ==  null  &&  token!=  JsDocToken.FIELD_NAME)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  ==  null  &&  token!=  JsDocToken.FIELD_NAME)  {	  if(line!=    null    &&    token!=    JsDocToken.FIELD_NAME)    {    	non-compiled	[CE]  	80	None	replace
253	[BUG]  [BUGGY]  if(line!=  null  ||  token!=  JsDocToken.FIELD_NAME)  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  null  ||  token!=  JsDocToken.FIELD_NAME)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  null  ||  token!=  JsDocToken.FIELD_NAME)  {	  if(line!=    null    &&    token!=    JsDocToken.FIELD_NAME)    {    	non-compiled	[CE]  	80	None	replace
254	[BUG]  [BUGGY]  if(token!=  JsDocToken.FIELD_NAME  ||  token!=  JsDocToken.FIELD_NAME)  {  [CE]  [FE]                            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.FIELD_NAME  ||  token!=  JsDocToken.FIELD_NAME)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.FIELD_NAME  ||  token!=  JsDocToken.FIELD_NAME)  {	  if(line!=    null    &&    token!=    JsDocToken.FIELD_NAME)    {    	non-compiled	[CE]  	80	None	replace
255	[BUG]  [BUGGY]  if(line  ==  null  ||  token!=  JsDocToken.FIELD_NAME)  {  [CE]  [FE]                              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  ==  null  ||  token!=  JsDocToken.FIELD_NAME)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  ==  null  ||  token!=  JsDocToken.FIELD_NAME)  {	  if(line!=    null    &&    token!=    JsDocToken.FIELD_NAME)    {    	non-compiled	[CE]  	80	None	replace
256	[BUG]  [BUGGY]  if(endLineno  ==  startCharno  ||  endLineno  ==  endCharno)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endLineno  ==  startCharno  ||  endLineno  ==  endCharno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endLineno  ==  startCharno  ||  endLineno  ==  endCharno)  {	  if(endLineno    ==    startCharno)    {    	non-compiled	[CE]  	64	None	replace
257	[BUG]  [BUGGY]  if(endLineno  ==  endCharno)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endLineno  ==  endCharno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endLineno  ==  endCharno)  {	  if(endLineno    ==    startCharno)    {    	non-compiled	[CE]  	64	None	replace
258	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  ||  token!=  JsDocToken.END_ARRAY)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  ||  token!=  JsDocToken.END_ARRAY)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  ||  token!=  JsDocToken.END_ARRAY)  {	  if(jsdocBuilder!=    null    &&    token!=    JsDocToken.END_ARRAY)    {    	non-compiled	[CE]  	100	None	replace
259	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  token!=  JsDocToken.START_ARRAY)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  token!=  JsDocToken.START_ARRAY)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  token!=  JsDocToken.START_ARRAY)  {	  if(jsdocBuilder!=    null    &&    token!=    JsDocToken.END_ARRAY)    {    	non-compiled	[CE]  	100	None	replace
260	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  token!=  JsDocToken.START_OBJECT)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  token!=  JsDocToken.START_OBJECT)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  token!=  JsDocToken.START_OBJECT)  {	  if(jsdocBuilder!=    null    &&    token!=    JsDocToken.END_ARRAY)    {    	non-compiled	[CE]  	100	None	replace
261	[BUG]  [BUGGY]  if(line  ==  null  &&  token!=  JsDocToken.START_TOKEN)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  ==  null  &&  token!=  JsDocToken.START_TOKEN)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  ==  null  &&  token!=  JsDocToken.START_TOKEN)  {	  if(line!=    null    &&    token!=    JsDocToken.START_TOKEN)    {    	non-compiled	[CE]  	79	None	replace
262	[BUG]  [BUGGY]  if(token!=  null  &&  token!=  JsDocToken.START_TOKEN)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token!=  JsDocToken.START_TOKEN)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token!=  JsDocToken.START_TOKEN)  {	  if(line!=    null    &&    token!=    JsDocToken.START_TOKEN)    {    	non-compiled	[CE]  	79	None	replace
263	[BUG]  [BUGGY]  if(line!=  null  ||  token!=  JsDocToken.START_TOKEN)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  null  ||  token!=  JsDocToken.START_TOKEN)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  null  ||  token!=  JsDocToken.START_TOKEN)  {	  if(line!=    null    &&    token!=    JsDocToken.START_TOKEN)    {    	non-compiled	[CE]  	79	None	replace
264	[BUG]  [BUGGY]  if(line  ==  null  ||  token!=  JsDocToken.START_TOKEN)  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  ==  null  ||  token!=  JsDocToken.START_TOKEN)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  ==  null  ||  token!=  JsDocToken.START_TOKEN)  {	  if(line!=    null    &&    token!=    JsDocToken.START_TOKEN)    {    	non-compiled	[CE]  	79	None	replace
265	[BUG]  [BUGGY]  if(token!=  null  &&  builder!=  null)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  builder!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  builder!=  null)  {	  if(builder!=    null    &&    token!=    null)    {    	non-compiled	[CE]  	2	None	replace
266	[BUG]  [BUGGY]  if(builder!=  null  ||  token!=  null)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder!=  null  ||  token!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder!=  null  ||  token!=  null)  {	  if(builder!=    null    &&    token!=    null)    {    	non-compiled	[CE]  	2	None	replace
267	[BUG]  [BUGGY]  if(endCharno  ==  0  ||  endCharno  ==  endLineno)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endCharno  ==  0  ||  endCharno  ==  endLineno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endCharno  ==  0  ||  endCharno  ==  endLineno)  {	  if(endCharno    ==    0)    {    	non-compiled	[CE]  	45	None	replace
268	[BUG]  [BUGGY]  if(endCharno!=  0  ||  endCharno  ==  endLineno)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endCharno!=  0  ||  endCharno  ==  endLineno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endCharno!=  0  ||  endCharno  ==  endLineno)  {	  if(endCharno    ==    0)    {    	non-compiled	[CE]  	45	None	replace
269	[BUG]  [BUGGY]  if(token!=  null  &&  token.charAt(0)!=  '/')  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token.charAt(0)!=  '/')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token.charAt(0)!=  '/')  {	  if(token!=    null    &&    token.charAt(0)!='')    {    	non-compiled	[CE]  	96	None	replace
270	[BUG]  [BUGGY]  if(token!=  null  &&  token.charAt(0)!=  '-')  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token.charAt(0)!=  '-')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token.charAt(0)!=  '-')  {	  if(token!=    null    &&    token.charAt(0)!='')    {    	non-compiled	[CE]  	96	None	replace
271	[BUG]  [BUGGY]  if(token!=  null  &&  token.charAt(0)!=  'n')  {  [CE]  [FE]                            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token.charAt(0)!=  'n')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token.charAt(0)!=  'n')  {	  if(token!=    null    &&    token.charAt(0)!='')    {    	non-compiled	[CE]  	96	None	replace
272	[BUG]  [BUGGY]  if(token!=  null  ||  token.charAt(0)!=  '')  {  [CE]  [FE]                              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  ||  token.charAt(0)!=  '')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  ||  token.charAt(0)!=  '')  {	  if(token!=    null    &&    token.charAt(0)!='')    {    	non-compiled	[CE]  	96	None	replace
273	[BUG]  [BUGGY]  if(token!=  null  &&  token.length()!=  0)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token.length()!=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token.length()!=  0)  {	  if(token.length()!=    0)    {    	non-compiled	[CE]  	31	None	replace
274	[BUG]  [BUGGY]  if(line  ==  null  ||  line.charAt(line.length()  -  1)!='')  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  ==  null  ||  line.charAt(line.length()  -  1)!='')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  ==  null  ||  line.charAt(line.length()  -  1)!='')  {	  if(line    ==    null)    {    	non-compiled	[CE]  	3	None	replace
275	[BUG]  [BUGGY]  if(token!=  JsDocToken.START_OBJECT  ||  token!=  JsDocToken.END_ARRAY)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.START_OBJECT  ||  token!=  JsDocToken.END_ARRAY)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.START_OBJECT  ||  token!=  JsDocToken.END_ARRAY)  {	  if(line!=    null    &&    token!=    JsDocToken.END_ARRAY)    {    	non-compiled	[CE]  	77	None	replace
276	[BUG]  [BUGGY]  if(token!=  JsDocToken.START_ARRAY)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.START_ARRAY)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.START_ARRAY)  {	  if(line!=    null    &&    token!=    JsDocToken.END_ARRAY)    {    	non-compiled	[CE]  	77	None	replace
277	[BUG]  [BUGGY]  if(line!=  null  &&  line.length()  >=  0)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  null  &&  line.length()  >=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  null  &&  line.length()  >=  0)  {	  if(line!=    null    &&    line.length()    >    0)    {    	non-compiled	[CE]  	18	None	replace
278	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  ||  jsdocBuilder.length()  ==  0)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  ||  jsdocBuilder.length()  ==  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  ||  jsdocBuilder.length()  ==  0)  {	  if(jsdocBuilder!=    null    ||    builder.length()    >    0)    {    	non-compiled	[CE]  	53	None	replace
279	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  token  ==  null)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  token  ==  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  token  ==  null)  {	  if(jsdocBuilder!=    null    &&    token!=    null)    {    	non-compiled	[CE]  	101	None	replace
280	[BUG]  [BUGGY]  if(startLineno  >=  endLineno)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(startLineno  >=  endLineno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(startLineno  >=  endLineno)  {	  if(startLineno!=    endCharno)    {    	non-compiled	[CE]  	43	None	replace
281	[BUG]  [BUGGY]  if(jsdocBuilder  ==  null  &&  fileLevelJsDocBuilder!=  null)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder  ==  null  &&  fileLevelJsDocBuilder!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder  ==  null  &&  fileLevelJsDocBuilder!=  null)  {	  if(jsdocBuilder!=    null    &&    fileLevelJsDocBuilder!=    null)    {    	non-compiled	[CE]  	98	None	replace
282	[BUG]  [BUGGY]  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endCharno);  [CE]  [FE]                                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endCharno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endCharno);	  jsdocBuilder.markText(token,    line,    startLineno,    endCharno);    	non-compiled	[CE]  	14	None	replace
283	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  line,  startCharno,  endCharno);  [CE]  [FE]                                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  line,  startCharno,  endCharno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  line,  startCharno,  endCharno);	  jsdocBuilder.markText(token,    line,    startLineno,    endCharno);    	non-compiled	[CE]  	14	None	replace
284	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  startLineno,  endCharno,  line);  [CE]  [FE]                                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  startLineno,  endCharno,  line);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  startLineno,  endCharno,  line);	  jsdocBuilder.markText(token,    line,    startLineno,    endCharno);    	non-compiled	[CE]  	14	None	replace
285	[BUG]  [BUGGY]  if(line  ==  null  ||  line.length()  <  0)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  ==  null  ||  line.length()  <  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  ==  null  ||  line.length()  <  0)  {	  if(line!=    null    ||    line.length()    >    0)    {    	non-compiled	[CE]  	17	None	replace
286	[BUG]  [BUGGY]  if(endCharno!=  line)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endCharno!=  line)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endCharno!=  line)  {	  if(line!=    endCharno)    {    	non-compiled	[CE]  	87	None	replace
287	[BUG]  [BUGGY]  if(line  ==  null  ||  toString(token)  ==  null)  {  [CE]  [FE]            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  ==  null  ||  toString(token)  ==  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  ==  null  ||  toString(token)  ==  null)  {	  if(line    ==    null    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	22	None	replace
288	[BUG]  [BUGGY]  if(token  ==  JsDocToken.NO_UNREAD_TOKEN  ||  toString(token)!=  null)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  JsDocToken.NO_UNREAD_TOKEN  ||  toString(token)!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  JsDocToken.NO_UNREAD_TOKEN  ||  toString(token)!=  null)  {	  if(line    ==    null    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	22	None	replace
289	[BUG]  [BUGGY]  if(token  ==  NO_UNREAD_TOKEN  ||  toString(token)!=  null)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  NO_UNREAD_TOKEN  ||  toString(token)!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  NO_UNREAD_TOKEN  ||  toString(token)!=  null)  {	  if(line    ==    null    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	22	None	replace
290	[BUG]  [BUGGY]  if(toString  ==  null  ||  toString(token)!=  null)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(toString  ==  null  ||  toString(token)!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(toString  ==  null  ||  toString(token)!=  null)  {	  if(line    ==    null    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	22	None	replace
291	[BUG]  [BUGGY]  if(token  ==  JsDocToken.FIELD_NAME  ||  token  ==  JsDocToken.START_TOKEN)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  JsDocToken.FIELD_NAME  ||  token  ==  JsDocToken.START_TOKEN)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  JsDocToken.FIELD_NAME  ||  token  ==  JsDocToken.START_TOKEN)  {	  if(line    ==    null    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	22	None	replace
292	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  token  ==  JsDocToken.END_ARRAY)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  token  ==  JsDocToken.END_ARRAY)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  token  ==  JsDocToken.END_ARRAY)  {	  if(jsdocBuilder!=    null    &&    token!=    JsDocToken.END_ARRAY)    {    	non-compiled	[CE]  	100	None	replace
293	[BUG]  [BUGGY]  jsdocBuilder.markText(multilineText,  null,  startLineno,  startCharno,  endCharno);  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(multilineText,  null,  startLineno,  startCharno,  endCharno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(multilineText,  null,  startLineno,  startCharno,  endCharno);	  jsdocBuilder.markText(token,    null,    startLineno,    endCharno);    	non-compiled	[CE]  	85	None	replace
294	[BUG]  [BUGGY]  jsdocBuilder.markText(line,  null,  startLineno,  endCharno);  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(line,  null,  startLineno,  endCharno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(line,  null,  startLineno,  endCharno);	  jsdocBuilder.markText(token,    null,    startLineno,    endCharno);    	non-compiled	[CE]  	85	None	replace
295	[BUG]  [BUGGY]  if(endCharno  ==  charno)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endCharno  ==  charno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endCharno  ==  charno)  {	  if(endCharno    ==    startCharno)    {    	non-compiled	[CE]  	36	None	replace
296	[BUG]  [BUGGY]  if(jsDocBuilder!=  null  &&  jsdocBuilder.markText())  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsDocBuilder!=  null  &&  jsdocBuilder.markText())  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsDocBuilder!=  null  &&  jsdocBuilder.markText())  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.markText())    {    	non-compiled	[CE]  	81	None	replace
297	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&!jsdocBuilder.markText())  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&!jsdocBuilder.markText())  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&!jsdocBuilder.markText())  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.markText())    {    	non-compiled	[CE]  	81	None	replace
298	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  ||  jsdocBuilder.markText(toString))  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  ||  jsdocBuilder.markText(toString))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  ||  jsdocBuilder.markText(toString))  {	  if(jsdocBuilder!=    null    ||    jsdocBuilder.markText(token))    {    	non-compiled	[CE]  	4	None	replace
299	[BUG]  [BUGGY]  if(token  ==  null  ||  endCharno!=  charno)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  null  ||  endCharno!=  charno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  null  ||  endCharno!=  charno)  {	  if(line    ==    null    ||    token!=    null)    {    	non-compiled	[CE]  	23	None	replace
300	[BUG]  [BUGGY]  if(token  ==  null  ||  endCharno  ==  charno)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  null  ||  endCharno  ==  charno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  null  ||  endCharno  ==  charno)  {	  if(line    ==    null    ||    token!=    null)    {    	non-compiled	[CE]  	23	None	replace
301	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  ||  jsdocBuilder.markText(toString(line)))  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  ||  jsdocBuilder.markText(toString(line)))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  ||  jsdocBuilder.markText(toString(line)))  {	  if(jsdocBuilder!=    null    ||    jsdocBuilder.markText(toString(token)))    {    	non-compiled	[CE]  	5	None	replace
302	[BUG]  [BUGGY]  if(builder!=  null  &&  builder.length()  <  0)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder!=  null  &&  builder.length()  <  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder!=  null  &&  builder.length()  <  0)  {	  if(builder.length()    >=    0)    {    	non-compiled	[CE]  	30	None	replace
303	[BUG]  [BUGGY]  jsdocBuilder.appendToString(token);  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.appendToString(token);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.appendToString(token);	  jsdocBuilder.markText(token);    	non-compiled	[CE]  	10	None	replace
304	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  startLineno);  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  startLineno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  startLineno);	  jsdocBuilder.markText(token);    	non-compiled	[CE]  	10	None	replace
305	[BUG]  [BUGGY]  if(builder  ==  null  &&  builder.length()!=  0)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder  ==  null  &&  builder.length()!=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder  ==  null  &&  builder.length()!=  0)  {	  if(builder!=    null    &&    builder.length()!=    0)    {    	non-compiled	[CE]  	65	None	replace
306	[BUG]  [BUGGY]  if(stream.getRemainingJSDoc()!=  0)  {  [CE]  [FE]            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(stream.getRemainingJSDoc()!=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(stream.getRemainingJSDoc()!=  0)  {	  if(stream.getRemainingJSDocLine()    ==    0)    {    	non-compiled	[CE]  	68	None	replace
307	[BUG]  [BUGGY]  if(stream.getRemainingJSDoc()!=  null)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(stream.getRemainingJSDoc()!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(stream.getRemainingJSDoc()!=  null)  {	  if(stream.getRemainingJSDocLine()    ==    0)    {    	non-compiled	[CE]  	68	None	replace
308	[BUG]  [BUGGY]  if(builder  ==  null  ||  builder.length()  >=  0)  {  [CE]  [FE]            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder  ==  null  ||  builder.length()  >=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder  ==  null  ||  builder.length()  >=  0)  {	  if(builder!=    null    ||    builder.length()    >    0)    {    	non-compiled	[CE]  	48	None	replace
309	[BUG]  [BUGGY]  if(builder  ==  null  ||  builder.length()!=  0)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder  ==  null  ||  builder.length()!=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder  ==  null  ||  builder.length()!=  0)  {	  if(builder!=    null    ||    builder.length()    >    0)    {    	non-compiled	[CE]  	48	None	replace
310	[BUG]  [BUGGY]  if(line  ==  0)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  ==  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  ==  0)  {	  if(line    ==    endCharno)    {    	non-compiled	[CE]  	37	None	replace
311	[BUG]  [BUGGY]  if(sourceFile!=  null  &&  builder.length()  >  0)  {  [CE]  [FE]            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(sourceFile!=  null  &&  builder.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(sourceFile!=  null  &&  builder.length()  >  0)  {	  if(line!=    null    &&    builder.length()    >    0)    {    	non-compiled	[CE]  	89	None	replace
312	[BUG]  [BUGGY]  if(builder!=  null  &&  stream.length()  >  0)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder!=  null  &&  stream.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder!=  null  &&  stream.length()  >  0)  {	  if(line!=    null    &&    builder.length()    >    0)    {    	non-compiled	[CE]  	89	None	replace
313	[BUG]  [BUGGY]  JsDocToken  token  =  stream.getJsDocToken();  [CE]  [FE]                                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  JsDocToken  token  =  stream.getJsDocToken();  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	JsDocToken  token  =  stream.getJsDocToken();	  JsDocToken    token    =    stream.getRemainingJSDocLine();    	non-compiled	[CE]  	15	None	replace
314	[BUG]  [BUGGY]  JsDocToken  token  =  stream.getRemainingJSDoc(startLineno);  [CE]  [FE]                                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  JsDocToken  token  =  stream.getRemainingJSDoc(startLineno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	JsDocToken  token  =  stream.getRemainingJSDoc(startLineno);	  JsDocToken    token    =    stream.getRemainingJSDocLine();    	non-compiled	[CE]  	15	None	replace
315	[BUG]  [BUGGY]  JsDocToken  token  =  stream.getRemainingJSDocInfo();  [CE]  [FE]                                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  JsDocToken  token  =  stream.getRemainingJSDocInfo();  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	JsDocToken  token  =  stream.getRemainingJSDocInfo();	  JsDocToken    token    =    stream.getRemainingJSDocLine();    	non-compiled	[CE]  	15	None	replace
316	[BUG]  [BUGGY]  JsDocToken  token  =  stream.getFirstChild();  [CE]  [FE]                                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  JsDocToken  token  =  stream.getFirstChild();  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	JsDocToken  token  =  stream.getFirstChild();	  JsDocToken    token    =    stream.getRemainingJSDocLine();    	non-compiled	[CE]  	15	None	replace
317	[BUG]  [BUGGY]  if(endLineno  >=  0)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endLineno  >=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endLineno  >=  0)  {	  if(endCharno    >=    0)    {    	non-compiled	[CE]  	59	None	replace
318	[BUG]  [BUGGY]  if(endCharno!=  -1)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endCharno!=  -1)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endCharno!=  -1)  {	  if(endCharno    >=    0)    {    	non-compiled	[CE]  	59	None	replace
319	[BUG]  [BUGGY]  if(token!=  JsDocToken.VALUE_STRING  ||  token!=  JsDocToken.VALUE_NULL)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.VALUE_STRING  ||  token!=  JsDocToken.VALUE_NULL)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.VALUE_STRING  ||  token!=  JsDocToken.VALUE_NULL)  {	  if(token!=    JsDocToken.VALUE_NULL)    {    	non-compiled	[CE]  	29	None	replace
320	[BUG]  [BUGGY]  jsdocBuilder.markText(line,  endLineno,  startCharno,  endCharno);  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(line,  endLineno,  startCharno,  endCharno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(line,  endLineno,  startCharno,  endCharno);	  jsdocBuilder.markText(token,    startLineno,    endCharno,    endCharno);    	non-compiled	[CE]  	84	None	replace
321	[BUG]  [BUGGY]  if(endCharno!=  charno)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endCharno!=  charno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endCharno!=  charno)  {	  if(endCharno!=    endCharno)    {    	non-compiled	[CE]  	86	None	replace
322	[BUG]  [BUGGY]  if(line  ==  null  &&  token!=  JsDocToken.END_TOKEN)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  ==  null  &&  token!=  JsDocToken.END_TOKEN)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  ==  null  &&  token!=  JsDocToken.END_TOKEN)  {	  if(line!=    null    &&    token!=    JsDocToken.START_TOKEN)    {    	non-compiled	[CE]  	79	None	replace
323	[BUG]  [BUGGY]  if(builder.length()  ==  0  &&  toString(token)!=  null)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder.length()  ==  0  &&  toString(token)!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder.length()  ==  0  &&  toString(token)!=  null)  {	  if(builder.length()    ==    0    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	35	None	replace
324	[BUG]  [BUGGY]  if(toString.length()  ==  0  ||  builder.charAt(0)!='')  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(toString.length()  ==  0  ||  builder.charAt(0)!='')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(toString.length()  ==  0  ||  builder.charAt(0)!='')  {	  if(builder.length()    ==    0    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	35	None	replace
325	[BUG]  [BUGGY]  if(endCharno!=  'n'  ||  endCharno  ==  'r')  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endCharno!=  'n'  ||  endCharno  ==  'r')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endCharno!=  'n'  ||  endCharno  ==  'r')  {	  if(endCharno    =='')    {    	non-compiled	[CE]  	47	None	replace
326	[BUG]  [BUGGY]  if(endCharno!=''  ||  endCharno  ==  '-')  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endCharno!=''  ||  endCharno  ==  '-')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endCharno!=''  ||  endCharno  ==  '-')  {	  if(endCharno    =='')    {    	non-compiled	[CE]  	47	None	replace
327	[BUG]  [BUGGY]  if(endLineno!=  startCharno)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endLineno!=  startCharno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endLineno!=  startCharno)  {	  if(endLineno    ==    startCharno)    {    	non-compiled	[CE]  	64	None	replace
328	[BUG]  [BUGGY]  if(fileLevelJsDocBuilder!=  null  &&  fileLevelJsDocBuilder.length()  ==  0)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(fileLevelJsDocBuilder!=  null  &&  fileLevelJsDocBuilder.length()  ==  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(fileLevelJsDocBuilder!=  null  &&  fileLevelJsDocBuilder.length()  ==  0)  {	  if(jsdocBuilder!=    null    &&    fileLevelJsDocBuilder.length()    >    0)    {    	non-compiled	[CE]  	61	None	replace
329	[BUG]  [BUGGY]  if(fileLevelJsDocBuilder  ==  null  &&  fileLevelJsDocBuilder.length()  >  0)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(fileLevelJsDocBuilder  ==  null  &&  fileLevelJsDocBuilder.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(fileLevelJsDocBuilder  ==  null  &&  fileLevelJsDocBuilder.length()  >  0)  {	  if(jsdocBuilder!=    null    &&    fileLevelJsDocBuilder.length()    >    0)    {    	non-compiled	[CE]  	61	None	replace
330	[BUG]  [BUGGY]  if(fileLevelJsDocBuilder!=  null  ||  fileLevelJsDocBuilder.length()  >  0)  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(fileLevelJsDocBuilder!=  null  ||  fileLevelJsDocBuilder.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(fileLevelJsDocBuilder!=  null  ||  fileLevelJsDocBuilder.length()  >  0)  {	  if(jsdocBuilder!=    null    &&    fileLevelJsDocBuilder.length()    >    0)    {    	non-compiled	[CE]  	61	None	replace
331	[BUG]  [BUGGY]  if(fileLevelJsDocBuilder!=  null  &&  fileLevelJsDocBuilder.length()  <=  0)  {  [CE]  [FE]                            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(fileLevelJsDocBuilder!=  null  &&  fileLevelJsDocBuilder.length()  <=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(fileLevelJsDocBuilder!=  null  &&  fileLevelJsDocBuilder.length()  <=  0)  {	  if(jsdocBuilder!=    null    &&    fileLevelJsDocBuilder.length()    >    0)    {    	non-compiled	[CE]  	61	None	replace
332	[BUG]  [BUGGY]  if(builder.length()  <  0)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder.length()  <  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder.length()  <  0)  {	  if(builder.length()    <=    0)    {    	non-compiled	[CE]  	32	None	replace
333	[BUG]  [BUGGY]  if(builder  ==  null  &&  token!=  null)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder  ==  null  &&  token!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder  ==  null  &&  token!=  null)  {	  if(builder!=    null    &&    token!=    null)    {    	non-compiled	[CE]  	2	None	replace
334	[BUG]  [BUGGY]  if(token!=  null  &&  token.startsWith( "- ")||  token.startsWith( "-- "))  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token.startsWith( "- ")||  token.startsWith( "-- "))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token.startsWith( "- ")||  token.startsWith( "-- "))  {	  if(token!=    null    &&    token.startsWith(   "-   "))    {    	non-compiled	[CE]  	95	None	replace
335	[BUG]  [BUGGY]  if(token!=  null  &&  token.startsWith( ".xml "))  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token.startsWith( ".xml "))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token.startsWith( ".xml "))  {	  if(token!=    null    &&    token.startsWith(   "-   "))    {    	non-compiled	[CE]  	95	None	replace
336	[BUG]  [BUGGY]  if(token!=  null  &&  token.startsWith( ". "))  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token.startsWith( ". "))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token.startsWith( ". "))  {	  if(token!=    null    &&    token.startsWith(   "-   "))    {    	non-compiled	[CE]  	95	None	replace
337	[BUG]  [BUGGY]  if(token!=  null  &&  token.endsWith( "- "))  {  [CE]  [FE]                            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token.endsWith( "- "))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token.endsWith( "- "))  {	  if(token!=    null    &&    token.startsWith(   "-   "))    {    	non-compiled	[CE]  	95	None	replace
338	[BUG]  [BUGGY]  if(unreadToken!=  NO_UNREAD_TOKEN)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(unreadToken!=  NO_UNREAD_TOKEN)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(unreadToken!=  NO_UNREAD_TOKEN)  {	  if(token!=    NO_UNREAD_TOKEN)    {    	non-compiled	[CE]  	62	None	replace
339	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  line,  startLineno,  startCharno,  endLineno);  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  line,  startLineno,  startCharno,  endLineno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  line,  startLineno,  startCharno,  endLineno);	  jsdocBuilder.markText(line,    startLineno,    startCharno,    endLineno);    	non-compiled	[CE]  	67	None	replace
340	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText('  ')&&  token!=  null)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText('  ')&&  token!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder.markText('  ')&&  token!=  null)  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.markText('    '))    {    	non-compiled	[CE]  	82	None	replace
341	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText('  ')&&  toString(token)!=  null)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText('  ')&&  toString(token)!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder.markText('  ')&&  toString(token)!=  null)  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.markText('    '))    {    	non-compiled	[CE]  	82	None	replace
342	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  token!=  JsDocToken.FIELD_NAME)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  token!=  JsDocToken.FIELD_NAME)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  token!=  JsDocToken.FIELD_NAME)  {	  if(jsdocBuilder!=    null    &&    token!=    JsDocToken.VALUE_STRING)    {    	non-compiled	[CE]  	99	None	replace
343	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.isCharno())  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.isCharno())  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder.isCharno())  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.isLineno())    {    	non-compiled	[CE]  	83	None	replace
344	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markLineno())  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markLineno())  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder.markLineno())  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.isLineno())    {    	non-compiled	[CE]  	83	None	replace
345	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.getLineno()  >  0)  {  [CE]  [FE]                            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.getLineno()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder.getLineno()  >  0)  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.isLineno())    {    	non-compiled	[CE]  	83	None	replace
346	[BUG]  [BUGGY]  if(token!=  JsDocToken.START_OBJECT  ||  token!=  JsDocToken.FIELD_NAME)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.START_OBJECT  ||  token!=  JsDocToken.FIELD_NAME)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.START_OBJECT  ||  token!=  JsDocToken.FIELD_NAME)  {	  if(token!=    JsDocToken.FIELD_NAME)    {    	non-compiled	[CE]  	28	None	replace
347	[BUG]  [BUGGY]  if(token!=  JsDocToken.FIELD_NAME  ||  token!=  JsDocToken.START_TOKEN)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.FIELD_NAME  ||  token!=  JsDocToken.START_TOKEN)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.FIELD_NAME  ||  token!=  JsDocToken.START_TOKEN)  {	  if(token!=    JsDocToken.FIELD_NAME)    {    	non-compiled	[CE]  	28	None	replace
348	[BUG]  [BUGGY]  if(buffer!=  null  &&  buffer.length()  ==  0)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(buffer!=  null  &&  buffer.length()  ==  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(buffer!=  null  &&  buffer.length()  ==  0)  {	  if(buffer.length()    ==    0)    {    	non-compiled	[CE]  	34	None	replace
349	[BUG]  [BUGGY]  if(token  ==  null  ||  token.length()  >  0)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  null  ||  token.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  null  ||  token.length()  >  0)  {	  if(line    ==    null    ||    token.length()    ==    0)    {    	non-compiled	[CE]  	25	None	replace
350	[BUG]  [BUGGY]  if(stream.getRemainingJSDoc()  ==  0)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(stream.getRemainingJSDoc()  ==  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(stream.getRemainingJSDoc()  ==  0)  {	  if(stream.getRemainingJSDocLine()!=    0)    {    	non-compiled	[CE]  	69	None	replace
351	[BUG]  [BUGGY]  if(stream.getRemainingJSDocLine()!=  null)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(stream.getRemainingJSDocLine()!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(stream.getRemainingJSDocLine()!=  null)  {	  if(stream.getRemainingJSDocLine()!=    0)    {    	non-compiled	[CE]  	69	None	replace
352	[BUG]  [BUGGY]  if(builder!=  null  &&  token!=  JsDocToken.START_OBJECT)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder!=  null  &&  token!=  JsDocToken.START_OBJECT)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder!=  null  &&  token!=  JsDocToken.START_OBJECT)  {	  if(builder!=    null    &&    token!=    JsDocToken.END_ARRAY)    {    	non-compiled	[CE]  	103	None	replace
353	[BUG]  [BUGGY]  if(unreadToken  ==  NO_UNREAD_TOKEN)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(unreadToken  ==  NO_UNREAD_TOKEN)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(unreadToken  ==  NO_UNREAD_TOKEN)  {	  if(token    ==    NO_UNREAD_TOKEN)    {    	non-compiled	[CE]  	63	None	replace
354	[BUG]  [BUGGY]  if(token!=  null  &&  stream.getRemainingJSDocLine()  ==  null)  {  [CE]  [FE]            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  stream.getRemainingJSDocLine()  ==  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  stream.getRemainingJSDocLine()  ==  null)  {	  if(line!=    null    &&    token!=    null)    {    	non-compiled	[CE]  	75	None	replace
355	[BUG]  [BUGGY]  if(token!=  JsDocToken.START_OBJECT  ||  token!=  JsDocToken.START_TOKEN)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.START_OBJECT  ||  token!=  JsDocToken.START_TOKEN)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.START_OBJECT  ||  token!=  JsDocToken.START_TOKEN)  {	  if(token!=    JsDocToken.START_TOKEN)    {    	non-compiled	[CE]  	94	None	replace
356	[BUG]  [BUGGY]  if(token!=  JsDocToken.START_OBJECT  ||  token  ==  JsDocToken.START_TOKEN)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.START_OBJECT  ||  token  ==  JsDocToken.START_TOKEN)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.START_OBJECT  ||  token  ==  JsDocToken.START_TOKEN)  {	  if(token!=    JsDocToken.START_TOKEN)    {    	non-compiled	[CE]  	94	None	replace
357	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  line,  startLineno,  startCharno,  endLineno,  endCharno);  [CE]  [FE]                            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  line,  startLineno,  startCharno,  endLineno,  endCharno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  line,  startLineno,  startCharno,  endLineno,  endCharno);	  jsdocBuilder.markText(line,    startLineno,    startCharno,    endLineno,    endCharno);    	non-compiled	[CE]  	12	None	replace
358	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText(toString))  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText(toString))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder.markText(toString))  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.markText(token))    {    	non-compiled	[CE]  	8	None	replace
359	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markDocText(token))  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markDocText(token))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder.markDocText(token))  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.markText(token))    {    	non-compiled	[CE]  	8	None	replace
360	[BUG]  [BUGGY]  if(line.length()  <=  0  ||  toString(token)!=  null)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line.length()  <=  0  ||  toString(token)!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line.length()  <=  0  ||  toString(token)!=  null)  {	  if(line.length()    >    0    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	90	None	replace
361	[BUG]  [BUGGY]  if(stream!=  null)  {  [CE]  [FE]            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(stream!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(stream!=  null)  {	  if(line    >=    null)    {    	non-compiled	[CE]  	70	None	replace
362	[BUG]  [BUGGY]  if(token!=  JsDocToken.VALUE_STRING  ||  token!=  JsDocToken.START_TOKEN)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.VALUE_STRING  ||  token!=  JsDocToken.START_TOKEN)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.VALUE_STRING  ||  token!=  JsDocToken.START_TOKEN)  {	  if(token!=    JsDocToken.VALUE_STRING)    {    	non-compiled	[CE]  	93	None	replace
363	[BUG]  [BUGGY]  if(builder!=  null  &&  token  ==  JsDocToken.VALUE_STRING)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder!=  null  &&  token  ==  JsDocToken.VALUE_STRING)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder!=  null  &&  token  ==  JsDocToken.VALUE_STRING)  {	  if(builder!=    null    &&    token!=    JsDocToken.VALUE_STRING)    {    	non-compiled	[CE]  	102	None	replace
364	[BUG]  [BUGGY]  if(builder  ==  null  &&  token!=  JsDocToken.VALUE_STRING)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder  ==  null  &&  token!=  JsDocToken.VALUE_STRING)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder  ==  null  &&  token!=  JsDocToken.VALUE_STRING)  {	  if(builder!=    null    &&    token!=    JsDocToken.VALUE_STRING)    {    	non-compiled	[CE]  	102	None	replace
365	[BUG]  [BUGGY]  if(stream.getCharno()  =='')  {  [CE]  [FE]            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(stream.getCharno()  =='')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(stream.getCharno()  =='')  {	  if(stream.getRemainingJSDocLine()    ==    0)    {    	non-compiled	[CE]  	68	None	replace
366	[BUG]  [BUGGY]  if(stream.getCharno()  ==''  ||  stream.getRemainingJSDocLine()  ==  0)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(stream.getCharno()  ==''  ||  stream.getRemainingJSDocLine()  ==  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(stream.getCharno()  ==''  ||  stream.getRemainingJSDocLine()  ==  0)  {	  if(stream.getRemainingJSDocLine()    ==    0)    {    	non-compiled	[CE]  	68	None	replace
367	[BUG]  [BUGGY]  if(line!=  null  &&  token.length()  >  0)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  null  &&  token.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  null  &&  token.length()  >  0)  {	  if(line!=    null    &&    line.length()    >    0)    {    	non-compiled	[CE]  	18	None	replace
368	[BUG]  [BUGGY]  if(endCharno!=  lineno)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endCharno!=  lineno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endCharno!=  lineno)  {	  if(endCharno    ==    startCharno)    {    	non-compiled	[CE]  	36	None	replace
369	[BUG]  [BUGGY]  if(token!=  JsDocToken.VALUE_NULL  ||  token.length()  ==  0)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.VALUE_NULL  ||  token.length()  ==  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.VALUE_NULL  ||  token.length()  ==  0)  {	  if(token!=    null    ||    token.length()    ==    0)    {    	non-compiled	[CE]  	27	None	replace
370	[BUG]  [BUGGY]  if(token!=  JsDocToken.START_TOKEN  &&  token.length()  ==  0)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.START_TOKEN  &&  token.length()  ==  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.START_TOKEN  &&  token.length()  ==  0)  {	  if(token!=    null    ||    token.length()    ==    0)    {    	non-compiled	[CE]  	27	None	replace
371	[BUG]  [BUGGY]  if(token!=  JsDocToken.START_TOKEN  ||  token.length()  ==  0)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.START_TOKEN  ||  token.length()  ==  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.START_TOKEN  ||  token.length()  ==  0)  {	  if(token!=    null    ||    token.length()    ==    0)    {    	non-compiled	[CE]  	27	None	replace
372	[BUG]  [BUGGY]  if(token!=  JsDocToken.FIELD_NAME  &&  token!=  JsDocToken.END_ARRAY)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.FIELD_NAME  &&  token!=  JsDocToken.END_ARRAY)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.FIELD_NAME  &&  token!=  JsDocToken.END_ARRAY)  {	  if(token!=    JsDocToken.FIELD_NAME)    {    	non-compiled	[CE]  	28	None	replace
373	[BUG]  [BUGGY]  if(token!=  JsDocToken.FIELD_NAME  &&  token!=  JsDocToken.VALUE_STRING)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.FIELD_NAME  &&  token!=  JsDocToken.VALUE_STRING)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.FIELD_NAME  &&  token!=  JsDocToken.VALUE_STRING)  {	  if(line!=    null    &&    token!=    JsDocToken.VALUE_STRING)    {    	non-compiled	[CE]  	76	None	replace
374	[BUG]  [BUGGY]  if(token!=  JsDocToken.VALUE_STRING  ||  token!=  JsDocToken.VALUE_TOKEN)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.VALUE_STRING  ||  token!=  JsDocToken.VALUE_TOKEN)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.VALUE_STRING  ||  token!=  JsDocToken.VALUE_TOKEN)  {	  if(line!=    null    &&    token!=    JsDocToken.VALUE_STRING)    {    	non-compiled	[CE]  	76	None	replace
375	[BUG]  [BUGGY]  if(token!=  JsDocToken.VALUE_STRING  &&  token!=  JsDocToken.START_TOKEN)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.VALUE_STRING  &&  token!=  JsDocToken.START_TOKEN)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.VALUE_STRING  &&  token!=  JsDocToken.START_TOKEN)  {	  if(line!=    null    &&    token!=    JsDocToken.VALUE_STRING)    {    	non-compiled	[CE]  	76	None	replace
376	[BUG]  [BUGGY]  if(line  ==  null  ||  endCharno  <  0)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  ==  null  ||  endCharno  <  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  ==  null  ||  endCharno  <  0)  {	  if(line!=    null    ||    line.length()    >    0)    {    	non-compiled	[CE]  	17	None	replace
377	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText(toString(token))  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText(toString(token))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder.markText(toString(token))  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.markText(token))    {    	non-compiled	[CE]  	8	None	replace
378	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markDocToken(token))  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markDocToken(token))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder.markDocToken(token))  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.markText(token))    {    	non-compiled	[CE]  	8	None	replace
379	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markDocLineno(token))  {  [CE]  [FE]                            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markDocLineno(token))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder.markDocLineno(token))  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.markText(token))    {    	non-compiled	[CE]  	8	None	replace
380	[BUG]  [BUGGY]  if(line  ==  null  ||  builder.length()  >  0)  {  [CE]  [FE]            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  ==  null  ||  builder.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  ==  null  ||  builder.length()  >  0)  {	  if(line!=    null    &&    builder.length()    >    0)    {    	non-compiled	[CE]  	89	None	replace
381	[BUG]  [BUGGY]  if(token  ==  JsDocToken.START_LINE  ||  token!=  JsDocToken.END_LINE)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  JsDocToken.START_LINE  ||  token!=  JsDocToken.END_LINE)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  JsDocToken.START_LINE  ||  token!=  JsDocToken.END_LINE)  {	  if(line    ==    null    ||    token!=    null)    {    	non-compiled	[CE]  	23	None	replace
382	[BUG]  [BUGGY]  if(jsDocToken!=  null  &&  jsdocBuilder.markText(token))  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsDocToken!=  null  &&  jsdocBuilder.markText(token))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsDocToken!=  null  &&  jsdocBuilder.markText(token))  {	  if(jsdocBuilder!=    null    ||    jsdocBuilder.markText(token))    {    	non-compiled	[CE]  	4	None	replace
383	[BUG]  [BUGGY]  if(token!=  JsDocToken.END_ARRAY  ||  token!=  JsDocToken.END_ARRAY)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.END_ARRAY  ||  token!=  JsDocToken.END_ARRAY)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.END_ARRAY  ||  token!=  JsDocToken.END_ARRAY)  {	  if(jsdocBuilder!=    null    ||    jsdocBuilder.markText(token))    {    	non-compiled	[CE]  	4	None	replace
384	[BUG]  [BUGGY]  if(token!=  JsDocToken.FIELD_NAME  &&  token!=  JsDocToken.START_TOKEN)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.FIELD_NAME  &&  token!=  JsDocToken.START_TOKEN)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.FIELD_NAME  &&  token!=  JsDocToken.START_TOKEN)  {	  if(line!=    null    &&    token!=    JsDocToken.START_TOKEN)    {    	non-compiled	[CE]  	79	None	replace
385	[BUG]  [BUGGY]  if(line!=  null  &&  token  ==  JsDocToken.START_TOKEN)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  null  &&  token  ==  JsDocToken.START_TOKEN)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  null  &&  token  ==  JsDocToken.START_TOKEN)  {	  if(line!=    null    &&    token!=    JsDocToken.START_TOKEN)    {    	non-compiled	[CE]  	79	None	replace
386	[BUG]  [BUGGY]  if(line!=  null  &&  token!=  JsDocToken.END_TOKEN)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  null  &&  token!=  JsDocToken.END_TOKEN)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  null  &&  token!=  JsDocToken.END_TOKEN)  {	  if(line!=    null    &&    token!=    JsDocToken.START_TOKEN)    {    	non-compiled	[CE]  	79	None	replace
387	[BUG]  [BUGGY]  if(line  >=  endCharno)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  >=  endCharno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  >=  endCharno)  {	  if(line!=    endCharno)    {    	non-compiled	[CE]  	87	None	replace
388	[BUG]  [BUGGY]  if(builder.length()  <=  0  ||  stream.getCharno()!=  endCharno)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder.length()  <=  0  ||  stream.getCharno()!=  endCharno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder.length()  <=  0  ||  stream.getCharno()!=  endCharno)  {	  if(builder.length()    <=    0)    {    	non-compiled	[CE]  	32	None	replace
389	[BUG]  [BUGGY]  if(builder.length()  <=  0  ||  token!=  null)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder.length()  <=  0  ||  token!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder.length()  <=  0  ||  token!=  null)  {	  if(builder.length()    <=    0)    {    	non-compiled	[CE]  	32	None	replace
390	[BUG]  [BUGGY]  if(stream.getCharno()!='')  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(stream.getCharno()!='')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(stream.getCharno()!='')  {	  if(stream.getRemainingJSDocLine()!=    0)    {    	non-compiled	[CE]  	69	None	replace
391	[BUG]  [BUGGY]  if(stream.getRemainingJSDocLine()!=  0  ||  stream.getCharno()!=  endCharno)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(stream.getRemainingJSDocLine()!=  0  ||  stream.getCharno()!=  endCharno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(stream.getRemainingJSDocLine()!=  0  ||  stream.getCharno()!=  endCharno)  {	  if(stream.getRemainingJSDocLine()!=    0)    {    	non-compiled	[CE]  	69	None	replace
392	[BUG]  [BUGGY]  if(stream.getRemainingJSDocLine()!=  0  ||  stream.getCharno()  ==  endCharno)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(stream.getRemainingJSDocLine()!=  0  ||  stream.getCharno()  ==  endCharno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(stream.getRemainingJSDocLine()!=  0  ||  stream.getCharno()  ==  endCharno)  {	  if(stream.getRemainingJSDocLine()!=    0)    {    	non-compiled	[CE]  	69	None	replace
393	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  token!=  null  &&  token.length()  >  0)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  token!=  null  &&  token.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  token!=  null  &&  token.length()  >  0)  {	  if(jsdocBuilder!=    null    &&    token!=    null)    {    	non-compiled	[CE]  	101	None	replace
394	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  token!=  null  &&  token.charAt(token.length()  -  1)!='')  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  token!=  null  &&  token.charAt(token.length()  -  1)!='')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  token!=  null  &&  token.charAt(token.length()  -  1)!='')  {	  if(jsdocBuilder!=    null    &&    token!=    null)    {    	non-compiled	[CE]  	101	None	replace
395	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  token!=  null  &&  toString(token)!=  null)  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  token!=  null  &&  toString(token)!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  token!=  null  &&  toString(token)!=  null)  {	  if(jsdocBuilder!=    null    &&    token!=    null)    {    	non-compiled	[CE]  	101	None	replace
396	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  token!=  null  &&  token.equals( " "))  {  [CE]  [FE]                            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  token!=  null  &&  token.equals( " "))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  token!=  null  &&  token.equals( " "))  {	  if(jsdocBuilder!=    null    &&    token!=    null)    {    	non-compiled	[CE]  	101	None	replace
397	[BUG]  [BUGGY]  jsdocBuilder.markText(toString(token));  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(toString(token));  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(toString(token));	  jsdocBuilder.markText(token);    	non-compiled	[CE]  	10	None	replace
398	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  stream.getCharno());  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  stream.getCharno());  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  stream.getCharno());	  jsdocBuilder.markText(token);    	non-compiled	[CE]  	10	None	replace
399	[BUG]  [BUGGY]  jsdocBuilder.append( ", ");  [CE]  [FE]                            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.append( ", ");  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.append( ", ");	  jsdocBuilder.markText(token);    	non-compiled	[CE]  	10	None	replace
400	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  token!=  JsDocToken.VALUE_STRING  &&  token!=  JsDocToken.FIELD_NAME)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  token!=  JsDocToken.VALUE_STRING  &&  token!=  JsDocToken.FIELD_NAME)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  token!=  JsDocToken.VALUE_STRING  &&  token!=  JsDocToken.FIELD_NAME)  {	  if(jsdocBuilder!=    null    &&    token!=    JsDocToken.VALUE_STRING)    {    	non-compiled	[CE]  	99	None	replace
401	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  token!=  JsDocToken.VALUE_STRING  &&  token!=  JsDocToken.START_OBJECT)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  token!=  JsDocToken.VALUE_STRING  &&  token!=  JsDocToken.START_OBJECT)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  token!=  JsDocToken.VALUE_STRING  &&  token!=  JsDocToken.START_OBJECT)  {	  if(jsdocBuilder!=    null    &&    token!=    JsDocToken.VALUE_STRING)    {    	non-compiled	[CE]  	99	None	replace
402	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  token!=  JsDocToken.VALUE_STRING  &&  token!=  JsDocToken.END_ARRAY)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  token!=  JsDocToken.VALUE_STRING  &&  token!=  JsDocToken.END_ARRAY)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  token!=  JsDocToken.VALUE_STRING  &&  token!=  JsDocToken.END_ARRAY)  {	  if(jsdocBuilder!=    null    &&    token!=    JsDocToken.VALUE_STRING)    {    	non-compiled	[CE]  	99	None	replace
403	[BUG]  [BUGGY]  if(token!=  JsDocToken.START_OBJECT  &&  token!=  JsDocToken.END_ARRAY)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.START_OBJECT  &&  token!=  JsDocToken.END_ARRAY)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.START_OBJECT  &&  token!=  JsDocToken.END_ARRAY)  {	  if(line!=    null    &&    token!=    JsDocToken.END_ARRAY)    {    	non-compiled	[CE]  	77	None	replace
404	[BUG]  [BUGGY]  if(builder!=  null  &&  builder.charAt(0)!='')  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder!=  null  &&  builder.charAt(0)!='')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder!=  null  &&  builder.charAt(0)!='')  {	  if(builder!=    null    &&    builder.length()!=    0)    {    	non-compiled	[CE]  	65	None	replace
405	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText('  ')&&  token!=  JsDocToken.END_ARRAY)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText('  ')&&  token!=  JsDocToken.END_ARRAY)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder.markText('  ')&&  token!=  JsDocToken.END_ARRAY)  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.markText('    '))    {    	non-compiled	[CE]  	82	None	replace
406	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText('  ')&&  toString(token)!=  JsDocToken.END_ARRAY)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText('  ')&&  toString(token)!=  JsDocToken.END_ARRAY)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder.markText('  ')&&  toString(token)!=  JsDocToken.END_ARRAY)  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.markText('    '))    {    	non-compiled	[CE]  	82	None	replace
407	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText('  ')&&  token!=  JsDocToken.VALUE_STRING)  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText('  ')&&  token!=  JsDocToken.VALUE_STRING)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder.markText('  ')&&  token!=  JsDocToken.VALUE_STRING)  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.markText('    '))    {    	non-compiled	[CE]  	82	None	replace
408	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&!jsdocBuilder.markText('  '))  {  [CE]  [FE]                            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&!jsdocBuilder.markText('  '))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&!jsdocBuilder.markText('  '))  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.markText('    '))    {    	non-compiled	[CE]  	82	None	replace
409	[BUG]  [BUGGY]  if(builder!=  null  &&  token!=  JsDocToken.FIELD_NAME)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder!=  null  &&  token!=  JsDocToken.FIELD_NAME)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder!=  null  &&  token!=  JsDocToken.FIELD_NAME)  {	  if(builder!=    null    &&    token!=    JsDocToken.VALUE_STRING)    {    	non-compiled	[CE]  	102	None	replace
410	[BUG]  [BUGGY]  if(token!=  JsDocToken.STRING)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.STRING)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.STRING)  {	  if(token!=    NO_UNREAD_TOKEN)    {    	non-compiled	[CE]  	62	None	replace
411	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  ||  jsdocBuilder.markText('  ')&&  token!=  JsDocToken.END_ARRAY)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  ||  jsdocBuilder.markText('  ')&&  token!=  JsDocToken.END_ARRAY)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  ||  jsdocBuilder.markText('  ')&&  token!=  JsDocToken.END_ARRAY)  {	  if(jsdocBuilder!=    null    ||    jsdocBuilder.markText('    '))    {    	non-compiled	[CE]  	7	None	replace
412	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  ||  jsdocBuilder.markText('  ')&&  token!=  JsDocToken.VALUE_STRING)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  ||  jsdocBuilder.markText('  ')&&  token!=  JsDocToken.VALUE_STRING)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  ||  jsdocBuilder.markText('  ')&&  token!=  JsDocToken.VALUE_STRING)  {	  if(jsdocBuilder!=    null    ||    jsdocBuilder.markText('    '))    {    	non-compiled	[CE]  	7	None	replace
413	[BUG]  [BUGGY]  if(line!=  0)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  0)  {	  if(endCharno!=    0)    {    	non-compiled	[CE]  	58	None	replace
414	[BUG]  [BUGGY]  if(endCharno!=  0  &&  token!=  null)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endCharno!=  0  &&  token!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endCharno!=  0  &&  token!=  null)  {	  if(endCharno!=    0)    {    	non-compiled	[CE]  	58	None	replace
415	[BUG]  [BUGGY]  if(line!=  null  &&  fileLevelJsDocBuilder.length()  >  0)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  null  &&  fileLevelJsDocBuilder.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  null  &&  fileLevelJsDocBuilder.length()  >  0)  {	  if(jsdocBuilder!=    null    &&    fileLevelJsDocBuilder.length()    >    0)    {    	non-compiled	[CE]  	61	None	replace
416	[BUG]  [BUGGY]  if(fileLevelJsDocBuilder!=  null  &&  builder.length()  >  0)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(fileLevelJsDocBuilder!=  null  &&  builder.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(fileLevelJsDocBuilder!=  null  &&  builder.length()  >  0)  {	  if(jsdocBuilder!=    null    &&    fileLevelJsDocBuilder.length()    >    0)    {    	non-compiled	[CE]  	61	None	replace
417	[BUG]  [BUGGY]  if(builder.length()  >  0  ||  toString(token)!=  null)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder.length()  >  0  ||  toString(token)!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder.length()  >  0  ||  toString(token)!=  null)  {	  if(builder.length()    ==    0    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	35	None	replace
418	[BUG]  [BUGGY]  if(jsdocBuilder.length()  ==  0  ||  toString(token)!=  null)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder.length()  ==  0  ||  toString(token)!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder.length()  ==  0  ||  toString(token)!=  null)  {	  if(builder.length()    ==    0    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	35	None	replace
419	[BUG]  [BUGGY]  if(line  >=  endLineno)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  >=  endLineno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  >=  endLineno)  {	  if(line!=    endLineno)    {    	non-compiled	[CE]  	74	None	replace
420	[BUG]  [BUGGY]  if(line!=  endLineno  ||  line  ==  endCharno)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  endLineno  ||  line  ==  endCharno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  endLineno  ||  line  ==  endCharno)  {	  if(line!=    endLineno)    {    	non-compiled	[CE]  	74	None	replace
421	[BUG]  [BUGGY]  if(token!=  null  &&  token!=  null  &&  token.length()  >  0)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token!=  null  &&  token.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token!=  null  &&  token.length()  >  0)  {	  if(builder    ==    null    &&    builder.length()    >    0)    {    	non-compiled	[CE]  	49	None	replace
422	[BUG]  [BUGGY]  if(builder  ==  null  &&  builder.length()  ==  0)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder  ==  null  &&  builder.length()  ==  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder  ==  null  &&  builder.length()  ==  0)  {	  if(builder!=    null    &&    builder.length()    ==    0)    {    	non-compiled	[CE]  	50	None	replace
423	[BUG]  [BUGGY]  if(builder!=  null  &&  builder.charAt(0)  =='')  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder!=  null  &&  builder.charAt(0)  =='')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder!=  null  &&  builder.charAt(0)  =='')  {	  if(builder!=    null    &&    builder.length()    ==    0)    {    	non-compiled	[CE]  	50	None	replace
424	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  charno,  startCharno,  endLineno,  endCharno);  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  charno,  startCharno,  endLineno,  endCharno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  charno,  startCharno,  endLineno,  endCharno);	  jsdocBuilder.markText(token,    startLineno,    startCharno,    endLineno,    endCharno);    	non-compiled	[CE]  	9	None	replace
425	[BUG]  [BUGGY]  jsdocBuilder.markText(token,  charno,  endCharno,  lineno,  endCharno);  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  jsdocBuilder.markText(token,  charno,  endCharno,  lineno,  endCharno);  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	jsdocBuilder.markText(token,  charno,  endCharno,  lineno,  endCharno);	  jsdocBuilder.markText(token,    startLineno,    startCharno,    endLineno,    endCharno);    	non-compiled	[CE]  	9	None	replace
426	[BUG]  [BUGGY]  if(token!=  null  &&  token.length()  >  0  &&  isEnabled(Feature.QUOTE_FIELD_NAMES))  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token.length()  >  0  &&  isEnabled(Feature.QUOTE_FIELD_NAMES))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token.length()  >  0  &&  isEnabled(Feature.QUOTE_FIELD_NAMES))  {	  if(token!=    null    &&    token.length()    >    0)    {    	non-compiled	[CE]  	91	None	replace
427	[BUG]  [BUGGY]  if(token!=  null  &&  token.length()  >  0  &&  token.charAt(token.length()  -  1)!='')  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token.length()  >  0  &&  token.charAt(token.length()  -  1)!='')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token.length()  >  0  &&  token.charAt(token.length()  -  1)!='')  {	  if(token!=    null    &&    token.length()    >    0)    {    	non-compiled	[CE]  	91	None	replace
428	[BUG]  [BUGGY]  if(token!=  JsDocToken.VALUE_NUMBER)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.VALUE_NUMBER)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.VALUE_NUMBER)  {	  if(line!=    null    &&    token!=    JsDocToken.VALUE_NULL)    {    	non-compiled	[CE]  	78	None	replace
429	[BUG]  [BUGGY]  if(builder  ==  null  &&  builder.length()  <=  0)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder  ==  null  &&  builder.length()  <=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder  ==  null  &&  builder.length()  <=  0)  {	  if(builder!=    null    &&    builder.length()    <=    0)    {    	non-compiled	[CE]  	51	None	replace
430	[BUG]  [BUGGY]  if(endLineno!=  endCharno)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endLineno!=  endCharno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endLineno!=  endCharno)  {	  if(endLineno    ==    startCharno)    {    	non-compiled	[CE]  	64	None	replace
431	[BUG]  [BUGGY]  if(endLineno!=  line)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endLineno!=  line)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endLineno!=  line)  {	  if(endLineno    ==    startCharno)    {    	non-compiled	[CE]  	64	None	replace
432	[BUG]  [BUGGY]  if(line!=  null  &&  token!=  null  &&  token.length()  >  0)  {  [CE]  [FE]            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  null  &&  token!=  null  &&  token.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  null  &&  token!=  null  &&  token.length()  >  0)  {	  if(line!=    null    &&    token!=    null)    {    	non-compiled	[CE]  	75	None	replace
433	[BUG]  [BUGGY]  if(line!=  null  &&  token!=  null  &&  token.equals( " "))  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  null  &&  token!=  null  &&  token.equals( " "))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  null  &&  token!=  null  &&  token.equals( " "))  {	  if(line!=    null    &&    token!=    null)    {    	non-compiled	[CE]  	75	None	replace
434	[BUG]  [BUGGY]  if(token!=  null  &&  token.startsWith( ".jsdoc. "))  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token.startsWith( ".jsdoc. "))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token.startsWith( ".jsdoc. "))  {	  if(token!=    null    &&    token.startsWith(   "-   "))    {    	non-compiled	[CE]  	95	None	replace
435	[BUG]  [BUGGY]  JsDocToken  token  =  stream.getLineno();  [CE]  [FE]                                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  JsDocToken  token  =  stream.getLineno();  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	JsDocToken  token  =  stream.getLineno();	  JsDocToken    token    =    stream.getRemainingJSDocLine();    	non-compiled	[CE]  	15	None	replace
436	[BUG]  [BUGGY]  if(token!=  JsDocToken.VALUE_STRING  &&  token!=  JsDocToken.START_OBJECT)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.VALUE_STRING  &&  token!=  JsDocToken.START_OBJECT)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.VALUE_STRING  &&  token!=  JsDocToken.START_OBJECT)  {	  if(token!=    JsDocToken.VALUE_STRING)    {    	non-compiled	[CE]  	93	None	replace
437	[BUG]  [BUGGY]  if(token!=  JsDocToken.VALUE_STRING  &&  token!=  JsDocToken.END_ARRAY)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.VALUE_STRING  &&  token!=  JsDocToken.END_ARRAY)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.VALUE_STRING  &&  token!=  JsDocToken.END_ARRAY)  {	  if(token!=    JsDocToken.VALUE_STRING)    {    	non-compiled	[CE]  	93	None	replace
438	[BUG]  [BUGGY]  if(token!=  JsDocToken.START_OBJECT  ||  token!=  JsDocToken.VALUE_STRING)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.START_OBJECT  ||  token!=  JsDocToken.VALUE_STRING)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.START_OBJECT  ||  token!=  JsDocToken.VALUE_STRING)  {	  if(token!=    JsDocToken.VALUE_STRING)    {    	non-compiled	[CE]  	93	None	replace
439	[BUG]  [BUGGY]  if(token!=  JsDocToken.VALUE_STRING  &&  token!=  null)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.VALUE_STRING  &&  token!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.VALUE_STRING  &&  token!=  null)  {	  if(token!=    JsDocToken.VALUE_STRING)    {    	non-compiled	[CE]  	93	None	replace
440	[BUG]  [BUGGY]  if(token!=  JsDocToken.START_TOKEN  &&  token!=  JsDocToken.START_OBJECT)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.START_TOKEN  &&  token!=  JsDocToken.START_OBJECT)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.START_TOKEN  &&  token!=  JsDocToken.START_OBJECT)  {	  if(token!=    JsDocToken.START_TOKEN)    {    	non-compiled	[CE]  	94	None	replace
441	[BUG]  [BUGGY]  if(token!=  JsDocToken.START_TOKEN  &&  token!=  JsDocToken.FIELD_NAME)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.START_TOKEN  &&  token!=  JsDocToken.FIELD_NAME)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.START_TOKEN  &&  token!=  JsDocToken.FIELD_NAME)  {	  if(token!=    JsDocToken.START_TOKEN)    {    	non-compiled	[CE]  	94	None	replace
442	[BUG]  [BUGGY]  if(token!=  JsDocToken.START_TOKEN  &&  token!=  JsDocToken.END_ARRAY)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.START_TOKEN  &&  token!=  JsDocToken.END_ARRAY)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.START_TOKEN  &&  token!=  JsDocToken.END_ARRAY)  {	  if(token!=    JsDocToken.START_TOKEN)    {    	non-compiled	[CE]  	94	None	replace
443	[BUG]  [BUGGY]  if(line!=  startCharno)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  startCharno)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  startCharno)  {	  if(line    ==    startCharno)    {    	non-compiled	[CE]  	73	None	replace
444	[BUG]  [BUGGY]  if(endCharno!=  'n'  ||  endCharno  ==  'r'  ||  endCharno  ==  'n'  ||  endCharno  ==  't')  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endCharno!=  'n'  ||  endCharno  ==  'r'  ||  endCharno  ==  'n'  ||  endCharno  ==  't')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endCharno!=  'n'  ||  endCharno  ==  'r'  ||  endCharno  ==  'n'  ||  endCharno  ==  't')  {	  if(endCharno    =='')    {    	non-compiled	[CE]  	47	None	replace
445	[BUG]  [BUGGY]  if(endCharno!=  'n'  ||  endCharno  ==  'r'  ||  endCharno  ==  'n'  ||  endCharno  ==  'n'  ||  endCharno  ==  't')  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endCharno!=  'n'  ||  endCharno  ==  'r'  ||  endCharno  ==  'n'  ||  endCharno  ==  'n'  ||  endCharno  ==  't')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endCharno!=  'n'  ||  endCharno  ==  'r'  ||  endCharno  ==  'n'  ||  endCharno  ==  'n'  ||  endCharno  ==  't')  {	  if(endCharno    =='')    {    	non-compiled	[CE]  	47	None	replace
446	[BUG]  [BUGGY]  if(endCharno!=  'n'  ||  endCharno  ==  'r'  ||  endCharno  ==  't')  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endCharno!=  'n'  ||  endCharno  ==  'r'  ||  endCharno  ==  't')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endCharno!=  'n'  ||  endCharno  ==  'r'  ||  endCharno  ==  't')  {	  if(endCharno    =='')    {    	non-compiled	[CE]  	47	None	replace
447	[BUG]  [BUGGY]  if(token!=  JsDocToken.VALUE_NULL  ||  token!=  JsDocToken.VALUE_STRING)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.VALUE_NULL  ||  token!=  JsDocToken.VALUE_STRING)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.VALUE_NULL  ||  token!=  JsDocToken.VALUE_STRING)  {	  if(token!=    JsDocToken.VALUE_NULL)    {    	non-compiled	[CE]  	29	None	replace
448	[BUG]  [BUGGY]  if(token!=  JsDocToken.VALUE_NULL  ||  token!=  JsDocToken.START_TOKEN)  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.VALUE_NULL  ||  token!=  JsDocToken.START_TOKEN)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.VALUE_NULL  ||  token!=  JsDocToken.START_TOKEN)  {	  if(token!=    JsDocToken.VALUE_NULL)    {    	non-compiled	[CE]  	29	None	replace
449	[BUG]  [BUGGY]  if(line.length()  >  0  ||  toString(token)  ==  null)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line.length()  >  0  ||  toString(token)  ==  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line.length()  >  0  ||  toString(token)  ==  null)  {	  if(line.length()    >    0    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	90	None	replace
450	[BUG]  [BUGGY]  if(line!=  null  &&  token.length()  >  0  ||  toString(token)!=  null)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  null  &&  token.length()  >  0  ||  toString(token)!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  null  &&  token.length()  >  0  ||  toString(token)!=  null)  {	  if(line.length()    >    0    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	90	None	replace
451	[BUG]  [BUGGY]  if(token!=  null  &&  token.charAt(0)!=  'n'  &&  token.charAt(0)!=  'r')  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token.charAt(0)!=  'n'  &&  token.charAt(0)!=  'r')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token.charAt(0)!=  'n'  &&  token.charAt(0)!=  'r')  {	  if(token!=    null    &&    token.charAt(0)!='')    {    	non-compiled	[CE]  	96	None	replace
452	[BUG]  [BUGGY]  if(token!=  null  &&  token.charAt(0)!=  'n'  &&  token.charAt(0)!=  'r'  &&  token.charAt(0)!=  'n')  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  null  &&  token.charAt(0)!=  'n'  &&  token.charAt(0)!=  'r'  &&  token.charAt(0)!=  'n')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  null  &&  token.charAt(0)!=  'n'  &&  token.charAt(0)!=  'r'  &&  token.charAt(0)!=  'n')  {	  if(token!=    null    &&    token.charAt(0)!='')    {    	non-compiled	[CE]  	96	None	replace
453	[BUG]  [BUGGY]  if(line!=  null  &&  jsdocBuilder.markText(toString(token)))  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line!=  null  &&  jsdocBuilder.markText(toString(token)))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line!=  null  &&  jsdocBuilder.markText(toString(token)))  {	  if(jsdocBuilder!=    null    ||    jsdocBuilder.markText(toString(token)))    {    	non-compiled	[CE]  	5	None	replace
454	[BUG]  [BUGGY]  if(token!=  JsDocToken.START_OBJECT  &&  jsdocBuilder.markText(toString(token)))  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.START_OBJECT  &&  jsdocBuilder.markText(toString(token)))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.START_OBJECT  &&  jsdocBuilder.markText(toString(token)))  {	  if(jsdocBuilder!=    null    ||    jsdocBuilder.markText(toString(token)))    {    	non-compiled	[CE]  	5	None	replace
455	[BUG]  [BUGGY]  if(jsdocBuilder.markText(toString(token)))  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder.markText(toString(token)))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder.markText(toString(token)))  {	  if(jsdocBuilder!=    null    ||    jsdocBuilder.markText(toString(token)))    {    	non-compiled	[CE]  	5	None	replace
456	[BUG]  [BUGGY]  if(token!=  JsDocToken.START_OBJECT  &&  token!=  JsDocToken.END_ARRAY  &&  token!=  JsDocToken.END_ARRAY)  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token!=  JsDocToken.START_OBJECT  &&  token!=  JsDocToken.END_ARRAY  &&  token!=  JsDocToken.END_ARRAY)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token!=  JsDocToken.START_OBJECT  &&  token!=  JsDocToken.END_ARRAY  &&  token!=  JsDocToken.END_ARRAY)  {	  if(jsdocBuilder!=    null    ||    jsdocBuilder.markText(toString(token)))    {    	non-compiled	[CE]  	5	None	replace
457	[BUG]  [BUGGY]  if(builder!=  null  &&  token!=  null  &&  token.length()  >  0)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder!=  null  &&  token!=  null  &&  token.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder!=  null  &&  token!=  null  &&  token.length()  >  0)  {	  if(builder!=    null    &&    token!=    null)    {    	non-compiled	[CE]  	2	None	replace
458	[BUG]  [BUGGY]  if(builder!=  null  &&  token!=  null  &&  token.charAt(token.length()  -  1)!='')  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(builder!=  null  &&  token!=  null  &&  token.charAt(token.length()  -  1)!='')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(builder!=  null  &&  token!=  null  &&  token.charAt(token.length()  -  1)!='')  {	  if(builder!=    null    &&    token!=    null)    {    	non-compiled	[CE]  	2	None	replace
459	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  fileLevelJsDocBuilder!=  null  &&  builder.length()  >  0)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  fileLevelJsDocBuilder!=  null  &&  builder.length()  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  fileLevelJsDocBuilder!=  null  &&  builder.length()  >  0)  {	  if(jsdocBuilder!=    null    &&    fileLevelJsDocBuilder!=    null)    {    	non-compiled	[CE]  	98	None	replace
460	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  fileLevelJsDocBuilder!=  null  &&  token!=  JsDocToken.END_ARRAY)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  fileLevelJsDocBuilder!=  null  &&  token!=  JsDocToken.END_ARRAY)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  fileLevelJsDocBuilder!=  null  &&  token!=  JsDocToken.END_ARRAY)  {	  if(jsdocBuilder!=    null    &&    fileLevelJsDocBuilder!=    null)    {    	non-compiled	[CE]  	98	None	replace
461	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  fileLevelJsDocBuilder!=  null  &&  token!=  JsDocToken.VALUE_STRING)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  fileLevelJsDocBuilder!=  null  &&  token!=  JsDocToken.VALUE_STRING)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  fileLevelJsDocBuilder!=  null  &&  token!=  JsDocToken.VALUE_STRING)  {	  if(jsdocBuilder!=    null    &&    fileLevelJsDocBuilder!=    null)    {    	non-compiled	[CE]  	98	None	replace
462	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  fileLevelJsDocBuilder!=  null  &&  stream.getCharno()  =='')  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  fileLevelJsDocBuilder!=  null  &&  stream.getCharno()  =='')  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  fileLevelJsDocBuilder!=  null  &&  stream.getCharno()  =='')  {	  if(jsdocBuilder!=    null    &&    fileLevelJsDocBuilder!=    null)    {    	non-compiled	[CE]  	98	None	replace
463	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText(startLineno))  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText(startLineno))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder.markText(startLineno))  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.markText())    {    	non-compiled	[CE]  	81	None	replace
464	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText(line))  {  [CE]  [FE]                      ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder.markText(line))  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder.markText(line))  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.markText())    {    	non-compiled	[CE]  	81	None	replace
465	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&!jsdocBuilder.isLineno())  {  [CE]  [FE]                        ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&!jsdocBuilder.isLineno())  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&!jsdocBuilder.isLineno())  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.isLineno())    {    	non-compiled	[CE]  	83	None	replace
466	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  stream.isLineno())  {  [CE]  [FE]                          ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  stream.isLineno())  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  stream.isLineno())  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.isLineno())    {    	non-compiled	[CE]  	83	None	replace
467	[BUG]  [BUGGY]  if(token  ==  JsDocToken.VALUE_STRING  ||  token!=  JsDocToken.VALUE_STRING)  {  [CE]  [FE]            ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  JsDocToken.VALUE_STRING  ||  token!=  JsDocToken.VALUE_STRING)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  JsDocToken.VALUE_STRING  ||  token!=  JsDocToken.VALUE_STRING)  {	  if(line    ==    null    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	22	None	replace
468	[BUG]  [BUGGY]  if(token  ==  JsDocToken.FIELD_NAME  ||  toString(token)!=  null)  {  [CE]  [FE]              ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(token  ==  JsDocToken.FIELD_NAME  ||  toString(token)!=  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(token  ==  JsDocToken.FIELD_NAME  ||  toString(token)!=  null)  {	  if(line    ==    null    ||    toString(token)!=    null)    {    	non-compiled	[CE]  	22	None	replace
469	[BUG]  [BUGGY]  if(endCharno  >  0)  {  [CE]  [FE]                ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endCharno  >  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endCharno  >  0)  {	  if(endCharno    >=    0)    {    	non-compiled	[CE]  	59	None	replace
470	[BUG]  [BUGGY]  if(line  >=  0)  {  [CE]  [FE]                  ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(line  >=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(line  >=  0)  {	  if(endCharno    >=    0)    {    	non-compiled	[CE]  	59	None	replace
471	[BUG]  [BUGGY]  if(endCharno  <  0  ||  endCharno  >  line.length())  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(endCharno  <  0  ||  endCharno  >  line.length())  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(endCharno  <  0  ||  endCharno  >  line.length())  {	  if(endCharno    >=    0)    {    	non-compiled	[CE]  	59	None	replace
472	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  ||  jsdocBuilder.length()  <=  0)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  ||  jsdocBuilder.length()  <=  0)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  ||  jsdocBuilder.length()  <=  0)  {	  if(jsdocBuilder!=    null    ||    builder.length()    >    0)    {    	non-compiled	[CE]  	53	None	replace
473	[BUG]  [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder  ==  null)  {  [CE]  [FE]                    ComparisonFailure      [CONTEXT]      int  endCharno  =  stream.getCharno();  if  (multilineText.length()  >  0)  {  jsdocBuilder.markText(multilineText,  startLineno,  startCharno,  endLineno,  endCharno);  }  return  new  ExtractionInfo(multilineText,  token);  }      [BUGGY]  if(jsdocBuilder!=  null  &&  jsdocBuilder  ==  null)  {  [BUGGY]      builder.append('  ');  }  builder.append(toString(token));  line  =  stream.getRemainingJSDocLine();  if  (option  !=  WhitespaceOption.PRESERVE)  {  line  =  trimEnd(line);  }  [CLASS]  JsDocInfoParser  ErrorReporterParser  State  ExtractionInfo  ExtendedTypeInfo  WhitespaceOption  [METHOD]  extractMultilineTextualBlock  [RETURN_TYPE]  JsDocInfoParser$ExtractionInfo  JsDocToken  token  WhitespaceOption  option  [VARIABLES]  Set  modifies  modifiesAnnotationKeywords  suppressionNames  suppressions  StringBuilder  builder  Node  associatedNode  n  templateNode  typeNode  JsDocTokenStream  stream  FileLevelJsDocBuilder  fileLevelJsDocBuilder  String  annotationName  author  description  fileOverview  line  meaning  messageArg  messageId  multilineText  name  paramDescription  preserve  reason  reference  returnDescription  string  templateTypeName  typeString  version  JSDocInfo  fileOverviewJSDocInfo  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  ErrorReporter  errorReporter  boolean  ignoreStar  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  ErrorReporterParser  parser  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  JSTypeExpression  type  JSDocInfoBuilder  jsdocBuilder  StaticSourceFile  sourceFile  Map  annotationNames  	projects/Closure32/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	0.4364357804719848	1414	1414	4	replace	if(jsdocBuilder!=  null  &&  jsdocBuilder  ==  null)  {	  if(jsdocBuilder!=    null    &&    jsdocBuilder.length()    >    0)    {    	non-compiled	[CE]  	60	None	replace
