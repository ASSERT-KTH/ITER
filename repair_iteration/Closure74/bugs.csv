bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] return n; [FE] AssertionFailedError [CONTEXT] case Token.GT: result = false; break; default: return n;// don't handle that op } break; default:  [BUGGY] return n; [BUGGY] } Node newNode = new Node(result ? Token.TRUE : Token.FALSE); n.getParent().replaceChild(n, newNode); reportCodeChange(); return newNode; } [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	1.0	1061	1061	3	replace	
2	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] case Token.GT: result = false; break; default: return n;// don't handle that op } break; default:  [BUGGY] [BUGGY] return n; } Node newNode = new Node(result ? Token.TRUE : Token.FALSE); n.getParent().replaceChild(n, newNode); reportCodeChange(); return newNode; } [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	1.0	1061	1061	3	add	
3	[BUG] [BUGGY] return n; [FE] AssertionFailedError [CONTEXT] if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) { [BUGGY] return n; [BUGGY] } [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.8164965809277261	930	930	3	replace	
4	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) { [BUGGY] [BUGGY] return n; } [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.8164965809277261	930	930	3	add	
5	[BUG] [BUGGY] result = lhType != rhType; [FE] AssertionFailedError [CONTEXT] return n; } switch (op) { case Token.SHEQ: case Token.EQ: result = lhType == rhType; break; case Token.SHNE: case Token.NE: [BUGGY] result = lhType != rhType; [BUGGY] break; case Token.GE: case Token.LE: case Token.GT: case Token.LT: Boolean compareResult = compareAsNumbers(op, left, right); if (compareResult != null) { result = compareResult; } else { [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.8164965809277261	940	940	3	replace	
6	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] return n; } switch (op) { case Token.SHEQ: case Token.EQ: result = lhType == rhType; break; case Token.SHNE: case Token.NE: [BUGGY] [BUGGY] result = lhType != rhType; break; case Token.GE: case Token.LE: case Token.GT: case Token.LT: Boolean compareResult = compareAsNumbers(op, left, right); if (compareResult != null) { result = compareResult; } else { [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.8164965809277261	940	940	3	add	
7	[BUG] [BUGGY] break; [FE] AssertionFailedError [CONTEXT] } switch (op) { case Token.SHEQ: case Token.EQ: result = lhType == rhType; break; case Token.SHNE: case Token.NE: result = lhType != rhType; [BUGGY] break; [BUGGY]  case Token.GE: case Token.LE: case Token.GT: case Token.LT: Boolean compareResult = compareAsNumbers(op, left, right); if (compareResult != null) { result = compareResult; } else { return n; [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.8164965809277261	941	941	3	replace	
8	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } switch (op) { case Token.SHEQ: case Token.EQ: result = lhType == rhType; break; case Token.SHNE: case Token.NE: result = lhType != rhType; [BUGGY] [BUGGY] break; case Token.GE: case Token.LE: case Token.GT: case Token.LT: Boolean compareResult = compareAsNumbers(op, left, right); if (compareResult != null) { result = compareResult; } else { return n; [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.8164965809277261	941	941	3	add	
9	[BUG] [BUGGY] return n; [FE] AssertionFailedError [CONTEXT] if (leftVal == TernaryValue.UNKNOWN) { return n; } switch (n.getType()) { case Token.NOT:  if (left.getType() == Token.NUMBER) { double numValue = left.getDouble(); if (numValue == 0 || numValue == 1) { [BUGGY] return n; [BUGGY] } } int result = leftVal.toBoolean(true) ? Token.FALSE : Token.TRUE; Node replacementNode = new Node(result); parent.replaceChild(n, replacementNode); reportCodeChange(); return replacementNode; case Token.POS: if (NodeUtil.isNumericResult(left)) {  [CLASS] PeepholeFoldConstants [METHOD] tryFoldUnaryOperator [RETURN_TYPE] Node  Node n [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER negNum numValue val value Node left n negNumNode notIntValNode parent replacementNode TernaryValue leftVal int intVal result UnsupportedOperationException ex  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.7071067811865476	346	346	3	replace	
10	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (leftVal == TernaryValue.UNKNOWN) { return n; } switch (n.getType()) { case Token.NOT:  if (left.getType() == Token.NUMBER) { double numValue = left.getDouble(); if (numValue == 0 || numValue == 1) { [BUGGY] [BUGGY] return n; } } int result = leftVal.toBoolean(true) ? Token.FALSE : Token.TRUE; Node replacementNode = new Node(result); parent.replaceChild(n, replacementNode); reportCodeChange(); return replacementNode; case Token.POS: if (NodeUtil.isNumericResult(left)) {  [CLASS] PeepholeFoldConstants [METHOD] tryFoldUnaryOperator [RETURN_TYPE] Node  Node n [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER negNum numValue val value Node left n negNumNode notIntValNode parent replacementNode TernaryValue leftVal int intVal result UnsupportedOperationException ex  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.7071067811865476	346	346	3	add	
11	[BUG] [BUGGY] return !equivalent; [FE] AssertionFailedError [CONTEXT] && value.getString().equals("undefined")) || (Token.VOID == value.getType() && NodeUtil.isLiteralValue(value.getFirstChild(), false))); boolean valueNull = (Token.NULL == value.getType()); boolean equivalent = valueUndefined || valueNull; switch (op) { case Token.EQ:  return equivalent; case Token.NE: [BUGGY] return !equivalent; [BUGGY] case Token.SHEQ: return valueUndefined; case Token.SHNE: return !valueUndefined; case Token.LT: case Token.GT: case Token.LE: case Token.GE: return false; default: [CLASS] PeepholeFoldConstants [METHOD] compareToUndefined [RETURN_TYPE] boolean  Node value int op [VARIABLES] Locale ROOT_LOCALE boolean equivalent valueNull valueUndefined DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lv lval negNum numValue result rv rval val value int op Node value  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.6666666666666666	1133	1133	3	replace	
12	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] && value.getString().equals("undefined")) || (Token.VOID == value.getType() && NodeUtil.isLiteralValue(value.getFirstChild(), false))); boolean valueNull = (Token.NULL == value.getType()); boolean equivalent = valueUndefined || valueNull; switch (op) { case Token.EQ:  return equivalent; case Token.NE: [BUGGY] [BUGGY] return !equivalent; case Token.SHEQ: return valueUndefined; case Token.SHNE: return !valueUndefined; case Token.LT: case Token.GT: case Token.LE: case Token.GE: return false; default: [CLASS] PeepholeFoldConstants [METHOD] compareToUndefined [RETURN_TYPE] boolean  Node value int op [VARIABLES] Locale ROOT_LOCALE boolean equivalent valueNull valueUndefined DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lv lval negNum numValue result rv rval val value int op Node value  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.6666666666666666	1133	1133	3	add	
13	[BUG] [BUGGY] double numValue = left.getDouble(); [FE] AssertionFailedError [CONTEXT] TernaryValue leftVal = NodeUtil.getPureBooleanValue(left); if (leftVal == TernaryValue.UNKNOWN) { return n; } switch (n.getType()) { case Token.NOT:  if (left.getType() == Token.NUMBER) { [BUGGY] double numValue = left.getDouble(); [BUGGY] if (numValue == 0 || numValue == 1) { return n; } } int result = leftVal.toBoolean(true) ? Token.FALSE : Token.TRUE; Node replacementNode = new Node(result); parent.replaceChild(n, replacementNode); reportCodeChange(); return replacementNode; case Token.POS: [CLASS] PeepholeFoldConstants [METHOD] tryFoldUnaryOperator [RETURN_TYPE] Node  Node n [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER negNum numValue val value Node left n negNumNode notIntValNode parent replacementNode TernaryValue leftVal int intVal result UnsupportedOperationException ex  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.6546536707079772	344	344	3	replace	
14	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] TernaryValue leftVal = NodeUtil.getPureBooleanValue(left); if (leftVal == TernaryValue.UNKNOWN) { return n; } switch (n.getType()) { case Token.NOT:  if (left.getType() == Token.NUMBER) { [BUGGY] [BUGGY] double numValue = left.getDouble(); if (numValue == 0 || numValue == 1) { return n; } } int result = leftVal.toBoolean(true) ? Token.FALSE : Token.TRUE; Node replacementNode = new Node(result); parent.replaceChild(n, replacementNode); reportCodeChange(); return replacementNode; case Token.POS: [CLASS] PeepholeFoldConstants [METHOD] tryFoldUnaryOperator [RETURN_TYPE] Node  Node n [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER negNum numValue val value Node left n negNumNode notIntValNode parent replacementNode TernaryValue leftVal int intVal result UnsupportedOperationException ex  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.6546536707079772	344	344	3	add	
15	[BUG] [BUGGY] if (numValue == 0 || numValue == 1) { [FE] AssertionFailedError [CONTEXT] TernaryValue leftVal = NodeUtil.getPureBooleanValue(left); if (leftVal == TernaryValue.UNKNOWN) { return n; } switch (n.getType()) { case Token.NOT:  if (left.getType() == Token.NUMBER) { double numValue = left.getDouble(); [BUGGY] if (numValue == 0 || numValue == 1) { [BUGGY] return n; } } int result = leftVal.toBoolean(true) ? Token.FALSE : Token.TRUE; Node replacementNode = new Node(result); parent.replaceChild(n, replacementNode); reportCodeChange(); return replacementNode; case Token.POS: if (NodeUtil.isNumericResult(left)) { [CLASS] PeepholeFoldConstants [METHOD] tryFoldUnaryOperator [RETURN_TYPE] Node  Node n [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER negNum numValue val value Node left n negNumNode notIntValNode parent replacementNode TernaryValue leftVal int intVal result UnsupportedOperationException ex  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.6546536707079772	345	345	3	replace	
16	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] TernaryValue leftVal = NodeUtil.getPureBooleanValue(left); if (leftVal == TernaryValue.UNKNOWN) { return n; } switch (n.getType()) { case Token.NOT:  if (left.getType() == Token.NUMBER) { double numValue = left.getDouble(); [BUGGY] [BUGGY] if (numValue == 0 || numValue == 1) { return n; } } int result = leftVal.toBoolean(true) ? Token.FALSE : Token.TRUE; Node replacementNode = new Node(result); parent.replaceChild(n, replacementNode); reportCodeChange(); return replacementNode; case Token.POS: if (NodeUtil.isNumericResult(left)) { [CLASS] PeepholeFoldConstants [METHOD] tryFoldUnaryOperator [RETURN_TYPE] Node  Node n [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER negNum numValue val value Node left n negNumNode notIntValNode parent replacementNode TernaryValue leftVal int intVal result UnsupportedOperationException ex  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.6546536707079772	345	345	3	add	
17	[BUG] [BUGGY] if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) { [FE] AssertionFailedError [CONTEXT] boolean rightLiteral = NodeUtil.isLiteralValue(right, false); boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals("undefined")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))); int lhType = left.getType(); int rhType = right.getType(); switch (lhType) { case Token.VOID: [BUGGY] if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) { [BUGGY] return n; } else if (!rightLiteral) { return n; } else { result = compareToUndefined(right, op); } break; case Token.NULL: case Token.TRUE: [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5773502691896258	911	911	3	replace	
18	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] boolean rightLiteral = NodeUtil.isLiteralValue(right, false); boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals("undefined")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))); int lhType = left.getType(); int rhType = right.getType(); switch (lhType) { case Token.VOID: [BUGGY] [BUGGY] if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) { return n; } else if (!rightLiteral) { return n; } else { result = compareToUndefined(right, op); } break; case Token.NULL: case Token.TRUE: [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5773502691896258	911	911	3	add	
19	[BUG] [BUGGY] } else if (!rightLiteral) { [FE] AssertionFailedError [CONTEXT] boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals("undefined")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))); int lhType = left.getType(); int rhType = right.getType(); switch (lhType) { case Token.VOID: if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) { return n; [BUGGY] } else if (!rightLiteral) { [BUGGY] return n; } else { result = compareToUndefined(right, op); } break; case Token.NULL: case Token.TRUE: case Token.FALSE: if (undefinedRight) { [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5773502691896258	913	913	3	replace	
20	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals("undefined")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))); int lhType = left.getType(); int rhType = right.getType(); switch (lhType) { case Token.VOID: if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) { return n; [BUGGY] [BUGGY] } else if (!rightLiteral) { return n; } else { result = compareToUndefined(right, op); } break; case Token.NULL: case Token.TRUE: case Token.FALSE: if (undefinedRight) { [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5773502691896258	913	913	3	add	
21	[BUG] [BUGGY] result = compareToUndefined(right, op); [FE] AssertionFailedError [CONTEXT] } else if (!rightLiteral) { return n; } else { [BUGGY] result = compareToUndefined(right, op); [BUGGY] } [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5773502691896258	916	916	3	replace	
22	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } else if (!rightLiteral) { return n; } else { [BUGGY] [BUGGY] result = compareToUndefined(right, op); } [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5773502691896258	916	916	3	add	
23	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } else if (!rightLiteral) { return n; } else { result = compareToUndefined(right, op); } [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5773502691896258	918	918	3	replace	
24	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } else if (!rightLiteral) { return n; } else { result = compareToUndefined(right, op); } [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5773502691896258	918	918	3	add	
25	[BUG] [BUGGY] result = compareToUndefined(left, op); [FE] AssertionFailedError [CONTEXT] return n; } else { result = compareToUndefined(right, op); } break; case Token.NULL: case Token.TRUE: case Token.FALSE: if (undefinedRight) { [BUGGY] result = compareToUndefined(left, op); [BUGGY] break; } if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) { return n; } switch (op) { case Token.SHEQ: case Token.EQ: [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5773502691896258	924	924	3	replace	
26	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] return n; } else { result = compareToUndefined(right, op); } break; case Token.NULL: case Token.TRUE: case Token.FALSE: if (undefinedRight) { [BUGGY] [BUGGY] result = compareToUndefined(left, op); break; } if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) { return n; } switch (op) { case Token.SHEQ: case Token.EQ: [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5773502691896258	924	924	3	add	
27	[BUG] [BUGGY] break; [FE] AssertionFailedError [CONTEXT] } else { result = compareToUndefined(right, op); } break; case Token.NULL: case Token.TRUE: case Token.FALSE: if (undefinedRight) { result = compareToUndefined(left, op); [BUGGY] break; [BUGGY] } if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) { return n; } switch (op) { case Token.SHEQ: case Token.EQ: result = lhType == rhType; [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5773502691896258	925	925	3	replace	
28	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } else { result = compareToUndefined(right, op); } break; case Token.NULL: case Token.TRUE: case Token.FALSE: if (undefinedRight) { result = compareToUndefined(left, op); [BUGGY] [BUGGY] break; } if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) { return n; } switch (op) { case Token.SHEQ: case Token.EQ: result = lhType == rhType; [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5773502691896258	925	925	3	add	
29	[BUG] [BUGGY] return n;// Only eval if they are the same type } [FE] AssertionFailedError [CONTEXT] return n; } break; case Token.STRING: if (undefinedRight) { result = compareToUndefined(left, op); break; } if (Token.STRING != right.getType()) { [BUGGY] return n;// Only eval if they are the same type  } [BUGGY] } switch (op) { case Token.SHEQ: case Token.EQ: result = left.getString().equals(right.getString()); break; case Token.SHNE: case Token.NE: result = !left.getString().equals(right.getString()); [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5773502691896258	990	991	3	replace	
30	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] return n; } break; case Token.STRING: if (undefinedRight) { result = compareToUndefined(left, op); break; } if (Token.STRING != right.getType()) { [BUGGY] [BUGGY] return n;// Only eval if they are the same type  } } switch (op) { case Token.SHEQ: case Token.EQ: result = left.getString().equals(right.getString()); break; case Token.SHNE: case Token.NE: result = !left.getString().equals(right.getString()); [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5773502691896258	990	991	3	add	
31	[BUG] [BUGGY] result = compareToUndefined(left, op); [FE] AssertionFailedError [CONTEXT] Boolean compareResult = compareAsNumbers(op, left, right); if (compareResult != null) { result = compareResult; } else { return null; } break; case Token.NAME: if (undefinedRight) { [BUGGY] result = compareToUndefined(left, op); [BUGGY] break; } if (rightLiteral) { boolean undefinedLeft = (left.getString().equals("undefined")); if (undefinedLeft) { result = compareToUndefined(right, op); break; } } [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5773502691896258	1026	1026	3	replace	
32	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] Boolean compareResult = compareAsNumbers(op, left, right); if (compareResult != null) { result = compareResult; } else { return null; } break; case Token.NAME: if (undefinedRight) { [BUGGY] [BUGGY] result = compareToUndefined(left, op); break; } if (rightLiteral) { boolean undefinedLeft = (left.getString().equals("undefined")); if (undefinedLeft) { result = compareToUndefined(right, op); break; } } [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5773502691896258	1026	1026	3	add	
33	[BUG] [BUGGY] break; [FE] AssertionFailedError [CONTEXT] if (compareResult != null) { result = compareResult; } else { return null; } break; case Token.NAME: if (undefinedRight) { result = compareToUndefined(left, op); [BUGGY] break; [BUGGY] } if (rightLiteral) { boolean undefinedLeft = (left.getString().equals("undefined")); if (undefinedLeft) { result = compareToUndefined(right, op); break; } }  [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5773502691896258	1027	1027	3	replace	
34	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (compareResult != null) { result = compareResult; } else { return null; } break; case Token.NAME: if (undefinedRight) { result = compareToUndefined(left, op); [BUGGY] [BUGGY] break; } if (rightLiteral) { boolean undefinedLeft = (left.getString().equals("undefined")); if (undefinedLeft) { result = compareToUndefined(right, op); break; } }  [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5773502691896258	1027	1027	3	add	
35	[BUG] [BUGGY] return n;// Only eval if they are the same type } [FE] AssertionFailedError [CONTEXT] if (rightLiteral) { boolean undefinedLeft = (left.getString().equals("undefined")); if (undefinedLeft) { result = compareToUndefined(right, op); break; } } if (Token.NAME != right.getType()) { [BUGGY] return n;// Only eval if they are the same type  } [BUGGY] } String ln = left.getString(); String rn = right.getString(); if (!ln.equals(rn)) { return n;// Not the same value name. } switch (op) {   [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5773502691896258	1039	1040	3	replace	
36	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (rightLiteral) { boolean undefinedLeft = (left.getString().equals("undefined")); if (undefinedLeft) { result = compareToUndefined(right, op); break; } } if (Token.NAME != right.getType()) { [BUGGY] [BUGGY] return n;// Only eval if they are the same type  } } String ln = left.getString(); String rn = right.getString(); if (!ln.equals(rn)) { return n;// Not the same value name. } switch (op) {   [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5773502691896258	1039	1040	3	add	
37	[BUG] [BUGGY] return equivalent; [FE] AssertionFailedError [CONTEXT] private boolean compareToUndefined(Node value, int op) { boolean valueUndefined = ((Token.NAME == value.getType() && value.getString().equals("undefined")) || (Token.VOID == value.getType() && NodeUtil.isLiteralValue(value.getFirstChild(), false))); boolean valueNull = (Token.NULL == value.getType()); boolean equivalent = valueUndefined || valueNull; switch (op) { case Token.EQ:  [BUGGY] return equivalent; [BUGGY] case Token.NE: return !equivalent; case Token.SHEQ: return valueUndefined; case Token.SHNE: return !valueUndefined; case Token.LT: case Token.GT: case Token.LE: case Token.GE: [CLASS] PeepholeFoldConstants [METHOD] compareToUndefined [RETURN_TYPE] boolean  Node value int op [VARIABLES] Locale ROOT_LOCALE boolean equivalent valueNull valueUndefined DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lv lval negNum numValue result rv rval val value int op Node value  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5773502691896258	1131	1131	3	replace	
38	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private boolean compareToUndefined(Node value, int op) { boolean valueUndefined = ((Token.NAME == value.getType() && value.getString().equals("undefined")) || (Token.VOID == value.getType() && NodeUtil.isLiteralValue(value.getFirstChild(), false))); boolean valueNull = (Token.NULL == value.getType()); boolean equivalent = valueUndefined || valueNull; switch (op) { case Token.EQ:  [BUGGY] [BUGGY] return equivalent; case Token.NE: return !equivalent; case Token.SHEQ: return valueUndefined; case Token.SHNE: return !valueUndefined; case Token.LT: case Token.GT: case Token.LE: case Token.GE: [CLASS] PeepholeFoldConstants [METHOD] compareToUndefined [RETURN_TYPE] boolean  Node value int op [VARIABLES] Locale ROOT_LOCALE boolean equivalent valueNull valueUndefined DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lv lval negNum numValue result rv rval val value int op Node value  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5773502691896258	1131	1131	3	add	
39	[BUG] [BUGGY] if (left.getType() == Token.NUMBER) { [FE] AssertionFailedError [CONTEXT] } TernaryValue leftVal = NodeUtil.getPureBooleanValue(left); if (leftVal == TernaryValue.UNKNOWN) { return n; } switch (n.getType()) { case Token.NOT:  [BUGGY] if (left.getType() == Token.NUMBER) { [BUGGY] double numValue = left.getDouble(); if (numValue == 0 || numValue == 1) { return n; } } int result = leftVal.toBoolean(true) ? Token.FALSE : Token.TRUE; Node replacementNode = new Node(result); parent.replaceChild(n, replacementNode); reportCodeChange(); return replacementNode; [CLASS] PeepholeFoldConstants [METHOD] tryFoldUnaryOperator [RETURN_TYPE] Node  Node n [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER negNum numValue val value Node left n negNumNode notIntValNode parent replacementNode TernaryValue leftVal int intVal result UnsupportedOperationException ex  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5773502691896257	343	343	3	replace	
40	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } TernaryValue leftVal = NodeUtil.getPureBooleanValue(left); if (leftVal == TernaryValue.UNKNOWN) { return n; } switch (n.getType()) { case Token.NOT:  [BUGGY] [BUGGY] if (left.getType() == Token.NUMBER) { double numValue = left.getDouble(); if (numValue == 0 || numValue == 1) { return n; } } int result = leftVal.toBoolean(true) ? Token.FALSE : Token.TRUE; Node replacementNode = new Node(result); parent.replaceChild(n, replacementNode); reportCodeChange(); return replacementNode; [CLASS] PeepholeFoldConstants [METHOD] tryFoldUnaryOperator [RETURN_TYPE] Node  Node n [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER negNum numValue val value Node left n negNumNode notIntValNode parent replacementNode TernaryValue leftVal int intVal result UnsupportedOperationException ex  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5773502691896257	343	343	3	add	
41	[BUG] [BUGGY] if (rhType != Token.TRUE && rhType != Token.FALSE &&  rhType != Token.NULL) { [FE] AssertionFailedError [CONTEXT] } break; case Token.NULL: case Token.TRUE: case Token.FALSE: if (undefinedRight) { result = compareToUndefined(left, op); break; } [BUGGY] if (rhType != Token.TRUE &&   rhType != Token.FALSE &&      rhType != Token.NULL) { [BUGGY] rhType != Token.FALSE && rhType != Token.NULL) { return n; } switch (op) { case Token.SHEQ: case Token.EQ: result = lhType == rhType; break;  [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5163977794943222	927	929	3	replace	
42	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } break; case Token.NULL: case Token.TRUE: case Token.FALSE: if (undefinedRight) { result = compareToUndefined(left, op); break; } [BUGGY] [BUGGY] if (rhType != Token.TRUE &&   rhType != Token.FALSE &&      rhType != Token.NULL) { rhType != Token.FALSE && rhType != Token.NULL) { return n; } switch (op) { case Token.SHEQ: case Token.EQ: result = lhType == rhType; break;  [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5163977794943222	927	929	3	add	
43	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) { return n; } [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5163977794943222	932	932	3	replace	
44	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) { return n; } [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5163977794943222	932	932	3	add	
45	[BUG] [BUGGY] result = lhType == rhType; [FE] AssertionFailedError [CONTEXT] break; } if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) { return n; } switch (op) { case Token.SHEQ: case Token.EQ: [BUGGY] result = lhType == rhType; [BUGGY] break; case Token.SHNE: case Token.NE: result = lhType != rhType; break; case Token.GE: case Token.LE: case Token.GT: [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5163977794943222	935	935	3	replace	
46	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] break; } if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) { return n; } switch (op) { case Token.SHEQ: case Token.EQ: [BUGGY] [BUGGY] result = lhType == rhType; break; case Token.SHNE: case Token.NE: result = lhType != rhType; break; case Token.GE: case Token.LE: case Token.GT: [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5163977794943222	935	935	3	add	
47	[BUG] [BUGGY] break; [FE] AssertionFailedError [CONTEXT] } if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) { return n; } switch (op) { case Token.SHEQ: case Token.EQ: result = lhType == rhType; [BUGGY] break; [BUGGY]  case Token.SHNE: case Token.NE: result = lhType != rhType; break; case Token.GE: case Token.LE: case Token.GT: case Token.LT: [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5163977794943222	936	936	3	replace	
48	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) { return n; } switch (op) { case Token.SHEQ: case Token.EQ: result = lhType == rhType; [BUGGY] [BUGGY] break; case Token.SHNE: case Token.NE: result = lhType != rhType; break; case Token.GE: case Token.LE: case Token.GT: case Token.LT: [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5163977794943222	936	936	3	add	
49	[BUG] [BUGGY] break; [FE] AssertionFailedError [CONTEXT] if (compareResult != null) { result = compareResult; } else { return n; } break; default: return n;// we only handle == and != here } [BUGGY] break; [BUGGY]  case Token.THIS: if (right.getType() != Token.THIS) { return n; } switch (op) { case Token.SHEQ: case Token.EQ: result = true; break; [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5163977794943222	958	958	3	replace	
50	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (compareResult != null) { result = compareResult; } else { return n; } break; default: return n;// we only handle == and != here } [BUGGY] [BUGGY] break; case Token.THIS: if (right.getType() != Token.THIS) { return n; } switch (op) { case Token.SHEQ: case Token.EQ: result = true; break; [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5163977794943222	958	958	3	add	
51	[BUG] [BUGGY] boolean undefinedLeft = (left.getString().equals("undefined")); [FE] AssertionFailedError [CONTEXT] } break; case Token.NAME: if (undefinedRight) { result = compareToUndefined(left, op); break; } if (rightLiteral) { [BUGGY] boolean undefinedLeft = (left.getString().equals("undefined")); [BUGGY] if (undefinedLeft) { result = compareToUndefined(right, op); break; } } if (Token.NAME != right.getType()) { return n;// Only eval if they are the same type } String ln = left.getString(); [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5163977794943222	1031	1031	3	replace	
52	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } break; case Token.NAME: if (undefinedRight) { result = compareToUndefined(left, op); break; } if (rightLiteral) { [BUGGY] [BUGGY] boolean undefinedLeft = (left.getString().equals("undefined")); if (undefinedLeft) { result = compareToUndefined(right, op); break; } } if (Token.NAME != right.getType()) { return n;// Only eval if they are the same type } String ln = left.getString(); [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5163977794943222	1031	1031	3	add	
53	[BUG] [BUGGY] if (undefinedLeft) { [FE] AssertionFailedError [CONTEXT] break; case Token.NAME: if (undefinedRight) { result = compareToUndefined(left, op); break; } if (rightLiteral) { boolean undefinedLeft = (left.getString().equals("undefined")); [BUGGY] if (undefinedLeft) { [BUGGY] result = compareToUndefined(right, op); break; } } if (Token.NAME != right.getType()) { return n;// Only eval if they are the same type } String ln = left.getString(); String rn = right.getString(); [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5163977794943222	1032	1032	3	replace	
54	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] break; case Token.NAME: if (undefinedRight) { result = compareToUndefined(left, op); break; } if (rightLiteral) { boolean undefinedLeft = (left.getString().equals("undefined")); [BUGGY] [BUGGY] if (undefinedLeft) { result = compareToUndefined(right, op); break; } } if (Token.NAME != right.getType()) { return n;// Only eval if they are the same type } String ln = left.getString(); String rn = right.getString(); [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5163977794943222	1032	1032	3	add	
55	[BUG] [BUGGY] result = compareToUndefined(right, op); [FE] AssertionFailedError [CONTEXT] case Token.NAME: if (undefinedRight) { result = compareToUndefined(left, op); break; } if (rightLiteral) { boolean undefinedLeft = (left.getString().equals("undefined")); if (undefinedLeft) { [BUGGY] result = compareToUndefined(right, op); [BUGGY] break; } } if (Token.NAME != right.getType()) { return n;// Only eval if they are the same type } String ln = left.getString(); String rn = right.getString(); if (!ln.equals(rn)) { [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5163977794943222	1033	1033	3	replace	
56	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] case Token.NAME: if (undefinedRight) { result = compareToUndefined(left, op); break; } if (rightLiteral) { boolean undefinedLeft = (left.getString().equals("undefined")); if (undefinedLeft) { [BUGGY] [BUGGY] result = compareToUndefined(right, op); break; } } if (Token.NAME != right.getType()) { return n;// Only eval if they are the same type } String ln = left.getString(); String rn = right.getString(); if (!ln.equals(rn)) { [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5163977794943222	1033	1033	3	add	
57	[BUG] [BUGGY] break; [FE] AssertionFailedError [CONTEXT] case Token.NAME: if (undefinedRight) { result = compareToUndefined(left, op); break; } if (rightLiteral) { boolean undefinedLeft = (left.getString().equals("undefined")); if (undefinedLeft) { result = compareToUndefined(right, op); [BUGGY] break; [BUGGY] } } if (Token.NAME != right.getType()) { return n;// Only eval if they are the same type } String ln = left.getString(); String rn = right.getString(); if (!ln.equals(rn)) { return n;// Not the same value name. [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5163977794943222	1034	1034	3	replace	
58	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] case Token.NAME: if (undefinedRight) { result = compareToUndefined(left, op); break; } if (rightLiteral) { boolean undefinedLeft = (left.getString().equals("undefined")); if (undefinedLeft) { result = compareToUndefined(right, op); [BUGGY] [BUGGY] break; } } if (Token.NAME != right.getType()) { return n;// Only eval if they are the same type } String ln = left.getString(); String rn = right.getString(); if (!ln.equals(rn)) { return n;// Not the same value name. [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5163977794943222	1034	1034	3	add	
59	[BUG] [BUGGY] return tryFoldComparison(subtree, left, right); [FE] AssertionFailedError [CONTEXT] return tryFoldLeftChildOp(subtree, left, right); case Token.LT: case Token.GT: case Token.LE: case Token.GE: case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: [BUGGY] return tryFoldComparison(subtree, left, right); [BUGGY]  default: return subtree; } } [CLASS] PeepholeFoldConstants [METHOD] tryFoldBinaryOperator [RETURN_TYPE] Node  Node subtree [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER Node left result right subtree  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5	158	158	3	replace	
60	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] return tryFoldLeftChildOp(subtree, left, right); case Token.LT: case Token.GT: case Token.LE: case Token.GE: case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: [BUGGY] [BUGGY] return tryFoldComparison(subtree, left, right); default: return subtree; } } [CLASS] PeepholeFoldConstants [METHOD] tryFoldBinaryOperator [RETURN_TYPE] Node  Node subtree [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER Node left result right subtree  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5	158	158	3	add	
61	[BUG] [BUGGY] if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) { [FE] AssertionFailedError [CONTEXT] private Node tryFoldComparison(Node n, Node left, Node right) { [BUGGY] if (!NodeUtil.isLiteralValue(left, false) ||  !NodeUtil.isLiteralValue(right, false)) { [BUGGY] !NodeUtil.isLiteralValue(right, false)) {  if (n.getType() != Token.GT && n.getType() != Token.LT) { return n; } } int op = n.getType(); boolean result;  [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5	889	890	3	replace	
62	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private Node tryFoldComparison(Node n, Node left, Node right) { [BUGGY] [BUGGY] if (!NodeUtil.isLiteralValue(left, false) ||  !NodeUtil.isLiteralValue(right, false)) { !NodeUtil.isLiteralValue(right, false)) {  if (n.getType() != Token.GT && n.getType() != Token.LT) { return n; } } int op = n.getType(); boolean result;  [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5	889	890	3	add	
63	[BUG] [BUGGY] int op = n.getType(); [FE] AssertionFailedError [CONTEXT] private Node tryFoldComparison(Node n, Node left, Node right) { if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {  if (n.getType() != Token.GT && n.getType() != Token.LT) { return n; } } [BUGGY] int op = n.getType(); [BUGGY] boolean result;   boolean rightLiteral = NodeUtil.isLiteralValue(right, false); boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals("undefined")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))); int lhType = left.getType(); [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5	897	897	3	replace	
64	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private Node tryFoldComparison(Node n, Node left, Node right) { if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {  if (n.getType() != Token.GT && n.getType() != Token.LT) { return n; } } [BUGGY] [BUGGY] int op = n.getType(); boolean result;   boolean rightLiteral = NodeUtil.isLiteralValue(right, false); boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals("undefined")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))); int lhType = left.getType(); [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5	897	897	3	add	
65	[BUG] [BUGGY] boolean rightLiteral = NodeUtil.isLiteralValue(right, false); [FE] AssertionFailedError [CONTEXT] if (n.getType() != Token.GT && n.getType() != Token.LT) { return n; } } int op = n.getType(); boolean result;   [BUGGY] boolean rightLiteral = NodeUtil.isLiteralValue(right, false); [BUGGY] boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals("undefined")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))); int lhType = left.getType(); int rhType = right.getType(); switch (lhType) { case Token.VOID: if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) { return n; [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5	902	902	3	replace	
66	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (n.getType() != Token.GT && n.getType() != Token.LT) { return n; } } int op = n.getType(); boolean result;   [BUGGY] [BUGGY] boolean rightLiteral = NodeUtil.isLiteralValue(right, false); boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals("undefined")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))); int lhType = left.getType(); int rhType = right.getType(); switch (lhType) { case Token.VOID: if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) { return n; [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5	902	902	3	add	
67	[BUG] [BUGGY] boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals("undefined"))  || (Token.VOID == right.getType() [FE] AssertionFailedError [CONTEXT] return n; } } int op = n.getType(); boolean result;   boolean rightLiteral = NodeUtil.isLiteralValue(right, false); [BUGGY] boolean undefinedRight = ((Token.NAME == right.getType()   && right.getString().equals("undefined"))     || (Token.VOID == right.getType() [BUGGY] && right.getString().equals("undefined")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))); int lhType = left.getType(); int rhType = right.getType(); switch (lhType) { case Token.VOID: if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) { return n; } else if (!rightLiteral) { [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5	903	905	3	replace	
68	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] return n; } } int op = n.getType(); boolean result;   boolean rightLiteral = NodeUtil.isLiteralValue(right, false); [BUGGY] [BUGGY] boolean undefinedRight = ((Token.NAME == right.getType()   && right.getString().equals("undefined"))     || (Token.VOID == right.getType() && right.getString().equals("undefined")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))); int lhType = left.getType(); int rhType = right.getType(); switch (lhType) { case Token.VOID: if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) { return n; } else if (!rightLiteral) { [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5	903	905	3	add	
69	[BUG] [BUGGY] int lhType = left.getType(); [FE] AssertionFailedError [CONTEXT] int op = n.getType(); boolean result;   boolean rightLiteral = NodeUtil.isLiteralValue(right, false); boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals("undefined")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))); [BUGGY] int lhType = left.getType(); [BUGGY] int rhType = right.getType(); switch (lhType) { case Token.VOID: if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) { return n; } else if (!rightLiteral) { return n; } else { result = compareToUndefined(right, op); } [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5	907	907	3	replace	
70	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] int op = n.getType(); boolean result;   boolean rightLiteral = NodeUtil.isLiteralValue(right, false); boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals("undefined")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))); [BUGGY] [BUGGY] int lhType = left.getType(); int rhType = right.getType(); switch (lhType) { case Token.VOID: if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) { return n; } else if (!rightLiteral) { return n; } else { result = compareToUndefined(right, op); } [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5	907	907	3	add	
71	[BUG] [BUGGY] int rhType = right.getType(); [FE] AssertionFailedError [CONTEXT] boolean result;   boolean rightLiteral = NodeUtil.isLiteralValue(right, false); boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals("undefined")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))); int lhType = left.getType(); [BUGGY] int rhType = right.getType(); [BUGGY] switch (lhType) { case Token.VOID: if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) { return n; } else if (!rightLiteral) { return n; } else { result = compareToUndefined(right, op); } break; [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5	908	908	3	replace	
72	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] boolean result;   boolean rightLiteral = NodeUtil.isLiteralValue(right, false); boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals("undefined")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))); int lhType = left.getType(); [BUGGY] [BUGGY] int rhType = right.getType(); switch (lhType) { case Token.VOID: if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) { return n; } else if (!rightLiteral) { return n; } else { result = compareToUndefined(right, op); } break; [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5	908	908	3	add	
73	[BUG] [BUGGY] switch (lhType) { [FE] AssertionFailedError [CONTEXT]   boolean rightLiteral = NodeUtil.isLiteralValue(right, false); boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals("undefined")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))); int lhType = left.getType(); int rhType = right.getType(); [BUGGY] switch (lhType) { [BUGGY] case Token.VOID: if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) { return n; } else if (!rightLiteral) { return n; } else { result = compareToUndefined(right, op); } break;  [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5	909	909	3	replace	
74	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]   boolean rightLiteral = NodeUtil.isLiteralValue(right, false); boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals("undefined")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))); int lhType = left.getType(); int rhType = right.getType(); [BUGGY] [BUGGY] switch (lhType) { case Token.VOID: if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) { return n; } else if (!rightLiteral) { return n; } else { result = compareToUndefined(right, op); } break;  [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.5	909	909	3	add	
75	[BUG] [BUGGY] switch (n.getType()) { [FE] AssertionFailedError [CONTEXT] if (left == null) { return n; } TernaryValue leftVal = NodeUtil.getPureBooleanValue(left); if (leftVal == TernaryValue.UNKNOWN) { return n; } [BUGGY] switch (n.getType()) { [BUGGY] case Token.NOT:  if (left.getType() == Token.NUMBER) { double numValue = left.getDouble(); if (numValue == 0 || numValue == 1) { return n; } } int result = leftVal.toBoolean(true) ? Token.FALSE : Token.TRUE; Node replacementNode = new Node(result); [CLASS] PeepholeFoldConstants [METHOD] tryFoldUnaryOperator [RETURN_TYPE] Node  Node n [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER negNum numValue val value Node left n negNumNode notIntValNode parent replacementNode TernaryValue leftVal int intVal result UnsupportedOperationException ex  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.48038446141526137	340	340	3	replace	
76	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (left == null) { return n; } TernaryValue leftVal = NodeUtil.getPureBooleanValue(left); if (leftVal == TernaryValue.UNKNOWN) { return n; } [BUGGY] [BUGGY] switch (n.getType()) { case Token.NOT:  if (left.getType() == Token.NUMBER) { double numValue = left.getDouble(); if (numValue == 0 || numValue == 1) { return n; } } int result = leftVal.toBoolean(true) ? Token.FALSE : Token.TRUE; Node replacementNode = new Node(result); [CLASS] PeepholeFoldConstants [METHOD] tryFoldUnaryOperator [RETURN_TYPE] Node  Node n [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER negNum numValue val value Node left n negNumNode notIntValNode parent replacementNode TernaryValue leftVal int intVal result UnsupportedOperationException ex  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.48038446141526137	340	340	3	add	
77	[BUG] [BUGGY] if (rightLiteral) { [FE] AssertionFailedError [CONTEXT] return null; } break; case Token.NAME: if (undefinedRight) { result = compareToUndefined(left, op); break; } [BUGGY] if (rightLiteral) { [BUGGY] boolean undefinedLeft = (left.getString().equals("undefined")); if (undefinedLeft) { result = compareToUndefined(right, op); break; } } if (Token.NAME != right.getType()) { return n;// Only eval if they are the same type } [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.47140452079103173	1030	1030	3	replace	
78	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] return null; } break; case Token.NAME: if (undefinedRight) { result = compareToUndefined(left, op); break; } [BUGGY] [BUGGY] if (rightLiteral) { boolean undefinedLeft = (left.getString().equals("undefined")); if (undefinedLeft) { result = compareToUndefined(right, op); break; } } if (Token.NAME != right.getType()) { return n;// Only eval if they are the same type } [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.47140452079103173	1030	1030	3	add	
79	[BUG] [BUGGY] return valueUndefined; [FE] AssertionFailedError [CONTEXT] && NodeUtil.isLiteralValue(value.getFirstChild(), false))); boolean valueNull = (Token.NULL == value.getType()); boolean equivalent = valueUndefined || valueNull; switch (op) { case Token.EQ:  return equivalent; case Token.NE: return !equivalent; case Token.SHEQ: [BUGGY] return valueUndefined; [BUGGY] case Token.SHNE: return !valueUndefined; case Token.LT: case Token.GT: case Token.LE: case Token.GE: return false; default: throw new IllegalStateException("unexpected."); } [CLASS] PeepholeFoldConstants [METHOD] compareToUndefined [RETURN_TYPE] boolean  Node value int op [VARIABLES] Locale ROOT_LOCALE boolean equivalent valueNull valueUndefined DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lv lval negNum numValue result rv rval val value int op Node value  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.47140452079103173	1135	1135	3	replace	
80	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] && NodeUtil.isLiteralValue(value.getFirstChild(), false))); boolean valueNull = (Token.NULL == value.getType()); boolean equivalent = valueUndefined || valueNull; switch (op) { case Token.EQ:  return equivalent; case Token.NE: return !equivalent; case Token.SHEQ: [BUGGY] [BUGGY] return valueUndefined; case Token.SHNE: return !valueUndefined; case Token.LT: case Token.GT: case Token.LE: case Token.GE: return false; default: throw new IllegalStateException("unexpected."); } [CLASS] PeepholeFoldConstants [METHOD] compareToUndefined [RETURN_TYPE] boolean  Node value int op [VARIABLES] Locale ROOT_LOCALE boolean equivalent valueNull valueUndefined DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lv lval negNum numValue result rv rval val value int op Node value  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.47140452079103173	1135	1135	3	add	
81	[BUG] [BUGGY] return !valueUndefined; [FE] AssertionFailedError [CONTEXT] boolean equivalent = valueUndefined || valueNull; switch (op) { case Token.EQ:  return equivalent; case Token.NE: return !equivalent; case Token.SHEQ: return valueUndefined; case Token.SHNE: [BUGGY] return !valueUndefined; [BUGGY] case Token.LT: case Token.GT: case Token.LE: case Token.GE: return false; default: throw new IllegalStateException("unexpected."); } } [CLASS] PeepholeFoldConstants [METHOD] compareToUndefined [RETURN_TYPE] boolean  Node value int op [VARIABLES] Locale ROOT_LOCALE boolean equivalent valueNull valueUndefined DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lv lval negNum numValue result rv rval val value int op Node value  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.47140452079103173	1137	1137	3	replace	
82	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] boolean equivalent = valueUndefined || valueNull; switch (op) { case Token.EQ:  return equivalent; case Token.NE: return !equivalent; case Token.SHEQ: return valueUndefined; case Token.SHNE: [BUGGY] [BUGGY] return !valueUndefined; case Token.LT: case Token.GT: case Token.LE: case Token.GE: return false; default: throw new IllegalStateException("unexpected."); } } [CLASS] PeepholeFoldConstants [METHOD] compareToUndefined [RETURN_TYPE] boolean  Node value int op [VARIABLES] Locale ROOT_LOCALE boolean equivalent valueNull valueUndefined DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lv lval negNum numValue result rv rval val value int op Node value  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.47140452079103173	1137	1137	3	add	
83	[BUG] [BUGGY] tryReduceOperandsForOp(subtree); [FE] AssertionFailedError [CONTEXT] case Token.NEW: return tryFoldCtorCall(subtree); case Token.TYPEOF: return tryFoldTypeof(subtree); case Token.NOT: case Token.POS: case Token.NEG: case Token.BITNOT: [BUGGY] tryReduceOperandsForOp(subtree); [BUGGY] return tryFoldUnaryOperator(subtree); case Token.VOID: return tryReduceVoid(subtree); default: tryReduceOperandsForOp(subtree); return tryFoldBinaryOperator(subtree); } } [CLASS] PeepholeFoldConstants [METHOD] optimizeSubtree [RETURN_TYPE] Node  Node subtree [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER Node subtree  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.4472135954999579	84	84	3	replace	
84	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] case Token.NEW: return tryFoldCtorCall(subtree); case Token.TYPEOF: return tryFoldTypeof(subtree); case Token.NOT: case Token.POS: case Token.NEG: case Token.BITNOT: [BUGGY] [BUGGY] tryReduceOperandsForOp(subtree); return tryFoldUnaryOperator(subtree); case Token.VOID: return tryReduceVoid(subtree); default: tryReduceOperandsForOp(subtree); return tryFoldBinaryOperator(subtree); } } [CLASS] PeepholeFoldConstants [METHOD] optimizeSubtree [RETURN_TYPE] Node  Node subtree [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER Node subtree  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.4472135954999579	84	84	3	add	
85	[BUG] [BUGGY] return tryFoldUnaryOperator(subtree); [FE] AssertionFailedError [CONTEXT] return tryFoldCtorCall(subtree); case Token.TYPEOF: return tryFoldTypeof(subtree); case Token.NOT: case Token.POS: case Token.NEG: case Token.BITNOT: tryReduceOperandsForOp(subtree); [BUGGY] return tryFoldUnaryOperator(subtree); [BUGGY]  case Token.VOID: return tryReduceVoid(subtree); default: tryReduceOperandsForOp(subtree); return tryFoldBinaryOperator(subtree); } } [CLASS] PeepholeFoldConstants [METHOD] optimizeSubtree [RETURN_TYPE] Node  Node subtree [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER Node subtree  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.4472135954999579	85	85	3	replace	
86	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] return tryFoldCtorCall(subtree); case Token.TYPEOF: return tryFoldTypeof(subtree); case Token.NOT: case Token.POS: case Token.NEG: case Token.BITNOT: tryReduceOperandsForOp(subtree); [BUGGY] [BUGGY] return tryFoldUnaryOperator(subtree); case Token.VOID: return tryReduceVoid(subtree); default: tryReduceOperandsForOp(subtree); return tryFoldBinaryOperator(subtree); } } [CLASS] PeepholeFoldConstants [METHOD] optimizeSubtree [RETURN_TYPE] Node  Node subtree [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER Node subtree  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.4472135954999579	85	85	3	add	
87	[BUG] [BUGGY] Preconditions.checkState(n.hasOneChild()); [FE] AssertionFailedError [CONTEXT] private Node tryFoldUnaryOperator(Node n) { [BUGGY] Preconditions.checkState(n.hasOneChild()); [BUGGY]  Node left = n.getFirstChild(); Node parent = n.getParent(); if (left == null) { return n; } TernaryValue leftVal = NodeUtil.getPureBooleanValue(left); if (leftVal == TernaryValue.UNKNOWN) { [CLASS] PeepholeFoldConstants [METHOD] tryFoldUnaryOperator [RETURN_TYPE] Node  Node n [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER negNum numValue val value Node left n negNumNode notIntValNode parent replacementNode TernaryValue leftVal int intVal result UnsupportedOperationException ex  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.4472135954999579	326	326	3	replace	
88	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private Node tryFoldUnaryOperator(Node n) { [BUGGY] [BUGGY] Preconditions.checkState(n.hasOneChild()); Node left = n.getFirstChild(); Node parent = n.getParent(); if (left == null) { return n; } TernaryValue leftVal = NodeUtil.getPureBooleanValue(left); if (leftVal == TernaryValue.UNKNOWN) { [CLASS] PeepholeFoldConstants [METHOD] tryFoldUnaryOperator [RETURN_TYPE] Node  Node n [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER negNum numValue val value Node left n negNumNode notIntValNode parent replacementNode TernaryValue leftVal int intVal result UnsupportedOperationException ex  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.4472135954999579	326	326	3	add	
89	[BUG] [BUGGY] Node left = n.getFirstChild(); [FE] AssertionFailedError [CONTEXT] private Node tryFoldUnaryOperator(Node n) { Preconditions.checkState(n.hasOneChild()); [BUGGY] Node left = n.getFirstChild(); [BUGGY] Node parent = n.getParent(); if (left == null) { return n; } TernaryValue leftVal = NodeUtil.getPureBooleanValue(left); if (leftVal == TernaryValue.UNKNOWN) { return n; } [CLASS] PeepholeFoldConstants [METHOD] tryFoldUnaryOperator [RETURN_TYPE] Node  Node n [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER negNum numValue val value Node left n negNumNode notIntValNode parent replacementNode TernaryValue leftVal int intVal result UnsupportedOperationException ex  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.4472135954999579	328	328	3	replace	
90	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private Node tryFoldUnaryOperator(Node n) { Preconditions.checkState(n.hasOneChild()); [BUGGY] [BUGGY] Node left = n.getFirstChild(); Node parent = n.getParent(); if (left == null) { return n; } TernaryValue leftVal = NodeUtil.getPureBooleanValue(left); if (leftVal == TernaryValue.UNKNOWN) { return n; } [CLASS] PeepholeFoldConstants [METHOD] tryFoldUnaryOperator [RETURN_TYPE] Node  Node n [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER negNum numValue val value Node left n negNumNode notIntValNode parent replacementNode TernaryValue leftVal int intVal result UnsupportedOperationException ex  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.4472135954999579	328	328	3	add	
91	[BUG] [BUGGY] Node parent = n.getParent(); [FE] AssertionFailedError [CONTEXT] private Node tryFoldUnaryOperator(Node n) { Preconditions.checkState(n.hasOneChild()); Node left = n.getFirstChild(); [BUGGY] Node parent = n.getParent(); [BUGGY]  if (left == null) { return n; } TernaryValue leftVal = NodeUtil.getPureBooleanValue(left); if (leftVal == TernaryValue.UNKNOWN) { return n; }  [CLASS] PeepholeFoldConstants [METHOD] tryFoldUnaryOperator [RETURN_TYPE] Node  Node n [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER negNum numValue val value Node left n negNumNode notIntValNode parent replacementNode TernaryValue leftVal int intVal result UnsupportedOperationException ex  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.4472135954999579	329	329	3	replace	
92	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private Node tryFoldUnaryOperator(Node n) { Preconditions.checkState(n.hasOneChild()); Node left = n.getFirstChild(); [BUGGY] [BUGGY] Node parent = n.getParent(); if (left == null) { return n; } TernaryValue leftVal = NodeUtil.getPureBooleanValue(left); if (leftVal == TernaryValue.UNKNOWN) { return n; }  [CLASS] PeepholeFoldConstants [METHOD] tryFoldUnaryOperator [RETURN_TYPE] Node  Node n [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER negNum numValue val value Node left n negNumNode notIntValNode parent replacementNode TernaryValue leftVal int intVal result UnsupportedOperationException ex  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.4472135954999579	329	329	3	add	
93	[BUG] [BUGGY] if (left == null) { [FE] AssertionFailedError [CONTEXT] private Node tryFoldUnaryOperator(Node n) { Preconditions.checkState(n.hasOneChild()); Node left = n.getFirstChild(); Node parent = n.getParent(); [BUGGY] if (left == null) { [BUGGY] return n; } TernaryValue leftVal = NodeUtil.getPureBooleanValue(left); if (leftVal == TernaryValue.UNKNOWN) { return n; } switch (n.getType()) { case Token.NOT: [CLASS] PeepholeFoldConstants [METHOD] tryFoldUnaryOperator [RETURN_TYPE] Node  Node n [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER negNum numValue val value Node left n negNumNode notIntValNode parent replacementNode TernaryValue leftVal int intVal result UnsupportedOperationException ex  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.4472135954999579	331	331	3	replace	
94	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private Node tryFoldUnaryOperator(Node n) { Preconditions.checkState(n.hasOneChild()); Node left = n.getFirstChild(); Node parent = n.getParent(); [BUGGY] [BUGGY] if (left == null) { return n; } TernaryValue leftVal = NodeUtil.getPureBooleanValue(left); if (leftVal == TernaryValue.UNKNOWN) { return n; } switch (n.getType()) { case Token.NOT: [CLASS] PeepholeFoldConstants [METHOD] tryFoldUnaryOperator [RETURN_TYPE] Node  Node n [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER negNum numValue val value Node left n negNumNode notIntValNode parent replacementNode TernaryValue leftVal int intVal result UnsupportedOperationException ex  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.4472135954999579	331	331	3	add	
95	[BUG] [BUGGY] TernaryValue leftVal = NodeUtil.getPureBooleanValue(left); [FE] AssertionFailedError [CONTEXT] private Node tryFoldUnaryOperator(Node n) { Preconditions.checkState(n.hasOneChild()); Node left = n.getFirstChild(); Node parent = n.getParent(); if (left == null) { return n; } [BUGGY] TernaryValue leftVal = NodeUtil.getPureBooleanValue(left); [BUGGY] if (leftVal == TernaryValue.UNKNOWN) { return n; } switch (n.getType()) { case Token.NOT:  if (left.getType() == Token.NUMBER) { double numValue = left.getDouble(); if (numValue == 0 || numValue == 1) { [CLASS] PeepholeFoldConstants [METHOD] tryFoldUnaryOperator [RETURN_TYPE] Node  Node n [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER negNum numValue val value Node left n negNumNode notIntValNode parent replacementNode TernaryValue leftVal int intVal result UnsupportedOperationException ex  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.4472135954999579	335	335	3	replace	
96	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private Node tryFoldUnaryOperator(Node n) { Preconditions.checkState(n.hasOneChild()); Node left = n.getFirstChild(); Node parent = n.getParent(); if (left == null) { return n; } [BUGGY] [BUGGY] TernaryValue leftVal = NodeUtil.getPureBooleanValue(left); if (leftVal == TernaryValue.UNKNOWN) { return n; } switch (n.getType()) { case Token.NOT:  if (left.getType() == Token.NUMBER) { double numValue = left.getDouble(); if (numValue == 0 || numValue == 1) { [CLASS] PeepholeFoldConstants [METHOD] tryFoldUnaryOperator [RETURN_TYPE] Node  Node n [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER negNum numValue val value Node left n negNumNode notIntValNode parent replacementNode TernaryValue leftVal int intVal result UnsupportedOperationException ex  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.4472135954999579	335	335	3	add	
97	[BUG] [BUGGY] if (leftVal == TernaryValue.UNKNOWN) { [FE] AssertionFailedError [CONTEXT] Preconditions.checkState(n.hasOneChild()); Node left = n.getFirstChild(); Node parent = n.getParent(); if (left == null) { return n; } TernaryValue leftVal = NodeUtil.getPureBooleanValue(left); [BUGGY] if (leftVal == TernaryValue.UNKNOWN) { [BUGGY] return n; } switch (n.getType()) { case Token.NOT:  if (left.getType() == Token.NUMBER) { double numValue = left.getDouble(); if (numValue == 0 || numValue == 1) { return n; [CLASS] PeepholeFoldConstants [METHOD] tryFoldUnaryOperator [RETURN_TYPE] Node  Node n [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER negNum numValue val value Node left n negNumNode notIntValNode parent replacementNode TernaryValue leftVal int intVal result UnsupportedOperationException ex  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.4472135954999579	336	336	3	replace	
98	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] Preconditions.checkState(n.hasOneChild()); Node left = n.getFirstChild(); Node parent = n.getParent(); if (left == null) { return n; } TernaryValue leftVal = NodeUtil.getPureBooleanValue(left); [BUGGY] [BUGGY] if (leftVal == TernaryValue.UNKNOWN) { return n; } switch (n.getType()) { case Token.NOT:  if (left.getType() == Token.NUMBER) { double numValue = left.getDouble(); if (numValue == 0 || numValue == 1) { return n; [CLASS] PeepholeFoldConstants [METHOD] tryFoldUnaryOperator [RETURN_TYPE] Node  Node n [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER negNum numValue val value Node left n negNumNode notIntValNode parent replacementNode TernaryValue leftVal int intVal result UnsupportedOperationException ex  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.4472135954999579	336	336	3	add	
99	[BUG] [BUGGY] if (undefinedRight) { [FE] AssertionFailedError [CONTEXT] } else if (!rightLiteral) { return n; } else { result = compareToUndefined(right, op); } break; case Token.NULL: case Token.TRUE: case Token.FALSE: [BUGGY] if (undefinedRight) { [BUGGY] result = compareToUndefined(left, op); break; } if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) { return n; } switch (op) { case Token.SHEQ: [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.4364357804719848	923	923	3	replace	
100	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } else if (!rightLiteral) { return n; } else { result = compareToUndefined(right, op); } break; case Token.NULL: case Token.TRUE: case Token.FALSE: [BUGGY] [BUGGY] if (undefinedRight) { result = compareToUndefined(left, op); break; } if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) { return n; } switch (op) { case Token.SHEQ: [CLASS] PeepholeFoldConstants [METHOD] tryFoldComparison [RETURN_TYPE] Node  Node n Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean result rightLiteral undefinedLeft undefinedRight DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left n newNode right String ln rn Boolean compareResult int lhType op rhType  	projects/Closure74/src/com/google/javascript/jscomp/PeepholeFoldConstants.java	0.4364357804719848	923	923	3	add	
