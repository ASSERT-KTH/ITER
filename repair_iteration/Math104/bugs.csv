bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] } else if (a >= 1.0 && x > a) { [FE] AssertionFailedError [CONTEXT] { double ret; if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) { ret = Double.NaN; } else if (x == 0.0) { ret = 0.0; [BUGGY] } else if (a >= 1.0 && x > a) { [BUGGY]   ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	162	162	1	replace	
2	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] { double ret; if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) { ret = Double.NaN; } else if (x == 0.0) { ret = 0.0; [BUGGY] [BUGGY] } else if (a >= 1.0 && x > a) {   ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	162	162	1	add	
3	[BUG] [BUGGY] double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series  double sum = an; // partial sum [FE] AssertionFailedError [CONTEXT] } else if (a >= 1.0 && x > a) {   ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  [BUGGY] double n = 0.0; // current element index   double an = 1.0 / a; // n-th element in the series      double sum = an; // partial sum [BUGGY] double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  n = n + 1.0; an = an * (x / (a + n));  sum = sum + an; } [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	replace	
4	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } else if (a >= 1.0 && x > a) {   ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  [BUGGY] [BUGGY] double n = 0.0; // current element index   double an = 1.0 / a; // n-th element in the series      double sum = an; // partial sum double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  n = n + 1.0; an = an * (x / (a + n));  sum = sum + an; } [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	add	
5	[BUG] [BUGGY] double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum  while (Math.abs(an) > epsilon && n < maxIterations) { [FE] AssertionFailedError [CONTEXT] ret = Double.NaN; } else if (x == 0.0) { ret = 0.0; } else if (a >= 1.0 && x > a) {   ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  double n = 0.0; // current element index [BUGGY] double an = 1.0 / a; // n-th element in the series   double sum = an; // partial sum      while (Math.abs(an) > epsilon && n < maxIterations) { [BUGGY] double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  n = n + 1.0; an = an * (x / (a + n));  sum = sum + an; } if (n >= maxIterations) { [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	replace	
6	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] ret = Double.NaN; } else if (x == 0.0) { ret = 0.0; } else if (a >= 1.0 && x > a) {   ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  double n = 0.0; // current element index [BUGGY] [BUGGY] double an = 1.0 / a; // n-th element in the series   double sum = an; // partial sum      while (Math.abs(an) > epsilon && n < maxIterations) { double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  n = n + 1.0; an = an * (x / (a + n));  sum = sum + an; } if (n >= maxIterations) { [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	add	
7	[BUG] [BUGGY] double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) { [FE] AssertionFailedError [CONTEXT] } else if (x == 0.0) { ret = 0.0; } else if (a >= 1.0 && x > a) {   ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series [BUGGY] double sum = an; // partial sum   while (Math.abs(an) > epsilon && n < maxIterations) { [BUGGY] while (Math.abs(an) > epsilon && n < maxIterations) {  n = n + 1.0; an = an * (x / (a + n));  sum = sum + an; } if (n >= maxIterations) { throw new MaxIterationsExceededException(maxIterations); [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	replace	
8	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } else if (x == 0.0) { ret = 0.0; } else if (a >= 1.0 && x > a) {   ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series [BUGGY] [BUGGY] double sum = an; // partial sum   while (Math.abs(an) > epsilon && n < maxIterations) { while (Math.abs(an) > epsilon && n < maxIterations) {  n = n + 1.0; an = an * (x / (a + n));  sum = sum + an; } if (n >= maxIterations) { throw new MaxIterationsExceededException(maxIterations); [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	add	
9	[BUG] [BUGGY] while (Math.abs(an) > epsilon && n < maxIterations) { [FE] AssertionFailedError [CONTEXT] ret = 0.0; } else if (a >= 1.0 && x > a) {   ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum [BUGGY] while (Math.abs(an) > epsilon && n < maxIterations) { [BUGGY]  n = n + 1.0; an = an * (x / (a + n));  sum = sum + an; } if (n >= maxIterations) { throw new MaxIterationsExceededException(maxIterations); } else { [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	replace	
10	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] ret = 0.0; } else if (a >= 1.0 && x > a) {   ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum [BUGGY] [BUGGY] while (Math.abs(an) > epsilon && n < maxIterations) {  n = n + 1.0; an = an * (x / (a + n));  sum = sum + an; } if (n >= maxIterations) { throw new MaxIterationsExceededException(maxIterations); } else { [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	add	
11	[BUG] [BUGGY] n = n + 1.0; [FE] AssertionFailedError [CONTEXT]   ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  [BUGGY] n = n + 1.0; [BUGGY] an = an * (x / (a + n));  sum = sum + an; } if (n >= maxIterations) { throw new MaxIterationsExceededException(maxIterations); } else { ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum; } [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	replace	
12	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]   ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  [BUGGY] [BUGGY] n = n + 1.0; an = an * (x / (a + n));  sum = sum + an; } if (n >= maxIterations) { throw new MaxIterationsExceededException(maxIterations); } else { ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum; } [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	add	
13	[BUG] [BUGGY] an = an * (x / (a + n)); [FE] AssertionFailedError [CONTEXT]  ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  n = n + 1.0; [BUGGY] an = an * (x / (a + n)); [BUGGY]   sum = sum + an; } if (n >= maxIterations) { throw new MaxIterationsExceededException(maxIterations); } else { ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum; } } [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	replace	
14	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  n = n + 1.0; [BUGGY] [BUGGY] an = an * (x / (a + n));  sum = sum + an; } if (n >= maxIterations) { throw new MaxIterationsExceededException(maxIterations); } else { ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum; } } [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	add	
15	[BUG] [BUGGY] sum = sum + an; [FE] AssertionFailedError [CONTEXT]  double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  n = n + 1.0; an = an * (x / (a + n));  [BUGGY] sum = sum + an; [BUGGY] } if (n >= maxIterations) { throw new MaxIterationsExceededException(maxIterations); } else { ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum; } } return ret; } [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	replace	
16	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  n = n + 1.0; an = an * (x / (a + n));  [BUGGY] [BUGGY] sum = sum + an; } if (n >= maxIterations) { throw new MaxIterationsExceededException(maxIterations); } else { ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum; } } return ret; } [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	add	
17	[BUG] [BUGGY] if (n >= maxIterations) { [FE] AssertionFailedError [CONTEXT] double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  n = n + 1.0; an = an * (x / (a + n));  sum = sum + an; } [BUGGY] if (n >= maxIterations) { [BUGGY] throw new MaxIterationsExceededException(maxIterations); } else { ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum; } } return ret; } [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	replace	
18	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  n = n + 1.0; an = an * (x / (a + n));  sum = sum + an; } [BUGGY] [BUGGY] if (n >= maxIterations) { throw new MaxIterationsExceededException(maxIterations); } else { ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum; } } return ret; } [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	add	
19	[BUG] [BUGGY] ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum; [FE] AssertionFailedError [CONTEXT]  n = n + 1.0; an = an * (x / (a + n));  sum = sum + an; } if (n >= maxIterations) { throw new MaxIterationsExceededException(maxIterations); } else { [BUGGY] ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum; [BUGGY] } } [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	replace	
20	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  n = n + 1.0; an = an * (x / (a + n));  sum = sum + an; } if (n >= maxIterations) { throw new MaxIterationsExceededException(maxIterations); } else { [BUGGY] [BUGGY] ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum; } } [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	add	
21	[BUG] [BUGGY] } else if (x < a || a < 1.0) { [FE] AssertionFailedError [CONTEXT] { double ret; if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) { ret = Double.NaN; } else if (x == 0.0) { ret = 1.0; [BUGGY] } else if (x < a || a < 1.0) { [BUGGY]   ret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations); } else {  ContinuedFraction cf = new ContinuedFraction() { private static final long serialVersionUID = 5378525034886164398L; protected double getA(int n, double x) { [CLASS] Gamma 1 [METHOD] regularizedGammaQ [RETURN_TYPE] double  final double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations n ContinuedFraction cf  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	237	237	1	replace	
22	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] { double ret; if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) { ret = Double.NaN; } else if (x == 0.0) { ret = 1.0; [BUGGY] [BUGGY] } else if (x < a || a < 1.0) {   ret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations); } else {  ContinuedFraction cf = new ContinuedFraction() { private static final long serialVersionUID = 5378525034886164398L; protected double getA(int n, double x) { [CLASS] Gamma 1 [METHOD] regularizedGammaQ [RETURN_TYPE] double  final double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations n ContinuedFraction cf  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	237	237	1	add	
23	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private static final long serialVersionUID = 5378525034886164398L; [CLASS] Gamma 1  [VARIABLES] 	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	243	243	1	replace	
24	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private static final long serialVersionUID = 5378525034886164398L; [CLASS] Gamma 1  [VARIABLES] 	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	243	243	1	add	
25	[BUG] [BUGGY] ret = 1.0 / cf.evaluate(x, epsilon, maxIterations); [FE] AssertionFailedError [CONTEXT] protected double getA(int n, double x) { return ((2.0 * n) + 1.0) - a + x; } protected double getB(int n, double x) { return n * (a - n); } }; [BUGGY] ret = 1.0 / cf.evaluate(x, epsilon, maxIterations); [BUGGY] ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret; } [CLASS] Gamma 1 [METHOD] regularizedGammaQ [RETURN_TYPE] double  final double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations n ContinuedFraction cf  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	256	256	1	replace	
26	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] protected double getA(int n, double x) { return ((2.0 * n) + 1.0) - a + x; } protected double getB(int n, double x) { return n * (a - n); } }; [BUGGY] [BUGGY] ret = 1.0 / cf.evaluate(x, epsilon, maxIterations); ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret; } [CLASS] Gamma 1 [METHOD] regularizedGammaQ [RETURN_TYPE] double  final double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations n ContinuedFraction cf  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	256	256	1	add	
27	[BUG] [BUGGY] ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret; [FE] AssertionFailedError [CONTEXT] protected double getA(int n, double x) { return ((2.0 * n) + 1.0) - a + x; } protected double getB(int n, double x) { return n * (a - n); } }; ret = 1.0 / cf.evaluate(x, epsilon, maxIterations); [BUGGY] ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret; [BUGGY] } [CLASS] Gamma 1 [METHOD] regularizedGammaQ [RETURN_TYPE] double  final double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations n ContinuedFraction cf  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	257	257	1	replace	
28	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] protected double getA(int n, double x) { return ((2.0 * n) + 1.0) - a + x; } protected double getB(int n, double x) { return n * (a - n); } }; ret = 1.0 / cf.evaluate(x, epsilon, maxIterations); [BUGGY] [BUGGY] ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret; } [CLASS] Gamma 1 [METHOD] regularizedGammaQ [RETURN_TYPE] double  final double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations n ContinuedFraction cf  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	257	257	1	add	
29	[BUG] [BUGGY] double g = 607.0 / 128.0; [FE] AssertionFailedError [CONTEXT] public static double logGamma(double x) { double ret; if (Double.isNaN(x) || (x <= 0.0)) { ret = Double.NaN; } else { [BUGGY] double g = 607.0 / 128.0; [BUGGY]  double sum = 0.0; for (int i = lanczos.length - 1; i > 0; --i) { sum = sum + (lanczos[i] / (x + i)); } sum = sum + lanczos[0]; double tmp = x + g + .5; ret = ((x + .5) * Math.log(tmp)) - tmp + HALF_LOG_2_PI + Math.log(sum / x); [CLASS] Gamma 1 [METHOD] logGamma [RETURN_TYPE] double  double x [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI g ret sum tmp x long serialVersionUID int i  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	0.7071067811865475	93	93	1	replace	
30	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public static double logGamma(double x) { double ret; if (Double.isNaN(x) || (x <= 0.0)) { ret = Double.NaN; } else { [BUGGY] [BUGGY] double g = 607.0 / 128.0; double sum = 0.0; for (int i = lanczos.length - 1; i > 0; --i) { sum = sum + (lanczos[i] / (x + i)); } sum = sum + lanczos[0]; double tmp = x + g + .5; ret = ((x + .5) * Math.log(tmp)) - tmp + HALF_LOG_2_PI + Math.log(sum / x); [CLASS] Gamma 1 [METHOD] logGamma [RETURN_TYPE] double  double x [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI g ret sum tmp x long serialVersionUID int i  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	0.7071067811865475	93	93	1	add	
31	[BUG] [BUGGY] double sum = 0.0; [FE] AssertionFailedError [CONTEXT] public static double logGamma(double x) { double ret; if (Double.isNaN(x) || (x <= 0.0)) { ret = Double.NaN; } else { double g = 607.0 / 128.0; [BUGGY] double sum = 0.0; [BUGGY] for (int i = lanczos.length - 1; i > 0; --i) { sum = sum + (lanczos[i] / (x + i)); } sum = sum + lanczos[0]; double tmp = x + g + .5; ret = ((x + .5) * Math.log(tmp)) - tmp + HALF_LOG_2_PI + Math.log(sum / x); }  [CLASS] Gamma 1 [METHOD] logGamma [RETURN_TYPE] double  double x [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI g ret sum tmp x long serialVersionUID int i  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	0.7071067811865475	95	95	1	replace	
32	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public static double logGamma(double x) { double ret; if (Double.isNaN(x) || (x <= 0.0)) { ret = Double.NaN; } else { double g = 607.0 / 128.0; [BUGGY] [BUGGY] double sum = 0.0; for (int i = lanczos.length - 1; i > 0; --i) { sum = sum + (lanczos[i] / (x + i)); } sum = sum + lanczos[0]; double tmp = x + g + .5; ret = ((x + .5) * Math.log(tmp)) - tmp + HALF_LOG_2_PI + Math.log(sum / x); }  [CLASS] Gamma 1 [METHOD] logGamma [RETURN_TYPE] double  double x [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI g ret sum tmp x long serialVersionUID int i  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	0.7071067811865475	95	95	1	add	
33	[BUG] [BUGGY] for (int i = lanczos.length - 1; i > 0; --i) { [FE] AssertionFailedError [CONTEXT] public static double logGamma(double x) { double ret; if (Double.isNaN(x) || (x <= 0.0)) { ret = Double.NaN; } else { double g = 607.0 / 128.0; double sum = 0.0; [BUGGY] for (int i = lanczos.length - 1; i > 0; --i) { [BUGGY] sum = sum + (lanczos[i] / (x + i)); } sum = sum + lanczos[0]; double tmp = x + g + .5; ret = ((x + .5) * Math.log(tmp)) - tmp + HALF_LOG_2_PI + Math.log(sum / x); } return ret; [CLASS] Gamma 1 [METHOD] logGamma [RETURN_TYPE] double  double x [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI g ret sum tmp x long serialVersionUID int i  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	0.7071067811865475	96	96	1	replace	
34	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public static double logGamma(double x) { double ret; if (Double.isNaN(x) || (x <= 0.0)) { ret = Double.NaN; } else { double g = 607.0 / 128.0; double sum = 0.0; [BUGGY] [BUGGY] for (int i = lanczos.length - 1; i > 0; --i) { sum = sum + (lanczos[i] / (x + i)); } sum = sum + lanczos[0]; double tmp = x + g + .5; ret = ((x + .5) * Math.log(tmp)) - tmp + HALF_LOG_2_PI + Math.log(sum / x); } return ret; [CLASS] Gamma 1 [METHOD] logGamma [RETURN_TYPE] double  double x [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI g ret sum tmp x long serialVersionUID int i  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	0.7071067811865475	96	96	1	add	
35	[BUG] [BUGGY] sum = sum + (lanczos[i] / (x + i)); [FE] AssertionFailedError [CONTEXT] public static double logGamma(double x) { double ret; if (Double.isNaN(x) || (x <= 0.0)) { ret = Double.NaN; } else { double g = 607.0 / 128.0; double sum = 0.0; for (int i = lanczos.length - 1; i > 0; --i) { [BUGGY] sum = sum + (lanczos[i] / (x + i)); [BUGGY] } sum = sum + lanczos[0]; double tmp = x + g + .5; ret = ((x + .5) * Math.log(tmp)) - tmp + HALF_LOG_2_PI + Math.log(sum / x); } return ret; } [CLASS] Gamma 1 [METHOD] logGamma [RETURN_TYPE] double  double x [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI g ret sum tmp x long serialVersionUID int i  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	0.7071067811865475	97	97	1	replace	
36	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public static double logGamma(double x) { double ret; if (Double.isNaN(x) || (x <= 0.0)) { ret = Double.NaN; } else { double g = 607.0 / 128.0; double sum = 0.0; for (int i = lanczos.length - 1; i > 0; --i) { [BUGGY] [BUGGY] sum = sum + (lanczos[i] / (x + i)); } sum = sum + lanczos[0]; double tmp = x + g + .5; ret = ((x + .5) * Math.log(tmp)) - tmp + HALF_LOG_2_PI + Math.log(sum / x); } return ret; } [CLASS] Gamma 1 [METHOD] logGamma [RETURN_TYPE] double  double x [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI g ret sum tmp x long serialVersionUID int i  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	0.7071067811865475	97	97	1	add	
37	[BUG] [BUGGY] sum = sum + lanczos[0]; [FE] AssertionFailedError [CONTEXT] if (Double.isNaN(x) || (x <= 0.0)) { ret = Double.NaN; } else { double g = 607.0 / 128.0; double sum = 0.0; for (int i = lanczos.length - 1; i > 0; --i) { sum = sum + (lanczos[i] / (x + i)); } [BUGGY] sum = sum + lanczos[0]; [BUGGY]  double tmp = x + g + .5; ret = ((x + .5) * Math.log(tmp)) - tmp + HALF_LOG_2_PI + Math.log(sum / x); } return ret; } [CLASS] Gamma 1 [METHOD] logGamma [RETURN_TYPE] double  double x [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI g ret sum tmp x long serialVersionUID int i  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	0.7071067811865475	99	99	1	replace	
38	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (Double.isNaN(x) || (x <= 0.0)) { ret = Double.NaN; } else { double g = 607.0 / 128.0; double sum = 0.0; for (int i = lanczos.length - 1; i > 0; --i) { sum = sum + (lanczos[i] / (x + i)); } [BUGGY] [BUGGY] sum = sum + lanczos[0]; double tmp = x + g + .5; ret = ((x + .5) * Math.log(tmp)) - tmp + HALF_LOG_2_PI + Math.log(sum / x); } return ret; } [CLASS] Gamma 1 [METHOD] logGamma [RETURN_TYPE] double  double x [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI g ret sum tmp x long serialVersionUID int i  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	0.7071067811865475	99	99	1	add	
39	[BUG] [BUGGY] double tmp = x + g + .5; [FE] AssertionFailedError [CONTEXT] ret = Double.NaN; } else { double g = 607.0 / 128.0; double sum = 0.0; for (int i = lanczos.length - 1; i > 0; --i) { sum = sum + (lanczos[i] / (x + i)); } sum = sum + lanczos[0]; [BUGGY] double tmp = x + g + .5; [BUGGY] ret = ((x + .5) * Math.log(tmp)) - tmp + HALF_LOG_2_PI + Math.log(sum / x); } return ret; } [CLASS] Gamma 1 [METHOD] logGamma [RETURN_TYPE] double  double x [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI g ret sum tmp x long serialVersionUID int i  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	0.7071067811865475	101	101	1	replace	
40	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] ret = Double.NaN; } else { double g = 607.0 / 128.0; double sum = 0.0; for (int i = lanczos.length - 1; i > 0; --i) { sum = sum + (lanczos[i] / (x + i)); } sum = sum + lanczos[0]; [BUGGY] [BUGGY] double tmp = x + g + .5; ret = ((x + .5) * Math.log(tmp)) - tmp + HALF_LOG_2_PI + Math.log(sum / x); } return ret; } [CLASS] Gamma 1 [METHOD] logGamma [RETURN_TYPE] double  double x [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI g ret sum tmp x long serialVersionUID int i  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	0.7071067811865475	101	101	1	add	
41	[BUG] [BUGGY] ret = ((x + .5) * Math.log(tmp)) - tmp + HALF_LOG_2_PI + Math.log(sum / x); [FE] AssertionFailedError [CONTEXT] } else { double g = 607.0 / 128.0; double sum = 0.0; for (int i = lanczos.length - 1; i > 0; --i) { sum = sum + (lanczos[i] / (x + i)); } sum = sum + lanczos[0]; double tmp = x + g + .5; [BUGGY] ret = ((x + .5) * Math.log(tmp)) - tmp +    HALF_LOG_2_PI + Math.log(sum / x); [BUGGY] HALF_LOG_2_PI + Math.log(sum / x); } return ret; } [CLASS] Gamma 1 [METHOD] logGamma [RETURN_TYPE] double  double x [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI g ret sum tmp x long serialVersionUID int i  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	0.7071067811865475	102	103	1	replace	
42	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } else { double g = 607.0 / 128.0; double sum = 0.0; for (int i = lanczos.length - 1; i > 0; --i) { sum = sum + (lanczos[i] / (x + i)); } sum = sum + lanczos[0]; double tmp = x + g + .5; [BUGGY] [BUGGY] ret = ((x + .5) * Math.log(tmp)) - tmp +    HALF_LOG_2_PI + Math.log(sum / x); HALF_LOG_2_PI + Math.log(sum / x); } return ret; } [CLASS] Gamma 1 [METHOD] logGamma [RETURN_TYPE] double  double x [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI g ret sum tmp x long serialVersionUID int i  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	0.7071067811865475	102	103	1	add	
43	[BUG] [BUGGY] } else if (x == 0.0) { [FE] AssertionFailedError [CONTEXT] { double ret; if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) { ret = Double.NaN; [BUGGY] } else if (x == 0.0) { [BUGGY] ret = 0.0; } else if (a >= 1.0 && x > a) {   ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	0.7071067811865475	160	160	1	replace	
44	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] { double ret; if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) { ret = Double.NaN; [BUGGY] [BUGGY] } else if (x == 0.0) { ret = 0.0; } else if (a >= 1.0 && x > a) {   ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	0.7071067811865475	160	160	1	add	
45	[BUG] [BUGGY] } else if (x == 0.0) { [FE] AssertionFailedError [CONTEXT] { double ret; if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) { ret = Double.NaN; [BUGGY] } else if (x == 0.0) { [BUGGY] ret = 1.0; } else if (x < a || a < 1.0) {   ret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations); } else {  ContinuedFraction cf = new ContinuedFraction() { private static final long serialVersionUID = 5378525034886164398L; [CLASS] Gamma 1 [METHOD] regularizedGammaQ [RETURN_TYPE] double  final double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations n ContinuedFraction cf  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	0.7071067811865475	235	235	1	replace	
46	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] { double ret; if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) { ret = Double.NaN; [BUGGY] [BUGGY] } else if (x == 0.0) { ret = 1.0; } else if (x < a || a < 1.0) {   ret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations); } else {  ContinuedFraction cf = new ContinuedFraction() { private static final long serialVersionUID = 5378525034886164398L; [CLASS] Gamma 1 [METHOD] regularizedGammaQ [RETURN_TYPE] double  final double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations n ContinuedFraction cf  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	0.7071067811865475	235	235	1	add	
47	[BUG] [BUGGY] if (Double.isNaN(x) || (x <= 0.0)) { [FE] AssertionFailedError [CONTEXT] public static double logGamma(double x) { double ret; [BUGGY] if (Double.isNaN(x) || (x <= 0.0)) { [BUGGY] ret = Double.NaN; } else { double g = 607.0 / 128.0; double sum = 0.0; for (int i = lanczos.length - 1; i > 0; --i) { sum = sum + (lanczos[i] / (x + i)); } sum = sum + lanczos[0];  [CLASS] Gamma 1 [METHOD] logGamma [RETURN_TYPE] double  double x [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI g ret sum tmp x long serialVersionUID int i  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	0.4472135954999579	90	90	1	replace	
48	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public static double logGamma(double x) { double ret; [BUGGY] [BUGGY] if (Double.isNaN(x) || (x <= 0.0)) { ret = Double.NaN; } else { double g = 607.0 / 128.0; double sum = 0.0; for (int i = lanczos.length - 1; i > 0; --i) { sum = sum + (lanczos[i] / (x + i)); } sum = sum + lanczos[0];  [CLASS] Gamma 1 [METHOD] logGamma [RETURN_TYPE] double  double x [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI g ret sum tmp x long serialVersionUID int i  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	0.4472135954999579	90	90	1	add	
49	[BUG] [BUGGY] return ret; [FE] AssertionFailedError [CONTEXT] for (int i = lanczos.length - 1; i > 0; --i) { sum = sum + (lanczos[i] / (x + i)); } sum = sum + lanczos[0]; double tmp = x + g + .5; ret = ((x + .5) * Math.log(tmp)) - tmp + HALF_LOG_2_PI + Math.log(sum / x); } [BUGGY] return ret; [BUGGY] } [CLASS] Gamma 1 [METHOD] logGamma [RETURN_TYPE] double  double x [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI g ret sum tmp x long serialVersionUID int i  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	0.4472135954999579	106	106	1	replace	
50	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] for (int i = lanczos.length - 1; i > 0; --i) { sum = sum + (lanczos[i] / (x + i)); } sum = sum + lanczos[0]; double tmp = x + g + .5; ret = ((x + .5) * Math.log(tmp)) - tmp + HALF_LOG_2_PI + Math.log(sum / x); } [BUGGY] [BUGGY] return ret; } [CLASS] Gamma 1 [METHOD] logGamma [RETURN_TYPE] double  double x [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI g ret sum tmp x long serialVersionUID int i  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	0.4472135954999579	106	106	1	add	
