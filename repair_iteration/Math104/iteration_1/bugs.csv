bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number
this_action1	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {    [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum;  [BUGGY]  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	add	    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	12	1
2	[BUG]  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum;  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {    [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum;  [BUGGY]  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	replace	    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	12	1	add
2	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {    [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  an;  [BUGGY]  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	add	    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  an;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	12	1
3	[BUG]  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  an;  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {    [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  an;  [BUGGY]  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	replace	    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  an;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	12	1	add
3	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {    [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a));  [BUGGY]  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	add	    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a));		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	12	1
4	[BUG]  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a));  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {    [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a));  [BUGGY]  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	replace	    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a));		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	12	1	add
4	[BUG]  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum);  [CE]  ';'  expected  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {    [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum);  [BUGGY]  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	replace	    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum);		non-compiled	[CE]  ';'  expected	12	None	add
5	[BUG]  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  an);  [CE]  ';'  expected  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {    [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  an);  [BUGGY]  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	replace	    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  an);		non-compiled	[CE]  ';'  expected	12	None	add
12	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));    [BUGGY]  sum  =  sum  +  an  *  epsilon;  [BUGGY]  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	add	sum  =  sum  +  an  *  epsilon;	sum  =  sum  +  an;  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	15	1
13	[BUG]  [BUGGY]  sum  =  sum  +  an  *  epsilon;  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));    [BUGGY]  sum  =  sum  +  an  *  epsilon;  [BUGGY]  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	replace	sum  =  sum  +  an  *  epsilon;	sum  =  sum  +  an;  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	15	1	replace
13	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));    [BUGGY]  sum  =  sum  /  an;  [BUGGY]  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	add	sum  =  sum  /  an;	sum  =  sum  +  an;  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	15	1
14	[BUG]  [BUGGY]  sum  =  sum  /  an;  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));    [BUGGY]  sum  =  sum  /  an;  [BUGGY]  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	replace	sum  =  sum  /  an;	sum  =  sum  +  an;  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	15	1	replace
14	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));    [BUGGY]  sum  =  sum  +  an  /  epsilon;  [BUGGY]  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	add	sum  =  sum  +  an  /  epsilon;	sum  =  sum  +  an;  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	15	1
15	[BUG]  [BUGGY]  sum  =  sum  +  an  /  epsilon;  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));    [BUGGY]  sum  =  sum  +  an  /  epsilon;  [BUGGY]  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	replace	sum  =  sum  +  an  /  epsilon;	sum  =  sum  +  an;  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	15	1	replace
15	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));    [BUGGY]    [BUGGY]  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	add	  	sum  =  sum  +  an;  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	15	1
16	[BUG]  [BUGGY]    [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));    [BUGGY]    [BUGGY]  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	replace	  	sum  =  sum  +  an;  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	15	1	replace
21	[BUG]  [BUGGY]    n  =  Math.log(a)-  logGamma(a));  [CE]  ';'  expected  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [BUGGY]    n  =  Math.log(a)-  logGamma(a));  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	replace	    n  =  Math.log(a)-  logGamma(a));		non-compiled	[CE]  ';'  expected	14	None	add
22	[BUG]  [BUGGY]  timeout  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [BUGGY]    n  =  Math.log(an)/  epsilon;  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	add	    n  =  Math.log(an)/  epsilon;		compilable	timeout	14	1
23	[BUG]  [BUGGY]    n  =  Math.log(an)/  epsilon;  timeout  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [BUGGY]    n  =  Math.log(an)/  epsilon;  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	replace	    n  =  Math.log(an)/  epsilon;		compilable	timeout	14	1	add
23	[BUG]  [BUGGY]  timeout  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [BUGGY]    n  =  Math.log(an)/  HALF_LOG_2_PI;  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	add	    n  =  Math.log(an)/  HALF_LOG_2_PI;		compilable	timeout	14	1
24	[BUG]  [BUGGY]    n  =  Math.log(an)/  HALF_LOG_2_PI;  timeout  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [BUGGY]    n  =  Math.log(an)/  HALF_LOG_2_PI;  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	replace	    n  =  Math.log(an)/  HALF_LOG_2_PI;		compilable	timeout	14	1	add
24	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [BUGGY]    n  =  Math.abs(an)/  epsilon;  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	add	    n  =  Math.abs(an)/  epsilon;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	14	1
25	[BUG]  [BUGGY]    n  =  Math.abs(an)/  epsilon;  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [BUGGY]    n  =  Math.abs(an)/  epsilon;  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	replace	    n  =  Math.abs(an)/  epsilon;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	14	1	add
25	[BUG]  [BUGGY]    n  =  Math.log(an)/  HALF_LOG_2_PI);  [CE]  ';'  expected  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [BUGGY]    n  =  Math.log(an)/  HALF_LOG_2_PI);  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	replace	    n  =  Math.log(an)/  HALF_LOG_2_PI);		non-compiled	[CE]  ';'  expected	14	None	add
32	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {    [BUGGY]  n  =  an  +  1.0;  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	add	n  =  an  +  1.0;	n  =  n  +  1.0;  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	11	1
33	[BUG]  [BUGGY]  n  =  an  +  1.0;  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {    [BUGGY]  n  =  an  +  1.0;  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	replace	n  =  an  +  1.0;	n  =  n  +  1.0;  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	11	1	replace
33	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {    [BUGGY]  n  =  n  +  0.5;  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	add	n  =  n  +  0.5;	n  =  n  +  1.0;  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	11	1
34	[BUG]  [BUGGY]  n  =  n  +  0.5;  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {    [BUGGY]  n  =  n  +  0.5;  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	replace	n  =  n  +  0.5;	n  =  n  +  1.0;  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	11	1	replace
34	[BUG]  [BUGGY]  timeout  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {    [BUGGY]  n  =  n  *  1.0;  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	add	n  =  n  *  1.0;	n  =  n  +  1.0;  	compilable	timeout	11	1
35	[BUG]  [BUGGY]  n  =  n  *  1.0;  timeout  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {    [BUGGY]  n  =  n  *  1.0;  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	replace	n  =  n  *  1.0;	n  =  n  +  1.0;  	compilable	timeout	11	1	replace
41	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  [BUGGY]    n  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series    double  sum  =  an;  //  partial  sum      while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	add	    n  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	6	1
42	[BUG]  [BUGGY]    n  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  [BUGGY]    n  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series    double  sum  =  an;  //  partial  sum      while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	replace	    n  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	6	1	add
42	[BUG]  [BUGGY]    -  regularizedGammaQ(a,  x,  epsilon,  maxIterations));  [CE]  not  a  statement  [CONTEXT]  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  [BUGGY]    -  regularizedGammaQ(a,  x,  epsilon,  maxIterations));  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series    double  sum  =  an;  //  partial  sum      while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	replace	    -  regularizedGammaQ(a,  x,  epsilon,  maxIterations));		non-compiled	[CE]  not  a  statement	6	None	add
43	[BUG]  [BUGGY]    n  =  regularizedGammaQ(x,  epsilon,  maxIterations);  [CE]  no  suitable  method  found  for  regularizedGammaQ(double,double,int)  [CONTEXT]  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  [BUGGY]    n  =  regularizedGammaQ(x,  epsilon,  maxIterations);  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series    double  sum  =  an;  //  partial  sum      while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	replace	    n  =  regularizedGammaQ(x,  epsilon,  maxIterations);		non-compiled	[CE]  no  suitable  method  found  for  regularizedGammaQ(double,double,int)	6	None	add
44	[BUG]  [BUGGY]    -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [CE]  not  a  statement  [CONTEXT]  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  [BUGGY]    -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series    double  sum  =  an;  //  partial  sum      while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	replace	    -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		non-compiled	[CE]  not  a  statement	6	None	add
45	[BUG]  [BUGGY]    n  =  RegularizedGammaQ(a,  x,  epsilon,  maxIterations);  [CE]  cannot  find  symbol  [CONTEXT]  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  [BUGGY]    n  =  RegularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series    double  sum  =  an;  //  partial  sum      while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	replace	    n  =  RegularizedGammaQ(a,  x,  epsilon,  maxIterations);		non-compiled	[CE]  cannot  find  symbol	6	None	add
52	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  {  double  ret;  if  (Double.isNaN(a)  ||  Double.isNaN(x)  ||  (a  <=  0.0)  ||  (x  <  0.0))  {  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  [BUGGY]  }  else  if(a  <=  1.0  &&  x  >  a)  {  [BUGGY]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	162	162	1	add	}  else  if(a  <=  1.0  &&  x  >  a)  {	}  else  if  (a  >=  1.0  &&  x  >  a)  {  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	1	1
53	[BUG]  [BUGGY]  }  else  if(a  <=  1.0  &&  x  >  a)  {  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  {  double  ret;  if  (Double.isNaN(a)  ||  Double.isNaN(x)  ||  (a  <=  0.0)  ||  (x  <  0.0))  {  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  [BUGGY]  }  else  if(a  <=  1.0  &&  x  >  a)  {  [BUGGY]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	162	162	1	replace	}  else  if(a  <=  1.0  &&  x  >  a)  {	}  else  if  (a  >=  1.0  &&  x  >  a)  {  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	1	1	replace
53	[BUG]  [BUGGY]  else  if(a  >=  1.0  &&  x  >  a)  {  [CE]  'else'  without  'if'  [CONTEXT]  {  double  ret;  if  (Double.isNaN(a)  ||  Double.isNaN(x)  ||  (a  <=  0.0)  ||  (x  <  0.0))  {  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  [BUGGY]  else  if(a  >=  1.0  &&  x  >  a)  {  [BUGGY]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	162	162	1	replace	else  if(a  >=  1.0  &&  x  >  a)  {	}  else  if  (a  >=  1.0  &&  x  >  a)  {  	non-compiled	[CE]  'else'  without  'if'	1	None	replace
54	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  {  double  ret;  if  (Double.isNaN(a)  ||  Double.isNaN(x)  ||  (a  <=  0.0)  ||  (x  <  0.0))  {  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  [BUGGY]  }  else  if(a  <  1.0  &&  x  >  a)  {  [BUGGY]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	162	162	1	add	}  else  if(a  <  1.0  &&  x  >  a)  {	}  else  if  (a  >=  1.0  &&  x  >  a)  {  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	1	1
55	[BUG]  [BUGGY]  }  else  if(a  <  1.0  &&  x  >  a)  {  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  {  double  ret;  if  (Double.isNaN(a)  ||  Double.isNaN(x)  ||  (a  <=  0.0)  ||  (x  <  0.0))  {  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  [BUGGY]  }  else  if(a  <  1.0  &&  x  >  a)  {  [BUGGY]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	162	162	1	replace	}  else  if(a  <  1.0  &&  x  >  a)  {	}  else  if  (a  >=  1.0  &&  x  >  a)  {  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	1	1	replace
55	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  {  double  ret;  if  (Double.isNaN(a)  ||  Double.isNaN(x)  ||  (a  <=  0.0)  ||  (x  <  0.0))  {  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  [BUGGY]    [BUGGY]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	162	162	1	add	  	}  else  if  (a  >=  1.0  &&  x  >  a)  {  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	1	1
56	[BUG]  [BUGGY]    [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  {  double  ret;  if  (Double.isNaN(a)  ||  Double.isNaN(x)  ||  (a  <=  0.0)  ||  (x  <  0.0))  {  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  [BUGGY]    [BUGGY]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	162	162	1	replace	  	}  else  if  (a  >=  1.0  &&  x  >  a)  {  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	1	1	replace
61	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {    [BUGGY]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  double  n  =  0.0;  //  current  element  index    double  an  =  1.0  /  a;  //  n-th  element  in  the  series      double  sum  =  an;  //  partial  sum  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	add	    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	4	1
62	[BUG]  [BUGGY]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {    [BUGGY]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  double  n  =  0.0;  //  current  element  index    double  an  =  1.0  /  a;  //  n-th  element  in  the  series      double  sum  =  an;  //  partial  sum  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	replace	    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	4	1	add
62	[BUG]  [BUGGY]    ret  =  1.0  -  normalizedGammaQ(a,  x,  epsilon,  maxIterations);  [CE]  cannot  find  symbol  [CONTEXT]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {    [BUGGY]    ret  =  1.0  -  normalizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  double  n  =  0.0;  //  current  element  index    double  an  =  1.0  /  a;  //  n-th  element  in  the  series      double  sum  =  an;  //  partial  sum  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	replace	    ret  =  1.0  -  normalizedGammaQ(a,  x,  epsilon,  maxIterations);		non-compiled	[CE]  cannot  find  symbol	4	None	add
63	[BUG]  [BUGGY]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations));  [CE]  ';'  expected  [CONTEXT]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {    [BUGGY]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations));  [BUGGY]  double  n  =  0.0;  //  current  element  index    double  an  =  1.0  /  a;  //  n-th  element  in  the  series      double  sum  =  an;  //  partial  sum  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	replace	    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations));		non-compiled	[CE]  ';'  expected	4	None	add
64	[BUG]  [BUGGY]    ret  =  1.0  -  regularizedGammaQ(x,  epsilon,  maxIterations);  [CE]  no  suitable  method  found  for  regularizedGammaQ(double,double,int)  [CONTEXT]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {    [BUGGY]    ret  =  1.0  -  regularizedGammaQ(x,  epsilon,  maxIterations);  [BUGGY]  double  n  =  0.0;  //  current  element  index    double  an  =  1.0  /  a;  //  n-th  element  in  the  series      double  sum  =  an;  //  partial  sum  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	replace	    ret  =  1.0  -  regularizedGammaQ(x,  epsilon,  maxIterations);		non-compiled	[CE]  no  suitable  method  found  for  regularizedGammaQ(double,double,int)	4	None	add
71	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  [BUGGY]    n  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	add	    n  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	8	1
72	[BUG]  [BUGGY]    n  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  [BUGGY]    n  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	replace	    n  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	8	1	add
72	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  [BUGGY]    an  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	add	    an  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	8	1
73	[BUG]  [BUGGY]    an  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  [BUGGY]    an  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	replace	    an  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	8	1	add
73	[BUG]  [BUGGY]    -  regularizedGammaQ(a,  x,  epsilon,  maxIterations));  [CE]  not  a  statement  [CONTEXT]  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  [BUGGY]    -  regularizedGammaQ(a,  x,  epsilon,  maxIterations));  [BUGGY]  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	replace	    -  regularizedGammaQ(a,  x,  epsilon,  maxIterations));		non-compiled	[CE]  not  a  statement	8	None	add
74	[BUG]  [BUGGY]    an  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations));  [CE]  ';'  expected  [CONTEXT]  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  [BUGGY]    an  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations));  [BUGGY]  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	replace	    an  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations));		non-compiled	[CE]  ';'  expected	8	None	add
75	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  [BUGGY]    n  =  regularizedGammaQ(x,  an,  epsilon,  maxIterations);  [BUGGY]  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	add	    n  =  regularizedGammaQ(x,  an,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	8	1
76	[BUG]  [BUGGY]    n  =  regularizedGammaQ(x,  an,  epsilon,  maxIterations);  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  [BUGGY]    n  =  regularizedGammaQ(x,  an,  epsilon,  maxIterations);  [BUGGY]  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	replace	    n  =  regularizedGammaQ(x,  an,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	8	1	add
81	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [BUGGY]  if(n  >  maxIterations)  {  [BUGGY]  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	add	if(n  >  maxIterations)  {	if  (n  >=  maxIterations)  {  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	17	1
82	[BUG]  [BUGGY]  if(n  >  maxIterations)  {  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [BUGGY]  if(n  >  maxIterations)  {  [BUGGY]  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	replace	if(n  >  maxIterations)  {	if  (n  >=  maxIterations)  {  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	17	1	replace
83	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [BUGGY]  if(n  <  maxIterations)  {  [BUGGY]  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	add	if(n  <  maxIterations)  {	if  (n  >=  maxIterations)  {  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	17	1
84	[BUG]  [BUGGY]  if(n  <  maxIterations)  {  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [BUGGY]  if(n  <  maxIterations)  {  [BUGGY]  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	replace	if(n  <  maxIterations)  {	if  (n  >=  maxIterations)  {  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	17	1	replace
84	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [BUGGY]  if(n  <=  maxIterations)  {  [BUGGY]  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	add	if(n  <=  maxIterations)  {	if  (n  >=  maxIterations)  {  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	17	1
85	[BUG]  [BUGGY]  if(n  <=  maxIterations)  {  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [BUGGY]  if(n  <=  maxIterations)  {  [BUGGY]  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	replace	if(n  <=  maxIterations)  {	if  (n  >=  maxIterations)  {  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	17	1	replace
85	[BUG]  [BUGGY]    [CE]  'else'  without  'if'  [CONTEXT]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [BUGGY]    [BUGGY]  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	replace	  	if  (n  >=  maxIterations)  {  	non-compiled	[CE]  'else'  without  'if'	17	None	replace
93	[BUG]  [BUGGY]  ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  Sum;  [CE]  cannot  find  symbol  Sum  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]  ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  Sum;  [BUGGY]  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	replace	ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  Sum;	ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  	non-compiled	[CE]  cannot  find  symbol  Sum	19	None	replace
94	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]  ret  =  Math.exp(-x  +(a  *  Math.log(x))  /  logGamma(a))  *  sum;  [BUGGY]  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	add	ret  =  Math.exp(-x  +(a  *  Math.log(x))  /  logGamma(a))  *  sum;	ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	19	1
95	[BUG]  [BUGGY]  ret  =  Math.exp(-x  +(a  *  Math.log(x))  /  logGamma(a))  *  sum;  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]  ret  =  Math.exp(-x  +(a  *  Math.log(x))  /  logGamma(a))  *  sum;  [BUGGY]  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	replace	ret  =  Math.exp(-x  +(a  *  Math.log(x))  /  logGamma(a))  *  sum;	ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	19	1	replace
95	[BUG]  [BUGGY]    [CE]  variable  ret  might  not  have  been  initialized  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]    [BUGGY]  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	replace	  	ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  	non-compiled	[CE]  variable  ret  might  not  have  been  initialized	19	None	replace
102	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]  while(Math.abs(an)>  epsilon  &&  n  <=  maxIterations)  {  [BUGGY]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	add	while(Math.abs(an)>  epsilon  &&  n  <=  maxIterations)  {	while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	9	1
103	[BUG]  [BUGGY]  while(Math.abs(an)>  epsilon  &&  n  <=  maxIterations)  {  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]  while(Math.abs(an)>  epsilon  &&  n  <=  maxIterations)  {  [BUGGY]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	replace	while(Math.abs(an)>  epsilon  &&  n  <=  maxIterations)  {	while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	9	1	replace
103	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]  while(Math.abs(an)>  epsilon  ||  n  <  maxIterations)  {  [BUGGY]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	add	while(Math.abs(an)>  epsilon  ||  n  <  maxIterations)  {	while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	9	1
104	[BUG]  [BUGGY]  while(Math.abs(an)>  epsilon  ||  n  <  maxIterations)  {  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]  while(Math.abs(an)>  epsilon  ||  n  <  maxIterations)  {  [BUGGY]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	replace	while(Math.abs(an)>  epsilon  ||  n  <  maxIterations)  {	while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	9	1	replace
104	[BUG]  [BUGGY]  while(Math.abs(an)>  epsilon  &&  n  <  maximalIterations)  {  [CE]  cannot  find  symbol  maximalIterations  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]  while(Math.abs(an)>  epsilon  &&  n  <  maximalIterations)  {  [BUGGY]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	replace	while(Math.abs(an)>  epsilon  &&  n  <  maximalIterations)  {	while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  	non-compiled	[CE]  cannot  find  symbol  maximalIterations	9	None	replace
105	[BUG]  [BUGGY]    [CE]  illegal  start  of  type  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]    [BUGGY]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	replace	  	while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  	non-compiled	[CE]  illegal  start  of  type	9	None	replace
111	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum;  [BUGGY]  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	add	    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	18	1
112	[BUG]  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum;  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum;  [BUGGY]  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	replace	    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	18	1	add
113	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [BUGGY]    ret  =  Math.exp(-x  *(a  *  Math.log(x))  -  logGamma(a))  *  sum;  [BUGGY]  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	add	    ret  =  Math.exp(-x  *(a  *  Math.log(x))  -  logGamma(a))  *  sum;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	18	1
114	[BUG]  [BUGGY]    ret  =  Math.exp(-x  *(a  *  Math.log(x))  -  logGamma(a))  *  sum;  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [BUGGY]    ret  =  Math.exp(-x  *(a  *  Math.log(x))  -  logGamma(a))  *  sum;  [BUGGY]  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	replace	    ret  =  Math.exp(-x  *(a  *  Math.log(x))  -  logGamma(a))  *  sum;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	18	1	add
114	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  an;  [BUGGY]  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	add	    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  an;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	18	1
115	[BUG]  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  an;  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  an;  [BUGGY]  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	replace	    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  an;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	18	1	add
115	[BUG]  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum);  [CE]  ';'  expected  [CONTEXT]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum);  [BUGGY]  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	replace	    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum);		non-compiled	[CE]  ';'  expected	18	None	add
121	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  {  double  ret;  if  (Double.isNaN(a)  ||  Double.isNaN(x)  ||  (a  <=  0.0)  ||  (x  <  0.0))  {  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  [BUGGY]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	162	162	1	add	    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	2	1
122	[BUG]  [BUGGY]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  {  double  ret;  if  (Double.isNaN(a)  ||  Double.isNaN(x)  ||  (a  <=  0.0)  ||  (x  <  0.0))  {  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  [BUGGY]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	162	162	1	replace	    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	2	1	add
123	[BUG]  [BUGGY]    ret  =  1.0  -  regularizedGammaQ(x,  epsilon,  maxIterations);  [CE]  no  suitable  method  found  for  regularizedGammaQ(double,double,int)  [CONTEXT]  {  double  ret;  if  (Double.isNaN(a)  ||  Double.isNaN(x)  ||  (a  <=  0.0)  ||  (x  <  0.0))  {  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  [BUGGY]    ret  =  1.0  -  regularizedGammaQ(x,  epsilon,  maxIterations);  [BUGGY]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	162	162	1	replace	    ret  =  1.0  -  regularizedGammaQ(x,  epsilon,  maxIterations);		non-compiled	[CE]  no  suitable  method  found  for  regularizedGammaQ(double,double,int)	2	None	add
124	[BUG]  [BUGGY]    ret  =  RegularizedGammaQ(x,  a,  epsilon,  maxIterations);  [CE]  cannot  find  symbol  [CONTEXT]  {  double  ret;  if  (Double.isNaN(a)  ||  Double.isNaN(x)  ||  (a  <=  0.0)  ||  (x  <  0.0))  {  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  [BUGGY]    ret  =  RegularizedGammaQ(x,  a,  epsilon,  maxIterations);  [BUGGY]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	162	162	1	replace	    ret  =  RegularizedGammaQ(x,  a,  epsilon,  maxIterations);		non-compiled	[CE]  cannot  find  symbol	2	None	add
125	[BUG]  [BUGGY]    ret  =  regularizedGammaQ(x,  epsilon,  maxIterations);  [CE]  no  suitable  method  found  for  regularizedGammaQ(double,double,int)  [CONTEXT]  {  double  ret;  if  (Double.isNaN(a)  ||  Double.isNaN(x)  ||  (a  <=  0.0)  ||  (x  <  0.0))  {  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  [BUGGY]    ret  =  regularizedGammaQ(x,  epsilon,  maxIterations);  [BUGGY]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	162	162	1	replace	    ret  =  regularizedGammaQ(x,  epsilon,  maxIterations);		non-compiled	[CE]  no  suitable  method  found  for  regularizedGammaQ(double,double,int)	2	None	add
131	[BUG]  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series;  [CE]  illegal  start  of  type  [CONTEXT]  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series;  [BUGGY]  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	replace	double  an  =  1.0  /  a;  //  n-th  element  in  the  series;	double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  	non-compiled	[CE]  illegal  start  of  type	5	None	replace
132	[BUG]  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series.double  an  =  an;  //  partial  sum  while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  [CE]  illegal  start  of  type  [CONTEXT]  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series.double  an  =  an;  //  partial  sum  while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  [BUGGY]  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	replace	double  an  =  1.0  /  a;  //  n-th  element  in  the  series.double  an  =  an;  //  partial  sum  while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {	double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  	non-compiled	[CE]  illegal  start  of  type	5	None	replace
133	[BUG]  [BUGGY]  double  an  =  1.0  /  n;  //  n-th  element  in  the  series;  [CE]  illegal  start  of  type  [CONTEXT]  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  [BUGGY]  double  an  =  1.0  /  n;  //  n-th  element  in  the  series;  [BUGGY]  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	replace	double  an  =  1.0  /  n;  //  n-th  element  in  the  series;	double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  	non-compiled	[CE]  illegal  start  of  type	5	None	replace
134	[BUG]  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series.double  an  =  an;  //  partial  sum  while(Math.abs(an)>  epsilon  &&  n  >>  maxIterations)  {  [CE]  illegal  start  of  type  [CONTEXT]  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series.double  an  =  an;  //  partial  sum  while(Math.abs(an)>  epsilon  &&  n  >>  maxIterations)  {  [BUGGY]  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	replace	double  an  =  1.0  /  a;  //  n-th  element  in  the  series.double  an  =  an;  //  partial  sum  while(Math.abs(an)>  epsilon  &&  n  >>  maxIterations)  {	double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  	non-compiled	[CE]  illegal  start  of  type	5	None	replace
144	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [BUGGY]  an  =  an  *(x  /(a  +  n)-  1);  [BUGGY]    sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	add	an  =  an  *(x  /(a  +  n)-  1);	an  =  an  *  (x  /  (a  +  n));  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	13	1
145	[BUG]  [BUGGY]  an  =  an  *(x  /(a  +  n)-  1);  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [BUGGY]  an  =  an  *(x  /(a  +  n)-  1);  [BUGGY]    sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	replace	an  =  an  *(x  /(a  +  n)-  1);	an  =  an  *  (x  /  (a  +  n));  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	13	1	replace
151	[BUG]  [BUGGY]    -  regularizedGammaQ(a,  x,  epsilon,  maxIterations));  [CE]  not  a  statement  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]    -  regularizedGammaQ(a,  x,  epsilon,  maxIterations));  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	replace	    -  regularizedGammaQ(a,  x,  epsilon,  maxIterations));		non-compiled	[CE]  not  a  statement	10	None	add
152	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]    ret  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	add	    ret  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	10	1
153	[BUG]  [BUGGY]    ret  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]    ret  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	replace	    ret  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	10	1	add
153	[BUG]  [BUGGY]    -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [CE]  not  a  statement  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]    -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	replace	    -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		non-compiled	[CE]  not  a  statement	10	None	add
154	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]    n  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	add	    n  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	10	1
155	[BUG]  [BUGGY]    n  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]    n  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	replace	    n  =  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	10	1	add
155	[BUG]  [BUGGY]    -  regularizedGammaQ(a,  x,  epsilon,  maxIterations),  an);  [CE]  not  a  statement  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]    -  regularizedGammaQ(a,  x,  epsilon,  maxIterations),  an);  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	replace	    -  regularizedGammaQ(a,  x,  epsilon,  maxIterations),  an);		non-compiled	[CE]  not  a  statement	10	None	add
161	[BUG]  [BUGGY]    if(an  >=  epsilon)  {  if(n  >  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  [CE]  illegal  start  of  expression  [CONTEXT]    double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));    [BUGGY]    if(an  >=  epsilon)  {  if(n  >  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  [BUGGY]  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	replace	    if(an  >=  epsilon)  {  if(n  >  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }		non-compiled	[CE]  illegal  start  of  expression	16	None	add
162	[BUG]  [BUGGY]    if(an  >  epsilon)  {  if(n  >  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  [CE]  illegal  start  of  expression  [CONTEXT]    double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));    [BUGGY]    if(an  >  epsilon)  {  if(n  >  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  [BUGGY]  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	replace	    if(an  >  epsilon)  {  if(n  >  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }		non-compiled	[CE]  illegal  start  of  expression	16	None	add
163	[BUG]  [BUGGY]    if(an  >  epsilon)  {  if(Math.abs(an)  <=  epsilon  &&  n  <  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  [CE]  illegal  start  of  expression  [CONTEXT]    double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));    [BUGGY]    if(an  >  epsilon)  {  if(Math.abs(an)  <=  epsilon  &&  n  <  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  [BUGGY]  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	replace	    if(an  >  epsilon)  {  if(Math.abs(an)  <=  epsilon  &&  n  <  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }		non-compiled	[CE]  illegal  start  of  expression	16	None	add
164	[BUG]  [BUGGY]    if(an  >  epsilon)  {  if(Math.abs(an)>  epsilon)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  [CE]  illegal  start  of  expression  [CONTEXT]    double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));    [BUGGY]    if(an  >  epsilon)  {  if(Math.abs(an)>  epsilon)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  [BUGGY]  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	replace	    if(an  >  epsilon)  {  if(Math.abs(an)>  epsilon)  {  throw  new  MaxIterationsExceededException(maxIterations);  }		non-compiled	[CE]  illegal  start  of  expression	16	None	add
165	[BUG]  [BUGGY]    if(an  >  epsilon)  {  if(Math.abs(an)  <=  epsilon  &&  n  <  maxIterations)  {  throw  new  MaxIterationExceededException(maxIterations);  }  [CE]  illegal  start  of  expression  [CONTEXT]    double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));    [BUGGY]    if(an  >  epsilon)  {  if(Math.abs(an)  <=  epsilon  &&  n  <  maxIterations)  {  throw  new  MaxIterationExceededException(maxIterations);  }  [BUGGY]  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	replace	    if(an  >  epsilon)  {  if(Math.abs(an)  <=  epsilon  &&  n  <  maxIterations)  {  throw  new  MaxIterationExceededException(maxIterations);  }		non-compiled	[CE]  illegal  start  of  expression	16	None	add
172	[BUG]  [BUGGY]  double  sum  =  a;  //  partial  sum  while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  [CE]  illegal  start  of  type  [CONTEXT]  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  [BUGGY]  double  sum  =  a;  //  partial  sum  while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	replace	double  sum  =  a;  //  partial  sum  while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {	double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  	non-compiled	[CE]  illegal  start  of  type	7	None	replace
173	[BUG]  [BUGGY]  double  sum  =  1.0;  //  partial  sum  while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  [CE]  illegal  start  of  type  [CONTEXT]  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  [BUGGY]  double  sum  =  1.0;  //  partial  sum  while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	replace	double  sum  =  1.0;  //  partial  sum  while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {	double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  	non-compiled	[CE]  illegal  start  of  type	7	None	replace
174	[BUG]  [BUGGY]  double  sum  =  n;  //  partial  sum  while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  [CE]  illegal  start  of  type  [CONTEXT]  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  [BUGGY]  double  sum  =  n;  //  partial  sum  while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	replace	double  sum  =  n;  //  partial  sum  while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {	double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  	non-compiled	[CE]  illegal  start  of  type	7	None	replace
181	[BUG]  [BUGGY]    sum  =  sum  +  an.doubleValue();  [CE]  double  cannot  be  dereferenced  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]    sum  =  sum  +  an.doubleValue();  [BUGGY]  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	replace	    sum  =  sum  +  an.doubleValue();		non-compiled	[CE]  double  cannot  be  dereferenced	20	None	add
182	[BUG]  [BUGGY]    sum  =  sum  +  an.doubleValue()  *  HALF_LOG_2_PI;  [CE]  double  cannot  be  dereferenced  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]    sum  =  sum  +  an.doubleValue()  *  HALF_LOG_2_PI;  [BUGGY]  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	replace	    sum  =  sum  +  an.doubleValue()  *  HALF_LOG_2_PI;		non-compiled	[CE]  double  cannot  be  dereferenced	20	None	add
183	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]    sum  =  sum  /  epsilon;  [BUGGY]  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	add	    sum  =  sum  /  epsilon;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	20	1
184	[BUG]  [BUGGY]    sum  =  sum  /  epsilon;  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]    sum  =  sum  /  epsilon;  [BUGGY]  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	replace	    sum  =  sum  /  epsilon;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	20	1	add
184	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]    sum  =  sum  /  epsilon  *(a  +  n);  [BUGGY]  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	add	    sum  =  sum  /  epsilon  *(a  +  n);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	20	1
185	[BUG]  [BUGGY]    sum  =  sum  /  epsilon  *(a  +  n);  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]    sum  =  sum  /  epsilon  *(a  +  n);  [BUGGY]  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	replace	    sum  =  sum  /  epsilon  *(a  +  n);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	20	1	add
185	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]    sum  =  sum  /  a;  [BUGGY]  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	add	    sum  =  sum  /  a;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	20	1
186	[BUG]  [BUGGY]    sum  =  sum  /  a;  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]    sum  =  sum  /  a;  [BUGGY]  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	replace	    sum  =  sum  /  a;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	20	1	add
191	[BUG]  [BUGGY]  double  n  =  1.0;  //  current  element  index  *  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [CE]  cannot  find  symbol  an  [CONTEXT]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {    [BUGGY]  double  n  =  1.0;  //  current  element  index  *  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	replace	double  n  =  1.0;  //  current  element  index  *  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum	double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series    double  sum  =  an;  //  partial  sum  	non-compiled	[CE]  cannot  find  symbol  an	3	None	replace
192	[BUG]  [BUGGY]  double  n  =  1.0;  //  current  element  index  =  1.0  /  a;  //  n-th  element  in  the  series  double  an  =  an;  //  partial  sum  [CE]  cannot  find  symbol  an  [CONTEXT]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {    [BUGGY]  double  n  =  1.0;  //  current  element  index  =  1.0  /  a;  //  n-th  element  in  the  series  double  an  =  an;  //  partial  sum  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	replace	double  n  =  1.0;  //  current  element  index  =  1.0  /  a;  //  n-th  element  in  the  series  double  an  =  an;  //  partial  sum	double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series    double  sum  =  an;  //  partial  sum  	non-compiled	[CE]  cannot  find  symbol  an	3	None	replace
193	[BUG]  [BUGGY]  double  n  =  1.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [CE]  cannot  find  symbol  an  [CONTEXT]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {    [BUGGY]  double  n  =  1.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	replace	double  n  =  1.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum	double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series    double  sum  =  an;  //  partial  sum  	non-compiled	[CE]  cannot  find  symbol  an	3	None	replace
194	[BUG]  [BUGGY]  double  n  =  1.0;  //  current  element  index  +  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [CE]  cannot  find  symbol  an  [CONTEXT]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {    [BUGGY]  double  n  =  1.0;  //  current  element  index  +  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	replace	double  n  =  1.0;  //  current  element  index  +  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum	double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series    double  sum  =  an;  //  partial  sum  	non-compiled	[CE]  cannot  find  symbol  an	3	None	replace
3	[BUG]  [BUGGY]  ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a)/  sum;  [CE]  ')'  expected  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]  ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a)/  sum;  [BUGGY]  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	replace	ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a)/  sum;	ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  	non-compiled	[CE]  ')'  expected	19	None	replace
4	[BUG]  [BUGGY]  ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum,  n;  [CE]  ';'  expected  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]  ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum,  n;  [BUGGY]  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	replace	ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum,  n;	ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  	non-compiled	[CE]  ';'  expected	19	None	replace
23	[BUG]  [BUGGY]  double  sum  =  0.0;  //  partial  sum  while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  [CE]  illegal  start  of  type  [CONTEXT]  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  [BUGGY]  double  sum  =  0.0;  //  partial  sum  while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	replace	double  sum  =  0.0;  //  partial  sum  while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {	double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  	non-compiled	[CE]  illegal  start  of  type	7	None	replace
24	[BUG]  [BUGGY]  double  sum  =  an;  //  sum  while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  [CE]  illegal  start  of  type  [CONTEXT]  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  [BUGGY]  double  sum  =  an;  //  sum  while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	replace	double  sum  =  an;  //  sum  while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {	double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  	non-compiled	[CE]  illegal  start  of  type	7	None	replace
42	[BUG]  [BUGGY]  [FE]  StackOverflowError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  [BUGGY]    n  =  regularizedGammaP(a,  x,  epsilon,  maxIterations);  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series    double  sum  =  an;  //  partial  sum      while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	add	    n  =  regularizedGammaP(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  StackOverflowError  testRegularizedGammaPositivePositive	6	1
43	[BUG]  [BUGGY]    n  =  regularizedGammaP(a,  x,  epsilon,  maxIterations);  [FE]  StackOverflowError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  [BUGGY]    n  =  regularizedGammaP(a,  x,  epsilon,  maxIterations);  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series    double  sum  =  an;  //  partial  sum      while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	replace	    n  =  regularizedGammaP(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  StackOverflowError  testRegularizedGammaPositivePositive	6	1	add
43	[BUG]  [BUGGY]    int  maxIterations  =  Math.max(relativeAccuracy  *  Math.abs(x),  epsilon,  maxIterations);  [CE]  variable  maxIterations  is  already  defined  in  method  regularizedGammaP(double,double,double,int)  [CONTEXT]  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  [BUGGY]    int  maxIterations  =  Math.max(relativeAccuracy  *  Math.abs(x),  epsilon,  maxIterations);  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series    double  sum  =  an;  //  partial  sum      while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	replace	    int  maxIterations  =  Math.max(relativeAccuracy  *  Math.abs(x),  epsilon,  maxIterations);		non-compiled	[CE]  variable  maxIterations  is  already  defined  in  method  regularizedGammaP(double,double,double,int)	6	None	add
44	[BUG]  [BUGGY]    int  maxIterations  =  Math.max(relativeAccuracy  *  Math.abs(x)/  a);  [CE]  variable  maxIterations  is  already  defined  in  method  regularizedGammaP(double,double,double,int)  [CONTEXT]  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  [BUGGY]    int  maxIterations  =  Math.max(relativeAccuracy  *  Math.abs(x)/  a);  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series    double  sum  =  an;  //  partial  sum      while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	replace	    int  maxIterations  =  Math.max(relativeAccuracy  *  Math.abs(x)/  a);		non-compiled	[CE]  variable  maxIterations  is  already  defined  in  method  regularizedGammaP(double,double,double,int)	6	None	add
45	[BUG]  [BUGGY]    int  maxIterations  =  Math.max(relativeAccuracy  *  Math.abs(x));  [CE]  variable  maxIterations  is  already  defined  in  method  regularizedGammaP(double,double,double,int)  [CONTEXT]  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  [BUGGY]    int  maxIterations  =  Math.max(relativeAccuracy  *  Math.abs(x));  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series    double  sum  =  an;  //  partial  sum      while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	replace	    int  maxIterations  =  Math.max(relativeAccuracy  *  Math.abs(x));		non-compiled	[CE]  variable  maxIterations  is  already  defined  in  method  regularizedGammaP(double,double,double,int)	6	None	add
61	[BUG]  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a)));  [CE]  ';'  expected  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a)));  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	replace	    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a)));		non-compiled	[CE]  ';'  expected	14	None	add
62	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum;  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	add	    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	14	1
63	[BUG]  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum;  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum;  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	replace	    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	14	1	add
63	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a));  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	add	    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a));		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	14	1
64	[BUG]  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a));  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a));  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	replace	    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a));		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	14	1	add
64	[BUG]  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  /  logGamma(a)));  [CE]  ';'  expected  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  /  logGamma(a)));  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	replace	    ret  =  Math.exp(-x  +(a  *  Math.log(x))  /  logGamma(a)));		non-compiled	[CE]  ';'  expected	14	None	add
65	[BUG]  [BUGGY]    n  =  Math.log(x,  epsilon,  maxIterations);  [CE]  method  log  in  class  Math  cannot  be  applied  to  given  types;  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [BUGGY]    n  =  Math.log(x,  epsilon,  maxIterations);  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	replace	    n  =  Math.log(x,  epsilon,  maxIterations);		non-compiled	[CE]  method  log  in  class  Math  cannot  be  applied  to  given  types;	14	None	add
81	[BUG]  [BUGGY]  double  n  =  1.0;  //  current  element  index  =  1.0;  //  n-th  element  in  the  series;  [CE]  cannot  find  symbol  an  [CONTEXT]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {    [BUGGY]  double  n  =  1.0;  //  current  element  index  =  1.0;  //  n-th  element  in  the  series;  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	replace	double  n  =  1.0;  //  current  element  index  =  1.0;  //  n-th  element  in  the  series;	double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series    double  sum  =  an;  //  partial  sum  	non-compiled	[CE]  cannot  find  symbol  an	3	None	replace
82	[BUG]  [BUGGY]  double  n  =  1.0;  //  current  element  index  =  a;  //  n-th  element  in  the  series;  [CE]  cannot  find  symbol  an  [CONTEXT]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {    [BUGGY]  double  n  =  1.0;  //  current  element  index  =  a;  //  n-th  element  in  the  series;  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	replace	double  n  =  1.0;  //  current  element  index  =  a;  //  n-th  element  in  the  series;	double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series    double  sum  =  an;  //  partial  sum  	non-compiled	[CE]  cannot  find  symbol  an	3	None	replace
83	[BUG]  [BUGGY]  double  n  =  1.0;  //  current  element  index  =  1.0  /  a;  //  n-th  element  in  the  series;  [CE]  cannot  find  symbol  an  [CONTEXT]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {    [BUGGY]  double  n  =  1.0;  //  current  element  index  =  1.0  /  a;  //  n-th  element  in  the  series;  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	replace	double  n  =  1.0;  //  current  element  index  =  1.0  /  a;  //  n-th  element  in  the  series;	double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series    double  sum  =  an;  //  partial  sum  	non-compiled	[CE]  cannot  find  symbol  an	3	None	replace
84	[BUG]  [BUGGY]  double  n  =  1.0;  //  current  element  index  +  an  =  1.0  /  a;  //  n-th  element  in  the  series;  [CE]  cannot  find  symbol  an  [CONTEXT]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {    [BUGGY]  double  n  =  1.0;  //  current  element  index  +  an  =  1.0  /  a;  //  n-th  element  in  the  series;  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	replace	double  n  =  1.0;  //  current  element  index  +  an  =  1.0  /  a;  //  n-th  element  in  the  series;	double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series    double  sum  =  an;  //  partial  sum  	non-compiled	[CE]  cannot  find  symbol  an	3	None	replace
101	[BUG]  [BUGGY]    if(an  >=  epsilon)  {  if(maxIterations  >  1)  {  maxIterations  =  Math.abs(an);  }  [CE]  illegal  start  of  expression  [CONTEXT]    double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));    [BUGGY]    if(an  >=  epsilon)  {  if(maxIterations  >  1)  {  maxIterations  =  Math.abs(an);  }  [BUGGY]  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	replace	    if(an  >=  epsilon)  {  if(maxIterations  >  1)  {  maxIterations  =  Math.abs(an);  }		non-compiled	[CE]  illegal  start  of  expression	16	None	add
102	[BUG]  [BUGGY]    if(an  <  epsilon)  {  if(maxIterations  >  1)  {  maxIterations  =  Math.abs(an);  }  [CE]  illegal  start  of  expression  [CONTEXT]    double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));    [BUGGY]    if(an  <  epsilon)  {  if(maxIterations  >  1)  {  maxIterations  =  Math.abs(an);  }  [BUGGY]  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	replace	    if(an  <  epsilon)  {  if(maxIterations  >  1)  {  maxIterations  =  Math.abs(an);  }		non-compiled	[CE]  illegal  start  of  expression	16	None	add
103	[BUG]  [BUGGY]    if(an  >=  epsilon)  {  if(maxIterations  >  1)  {  maxIterations  =  Math.max(an,  epsilon);  }  [CE]  illegal  start  of  expression  [CONTEXT]    double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));    [BUGGY]    if(an  >=  epsilon)  {  if(maxIterations  >  1)  {  maxIterations  =  Math.max(an,  epsilon);  }  [BUGGY]  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	replace	    if(an  >=  epsilon)  {  if(maxIterations  >  1)  {  maxIterations  =  Math.max(an,  epsilon);  }		non-compiled	[CE]  illegal  start  of  expression	16	None	add
104	[BUG]  [BUGGY]    if(an  >=  epsilon)  {  if(n  <  maxIterations)  {  throw  new  MaxIterationExceededException( " ");  }  [CE]  illegal  start  of  expression  [CONTEXT]    double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));    [BUGGY]    if(an  >=  epsilon)  {  if(n  <  maxIterations)  {  throw  new  MaxIterationExceededException( " ");  }  [BUGGY]  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	replace	    if(an  >=  epsilon)  {  if(n  <  maxIterations)  {  throw  new  MaxIterationExceededException( " ");  }		non-compiled	[CE]  illegal  start  of  expression	16	None	add
105	[BUG]  [BUGGY]    if(an  >=  epsilon)  {  if(n  <  maxIterations)  {  throw  new  MaxIterationExceededException( "maximum  number  of  entries  must  be  >  0 ");  }  [CE]  illegal  start  of  expression  [CONTEXT]    double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));    [BUGGY]    if(an  >=  epsilon)  {  if(n  <  maxIterations)  {  throw  new  MaxIterationExceededException( "maximum  number  of  entries  must  be  >  0 ");  }  [BUGGY]  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	replace	    if(an  >=  epsilon)  {  if(n  <  maxIterations)  {  throw  new  MaxIterationExceededException( "maximum  number  of  entries  must  be  >  0 ");  }		non-compiled	[CE]  illegal  start  of  expression	16	None	add
121	[BUG]  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a)));  [CE]  ';'  expected  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {    [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a)));  [BUGGY]  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	replace	    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a)));		non-compiled	[CE]  ';'  expected	12	None	add
123	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {    [BUGGY]    ret  =  1.0  /  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	add	    ret  =  1.0  /  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	12	1
124	[BUG]  [BUGGY]    ret  =  1.0  /  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {    [BUGGY]    ret  =  1.0  /  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	replace	    ret  =  1.0  /  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	12	1	add
125	[BUG]  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  /  logGamma(a)));  [CE]  ';'  expected  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {    [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  /  logGamma(a)));  [BUGGY]  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	replace	    ret  =  Math.exp(-x  +(a  *  Math.log(x))  /  logGamma(a)));		non-compiled	[CE]  ';'  expected	12	None	add
144	[BUG]  [BUGGY]  }  else  if(a  >=  1.0  &&  x  >  A)  {  [CE]  cannot  find  symbol  A  [CONTEXT]  {  double  ret;  if  (Double.isNaN(a)  ||  Double.isNaN(x)  ||  (a  <=  0.0)  ||  (x  <  0.0))  {  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  [BUGGY]  }  else  if(a  >=  1.0  &&  x  >  A)  {  [BUGGY]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	162	162	1	replace	}  else  if(a  >=  1.0  &&  x  >  A)  {	}  else  if  (a  >=  1.0  &&  x  >  a)  {  	non-compiled	[CE]  cannot  find  symbol  A	1	None	replace
163	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [BUGGY]  an  =  an  *(x  /(an  +  n));  [BUGGY]    sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	add	an  =  an  *(x  /(an  +  n));	an  =  an  *  (x  /  (a  +  n));  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	13	1
164	[BUG]  [BUGGY]  an  =  an  *(x  /(an  +  n));  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [BUGGY]  an  =  an  *(x  /(an  +  n));  [BUGGY]    sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	replace	an  =  an  *(x  /(an  +  n));	an  =  an  *  (x  /  (a  +  n));  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	13	1	replace
181	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	add	    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	10	1
182	[BUG]  [BUGGY]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	replace	    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	10	1	add
182	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]    ret  =  1.0  /  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	add	    ret  =  1.0  /  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	10	1
183	[BUG]  [BUGGY]    ret  =  1.0  /  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]    ret  =  1.0  /  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	replace	    ret  =  1.0  /  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	10	1	add
183	[BUG]  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a)));  [CE]  ';'  expected  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a)));  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	replace	    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a)));		non-compiled	[CE]  ';'  expected	10	None	add
184	[BUG]  [BUGGY]  [FE]  StackOverflowError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]    ret  =  1.0  /  regularizedGammaP(a,  x,  epsilon,  maxIterations);  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	add	    ret  =  1.0  /  regularizedGammaP(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  StackOverflowError  testRegularizedGammaPositivePositive	10	1
185	[BUG]  [BUGGY]    ret  =  1.0  /  regularizedGammaP(a,  x,  epsilon,  maxIterations);  [FE]  StackOverflowError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]    ret  =  1.0  /  regularizedGammaP(a,  x,  epsilon,  maxIterations);  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	replace	    ret  =  1.0  /  regularizedGammaP(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  StackOverflowError  testRegularizedGammaPositivePositive	10	1	add
185	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]    ret  =  1.0  /  regularizedGammaQ(x,  an,  epsilon,  maxIterations);  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	add	    ret  =  1.0  /  regularizedGammaQ(x,  an,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	10	1
186	[BUG]  [BUGGY]    ret  =  1.0  /  regularizedGammaQ(x,  an,  epsilon,  maxIterations);  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]    ret  =  1.0  /  regularizedGammaQ(x,  an,  epsilon,  maxIterations);  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	replace	    ret  =  1.0  /  regularizedGammaQ(x,  an,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	10	1	add
203	[BUG]  [BUGGY]  while(Math.abs(an)>  epsilon  &&  n  <  maximumIterations)  {  [CE]  cannot  find  symbol  maximumIterations  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]  while(Math.abs(an)>  epsilon  &&  n  <  maximumIterations)  {  [BUGGY]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	replace	while(Math.abs(an)>  epsilon  &&  n  <  maximumIterations)  {	while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  	non-compiled	[CE]  cannot  find  symbol  maximumIterations	9	None	replace
204	[BUG]  [BUGGY]  while(Math.abs(an)>  epsilon  &&  n  <  minIterations)  {  [CE]  cannot  find  symbol  minIterations  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]  while(Math.abs(an)>  epsilon  &&  n  <  minIterations)  {  [BUGGY]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	replace	while(Math.abs(an)>  epsilon  &&  n  <  minIterations)  {	while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  	non-compiled	[CE]  cannot  find  symbol  minIterations	9	None	replace
221	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]    sum  =  sum  +  Math.log(a)/  HALF_LOG_2_PI;  [BUGGY]  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	add	    sum  =  sum  +  Math.log(a)/  HALF_LOG_2_PI;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	20	1
222	[BUG]  [BUGGY]    sum  =  sum  +  Math.log(a)/  HALF_LOG_2_PI;  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]    sum  =  sum  +  Math.log(a)/  HALF_LOG_2_PI;  [BUGGY]  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	replace	    sum  =  sum  +  Math.log(a)/  HALF_LOG_2_PI;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	20	1	add
222	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]    sum  =  sum  +  Math.log(x);  [BUGGY]  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	add	    sum  =  sum  +  Math.log(x);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	20	1
223	[BUG]  [BUGGY]    sum  =  sum  +  Math.log(x);  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]    sum  =  sum  +  Math.log(x);  [BUGGY]  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	replace	    sum  =  sum  +  Math.log(x);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	20	1	add
223	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]    sum  =  sum  /  HALF_LOG_2_PI;  [BUGGY]  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	add	    sum  =  sum  /  HALF_LOG_2_PI;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	20	1
224	[BUG]  [BUGGY]    sum  =  sum  /  HALF_LOG_2_PI;  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]    sum  =  sum  /  HALF_LOG_2_PI;  [BUGGY]  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	replace	    sum  =  sum  /  HALF_LOG_2_PI;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	20	1	add
224	[BUG]  [BUGGY]    sum  =  sum  +  Math.log(a)/  HALF_LOG_2_PI);  [CE]  ';'  expected  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]    sum  =  sum  +  Math.log(a)/  HALF_LOG_2_PI);  [BUGGY]  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	replace	    sum  =  sum  +  Math.log(a)/  HALF_LOG_2_PI);		non-compiled	[CE]  ';'  expected	20	None	add
225	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]    sum  =  sum  +  Math.log(a);  [BUGGY]  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	add	    sum  =  sum  +  Math.log(a);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	20	1
226	[BUG]  [BUGGY]    sum  =  sum  +  Math.log(a);  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]    sum  =  sum  +  Math.log(a);  [BUGGY]  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	replace	    sum  =  sum  +  Math.log(a);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	20	1	add
262	[BUG]  [BUGGY]    int  maxIterations  =  Math.max(an,  epsilon);  [CE]  variable  maxIterations  is  already  defined  in  method  regularizedGammaP(double,double,double,int)  [CONTEXT]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [BUGGY]    int  maxIterations  =  Math.max(an,  epsilon);  [BUGGY]  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	replace	    int  maxIterations  =  Math.max(an,  epsilon);		non-compiled	[CE]  variable  maxIterations  is  already  defined  in  method  regularizedGammaP(double,double,double,int)	18	None	add
263	[BUG]  [BUGGY]    int  maxIterations  =  Math.max(an,  sum);  [CE]  variable  maxIterations  is  already  defined  in  method  regularizedGammaP(double,double,double,int)  [CONTEXT]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [BUGGY]    int  maxIterations  =  Math.max(an,  sum);  [BUGGY]  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	replace	    int  maxIterations  =  Math.max(an,  sum);		non-compiled	[CE]  variable  maxIterations  is  already  defined  in  method  regularizedGammaP(double,double,double,int)	18	None	add
264	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a));  [BUGGY]  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	add	    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a));		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	18	1
265	[BUG]  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a));  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a));  [BUGGY]  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	replace	    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a));		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	18	1	add
265	[BUG]  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a)));  [CE]  ';'  expected  [CONTEXT]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [BUGGY]    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a)));  [BUGGY]  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	replace	    ret  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a)));		non-compiled	[CE]  ';'  expected	18	None	add
281	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  [BUGGY]    ret  =  1.0  /  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	add	    ret  =  1.0  /  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	8	1
282	[BUG]  [BUGGY]    ret  =  1.0  /  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  [BUGGY]    ret  =  1.0  /  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	replace	    ret  =  1.0  /  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	8	1	add
282	[BUG]  [BUGGY]    n  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a)));  [CE]  ';'  expected  [CONTEXT]  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  [BUGGY]    n  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a)));  [BUGGY]  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	replace	    n  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a)));		non-compiled	[CE]  ';'  expected	8	None	add
283	[BUG]  [BUGGY]  [FE]  StackOverflowError  testRegularizedGammaPositivePositive  [CONTEXT]  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  [BUGGY]    ret  =  1.0  /  regularizedGammaP(a,  x,  epsilon,  maxIterations);  [BUGGY]  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	add	    ret  =  1.0  /  regularizedGammaP(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  StackOverflowError  testRegularizedGammaPositivePositive	8	1
284	[BUG]  [BUGGY]    ret  =  1.0  /  regularizedGammaP(a,  x,  epsilon,  maxIterations);  [FE]  StackOverflowError  testRegularizedGammaPositivePositive  [CONTEXT]  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  [BUGGY]    ret  =  1.0  /  regularizedGammaP(a,  x,  epsilon,  maxIterations);  [BUGGY]  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	replace	    ret  =  1.0  /  regularizedGammaP(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  StackOverflowError  testRegularizedGammaPositivePositive	8	1	add
284	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  [BUGGY]    n  =  Math.exp(-x  +(a  *  Math.log(x)));  [BUGGY]  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	add	    n  =  Math.exp(-x  +(a  *  Math.log(x)));		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	8	1
285	[BUG]  [BUGGY]    n  =  Math.exp(-x  +(a  *  Math.log(x)));  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  [BUGGY]    n  =  Math.exp(-x  +(a  *  Math.log(x)));  [BUGGY]  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	replace	    n  =  Math.exp(-x  +(a  *  Math.log(x)));		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	8	1	add
285	[BUG]  [BUGGY]    ret  =  1.0  /  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  an  =  an  *  x  /(a  +  n));  [CE]  ';'  expected  [CONTEXT]  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  [BUGGY]    ret  =  1.0  /  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  an  =  an  *  x  /(a  +  n));  [BUGGY]  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	replace	    ret  =  1.0  /  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  an  =  an  *  x  /(a  +  n));		non-compiled	[CE]  ';'  expected	8	None	add
324	[BUG]  [BUGGY]    ret  =  RegularizedGammaQ(a,  x,  epsilon,  maxIterations);  [CE]  cannot  find  symbol  [CONTEXT]  {  double  ret;  if  (Double.isNaN(a)  ||  Double.isNaN(x)  ||  (a  <=  0.0)  ||  (x  <  0.0))  {  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  [BUGGY]    ret  =  RegularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	162	162	1	replace	    ret  =  RegularizedGammaQ(a,  x,  epsilon,  maxIterations);		non-compiled	[CE]  cannot  find  symbol	2	None	add
325	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  {  double  ret;  if  (Double.isNaN(a)  ||  Double.isNaN(x)  ||  (a  <=  0.0)  ||  (x  <  0.0))  {  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  [BUGGY]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations  +  1);  [BUGGY]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	162	162	1	add	    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations  +  1);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	2	1
326	[BUG]  [BUGGY]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations  +  1);  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  {  double  ret;  if  (Double.isNaN(a)  ||  Double.isNaN(x)  ||  (a  <=  0.0)  ||  (x  <  0.0))  {  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  [BUGGY]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations  +  1);  [BUGGY]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	162	162	1	replace	    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations  +  1);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	2	1	add
342	[BUG]  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series;  sum  =  an;  //  partial  sum  while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  [CE]  illegal  start  of  type  [CONTEXT]  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series;  sum  =  an;  //  partial  sum  while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  [BUGGY]  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	replace	double  an  =  1.0  /  a;  //  n-th  element  in  the  series;  sum  =  an;  //  partial  sum  while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {	double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  	non-compiled	[CE]  illegal  start  of  type	5	None	replace
343	[BUG]  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series:  an;  //  partial  sum  while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  [CE]  illegal  start  of  type  [CONTEXT]  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series:  an;  //  partial  sum  while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  [BUGGY]  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	replace	double  an  =  1.0  /  a;  //  n-th  element  in  the  series:  an;  //  partial  sum  while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {	double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  	non-compiled	[CE]  illegal  start  of  type	5	None	replace
344	[BUG]  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series;  sum  =  an;  //  partial  sum  while(Math.abs(an)  <  epsilon  &&  n  <  maxIterations)  {  [CE]  illegal  start  of  type  [CONTEXT]  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series;  sum  =  an;  //  partial  sum  while(Math.abs(an)  <  epsilon  &&  n  <  maxIterations)  {  [BUGGY]  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	replace	double  an  =  1.0  /  a;  //  n-th  element  in  the  series;  sum  =  an;  //  partial  sum  while(Math.abs(an)  <  epsilon  &&  n  <  maxIterations)  {	double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  	non-compiled	[CE]  illegal  start  of  type	5	None	replace
363	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));    [BUGGY]  sum  =  sum  +  an  -  epsilon;  [BUGGY]  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	add	sum  =  sum  +  an  -  epsilon;	sum  =  sum  +  an;  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	15	1
364	[BUG]  [BUGGY]  sum  =  sum  +  an  -  epsilon;  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));    [BUGGY]  sum  =  sum  +  an  -  epsilon;  [BUGGY]  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	replace	sum  =  sum  +  an  -  epsilon;	sum  =  sum  +  an;  	compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	15	1	replace
382	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {    [BUGGY]    regularizedGammaQ(a,  x,  epsilon,  maxIterations);  ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  double  n  =  0.0;  //  current  element  index    double  an  =  1.0  /  a;  //  n-th  element  in  the  series      double  sum  =  an;  //  partial  sum  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	add	    regularizedGammaQ(a,  x,  epsilon,  maxIterations);  ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	4	1
383	[BUG]  [BUGGY]    regularizedGammaQ(a,  x,  epsilon,  maxIterations);  ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {    [BUGGY]    regularizedGammaQ(a,  x,  epsilon,  maxIterations);  ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  double  n  =  0.0;  //  current  element  index    double  an  =  1.0  /  a;  //  n-th  element  in  the  series      double  sum  =  an;  //  partial  sum  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	replace	    regularizedGammaQ(a,  x,  epsilon,  maxIterations);  ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	4	1	add
383	[BUG]  [BUGGY]  [FE]  StackOverflowError  testRegularizedGammaPositivePositive  [CONTEXT]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {    [BUGGY]    ret  =  1.0  -  regularizedGammaP(a,  x,  epsilon,  maxIterations);  [BUGGY]  double  n  =  0.0;  //  current  element  index    double  an  =  1.0  /  a;  //  n-th  element  in  the  series      double  sum  =  an;  //  partial  sum  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	add	    ret  =  1.0  -  regularizedGammaP(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  StackOverflowError  testRegularizedGammaPositivePositive	4	1
384	[BUG]  [BUGGY]    ret  =  1.0  -  regularizedGammaP(a,  x,  epsilon,  maxIterations);  [FE]  StackOverflowError  testRegularizedGammaPositivePositive  [CONTEXT]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {    [BUGGY]    ret  =  1.0  -  regularizedGammaP(a,  x,  epsilon,  maxIterations);  [BUGGY]  double  n  =  0.0;  //  current  element  index    double  an  =  1.0  /  a;  //  n-th  element  in  the  series      double  sum  =  an;  //  partial  sum  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	replace	    ret  =  1.0  -  regularizedGammaP(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  StackOverflowError  testRegularizedGammaPositivePositive	4	1	add
384	[BUG]  [BUGGY]    ret  =  1.0  -  regularizedGammaS(a,  x,  epsilon,  maxIterations);  [CE]  cannot  find  symbol  [CONTEXT]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {    [BUGGY]    ret  =  1.0  -  regularizedGammaS(a,  x,  epsilon,  maxIterations);  [BUGGY]  double  n  =  0.0;  //  current  element  index    double  an  =  1.0  /  a;  //  n-th  element  in  the  series      double  sum  =  an;  //  partial  sum  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	replace	    ret  =  1.0  -  regularizedGammaS(a,  x,  epsilon,  maxIterations);		non-compiled	[CE]  cannot  find  symbol	4	None	add
385	[BUG]  [BUGGY]  [FE]  StackOverflowError  testRegularizedGammaPositivePositive  [CONTEXT]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {    [BUGGY]    regularizedGammaQ(a,  x,  epsilon,  maxIterations);  ret  =  1.0  -  regularizedGammaP(a,  x,  epsilon,  maxIterations);  [BUGGY]  double  n  =  0.0;  //  current  element  index    double  an  =  1.0  /  a;  //  n-th  element  in  the  series      double  sum  =  an;  //  partial  sum  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	add	    regularizedGammaQ(a,  x,  epsilon,  maxIterations);  ret  =  1.0  -  regularizedGammaP(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  StackOverflowError  testRegularizedGammaPositivePositive	4	1
386	[BUG]  [BUGGY]    regularizedGammaQ(a,  x,  epsilon,  maxIterations);  ret  =  1.0  -  regularizedGammaP(a,  x,  epsilon,  maxIterations);  [FE]  StackOverflowError  testRegularizedGammaPositivePositive  [CONTEXT]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {    [BUGGY]    regularizedGammaQ(a,  x,  epsilon,  maxIterations);  ret  =  1.0  -  regularizedGammaP(a,  x,  epsilon,  maxIterations);  [BUGGY]  double  n  =  0.0;  //  current  element  index    double  an  =  1.0  /  a;  //  n-th  element  in  the  series      double  sum  =  an;  //  partial  sum  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	replace	    regularizedGammaQ(a,  x,  epsilon,  maxIterations);  ret  =  1.0  -  regularizedGammaP(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  StackOverflowError  testRegularizedGammaPositivePositive	4	1	add
1	[BUG]  [BUGGY]    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  throw  new  MaxIterationsExceededException( "max  [CE]  unclosed  string  literal  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {    [BUGGY]    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  throw  new  MaxIterationsExceededException( "max  [BUGGY]  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	replace	    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  throw  new  MaxIterationsExceededException( "max		non-compiled	[CE]  unclosed  string  literal	12	None	add
2	[BUG]  [BUGGY]    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  throw  new  MaxIterationExceededException( "max  [CE]  unclosed  string  literal  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {    [BUGGY]    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  throw  new  MaxIterationExceededException( "max  [BUGGY]  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	replace	    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  throw  new  MaxIterationExceededException( "max		non-compiled	[CE]  unclosed  string  literal	12	None	add
3	[BUG]  [BUGGY]  [FE]  StackOverflowError  testRegularizedGammaPositivePositive  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {    [BUGGY]    x  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	add	    x  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  StackOverflowError  testRegularizedGammaPositivePositive	12	1
4	[BUG]  [BUGGY]    x  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [FE]  StackOverflowError  testRegularizedGammaPositivePositive  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {    [BUGGY]    x  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  [BUGGY]  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	replace	    x  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);		compilable	  [FE]  StackOverflowError  testRegularizedGammaPositivePositive	12	1	add
4	[BUG]  [BUGGY]    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  }  [CE]  illegal  start  of  expression  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {    [BUGGY]    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  }  [BUGGY]  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	replace	    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  }		non-compiled	[CE]  illegal  start  of  expression	12	None	add
5	[BUG]  [BUGGY]    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  throw  new  ClassExceededException( "max  [CE]  unclosed  string  literal  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {    [BUGGY]    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  throw  new  ClassExceededException( "max  [BUGGY]  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	replace	    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  throw  new  ClassExceededException( "max		non-compiled	[CE]  unclosed  string  literal	12	None	add
31	[BUG]  [BUGGY]  double  n  =  1.0;  //  current  moment  =  a;  [CE]  cannot  find  symbol  an  [CONTEXT]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {    [BUGGY]  double  n  =  1.0;  //  current  moment  =  a;  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	replace	double  n  =  1.0;  //  current  moment  =  a;	double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series    double  sum  =  an;  //  partial  sum  	non-compiled	[CE]  cannot  find  symbol  an	3	None	replace
32	[BUG]  [BUGGY]  double  n  =  1.0;  //  current  element  index  =  a;  [CE]  cannot  find  symbol  an  [CONTEXT]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {    [BUGGY]  double  n  =  1.0;  //  current  element  index  =  a;  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	replace	double  n  =  1.0;  //  current  element  index  =  a;	double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series    double  sum  =  an;  //  partial  sum  	non-compiled	[CE]  cannot  find  symbol  an	3	None	replace
33	[BUG]  [BUGGY]  double  n  =  1.0;  //  current  element  index  =  1.0  /  a;  [CE]  cannot  find  symbol  an  [CONTEXT]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {    [BUGGY]  double  n  =  1.0;  //  current  element  index  =  1.0  /  a;  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	replace	double  n  =  1.0;  //  current  element  index  =  1.0  /  a;	double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series    double  sum  =  an;  //  partial  sum  	non-compiled	[CE]  cannot  find  symbol  an	3	None	replace
34	[BUG]  [BUGGY]  double  n  =  1.0;  //  current  day  =  a;  [CE]  cannot  find  symbol  an  [CONTEXT]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {    [BUGGY]  double  n  =  1.0;  //  current  day  =  a;  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	replace	double  n  =  1.0;  //  current  day  =  a;	double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series    double  sum  =  an;  //  partial  sum  	non-compiled	[CE]  cannot  find  symbol  an	3	None	replace
64	[BUG]  [BUGGY]    ret  =  RegularizedGammaP(a,  x,  epsilon,  maxIterations);  [CE]  cannot  find  symbol  [CONTEXT]  {  double  ret;  if  (Double.isNaN(a)  ||  Double.isNaN(x)  ||  (a  <=  0.0)  ||  (x  <  0.0))  {  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  [BUGGY]    ret  =  RegularizedGammaP(a,  x,  epsilon,  maxIterations);  [BUGGY]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	162	162	1	replace	    ret  =  RegularizedGammaP(a,  x,  epsilon,  maxIterations);		non-compiled	[CE]  cannot  find  symbol	2	None	add
65	[BUG]  [BUGGY]    if(a  >=  1.0  &&  x  <  1.0  &&!isVowel(x))  {  ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  [CE]  cannot  find  symbol  [CONTEXT]  {  double  ret;  if  (Double.isNaN(a)  ||  Double.isNaN(x)  ||  (a  <=  0.0)  ||  (x  <  0.0))  {  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  [BUGGY]    if(a  >=  1.0  &&  x  <  1.0  &&!isVowel(x))  {  ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  [BUGGY]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	162	162	1	replace	    if(a  >=  1.0  &&  x  <  1.0  &&!isVowel(x))  {  ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }		non-compiled	[CE]  cannot  find  symbol	2	None	add
91	[BUG]  [BUGGY]    while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [CE]  illegal  start  of  expression  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [BUGGY]    while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	replace	    while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;		non-compiled	[CE]  illegal  start  of  expression	14	None	add
92	[BUG]  [BUGGY]    while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  -  1.0;  [CE]  illegal  start  of  expression  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [BUGGY]    while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  -  1.0;  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	replace	    while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  -  1.0;		non-compiled	[CE]  illegal  start  of  expression	14	None	add
93	[BUG]  [BUGGY]    while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n++;  [CE]  illegal  start  of  expression  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [BUGGY]    while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n++;  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	replace	    while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n++;		non-compiled	[CE]  illegal  start  of  expression	14	None	add
94	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [BUGGY]    n  =  Math.abs(an);  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	add	    n  =  Math.abs(an);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	14	1
95	[BUG]  [BUGGY]    n  =  Math.abs(an);  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [BUGGY]    n  =  Math.abs(an);  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	replace	    n  =  Math.abs(an);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	14	1	add
95	[BUG]  [BUGGY]    while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  *  1.0;  [CE]  illegal  start  of  expression  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [BUGGY]    while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  *  1.0;  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	replace	    while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  *  1.0;		non-compiled	[CE]  illegal  start  of  expression	14	None	add
123	[BUG]  [BUGGY]  else  if(n  >=  maxIterations)  {  [CE]  'else'  without  'if'  [CONTEXT]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [BUGGY]  else  if(n  >=  maxIterations)  {  [BUGGY]  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	replace	else  if(n  >=  maxIterations)  {	if  (n  >=  maxIterations)  {  	non-compiled	[CE]  'else'  without  'if'	17	None	replace
152	[BUG]  [BUGGY]    ret  =  Math.exp(-x  +(a  <<  1.0  /  getSlope())*  x)-  1;  [CE]  cannot  find  symbol  [CONTEXT]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {    [BUGGY]    ret  =  Math.exp(-x  +(a  <<  1.0  /  getSlope())*  x)-  1;  [BUGGY]  double  n  =  0.0;  //  current  element  index    double  an  =  1.0  /  a;  //  n-th  element  in  the  series      double  sum  =  an;  //  partial  sum  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	replace	    ret  =  Math.exp(-x  +(a  <<  1.0  /  getSlope())*  x)-  1;		non-compiled	[CE]  cannot  find  symbol	4	None	add
153	[BUG]  [BUGGY]    ret  =  Math.exp(-x  +(a  >>  1.0  /  getSlope())*  x)-  1;  [CE]  cannot  find  symbol  [CONTEXT]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {    [BUGGY]    ret  =  Math.exp(-x  +(a  >>  1.0  /  getSlope())*  x)-  1;  [BUGGY]  double  n  =  0.0;  //  current  element  index    double  an  =  1.0  /  a;  //  n-th  element  in  the  series      double  sum  =  an;  //  partial  sum  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	replace	    ret  =  Math.exp(-x  +(a  >>  1.0  /  getSlope())*  x)-  1;		non-compiled	[CE]  cannot  find  symbol	4	None	add
155	[BUG]  [BUGGY]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations),  0.0);  [CE]  ';'  expected  [CONTEXT]  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {    [BUGGY]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations),  0.0);  [BUGGY]  double  n  =  0.0;  //  current  element  index    double  an  =  1.0  /  a;  //  n-th  element  in  the  series      double  sum  =  an;  //  partial  sum  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	replace	    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations),  0.0);		non-compiled	[CE]  ';'  expected	4	None	add
182	[BUG]  [BUGGY]  double  an  =  1.0  /  x;  //  n-th  element  in  the  series;  [CE]  illegal  start  of  type  [CONTEXT]  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  [BUGGY]  double  an  =  1.0  /  x;  //  n-th  element  in  the  series;  [BUGGY]  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	replace	double  an  =  1.0  /  x;  //  n-th  element  in  the  series;	double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  	non-compiled	[CE]  illegal  start  of  type	5	None	replace
184	[BUG]  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series.double  an  =  an;  [CE]  illegal  start  of  type  [CONTEXT]  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series.double  an  =  an;  [BUGGY]  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	replace	double  an  =  1.0  /  a;  //  n-th  element  in  the  series.double  an  =  an;	double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  	non-compiled	[CE]  illegal  start  of  type	5	None	replace
272	[BUG]  [BUGGY]  n  =  n  +  1.0,  an  *  x  /(a  +  n).doubleValue();  [CE]  ';'  expected  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {    [BUGGY]  n  =  n  +  1.0,  an  *  x  /(a  +  n).doubleValue();  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	replace	n  =  n  +  1.0,  an  *  x  /(a  +  n).doubleValue();	n  =  n  +  1.0;  	non-compiled	[CE]  ';'  expected	11	None	replace
273	[BUG]  [BUGGY]  n  =  n  +  1.0,  an  *  x  /(a  +  n);  [CE]  ';'  expected  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {    [BUGGY]  n  =  n  +  1.0,  an  *  x  /(a  +  n);  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	replace	n  =  n  +  1.0,  an  *  x  /(a  +  n);	n  =  n  +  1.0;  	non-compiled	[CE]  ';'  expected	11	None	replace
274	[BUG]  [BUGGY]  n  =  n  +  1.0,  an  *  x  /(a  +  n)-  10.0);  [CE]  ';'  expected  [CONTEXT]    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {    [BUGGY]  n  =  n  +  1.0,  an  *  x  /(a  +  n)-  10.0);  [BUGGY]  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	replace	n  =  n  +  1.0,  an  *  x  /(a  +  n)-  10.0);	n  =  n  +  1.0;  	non-compiled	[CE]  ';'  expected	11	None	replace
334	[BUG]  [BUGGY]  ret  =  Math.exp(-x  +(a  *  Math.log(x),  epsilon)-  logGamma(a))  *  sum;  [CE]  ')'  expected  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]  ret  =  Math.exp(-x  +(a  *  Math.log(x),  epsilon)-  logGamma(a))  *  sum;  [BUGGY]  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	replace	ret  =  Math.exp(-x  +(a  *  Math.log(x),  epsilon)-  logGamma(a))  *  sum;	ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  	non-compiled	[CE]  ')'  expected	19	None	replace
362	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  [BUGGY]    n  =  Math.abs(1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations));  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series    double  sum  =  an;  //  partial  sum      while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	add	    n  =  Math.abs(1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations));		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	6	1
363	[BUG]  [BUGGY]    n  =  Math.abs(1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations));  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  [BUGGY]    n  =  Math.abs(1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations));  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series    double  sum  =  an;  //  partial  sum      while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	replace	    n  =  Math.abs(1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations));		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	6	1	add
364	[BUG]  [BUGGY]    n  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  /  ret;  [CE]  variable  ret  might  not  have  been  initialized  [CONTEXT]  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  [BUGGY]    n  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  /  ret;  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series    double  sum  =  an;  //  partial  sum      while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	replace	    n  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  /  ret;		non-compiled	[CE]  variable  ret  might  not  have  been  initialized	6	None	add
365	[BUG]  [BUGGY]    n  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a)));  [CE]  ';'  expected  [CONTEXT]  ret  =  Double.NaN;  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  [BUGGY]    n  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a)));  [BUGGY]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series    double  sum  =  an;  //  partial  sum      while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	replace	    n  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a)));		non-compiled	[CE]  ';'  expected	6	None	add
392	[BUG]  [BUGGY]    n  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  ret;  [CE]  variable  ret  might  not  have  been  initialized  [CONTEXT]  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  [BUGGY]    n  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  ret;  [BUGGY]  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	replace	    n  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  ret;		non-compiled	[CE]  variable  ret  might  not  have  been  initialized	8	None	add
393	[BUG]  [BUGGY]    an  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  ret;  [CE]  variable  ret  might  not  have  been  initialized  [CONTEXT]  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  [BUGGY]    an  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  ret;  [BUGGY]  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	replace	    an  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  ret;		non-compiled	[CE]  variable  ret  might  not  have  been  initialized	8	None	add
394	[BUG]  [BUGGY]    n  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  /  ret;  [CE]  variable  ret  might  not  have  been  initialized  [CONTEXT]  }  else  if  (x  ==  0.0)  {  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  [BUGGY]    n  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  /  ret;  [BUGGY]  double  sum  =  an;  //  partial  sum    while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	replace	    n  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  /  ret;		non-compiled	[CE]  variable  ret  might  not  have  been  initialized	8	None	add
424	[BUG]  [BUGGY]  timeout  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]  while(Math.abs(an)>  epsilon  -  n)  {  [BUGGY]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	add	while(Math.abs(an)>  epsilon  -  n)  {	while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  	compilable	timeout	9	1
425	[BUG]  [BUGGY]  while(Math.abs(an)>  epsilon  -  n)  {  timeout  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]  while(Math.abs(an)>  epsilon  -  n)  {  [BUGGY]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	replace	while(Math.abs(an)>  epsilon  -  n)  {	while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  	compilable	timeout	9	1	replace
452	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [BUGGY]    ret  =  Math.log(an)/  HALF_LOG_2_PI;  [BUGGY]  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	add	    ret  =  Math.log(an)/  HALF_LOG_2_PI;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	18	1
453	[BUG]  [BUGGY]    ret  =  Math.log(an)/  HALF_LOG_2_PI;  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [BUGGY]    ret  =  Math.log(an)/  HALF_LOG_2_PI;  [BUGGY]  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	replace	    ret  =  Math.log(an)/  HALF_LOG_2_PI;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	18	1	add
453	[BUG]  [BUGGY]    int  maxIterations  =  Math.max(Math.abs(an)/  epsilon);  [CE]  variable  maxIterations  is  already  defined  in  method  regularizedGammaP(double,double,double,int)  [CONTEXT]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [BUGGY]    int  maxIterations  =  Math.max(Math.abs(an)/  epsilon);  [BUGGY]  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	replace	    int  maxIterations  =  Math.max(Math.abs(an)/  epsilon);		non-compiled	[CE]  variable  maxIterations  is  already  defined  in  method  regularizedGammaP(double,double,double,int)	18	None	add
454	[BUG]  [BUGGY]    int  maxIterations  =  Math.max(Math.abs(an)%  epsilon  -  1.0);  [CE]  variable  maxIterations  is  already  defined  in  method  regularizedGammaP(double,double,double,int)  [CONTEXT]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [BUGGY]    int  maxIterations  =  Math.max(Math.abs(an)%  epsilon  -  1.0);  [BUGGY]  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	replace	    int  maxIterations  =  Math.max(Math.abs(an)%  epsilon  -  1.0);		non-compiled	[CE]  variable  maxIterations  is  already  defined  in  method  regularizedGammaP(double,double,double,int)	18	None	add
455	[BUG]  [BUGGY]    int  maxIterations  =  Math.max(Math.abs(an)/  epsilon,  1.0);  [CE]  variable  maxIterations  is  already  defined  in  method  regularizedGammaP(double,double,double,int)  [CONTEXT]  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  [BUGGY]    int  maxIterations  =  Math.max(Math.abs(an)/  epsilon,  1.0);  [BUGGY]  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	replace	    int  maxIterations  =  Math.max(Math.abs(an)/  epsilon,  1.0);		non-compiled	[CE]  variable  maxIterations  is  already  defined  in  method  regularizedGammaP(double,double,double,int)	18	None	add
481	[BUG]  [BUGGY]    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  throw  new  MaxIterationExceededException( "max  [CE]  unclosed  string  literal  [CONTEXT]    double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));    [BUGGY]    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  throw  new  MaxIterationExceededException( "max  [BUGGY]  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	replace	    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  throw  new  MaxIterationExceededException( "max		non-compiled	[CE]  unclosed  string  literal	16	None	add
482	[BUG]  [BUGGY]    while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [CE]  illegal  start  of  expression  [CONTEXT]    double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));    [BUGGY]    while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  [BUGGY]  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	replace	    while(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;		non-compiled	[CE]  illegal  start  of  expression	16	None	add
483	[BUG]  [BUGGY]    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  throw  new  MaxIterationsExceededException( "max  [CE]  unclosed  string  literal  [CONTEXT]    double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));    [BUGGY]    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  throw  new  MaxIterationsExceededException( "max  [BUGGY]  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	replace	    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  throw  new  MaxIterationsExceededException( "max		non-compiled	[CE]  unclosed  string  literal	16	None	add
484	[BUG]  [BUGGY]    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  throw  new  MaxIterationExceededException( " ")  [CE]  [CONTEXT]    double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));    [BUGGY]    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  throw  new  MaxIterationExceededException( " ")  [BUGGY]  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	replace	    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  throw  new  MaxIterationExceededException( " ")		non-compiled	[CE]  	16	None	add
485	[BUG]  [BUGGY]    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  throw  new  ClassExceededException( "max  [CE]  unclosed  string  literal  [CONTEXT]    double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));    [BUGGY]    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  throw  new  ClassExceededException( "max  [BUGGY]  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  return  ret;  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	replace	    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  throw  new  ClassExceededException( "max		non-compiled	[CE]  unclosed  string  literal	16	None	add
512	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]    sum  =  sum  +  an  *  x  /  epsilon;  [BUGGY]  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	add	    sum  =  sum  +  an  *  x  /  epsilon;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	20	1
513	[BUG]  [BUGGY]    sum  =  sum  +  an  *  x  /  epsilon;  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]    sum  =  sum  +  an  *  x  /  epsilon;  [BUGGY]  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	replace	    sum  =  sum  +  an  *  x  /  epsilon;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	20	1	add
513	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]    n  =  n  +  1;  [BUGGY]  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	add	    n  =  n  +  1;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	20	1
514	[BUG]  [BUGGY]    n  =  n  +  1;  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]    n  =  n  +  1;  [BUGGY]  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	replace	    n  =  n  +  1;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	20	1	add
514	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]    sum  =  sum  +  Math.log(x);  n  =  n  +  1;  [BUGGY]  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	add	    sum  =  sum  +  Math.log(x);  n  =  n  +  1;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	20	1
515	[BUG]  [BUGGY]    sum  =  sum  +  Math.log(x);  n  =  n  +  1;  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]    sum  =  sum  +  Math.log(x);  n  =  n  +  1;  [BUGGY]  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	replace	    sum  =  sum  +  Math.log(x);  n  =  n  +  1;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	20	1	add
515	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]    sum  =  sum  +  Math.log(a  /  x);  [BUGGY]  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	add	    sum  =  sum  +  Math.log(a  /  x);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	20	1
516	[BUG]  [BUGGY]    sum  =  sum  +  Math.log(a  /  x);  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]    n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [BUGGY]    sum  =  sum  +  Math.log(a  /  x);  [BUGGY]  ret  =  Math.exp(-x  +  (a  *  Math.log(x))  -  logGamma(a))  *  sum;  }  }  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	replace	    sum  =  sum  +  Math.log(a  /  x);		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	20	1	add
571	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  n  =  n  +  1.0;  }  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	add	    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  n  =  n  +  1.0;  }		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	10	1
572	[BUG]  [BUGGY]    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  n  =  n  +  1.0;  }  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  n  =  n  +  1.0;  }  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	replace	    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  n  =  n  +  1.0;  }		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	10	1	add
572	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]    n  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum;  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	add	    n  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	10	1
573	[BUG]  [BUGGY]    n  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum;  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]    n  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum;  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	replace	    n  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  *  sum;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	10	1	add
573	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]    n  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  /  sum;  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	add	    n  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  /  sum;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	10	1
574	[BUG]  [BUGGY]    n  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  /  sum;  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]    n  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  /  sum;  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	replace	    n  =  Math.exp(-x  +(a  *  Math.log(x))  -  logGamma(a))  /  sum;		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	10	1	add
574	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  n  =  an  *  sum;  }  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	add	    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  n  =  an  *  sum;  }		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	10	1
575	[BUG]  [BUGGY]    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  n  =  an  *  sum;  }  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  n  =  an  *  sum;  }  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	replace	    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  n  =  an  *  sum;  }		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	10	1	add
575	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  n  =  an  *  x  /  sum;  }  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	add	    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  n  =  an  *  x  /  sum;  }		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	10	1
576	[BUG]  [BUGGY]    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  n  =  an  *  x  /  sum;  }  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive  [CONTEXT]  ret  =  0.0;  }  else  if  (a  >=  1.0  &&  x  >  a)  {    ret  =  1.0  -  regularizedGammaQ(a,  x,  epsilon,  maxIterations);  }  else  {  double  n  =  0.0;  //  current  element  index  double  an  =  1.0  /  a;  //  n-th  element  in  the  series  double  sum  =  an;  //  partial  sum  [BUGGY]    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  n  =  an  *  x  /  sum;  }  [BUGGY]  while  (Math.abs(an)  >  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  an  =  an  *  (x  /  (a  +  n));  sum  =  sum  +  an;  }  if  (n  >=  maxIterations)  {  throw  new  MaxIterationsExceededException(maxIterations);  }  else  {  [CLASS]  Gamma  1  [METHOD]  regularizedGammaP  [RETURN_TYPE]  double  double  a  double  x  double  epsilon  int  maxIterations  [VARIABLES]  boolean  double[]  lanczos  double  DEFAULT_EPSILON  HALF_LOG_2_PI  a  an  epsilon  g  n  ret  sum  tmp  x  long  serialVersionUID  int  maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	replace	    if(Math.abs(an)>  epsilon  &&  n  <  maxIterations)  {  n  =  n  +  1.0;  n  =  an  *  x  /  sum;  }		compilable	  [FE]  AssertionFailedError  testRegularizedGammaPositivePositive	10	1	add
