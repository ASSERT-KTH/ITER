bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] } else if (a >= 1.0 && x > a) { [FE] AssertionFailedError testRegularizedGammaPositivePositive [CONTEXT] { double ret; if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) { ret = Double.NaN; } else if (x == 0.0) { ret = 0.0; [BUGGY] } else if (a >= 1.0 && x > a) { [BUGGY]   ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	162	162	1	replace	
2	[BUG] [BUGGY] [FE] AssertionFailedError testRegularizedGammaPositivePositive [CONTEXT] { double ret; if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) { ret = Double.NaN; } else if (x == 0.0) { ret = 0.0; [BUGGY] [BUGGY] } else if (a >= 1.0 && x > a) {   ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	162	162	1	add	
3	[BUG] [BUGGY] double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series  double sum = an; // partial sum [FE] AssertionFailedError testRegularizedGammaPositivePositive [CONTEXT] } else if (a >= 1.0 && x > a) {   ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  [BUGGY] double n = 0.0; // current element index   double an = 1.0 / a; // n-th element in the series      double sum = an; // partial sum [BUGGY] double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  n = n + 1.0; an = an * (x / (a + n));  sum = sum + an; } [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	replace	
4	[BUG] [BUGGY] [FE] AssertionFailedError testRegularizedGammaPositivePositive [CONTEXT] } else if (a >= 1.0 && x > a) {   ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  [BUGGY] [BUGGY] double n = 0.0; // current element index   double an = 1.0 / a; // n-th element in the series      double sum = an; // partial sum double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  n = n + 1.0; an = an * (x / (a + n));  sum = sum + an; } [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	168	170	1	add	
5	[BUG] [BUGGY] double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum  while (Math.abs(an) > epsilon && n < maxIterations) { [FE] AssertionFailedError testRegularizedGammaPositivePositive [CONTEXT] ret = Double.NaN; } else if (x == 0.0) { ret = 0.0; } else if (a >= 1.0 && x > a) {   ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  double n = 0.0; // current element index [BUGGY] double an = 1.0 / a; // n-th element in the series   double sum = an; // partial sum      while (Math.abs(an) > epsilon && n < maxIterations) { [BUGGY] double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  n = n + 1.0; an = an * (x / (a + n));  sum = sum + an; } if (n >= maxIterations) { [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	replace	
6	[BUG] [BUGGY] [FE] AssertionFailedError testRegularizedGammaPositivePositive [CONTEXT] ret = Double.NaN; } else if (x == 0.0) { ret = 0.0; } else if (a >= 1.0 && x > a) {   ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  double n = 0.0; // current element index [BUGGY] [BUGGY] double an = 1.0 / a; // n-th element in the series   double sum = an; // partial sum      while (Math.abs(an) > epsilon && n < maxIterations) { double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  n = n + 1.0; an = an * (x / (a + n));  sum = sum + an; } if (n >= maxIterations) { [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	169	171	1	add	
7	[BUG] [BUGGY] double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) { [FE] AssertionFailedError testRegularizedGammaPositivePositive [CONTEXT] } else if (x == 0.0) { ret = 0.0; } else if (a >= 1.0 && x > a) {   ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series [BUGGY] double sum = an; // partial sum   while (Math.abs(an) > epsilon && n < maxIterations) { [BUGGY] while (Math.abs(an) > epsilon && n < maxIterations) {  n = n + 1.0; an = an * (x / (a + n));  sum = sum + an; } if (n >= maxIterations) { throw new MaxIterationsExceededException(maxIterations); [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	replace	
8	[BUG] [BUGGY] [FE] AssertionFailedError testRegularizedGammaPositivePositive [CONTEXT] } else if (x == 0.0) { ret = 0.0; } else if (a >= 1.0 && x > a) {   ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series [BUGGY] [BUGGY] double sum = an; // partial sum   while (Math.abs(an) > epsilon && n < maxIterations) { while (Math.abs(an) > epsilon && n < maxIterations) {  n = n + 1.0; an = an * (x / (a + n));  sum = sum + an; } if (n >= maxIterations) { throw new MaxIterationsExceededException(maxIterations); [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	170	171	1	add	
9	[BUG] [BUGGY] while (Math.abs(an) > epsilon && n < maxIterations) { [FE] AssertionFailedError testRegularizedGammaPositivePositive [CONTEXT] ret = 0.0; } else if (a >= 1.0 && x > a) {   ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum [BUGGY] while (Math.abs(an) > epsilon && n < maxIterations) { [BUGGY]  n = n + 1.0; an = an * (x / (a + n));  sum = sum + an; } if (n >= maxIterations) { throw new MaxIterationsExceededException(maxIterations); } else { [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	replace	
10	[BUG] [BUGGY] [FE] AssertionFailedError testRegularizedGammaPositivePositive [CONTEXT] ret = 0.0; } else if (a >= 1.0 && x > a) {   ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum [BUGGY] [BUGGY] while (Math.abs(an) > epsilon && n < maxIterations) {  n = n + 1.0; an = an * (x / (a + n));  sum = sum + an; } if (n >= maxIterations) { throw new MaxIterationsExceededException(maxIterations); } else { [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	171	171	1	add	
11	[BUG] [BUGGY] n = n + 1.0; [FE] AssertionFailedError testRegularizedGammaPositivePositive [CONTEXT]   ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  [BUGGY] n = n + 1.0; [BUGGY] an = an * (x / (a + n));  sum = sum + an; } if (n >= maxIterations) { throw new MaxIterationsExceededException(maxIterations); } else { ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum; } [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	replace	
12	[BUG] [BUGGY] [FE] AssertionFailedError testRegularizedGammaPositivePositive [CONTEXT]   ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  [BUGGY] [BUGGY] n = n + 1.0; an = an * (x / (a + n));  sum = sum + an; } if (n >= maxIterations) { throw new MaxIterationsExceededException(maxIterations); } else { ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum; } [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	173	173	1	add	
13	[BUG] [BUGGY] an = an * (x / (a + n)); [FE] AssertionFailedError testRegularizedGammaPositivePositive [CONTEXT]  ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  n = n + 1.0; [BUGGY] an = an * (x / (a + n)); [BUGGY]   sum = sum + an; } if (n >= maxIterations) { throw new MaxIterationsExceededException(maxIterations); } else { ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum; } } [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	replace	
14	[BUG] [BUGGY] [FE] AssertionFailedError testRegularizedGammaPositivePositive [CONTEXT]  ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); } else {  double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  n = n + 1.0; [BUGGY] [BUGGY] an = an * (x / (a + n));  sum = sum + an; } if (n >= maxIterations) { throw new MaxIterationsExceededException(maxIterations); } else { ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum; } } [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	174	174	1	add	
15	[BUG] [BUGGY] sum = sum + an; [FE] AssertionFailedError testRegularizedGammaPositivePositive [CONTEXT]  double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  n = n + 1.0; an = an * (x / (a + n));  [BUGGY] sum = sum + an; [BUGGY] } if (n >= maxIterations) { throw new MaxIterationsExceededException(maxIterations); } else { ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum; } } return ret; } [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	replace	
16	[BUG] [BUGGY] [FE] AssertionFailedError testRegularizedGammaPositivePositive [CONTEXT]  double n = 0.0; // current element index double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  n = n + 1.0; an = an * (x / (a + n));  [BUGGY] [BUGGY] sum = sum + an; } if (n >= maxIterations) { throw new MaxIterationsExceededException(maxIterations); } else { ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum; } } return ret; } [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	177	177	1	add	
17	[BUG] [BUGGY] if (n >= maxIterations) { [FE] AssertionFailedError testRegularizedGammaPositivePositive [CONTEXT] double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  n = n + 1.0; an = an * (x / (a + n));  sum = sum + an; } [BUGGY] if (n >= maxIterations) { [BUGGY] throw new MaxIterationsExceededException(maxIterations); } else { ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum; } } return ret; } [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	replace	
18	[BUG] [BUGGY] [FE] AssertionFailedError testRegularizedGammaPositivePositive [CONTEXT] double an = 1.0 / a; // n-th element in the series double sum = an; // partial sum while (Math.abs(an) > epsilon && n < maxIterations) {  n = n + 1.0; an = an * (x / (a + n));  sum = sum + an; } [BUGGY] [BUGGY] if (n >= maxIterations) { throw new MaxIterationsExceededException(maxIterations); } else { ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum; } } return ret; } [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	179	179	1	add	
19	[BUG] [BUGGY] ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum; [FE] AssertionFailedError testRegularizedGammaPositivePositive [CONTEXT]  n = n + 1.0; an = an * (x / (a + n));  sum = sum + an; } if (n >= maxIterations) { throw new MaxIterationsExceededException(maxIterations); } else { [BUGGY] ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum; [BUGGY] } } [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	replace	
20	[BUG] [BUGGY] [FE] AssertionFailedError testRegularizedGammaPositivePositive [CONTEXT]  n = n + 1.0; an = an * (x / (a + n));  sum = sum + an; } if (n >= maxIterations) { throw new MaxIterationsExceededException(maxIterations); } else { [BUGGY] [BUGGY] ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum; } } [CLASS] Gamma 1 [METHOD] regularizedGammaP [RETURN_TYPE] double  double a double x double epsilon int maxIterations [VARIABLES] boolean double[] lanczos double DEFAULT_EPSILON HALF_LOG_2_PI a an epsilon g n ret sum tmp x long serialVersionUID int maxIterations  	projects/Math104/src/java/org/apache/commons/math/special/Gamma.java	1.0	182	182	1	add	
