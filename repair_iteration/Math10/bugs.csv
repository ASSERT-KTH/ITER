bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] double[] tmp1 = new double[getSize()]; [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {  [BUGGY] double[] tmp1 = new double[getSize()]; [BUGGY] multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1387	1387	1	replace	
2	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {  [BUGGY] [BUGGY] double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1387	1387	1	add	
3	[BUG] [BUGGY] multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {  double[] tmp1 = new double[getSize()]; [BUGGY] multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2  double[] tmp2 = new double[getSize()]; [BUGGY] double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1388	1389	1	replace	
4	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {  double[] tmp1 = new double[getSize()]; [BUGGY] [BUGGY] multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2  double[] tmp2 = new double[getSize()]; double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1388	1389	1	add	
5	[BUG] [BUGGY] double[] tmp2 = new double[getSize()]; [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {  double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 [BUGGY] double[] tmp2 = new double[getSize()]; [BUGGY] multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1389	1389	1	replace	
6	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {  double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 [BUGGY] [BUGGY] double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1389	1389	1	add	
7	[BUG] [BUGGY] multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0);  // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0);   // r = sqrt(x^2 + y^2) [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {  double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; [BUGGY] multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2  add(tmp1, 0, tmp2, 0, tmp2, 0);     // x^2 + y^2    rootN(tmp2, 0, 2, tmp1, 0);           // r = sqrt(x^2 + y^2) [BUGGY] add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1390	1392	1	replace	
8	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {  double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; [BUGGY] [BUGGY] multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2  add(tmp1, 0, tmp2, 0, tmp2, 0);     // x^2 + y^2    rootN(tmp2, 0, 2, tmp1, 0);           // r = sqrt(x^2 + y^2) add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1390	1392	1	add	
9	[BUG] [BUGGY] add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0);  // r = sqrt(x^2 + y^2) [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {  double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 [BUGGY] add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2  rootN(tmp2, 0, 2, tmp1, 0);      // r = sqrt(x^2 + y^2) [BUGGY] rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1391	1393	1	replace	
10	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {  double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 [BUGGY] [BUGGY] add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2  rootN(tmp2, 0, 2, tmp1, 0);      // r = sqrt(x^2 + y^2) rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1391	1393	1	add	
11	[BUG] [BUGGY] rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) { [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {  double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 [BUGGY] rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2)    if (x[xOffset] >= 0) { [BUGGY]  if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) } [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1392	1394	1	replace	
12	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {  double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 [BUGGY] [BUGGY] rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2)    if (x[xOffset] >= 0) { if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) } [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1392	1394	1	add	
13	[BUG] [BUGGY] if (x[xOffset] >= 0) { [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {  double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) [BUGGY] if (x[xOffset] >= 0) { [BUGGY]   add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) } } else { [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1394	1394	1	replace	
14	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {  double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) [BUGGY] [BUGGY] if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) } } else { [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1394	1394	1	add	
15	[BUG] [BUGGY] add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x)  atan(tmp1, 0, tmp2, 0);   // atan(y / (r + x)) [FE] AssertionError [CONTEXT] double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  [BUGGY] add(tmp1, 0, x, xOffset, tmp2, 0);// r + x   divide(y, yOffset, tmp2, 0, tmp1, 0);  // y /(r + x)      atan(tmp1, 0, tmp2, 0);           // atan(y / (r + x)) [BUGGY] divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) } } else {  subtract(tmp1, 0, x, xOffset, tmp2, 0); // r - x [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1397	1399	1	replace	
16	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  [BUGGY] [BUGGY] add(tmp1, 0, x, xOffset, tmp2, 0);// r + x   divide(y, yOffset, tmp2, 0, tmp1, 0);  // y /(r + x)      atan(tmp1, 0, tmp2, 0);           // atan(y / (r + x)) divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) } } else {  subtract(tmp1, 0, x, xOffset, tmp2, 0); // r - x [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1397	1399	1	add	
17	[BUG] [BUGGY] divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0);  // atan(y / (r + x))  for (int i = 0; i < tmp2.length; ++i) { [FE] AssertionError [CONTEXT] multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x [BUGGY] divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x)   atan(tmp1, 0, tmp2, 0);      // atan(y / (r + x))      for (int i = 0; i < tmp2.length; ++i) { [BUGGY] atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) } } else {  subtract(tmp1, 0, x, xOffset, tmp2, 0); // r - x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r - x) [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1398	1400	1	replace	
18	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x [BUGGY] [BUGGY] divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x)   atan(tmp1, 0, tmp2, 0);      // atan(y / (r + x))      for (int i = 0; i < tmp2.length; ++i) { atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) } } else {  subtract(tmp1, 0, x, xOffset, tmp2, 0); // r - x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r - x) [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1398	1400	1	add	
19	[BUG] [BUGGY] atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { [FE] AssertionError [CONTEXT] double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) [BUGGY] atan(tmp1, 0, tmp2, 0); // atan(y / (r + x))   for (int i = 0; i < tmp2.length; ++i) { [BUGGY] for (int i = 0; i < tmp2.length; ++i) { result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) } } else {  subtract(tmp1, 0, x, xOffset, tmp2, 0); // r - x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r - x) atan(tmp1, 0, tmp2, 0); // atan(y / (r - x)) [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1399	1400	1	replace	
20	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) [BUGGY] [BUGGY] atan(tmp1, 0, tmp2, 0); // atan(y / (r + x))   for (int i = 0; i < tmp2.length; ++i) { for (int i = 0; i < tmp2.length; ++i) { result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) } } else {  subtract(tmp1, 0, x, xOffset, tmp2, 0); // r - x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r - x) atan(tmp1, 0, tmp2, 0); // atan(y / (r - x)) [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1399	1400	1	add	
21	[BUG] [BUGGY] for (int i = 0; i < tmp2.length; ++i) { [FE] AssertionError [CONTEXT] multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) [BUGGY] for (int i = 0; i < tmp2.length; ++i) { [BUGGY] result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) } } else {  subtract(tmp1, 0, x, xOffset, tmp2, 0); // r - x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r - x) atan(tmp1, 0, tmp2, 0); // atan(y / (r - x)) result[resultOffset] = [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1400	1400	1	replace	
22	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) [BUGGY] [BUGGY] for (int i = 0; i < tmp2.length; ++i) { result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) } } else {  subtract(tmp1, 0, x, xOffset, tmp2, 0); // r - x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r - x) atan(tmp1, 0, tmp2, 0); // atan(y / (r - x)) result[resultOffset] = [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1400	1400	1	add	
23	[BUG] [BUGGY] result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) } [FE] AssertionError [CONTEXT] add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { [BUGGY] result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x))   } [BUGGY] } } else {  subtract(tmp1, 0, x, xOffset, tmp2, 0); // r - x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r - x) atan(tmp1, 0, tmp2, 0); // atan(y / (r - x)) result[resultOffset] = ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; // +/-pi - 2 * atan(y / (r - x)) [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1401	1402	1	replace	
24	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { [BUGGY] [BUGGY] result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x))   } } } else {  subtract(tmp1, 0, x, xOffset, tmp2, 0); // r - x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r - x) atan(tmp1, 0, tmp2, 0); // atan(y / (r - x)) result[resultOffset] = ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; // +/-pi - 2 * atan(y / (r - x)) [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1401	1402	1	add	
26	[BUG] [BUGGY] double[] function = new double[1 + order]; [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {  [BUGGY] double[] function = new double[1 + order]; [BUGGY] final double x = operand[operandOffset]; function[0] = FastMath.atan(x); if (order > 0) {        [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1327	1327	1	replace	
27	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {  [BUGGY] [BUGGY] double[] function = new double[1 + order]; final double x = operand[operandOffset]; function[0] = FastMath.atan(x); if (order > 0) {        [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1327	1327	1	add	
28	[BUG] [BUGGY] final double x = operand[operandOffset]; [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {  double[] function = new double[1 + order]; [BUGGY] final double x = operand[operandOffset]; [BUGGY] function[0] = FastMath.atan(x); if (order > 0) {        final double[] q = new double[order]; [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1328	1328	1	replace	
29	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {  double[] function = new double[1 + order]; [BUGGY] [BUGGY] final double x = operand[operandOffset]; function[0] = FastMath.atan(x); if (order > 0) {        final double[] q = new double[order]; [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1328	1328	1	add	
30	[BUG] [BUGGY] function[0] = FastMath.atan(x); [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {  double[] function = new double[1 + order]; final double x = operand[operandOffset]; [BUGGY] function[0] = FastMath.atan(x); [BUGGY] if (order > 0) {        final double[] q = new double[order]; q[0] = 1; [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1329	1329	1	replace	
31	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {  double[] function = new double[1 + order]; final double x = operand[operandOffset]; [BUGGY] [BUGGY] function[0] = FastMath.atan(x); if (order > 0) {        final double[] q = new double[order]; q[0] = 1; [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1329	1329	1	add	
32	[BUG] [BUGGY] if (order > 0) { [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {  double[] function = new double[1 + order]; final double x = operand[operandOffset]; function[0] = FastMath.atan(x); [BUGGY] if (order > 0) { [BUGGY]        final double[] q = new double[order]; q[0] = 1; final double x2= x * x; [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1330	1330	1	replace	
33	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {  double[] function = new double[1 + order]; final double x = operand[operandOffset]; function[0] = FastMath.atan(x); [BUGGY] [BUGGY] if (order > 0) {        final double[] q = new double[order]; q[0] = 1; final double x2= x * x; [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1330	1330	1	add	
34	[BUG] [BUGGY] final double[] q = new double[order]; [FE] AssertionError [CONTEXT] final double x = operand[operandOffset]; function[0] = FastMath.atan(x); if (order > 0) {        [BUGGY] final double[] q = new double[order]; [BUGGY] q[0] = 1; final double x2= x * x; final double f = 1.0 / (1 + x2); double coeff = f; function[1] = coeff * q[0]; for (int n = 2; n <= order; ++n) {  double v = 0; q[n - 1] = -n * q[n - 2]; [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1338	1338	1	replace	
35	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] final double x = operand[operandOffset]; function[0] = FastMath.atan(x); if (order > 0) {        [BUGGY] [BUGGY] final double[] q = new double[order]; q[0] = 1; final double x2= x * x; final double f = 1.0 / (1 + x2); double coeff = f; function[1] = coeff * q[0]; for (int n = 2; n <= order; ++n) {  double v = 0; q[n - 1] = -n * q[n - 2]; [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1338	1338	1	add	
36	[BUG] [BUGGY] q[0] = 1; [FE] AssertionError [CONTEXT] function[0] = FastMath.atan(x); if (order > 0) {        final double[] q = new double[order]; [BUGGY] q[0] = 1; [BUGGY] final double x2= x * x; final double f = 1.0 / (1 + x2); double coeff = f; function[1] = coeff * q[0]; for (int n = 2; n <= order; ++n) {  double v = 0; q[n - 1] = -n * q[n - 2]; for (int k = n - 1; k >= 0; k -= 2) { [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1339	1339	1	replace	
37	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] function[0] = FastMath.atan(x); if (order > 0) {        final double[] q = new double[order]; [BUGGY] [BUGGY] q[0] = 1; final double x2= x * x; final double f = 1.0 / (1 + x2); double coeff = f; function[1] = coeff * q[0]; for (int n = 2; n <= order; ++n) {  double v = 0; q[n - 1] = -n * q[n - 2]; for (int k = n - 1; k >= 0; k -= 2) { [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1339	1339	1	add	
38	[BUG] [BUGGY] final double x2= x * x; [FE] AssertionError [CONTEXT] if (order > 0) {        final double[] q = new double[order]; q[0] = 1; [BUGGY] final double x2= x * x; [BUGGY] final double f = 1.0 / (1 + x2); double coeff = f; function[1] = coeff * q[0]; for (int n = 2; n <= order; ++n) {  double v = 0; q[n - 1] = -n * q[n - 2]; for (int k = n - 1; k >= 0; k -= 2) { v = v * x2 + q[k]; [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1340	1340	1	replace	
39	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] if (order > 0) {        final double[] q = new double[order]; q[0] = 1; [BUGGY] [BUGGY] final double x2= x * x; final double f = 1.0 / (1 + x2); double coeff = f; function[1] = coeff * q[0]; for (int n = 2; n <= order; ++n) {  double v = 0; q[n - 1] = -n * q[n - 2]; for (int k = n - 1; k >= 0; k -= 2) { v = v * x2 + q[k]; [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1340	1340	1	add	
40	[BUG] [BUGGY] final double f = 1.0 / (1 + x2); [FE] AssertionError [CONTEXT]        final double[] q = new double[order]; q[0] = 1; final double x2= x * x; [BUGGY] final double f = 1.0 / (1 + x2); [BUGGY] double coeff = f; function[1] = coeff * q[0]; for (int n = 2; n <= order; ++n) {  double v = 0; q[n - 1] = -n * q[n - 2]; for (int k = n - 1; k >= 0; k -= 2) { v = v * x2 + q[k]; if (k > 2) { [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1341	1341	1	replace	
41	[BUG] [BUGGY] [FE] AssertionError [CONTEXT]        final double[] q = new double[order]; q[0] = 1; final double x2= x * x; [BUGGY] [BUGGY] final double f = 1.0 / (1 + x2); double coeff = f; function[1] = coeff * q[0]; for (int n = 2; n <= order; ++n) {  double v = 0; q[n - 1] = -n * q[n - 2]; for (int k = n - 1; k >= 0; k -= 2) { v = v * x2 + q[k]; if (k > 2) { [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1341	1341	1	add	
42	[BUG] [BUGGY] double coeff = f; [FE] AssertionError [CONTEXT]       final double[] q = new double[order]; q[0] = 1; final double x2= x * x; final double f = 1.0 / (1 + x2); [BUGGY] double coeff = f; [BUGGY] function[1] = coeff * q[0]; for (int n = 2; n <= order; ++n) {  double v = 0; q[n - 1] = -n * q[n - 2]; for (int k = n - 1; k >= 0; k -= 2) { v = v * x2 + q[k]; if (k > 2) { q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3]; [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1342	1342	1	replace	
43	[BUG] [BUGGY] [FE] AssertionError [CONTEXT]       final double[] q = new double[order]; q[0] = 1; final double x2= x * x; final double f = 1.0 / (1 + x2); [BUGGY] [BUGGY] double coeff = f; function[1] = coeff * q[0]; for (int n = 2; n <= order; ++n) {  double v = 0; q[n - 1] = -n * q[n - 2]; for (int k = n - 1; k >= 0; k -= 2) { v = v * x2 + q[k]; if (k > 2) { q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3]; [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1342	1342	1	add	
44	[BUG] [BUGGY] function[1] = coeff * q[0]; [FE] AssertionError [CONTEXT]      final double[] q = new double[order]; q[0] = 1; final double x2= x * x; final double f = 1.0 / (1 + x2); double coeff = f; [BUGGY] function[1] = coeff * q[0]; [BUGGY] for (int n = 2; n <= order; ++n) {  double v = 0; q[n - 1] = -n * q[n - 2]; for (int k = n - 1; k >= 0; k -= 2) { v = v * x2 + q[k]; if (k > 2) { q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3]; } else if (k == 2) { [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1343	1343	1	replace	
45	[BUG] [BUGGY] [FE] AssertionError [CONTEXT]      final double[] q = new double[order]; q[0] = 1; final double x2= x * x; final double f = 1.0 / (1 + x2); double coeff = f; [BUGGY] [BUGGY] function[1] = coeff * q[0]; for (int n = 2; n <= order; ++n) {  double v = 0; q[n - 1] = -n * q[n - 2]; for (int k = n - 1; k >= 0; k -= 2) { v = v * x2 + q[k]; if (k > 2) { q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3]; } else if (k == 2) { [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1343	1343	1	add	
46	[BUG] [BUGGY] for (int n = 2; n <= order; ++n) { [FE] AssertionError [CONTEXT]     final double[] q = new double[order]; q[0] = 1; final double x2= x * x; final double f = 1.0 / (1 + x2); double coeff = f; function[1] = coeff * q[0]; [BUGGY] for (int n = 2; n <= order; ++n) { [BUGGY]   double v = 0; q[n - 1] = -n * q[n - 2]; for (int k = n - 1; k >= 0; k -= 2) { v = v * x2 + q[k]; if (k > 2) { q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3]; } else if (k == 2) { q[0] = q[1]; [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1344	1344	1	replace	
47	[BUG] [BUGGY] [FE] AssertionError [CONTEXT]     final double[] q = new double[order]; q[0] = 1; final double x2= x * x; final double f = 1.0 / (1 + x2); double coeff = f; function[1] = coeff * q[0]; [BUGGY] [BUGGY] for (int n = 2; n <= order; ++n) {  double v = 0; q[n - 1] = -n * q[n - 2]; for (int k = n - 1; k >= 0; k -= 2) { v = v * x2 + q[k]; if (k > 2) { q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3]; } else if (k == 2) { q[0] = q[1]; [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1344	1344	1	add	
48	[BUG] [BUGGY] double v = 0; [FE] AssertionError [CONTEXT]  final double[] q = new double[order]; q[0] = 1; final double x2= x * x; final double f = 1.0 / (1 + x2); double coeff = f; function[1] = coeff * q[0]; for (int n = 2; n <= order; ++n) {  [BUGGY] double v = 0; [BUGGY] q[n - 1] = -n * q[n - 2]; for (int k = n - 1; k >= 0; k -= 2) { v = v * x2 + q[k]; if (k > 2) { q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3]; } else if (k == 2) { q[0] = q[1]; } } if ((n & 0x1) == 0) { [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1347	1347	1	replace	
49	[BUG] [BUGGY] [FE] AssertionError [CONTEXT]  final double[] q = new double[order]; q[0] = 1; final double x2= x * x; final double f = 1.0 / (1 + x2); double coeff = f; function[1] = coeff * q[0]; for (int n = 2; n <= order; ++n) {  [BUGGY] [BUGGY] double v = 0; q[n - 1] = -n * q[n - 2]; for (int k = n - 1; k >= 0; k -= 2) { v = v * x2 + q[k]; if (k > 2) { q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3]; } else if (k == 2) { q[0] = q[1]; } } if ((n & 0x1) == 0) { [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1347	1347	1	add	
50	[BUG] [BUGGY] q[n - 1] = -n * q[n - 2]; [FE] AssertionError [CONTEXT] final double[] q = new double[order]; q[0] = 1; final double x2= x * x; final double f = 1.0 / (1 + x2); double coeff = f; function[1] = coeff * q[0]; for (int n = 2; n <= order; ++n) {  double v = 0; [BUGGY] q[n - 1] = -n * q[n - 2]; [BUGGY] for (int k = n - 1; k >= 0; k -= 2) { v = v * x2 + q[k]; if (k > 2) { q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3]; } else if (k == 2) { q[0] = q[1]; } } if ((n & 0x1) == 0) { v *= x; [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1348	1348	1	replace	
51	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] final double[] q = new double[order]; q[0] = 1; final double x2= x * x; final double f = 1.0 / (1 + x2); double coeff = f; function[1] = coeff * q[0]; for (int n = 2; n <= order; ++n) {  double v = 0; [BUGGY] [BUGGY] q[n - 1] = -n * q[n - 2]; for (int k = n - 1; k >= 0; k -= 2) { v = v * x2 + q[k]; if (k > 2) { q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3]; } else if (k == 2) { q[0] = q[1]; } } if ((n & 0x1) == 0) { v *= x; [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1348	1348	1	add	
52	[BUG] [BUGGY] for (int k = n - 1; k >= 0; k -= 2) { [FE] AssertionError [CONTEXT] q[0] = 1; final double x2= x * x; final double f = 1.0 / (1 + x2); double coeff = f; function[1] = coeff * q[0]; for (int n = 2; n <= order; ++n) {  double v = 0; q[n - 1] = -n * q[n - 2]; [BUGGY] for (int k = n - 1; k >= 0; k -= 2) { [BUGGY] v = v * x2 + q[k]; if (k > 2) { q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3]; } else if (k == 2) { q[0] = q[1]; } } if ((n & 0x1) == 0) { v *= x; } [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1349	1349	1	replace	
53	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] q[0] = 1; final double x2= x * x; final double f = 1.0 / (1 + x2); double coeff = f; function[1] = coeff * q[0]; for (int n = 2; n <= order; ++n) {  double v = 0; q[n - 1] = -n * q[n - 2]; [BUGGY] [BUGGY] for (int k = n - 1; k >= 0; k -= 2) { v = v * x2 + q[k]; if (k > 2) { q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3]; } else if (k == 2) { q[0] = q[1]; } } if ((n & 0x1) == 0) { v *= x; } [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1349	1349	1	add	
54	[BUG] [BUGGY] v = v * x2 + q[k]; [FE] AssertionError [CONTEXT] final double x2= x * x; final double f = 1.0 / (1 + x2); double coeff = f; function[1] = coeff * q[0]; for (int n = 2; n <= order; ++n) {  double v = 0; q[n - 1] = -n * q[n - 2]; for (int k = n - 1; k >= 0; k -= 2) { [BUGGY] v = v * x2 + q[k]; [BUGGY] if (k > 2) { q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3]; } else if (k == 2) { q[0] = q[1]; } } if ((n & 0x1) == 0) { v *= x; }  [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1350	1350	1	replace	
55	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] final double x2= x * x; final double f = 1.0 / (1 + x2); double coeff = f; function[1] = coeff * q[0]; for (int n = 2; n <= order; ++n) {  double v = 0; q[n - 1] = -n * q[n - 2]; for (int k = n - 1; k >= 0; k -= 2) { [BUGGY] [BUGGY] v = v * x2 + q[k]; if (k > 2) { q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3]; } else if (k == 2) { q[0] = q[1]; } } if ((n & 0x1) == 0) { v *= x; }  [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1350	1350	1	add	
56	[BUG] [BUGGY] if (k > 2) { [FE] AssertionError [CONTEXT] final double f = 1.0 / (1 + x2); double coeff = f; function[1] = coeff * q[0]; for (int n = 2; n <= order; ++n) {  double v = 0; q[n - 1] = -n * q[n - 2]; for (int k = n - 1; k >= 0; k -= 2) { v = v * x2 + q[k]; [BUGGY] if (k > 2) { [BUGGY] q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3]; } else if (k == 2) { q[0] = q[1]; } } if ((n & 0x1) == 0) { v *= x; } coeff *= f; [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1351	1351	1	replace	
57	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] final double f = 1.0 / (1 + x2); double coeff = f; function[1] = coeff * q[0]; for (int n = 2; n <= order; ++n) {  double v = 0; q[n - 1] = -n * q[n - 2]; for (int k = n - 1; k >= 0; k -= 2) { v = v * x2 + q[k]; [BUGGY] [BUGGY] if (k > 2) { q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3]; } else if (k == 2) { q[0] = q[1]; } } if ((n & 0x1) == 0) { v *= x; } coeff *= f; [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1351	1351	1	add	
58	[BUG] [BUGGY] } else if (k == 2) { [FE] AssertionError [CONTEXT] function[1] = coeff * q[0]; for (int n = 2; n <= order; ++n) {  double v = 0; q[n - 1] = -n * q[n - 2]; for (int k = n - 1; k >= 0; k -= 2) { v = v * x2 + q[k]; if (k > 2) { q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3]; [BUGGY] } else if (k == 2) { [BUGGY] q[0] = q[1]; } } if ((n & 0x1) == 0) { v *= x; } coeff *= f; function[n] = coeff * v;  [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1353	1353	1	replace	
59	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] function[1] = coeff * q[0]; for (int n = 2; n <= order; ++n) {  double v = 0; q[n - 1] = -n * q[n - 2]; for (int k = n - 1; k >= 0; k -= 2) { v = v * x2 + q[k]; if (k > 2) { q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3]; [BUGGY] [BUGGY] } else if (k == 2) { q[0] = q[1]; } } if ((n & 0x1) == 0) { v *= x; } coeff *= f; function[n] = coeff * v;  [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1353	1353	1	add	
60	[BUG] [BUGGY] if ((n & 0x1) == 0) { [FE] AssertionError [CONTEXT] double v = 0; q[n - 1] = -n * q[n - 2]; for (int k = n - 1; k >= 0; k -= 2) { v = v * x2 + q[k]; if (k > 2) { q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3]; } else if (k == 2) { q[0] = q[1]; } } [BUGGY] if ((n & 0x1) == 0) { [BUGGY] v *= x; } coeff *= f; function[n] = coeff * v; } }   [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1357	1357	1	replace	
61	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] double v = 0; q[n - 1] = -n * q[n - 2]; for (int k = n - 1; k >= 0; k -= 2) { v = v * x2 + q[k]; if (k > 2) { q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3]; } else if (k == 2) { q[0] = q[1]; } } [BUGGY] [BUGGY] if ((n & 0x1) == 0) { v *= x; } coeff *= f; function[n] = coeff * v; } }   [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1357	1357	1	add	
62	[BUG] [BUGGY] v *= x; [FE] AssertionError [CONTEXT] q[n - 1] = -n * q[n - 2]; for (int k = n - 1; k >= 0; k -= 2) { v = v * x2 + q[k]; if (k > 2) { q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3]; } else if (k == 2) { q[0] = q[1]; } } if ((n & 0x1) == 0) { [BUGGY] v *= x; [BUGGY] } coeff *= f; function[n] = coeff * v; } }  compose(operand, operandOffset, function, result, resultOffset); [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1358	1358	1	replace	
63	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] q[n - 1] = -n * q[n - 2]; for (int k = n - 1; k >= 0; k -= 2) { v = v * x2 + q[k]; if (k > 2) { q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3]; } else if (k == 2) { q[0] = q[1]; } } if ((n & 0x1) == 0) { [BUGGY] [BUGGY] v *= x; } coeff *= f; function[n] = coeff * v; } }  compose(operand, operandOffset, function, result, resultOffset); [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1358	1358	1	add	
64	[BUG] [BUGGY] coeff *= f; [FE] AssertionError [CONTEXT] if (k > 2) { q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3]; } else if (k == 2) { q[0] = q[1]; } } if ((n & 0x1) == 0) { v *= x; } [BUGGY] coeff *= f; [BUGGY] function[n] = coeff * v; } }  compose(operand, operandOffset, function, result, resultOffset); } [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1361	1361	1	replace	
65	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] if (k > 2) { q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3]; } else if (k == 2) { q[0] = q[1]; } } if ((n & 0x1) == 0) { v *= x; } [BUGGY] [BUGGY] coeff *= f; function[n] = coeff * v; } }  compose(operand, operandOffset, function, result, resultOffset); } [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1361	1361	1	add	
66	[BUG] [BUGGY] function[n] = coeff * v; [FE] AssertionError [CONTEXT] q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3]; } else if (k == 2) { q[0] = q[1]; } } if ((n & 0x1) == 0) { v *= x; } coeff *= f; [BUGGY] function[n] = coeff * v; [BUGGY]  } }  compose(operand, operandOffset, function, result, resultOffset); } [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1362	1362	1	replace	
67	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3]; } else if (k == 2) { q[0] = q[1]; } } if ((n & 0x1) == 0) { v *= x; } coeff *= f; [BUGGY] [BUGGY] function[n] = coeff * v; } }  compose(operand, operandOffset, function, result, resultOffset); } [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1362	1362	1	add	
68	[BUG] [BUGGY] compose(operand, operandOffset, function, result, resultOffset); [FE] AssertionError [CONTEXT] v *= x; } coeff *= f; function[n] = coeff * v; } }  [BUGGY] compose(operand, operandOffset, function, result, resultOffset); [BUGGY]  } [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1368	1368	1	replace	
69	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] v *= x; } coeff *= f; function[n] = coeff * v; } }  [BUGGY] [BUGGY] compose(operand, operandOffset, function, result, resultOffset); } [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1368	1368	1	add	
70	[BUG] [BUGGY] } [FE] AssertionError [CONTEXT] coeff *= f; function[n] = coeff * v; } }  compose(operand, operandOffset, function, result, resultOffset); [BUGGY] } [BUGGY]  [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1370	1370	1	replace	
71	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] coeff *= f; function[n] = coeff * v; } }  compose(operand, operandOffset, function, result, resultOffset); [BUGGY] [BUGGY] } [CLASS] DSCompiler [METHOD] atan [RETURN_TYPE] void  final double[] operand final int operandOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand q result double coeff f v x x2 AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5	1370	1370	1	add	
72	[BUG] [BUGGY] final double[] reciprocal = new double[getSize()]; [FE] AssertionError [CONTEXT] public void divide(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) { [BUGGY] final double[] reciprocal = new double[getSize()]; [BUGGY] pow(rhs, lhsOffset, -1, reciprocal, 0); multiply(lhs, lhsOffset, reciprocal, 0, result, resultOffset); } [CLASS] DSCompiler [METHOD] divide [RETURN_TYPE] void  final double[] lhs final int lhsOffset final double[] rhs final int rhsOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] lhs reciprocal result rhs AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters o offset1 offset2 offset3 offset4 order ordersSum p parameters resultOffset rhsOffset srcP vSize  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.35355339059327373	796	796	1	replace	
73	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public void divide(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) { [BUGGY] [BUGGY] final double[] reciprocal = new double[getSize()]; pow(rhs, lhsOffset, -1, reciprocal, 0); multiply(lhs, lhsOffset, reciprocal, 0, result, resultOffset); } [CLASS] DSCompiler [METHOD] divide [RETURN_TYPE] void  final double[] lhs final int lhsOffset final double[] rhs final int rhsOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] lhs reciprocal result rhs AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters o offset1 offset2 offset3 offset4 order ordersSum p parameters resultOffset rhsOffset srcP vSize  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.35355339059327373	796	796	1	add	
74	[BUG] [BUGGY] pow(rhs, lhsOffset, -1, reciprocal, 0); [FE] AssertionError [CONTEXT] public void divide(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) { final double[] reciprocal = new double[getSize()]; [BUGGY] pow(rhs, lhsOffset, -1, reciprocal, 0); [BUGGY] multiply(lhs, lhsOffset, reciprocal, 0, result, resultOffset); } [CLASS] DSCompiler [METHOD] divide [RETURN_TYPE] void  final double[] lhs final int lhsOffset final double[] rhs final int rhsOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] lhs reciprocal result rhs AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters o offset1 offset2 offset3 offset4 order ordersSum p parameters resultOffset rhsOffset srcP vSize  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.35355339059327373	797	797	1	replace	
75	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public void divide(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) { final double[] reciprocal = new double[getSize()]; [BUGGY] [BUGGY] pow(rhs, lhsOffset, -1, reciprocal, 0); multiply(lhs, lhsOffset, reciprocal, 0, result, resultOffset); } [CLASS] DSCompiler [METHOD] divide [RETURN_TYPE] void  final double[] lhs final int lhsOffset final double[] rhs final int rhsOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] lhs reciprocal result rhs AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters o offset1 offset2 offset3 offset4 order ordersSum p parameters resultOffset rhsOffset srcP vSize  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.35355339059327373	797	797	1	add	
76	[BUG] [BUGGY] multiply(lhs, lhsOffset, reciprocal, 0, result, resultOffset); [FE] AssertionError [CONTEXT] public void divide(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) { final double[] reciprocal = new double[getSize()]; pow(rhs, lhsOffset, -1, reciprocal, 0); [BUGGY] multiply(lhs, lhsOffset, reciprocal, 0, result, resultOffset); [BUGGY] } [CLASS] DSCompiler [METHOD] divide [RETURN_TYPE] void  final double[] lhs final int lhsOffset final double[] rhs final int rhsOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] lhs reciprocal result rhs AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters o offset1 offset2 offset3 offset4 order ordersSum p parameters resultOffset rhsOffset srcP vSize  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.35355339059327373	798	798	1	replace	
77	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public void divide(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) { final double[] reciprocal = new double[getSize()]; pow(rhs, lhsOffset, -1, reciprocal, 0); [BUGGY] [BUGGY] multiply(lhs, lhsOffset, reciprocal, 0, result, resultOffset); } [CLASS] DSCompiler [METHOD] divide [RETURN_TYPE] void  final double[] lhs final int lhsOffset final double[] rhs final int rhsOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] lhs reciprocal result rhs AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters o offset1 offset2 offset3 offset4 order ordersSum p parameters resultOffset rhsOffset srcP vSize  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.35355339059327373	798	798	1	add	
78	[BUG] [BUGGY] } [FE] AssertionError [CONTEXT] public void divide(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) { final double[] reciprocal = new double[getSize()]; pow(rhs, lhsOffset, -1, reciprocal, 0); multiply(lhs, lhsOffset, reciprocal, 0, result, resultOffset); [BUGGY] } [BUGGY]  [CLASS] DSCompiler [METHOD] divide [RETURN_TYPE] void  final double[] lhs final int lhsOffset final double[] rhs final int rhsOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] lhs reciprocal result rhs AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters o offset1 offset2 offset3 offset4 order ordersSum p parameters resultOffset rhsOffset srcP vSize  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.35355339059327373	799	799	1	replace	
79	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] public void divide(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) { final double[] reciprocal = new double[getSize()]; pow(rhs, lhsOffset, -1, reciprocal, 0); multiply(lhs, lhsOffset, reciprocal, 0, result, resultOffset); [BUGGY] [BUGGY] } [CLASS] DSCompiler [METHOD] divide [RETURN_TYPE] void  final double[] lhs final int lhsOffset final double[] rhs final int rhsOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] lhs reciprocal result rhs AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters o offset1 offset2 offset3 offset4 order ordersSum p parameters resultOffset rhsOffset srcP vSize  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.35355339059327373	799	799	1	add	
80	[BUG] [BUGGY] function[0] = FastMath.sqrt(operand[operandOffset]); [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {   double[] function = new double[1 + order]; double xk; if (n == 2) { [BUGGY] function[0] = FastMath.sqrt(operand[operandOffset]); [BUGGY] xk= 0.5 / function[0]; } else if (n == 3) { function[0] = FastMath.cbrt(operand[operandOffset]); xk= 1.0 / (3.0 * function[0] * function[0]); } else { function[0] = FastMath.pow(operand[operandOffset], 1.0 / n); xk= 1.0 / (n * FastMath.pow(function[0], n - 1)); } final double nReciprocal = 1.0 / n; final double xReciprocal = 1.0 / operand[operandOffset]; [CLASS] DSCompiler [METHOD] rootN [RETURN_TYPE] void  final double[] operand final int operandOffset final int n final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand result double nReciprocal xReciprocal xk AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.31622776601683794	950	950	1	replace	
81	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {   double[] function = new double[1 + order]; double xk; if (n == 2) { [BUGGY] [BUGGY] function[0] = FastMath.sqrt(operand[operandOffset]); xk= 0.5 / function[0]; } else if (n == 3) { function[0] = FastMath.cbrt(operand[operandOffset]); xk= 1.0 / (3.0 * function[0] * function[0]); } else { function[0] = FastMath.pow(operand[operandOffset], 1.0 / n); xk= 1.0 / (n * FastMath.pow(function[0], n - 1)); } final double nReciprocal = 1.0 / n; final double xReciprocal = 1.0 / operand[operandOffset]; [CLASS] DSCompiler [METHOD] rootN [RETURN_TYPE] void  final double[] operand final int operandOffset final int n final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand result double nReciprocal xReciprocal xk AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.31622776601683794	950	950	1	add	
82	[BUG] [BUGGY] xk= 0.5 / function[0]; [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {   double[] function = new double[1 + order]; double xk; if (n == 2) { function[0] = FastMath.sqrt(operand[operandOffset]); [BUGGY] xk= 0.5 / function[0]; [BUGGY] } else if (n == 3) { function[0] = FastMath.cbrt(operand[operandOffset]); xk= 1.0 / (3.0 * function[0] * function[0]); } else { function[0] = FastMath.pow(operand[operandOffset], 1.0 / n); xk= 1.0 / (n * FastMath.pow(function[0], n - 1)); } final double nReciprocal = 1.0 / n; final double xReciprocal = 1.0 / operand[operandOffset]; for (int i = 1; i <= order; ++i) { [CLASS] DSCompiler [METHOD] rootN [RETURN_TYPE] void  final double[] operand final int operandOffset final int n final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand result double nReciprocal xReciprocal xk AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.31622776601683794	951	951	1	replace	
83	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {   double[] function = new double[1 + order]; double xk; if (n == 2) { function[0] = FastMath.sqrt(operand[operandOffset]); [BUGGY] [BUGGY] xk= 0.5 / function[0]; } else if (n == 3) { function[0] = FastMath.cbrt(operand[operandOffset]); xk= 1.0 / (3.0 * function[0] * function[0]); } else { function[0] = FastMath.pow(operand[operandOffset], 1.0 / n); xk= 1.0 / (n * FastMath.pow(function[0], n - 1)); } final double nReciprocal = 1.0 / n; final double xReciprocal = 1.0 / operand[operandOffset]; for (int i = 1; i <= order; ++i) { [CLASS] DSCompiler [METHOD] rootN [RETURN_TYPE] void  final double[] operand final int operandOffset final int n final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand result double nReciprocal xReciprocal xk AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.31622776601683794	951	951	1	add	
84	[BUG] [BUGGY] final double inv = 1.0 / operand[operandOffset]; [FE] AssertionError [CONTEXT]  final int maxOrder = FastMath.min(order, n); double xk = FastMath.pow(operand[operandOffset], n - maxOrder); for (int i = maxOrder; i > 0; --i) { function[i] = xk; xk *= operand[operandOffset]; } function[0] = xk; } else {  [BUGGY] final double inv = 1.0 / operand[operandOffset]; [BUGGY] double xk = FastMath.pow(inv, -n); for (int i = 0; i <= order; ++i) { function[i] = xk; xk *= inv; } } [CLASS] DSCompiler [METHOD] pow [RETURN_TYPE] void  final double[] operand final int operandOffset final int n final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand result double coefficient inv xk AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.2886751345948129	894	894	1	replace	
85	[BUG] [BUGGY] [FE] AssertionError [CONTEXT]  final int maxOrder = FastMath.min(order, n); double xk = FastMath.pow(operand[operandOffset], n - maxOrder); for (int i = maxOrder; i > 0; --i) { function[i] = xk; xk *= operand[operandOffset]; } function[0] = xk; } else {  [BUGGY] [BUGGY] final double inv = 1.0 / operand[operandOffset]; double xk = FastMath.pow(inv, -n); for (int i = 0; i <= order; ++i) { function[i] = xk; xk *= inv; } } [CLASS] DSCompiler [METHOD] pow [RETURN_TYPE] void  final double[] operand final int operandOffset final int n final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand result double coefficient inv xk AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.2886751345948129	894	894	1	add	
86	[BUG] [BUGGY] double xk = FastMath.pow(inv, -n); [FE] AssertionError [CONTEXT] final int maxOrder = FastMath.min(order, n); double xk = FastMath.pow(operand[operandOffset], n - maxOrder); for (int i = maxOrder; i > 0; --i) { function[i] = xk; xk *= operand[operandOffset]; } function[0] = xk; } else {  final double inv = 1.0 / operand[operandOffset]; [BUGGY] double xk = FastMath.pow(inv, -n); [BUGGY] for (int i = 0; i <= order; ++i) { function[i] = xk; xk *= inv; } } [CLASS] DSCompiler [METHOD] pow [RETURN_TYPE] void  final double[] operand final int operandOffset final int n final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand result double coefficient inv xk AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.2886751345948129	895	895	1	replace	
87	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] final int maxOrder = FastMath.min(order, n); double xk = FastMath.pow(operand[operandOffset], n - maxOrder); for (int i = maxOrder; i > 0; --i) { function[i] = xk; xk *= operand[operandOffset]; } function[0] = xk; } else {  final double inv = 1.0 / operand[operandOffset]; [BUGGY] [BUGGY] double xk = FastMath.pow(inv, -n); for (int i = 0; i <= order; ++i) { function[i] = xk; xk *= inv; } } [CLASS] DSCompiler [METHOD] pow [RETURN_TYPE] void  final double[] operand final int operandOffset final int n final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand result double coefficient inv xk AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.2886751345948129	895	895	1	add	
88	[BUG] [BUGGY] for (int i = 0; i <= order; ++i) { [FE] AssertionError [CONTEXT] double xk = FastMath.pow(operand[operandOffset], n - maxOrder); for (int i = maxOrder; i > 0; --i) { function[i] = xk; xk *= operand[operandOffset]; } function[0] = xk; } else {  final double inv = 1.0 / operand[operandOffset]; double xk = FastMath.pow(inv, -n); [BUGGY] for (int i = 0; i <= order; ++i) { [BUGGY] function[i] = xk; xk *= inv; } } [CLASS] DSCompiler [METHOD] pow [RETURN_TYPE] void  final double[] operand final int operandOffset final int n final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand result double coefficient inv xk AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.2886751345948129	896	896	1	replace	
89	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] double xk = FastMath.pow(operand[operandOffset], n - maxOrder); for (int i = maxOrder; i > 0; --i) { function[i] = xk; xk *= operand[operandOffset]; } function[0] = xk; } else {  final double inv = 1.0 / operand[operandOffset]; double xk = FastMath.pow(inv, -n); [BUGGY] [BUGGY] for (int i = 0; i <= order; ++i) { function[i] = xk; xk *= inv; } } [CLASS] DSCompiler [METHOD] pow [RETURN_TYPE] void  final double[] operand final int operandOffset final int n final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand result double coefficient inv xk AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.2886751345948129	896	896	1	add	
90	[BUG] [BUGGY] function[i] = xk; [FE] AssertionError [CONTEXT] for (int i = maxOrder; i > 0; --i) { function[i] = xk; xk *= operand[operandOffset]; } function[0] = xk; } else {  final double inv = 1.0 / operand[operandOffset]; double xk = FastMath.pow(inv, -n); for (int i = 0; i <= order; ++i) { [BUGGY] function[i] = xk; [BUGGY] xk *= inv; } } [CLASS] DSCompiler [METHOD] pow [RETURN_TYPE] void  final double[] operand final int operandOffset final int n final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand result double coefficient inv xk AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.2886751345948129	897	897	1	replace	
91	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] for (int i = maxOrder; i > 0; --i) { function[i] = xk; xk *= operand[operandOffset]; } function[0] = xk; } else {  final double inv = 1.0 / operand[operandOffset]; double xk = FastMath.pow(inv, -n); for (int i = 0; i <= order; ++i) { [BUGGY] [BUGGY] function[i] = xk; xk *= inv; } } [CLASS] DSCompiler [METHOD] pow [RETURN_TYPE] void  final double[] operand final int operandOffset final int n final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand result double coefficient inv xk AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.2886751345948129	897	897	1	add	
92	[BUG] [BUGGY] xk *= inv; [FE] AssertionError [CONTEXT] function[i] = xk; xk *= operand[operandOffset]; } function[0] = xk; } else {  final double inv = 1.0 / operand[operandOffset]; double xk = FastMath.pow(inv, -n); for (int i = 0; i <= order; ++i) { function[i] = xk; [BUGGY] xk *= inv; [BUGGY] } } [CLASS] DSCompiler [METHOD] pow [RETURN_TYPE] void  final double[] operand final int operandOffset final int n final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand result double coefficient inv xk AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.2886751345948129	898	898	1	replace	
93	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] function[i] = xk; xk *= operand[operandOffset]; } function[0] = xk; } else {  final double inv = 1.0 / operand[operandOffset]; double xk = FastMath.pow(inv, -n); for (int i = 0; i <= order; ++i) { function[i] = xk; [BUGGY] [BUGGY] xk *= inv; } } [CLASS] DSCompiler [METHOD] pow [RETURN_TYPE] void  final double[] operand final int operandOffset final int n final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand result double coefficient inv xk AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.2886751345948129	898	898	1	add	
94	[BUG] [BUGGY] double[] function = new double[1 + order]; [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {   [BUGGY] double[] function = new double[1 + order]; [BUGGY] double xk; if (n == 2) { function[0] = FastMath.sqrt(operand[operandOffset]); xk= 0.5 / function[0]; } else if (n == 3) { function[0] = FastMath.cbrt(operand[operandOffset]); xk= 1.0 / (3.0 * function[0] * function[0]); } else { function[0] = FastMath.pow(operand[operandOffset], 1.0 / n); xk= 1.0 / (n * FastMath.pow(function[0], n - 1)); [CLASS] DSCompiler [METHOD] rootN [RETURN_TYPE] void  final double[] operand final int operandOffset final int n final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand result double nReciprocal xReciprocal xk AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.2886751345948129	947	947	1	replace	
95	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {   [BUGGY] [BUGGY] double[] function = new double[1 + order]; double xk; if (n == 2) { function[0] = FastMath.sqrt(operand[operandOffset]); xk= 0.5 / function[0]; } else if (n == 3) { function[0] = FastMath.cbrt(operand[operandOffset]); xk= 1.0 / (3.0 * function[0] * function[0]); } else { function[0] = FastMath.pow(operand[operandOffset], 1.0 / n); xk= 1.0 / (n * FastMath.pow(function[0], n - 1)); [CLASS] DSCompiler [METHOD] rootN [RETURN_TYPE] void  final double[] operand final int operandOffset final int n final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand result double nReciprocal xReciprocal xk AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.2886751345948129	947	947	1	add	
96	[BUG] [BUGGY] if (n == 2) { [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {   double[] function = new double[1 + order]; double xk; [BUGGY] if (n == 2) { [BUGGY] function[0] = FastMath.sqrt(operand[operandOffset]); xk= 0.5 / function[0]; } else if (n == 3) { function[0] = FastMath.cbrt(operand[operandOffset]); xk= 1.0 / (3.0 * function[0] * function[0]); } else { function[0] = FastMath.pow(operand[operandOffset], 1.0 / n); xk= 1.0 / (n * FastMath.pow(function[0], n - 1)); } final double nReciprocal = 1.0 / n; [CLASS] DSCompiler [METHOD] rootN [RETURN_TYPE] void  final double[] operand final int operandOffset final int n final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand result double nReciprocal xReciprocal xk AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.2886751345948129	949	949	1	replace	
97	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {   double[] function = new double[1 + order]; double xk; [BUGGY] [BUGGY] if (n == 2) { function[0] = FastMath.sqrt(operand[operandOffset]); xk= 0.5 / function[0]; } else if (n == 3) { function[0] = FastMath.cbrt(operand[operandOffset]); xk= 1.0 / (3.0 * function[0] * function[0]); } else { function[0] = FastMath.pow(operand[operandOffset], 1.0 / n); xk= 1.0 / (n * FastMath.pow(function[0], n - 1)); } final double nReciprocal = 1.0 / n; [CLASS] DSCompiler [METHOD] rootN [RETURN_TYPE] void  final double[] operand final int operandOffset final int n final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand result double nReciprocal xReciprocal xk AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.2886751345948129	949	949	1	add	
98	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] } else if (n == 3) { function[0] = FastMath.cbrt(operand[operandOffset]); xk= 1.0 / (3.0 * function[0] * function[0]); } else { function[0] = FastMath.pow(operand[operandOffset], 1.0 / n); xk= 1.0 / (n * FastMath.pow(function[0], n - 1)); } [CLASS] DSCompiler [METHOD] rootN [RETURN_TYPE] void  final double[] operand final int operandOffset final int n final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand result double nReciprocal xReciprocal xk AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.2886751345948129	959	959	1	replace	
99	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] } else if (n == 3) { function[0] = FastMath.cbrt(operand[operandOffset]); xk= 1.0 / (3.0 * function[0] * function[0]); } else { function[0] = FastMath.pow(operand[operandOffset], 1.0 / n); xk= 1.0 / (n * FastMath.pow(function[0], n - 1)); } [CLASS] DSCompiler [METHOD] rootN [RETURN_TYPE] void  final double[] operand final int operandOffset final int n final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] function operand result double nReciprocal xReciprocal xk AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.2886751345948129	959	959	1	add	
