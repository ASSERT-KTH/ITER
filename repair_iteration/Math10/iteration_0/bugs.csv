bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] double[] tmp1 = new double[getSize()]; [FE] AssertionError testAtan2SpecialCases [CONTEXT] final double[] result, final int resultOffset) {  [BUGGY] double[] tmp1 = new double[getSize()]; [BUGGY] multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1387	1387	1	replace	
2	[BUG] [BUGGY] [FE] AssertionError testAtan2SpecialCases [CONTEXT] final double[] result, final int resultOffset) {  [BUGGY] [BUGGY] double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1387	1387	1	add	
3	[BUG] [BUGGY] multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; [FE] AssertionError testAtan2SpecialCases [CONTEXT] final double[] result, final int resultOffset) {  double[] tmp1 = new double[getSize()]; [BUGGY] multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2  double[] tmp2 = new double[getSize()]; [BUGGY] double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1388	1389	1	replace	
4	[BUG] [BUGGY] [FE] AssertionError testAtan2SpecialCases [CONTEXT] final double[] result, final int resultOffset) {  double[] tmp1 = new double[getSize()]; [BUGGY] [BUGGY] multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2  double[] tmp2 = new double[getSize()]; double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1388	1389	1	add	
5	[BUG] [BUGGY] double[] tmp2 = new double[getSize()]; [FE] AssertionError testAtan2SpecialCases [CONTEXT] final double[] result, final int resultOffset) {  double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 [BUGGY] double[] tmp2 = new double[getSize()]; [BUGGY] multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1389	1389	1	replace	
6	[BUG] [BUGGY] [FE] AssertionError testAtan2SpecialCases [CONTEXT] final double[] result, final int resultOffset) {  double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 [BUGGY] [BUGGY] double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1389	1389	1	add	
7	[BUG] [BUGGY] multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0);  // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0);   // r = sqrt(x^2 + y^2) [FE] AssertionError testAtan2SpecialCases [CONTEXT] final double[] result, final int resultOffset) {  double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; [BUGGY] multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2  add(tmp1, 0, tmp2, 0, tmp2, 0);     // x^2 + y^2    rootN(tmp2, 0, 2, tmp1, 0);           // r = sqrt(x^2 + y^2) [BUGGY] add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1390	1392	1	replace	
8	[BUG] [BUGGY] [FE] AssertionError testAtan2SpecialCases [CONTEXT] final double[] result, final int resultOffset) {  double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; [BUGGY] [BUGGY] multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2  add(tmp1, 0, tmp2, 0, tmp2, 0);     // x^2 + y^2    rootN(tmp2, 0, 2, tmp1, 0);           // r = sqrt(x^2 + y^2) add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1390	1392	1	add	
9	[BUG] [BUGGY] add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0);  // r = sqrt(x^2 + y^2) [FE] AssertionError testAtan2SpecialCases [CONTEXT] final double[] result, final int resultOffset) {  double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 [BUGGY] add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2  rootN(tmp2, 0, 2, tmp1, 0);      // r = sqrt(x^2 + y^2) [BUGGY] rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1391	1393	1	replace	
10	[BUG] [BUGGY] [FE] AssertionError testAtan2SpecialCases [CONTEXT] final double[] result, final int resultOffset) {  double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 [BUGGY] [BUGGY] add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2  rootN(tmp2, 0, 2, tmp1, 0);      // r = sqrt(x^2 + y^2) rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1391	1393	1	add	
11	[BUG] [BUGGY] rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) { [FE] AssertionError testAtan2SpecialCases [CONTEXT] final double[] result, final int resultOffset) {  double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 [BUGGY] rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2)    if (x[xOffset] >= 0) { [BUGGY]  if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) } [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1392	1394	1	replace	
12	[BUG] [BUGGY] [FE] AssertionError testAtan2SpecialCases [CONTEXT] final double[] result, final int resultOffset) {  double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 [BUGGY] [BUGGY] rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2)    if (x[xOffset] >= 0) { if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) } [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1392	1394	1	add	
13	[BUG] [BUGGY] if (x[xOffset] >= 0) { [FE] AssertionError testAtan2SpecialCases [CONTEXT] final double[] result, final int resultOffset) {  double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) [BUGGY] if (x[xOffset] >= 0) { [BUGGY]   add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) } } else { [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1394	1394	1	replace	
14	[BUG] [BUGGY] [FE] AssertionError testAtan2SpecialCases [CONTEXT] final double[] result, final int resultOffset) {  double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) [BUGGY] [BUGGY] if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) } } else { [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1394	1394	1	add	
15	[BUG] [BUGGY] add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x)  atan(tmp1, 0, tmp2, 0);   // atan(y / (r + x)) [FE] AssertionError testAtan2SpecialCases [CONTEXT] double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  [BUGGY] add(tmp1, 0, x, xOffset, tmp2, 0);// r + x   divide(y, yOffset, tmp2, 0, tmp1, 0);  // y /(r + x)      atan(tmp1, 0, tmp2, 0);           // atan(y / (r + x)) [BUGGY] divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) } } else {  subtract(tmp1, 0, x, xOffset, tmp2, 0); // r - x [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1397	1399	1	replace	
16	[BUG] [BUGGY] [FE] AssertionError testAtan2SpecialCases [CONTEXT] double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  [BUGGY] [BUGGY] add(tmp1, 0, x, xOffset, tmp2, 0);// r + x   divide(y, yOffset, tmp2, 0, tmp1, 0);  // y /(r + x)      atan(tmp1, 0, tmp2, 0);           // atan(y / (r + x)) divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) } } else {  subtract(tmp1, 0, x, xOffset, tmp2, 0); // r - x [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1397	1399	1	add	
17	[BUG] [BUGGY] divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0);  // atan(y / (r + x))  for (int i = 0; i < tmp2.length; ++i) { [FE] AssertionError testAtan2SpecialCases [CONTEXT] multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x [BUGGY] divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x)   atan(tmp1, 0, tmp2, 0);      // atan(y / (r + x))      for (int i = 0; i < tmp2.length; ++i) { [BUGGY] atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) } } else {  subtract(tmp1, 0, x, xOffset, tmp2, 0); // r - x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r - x) [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1398	1400	1	replace	
18	[BUG] [BUGGY] [FE] AssertionError testAtan2SpecialCases [CONTEXT] multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x [BUGGY] [BUGGY] divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x)   atan(tmp1, 0, tmp2, 0);      // atan(y / (r + x))      for (int i = 0; i < tmp2.length; ++i) { atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) } } else {  subtract(tmp1, 0, x, xOffset, tmp2, 0); // r - x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r - x) [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1398	1400	1	add	
19	[BUG] [BUGGY] atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { [FE] AssertionError testAtan2SpecialCases [CONTEXT] double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) [BUGGY] atan(tmp1, 0, tmp2, 0); // atan(y / (r + x))   for (int i = 0; i < tmp2.length; ++i) { [BUGGY] for (int i = 0; i < tmp2.length; ++i) { result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) } } else {  subtract(tmp1, 0, x, xOffset, tmp2, 0); // r - x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r - x) atan(tmp1, 0, tmp2, 0); // atan(y / (r - x)) [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1399	1400	1	replace	
20	[BUG] [BUGGY] [FE] AssertionError testAtan2SpecialCases [CONTEXT] double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) [BUGGY] [BUGGY] atan(tmp1, 0, tmp2, 0); // atan(y / (r + x))   for (int i = 0; i < tmp2.length; ++i) { for (int i = 0; i < tmp2.length; ++i) { result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) } } else {  subtract(tmp1, 0, x, xOffset, tmp2, 0); // r - x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r - x) atan(tmp1, 0, tmp2, 0); // atan(y / (r - x)) [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1399	1400	1	add	
