bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
11	[BUG] [BUGGY] rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2) if (x[xOffset] >= 0) { [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {  double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 [BUGGY] rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2)    if (x[xOffset] >= 0) { [BUGGY]  if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) } [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1392	1394	1	replace	
12	[BUG] [BUGGY] [FE] AssertionError [CONTEXT] final double[] result, final int resultOffset) {  double[] tmp1 = new double[getSize()]; multiply(x, xOffset, x, xOffset, tmp1, 0);// x^2 double[] tmp2 = new double[getSize()]; multiply(y, yOffset, y, yOffset, tmp2, 0);// y^2 add(tmp1, 0, tmp2, 0, tmp2, 0); // x^2 + y^2 [BUGGY] [BUGGY] rootN(tmp2, 0, 2, tmp1, 0); // r = sqrt(x^2 + y^2)    if (x[xOffset] >= 0) { if (x[xOffset] >= 0) {  add(tmp1, 0, x, xOffset, tmp2, 0);// r + x divide(y, yOffset, tmp2, 0, tmp1, 0); // y /(r + x) atan(tmp1, 0, tmp2, 0); // atan(y / (r + x)) for (int i = 0; i < tmp2.length; ++i) { result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x)) } [CLASS] DSCompiler [METHOD] atan2 [RETURN_TYPE] void  final double[] y final int yOffset final double[] x final int xOffset final double[] result final int resultOffset [VARIABLES] int[][][] compIndirection multIndirection int[][] dRow derivativesIndirection destSizes mappingI sizes srcDerivativesIndirection boolean double[] result tmp1 tmp2 x y AtomicReference compilers int[] derivedTermF derivedTermG lowerIndirection orders term termJ termK int dSize derivativeOrder destO destP diag i index j k l lhsOffset m maxOrder maxParameters n o offset1 offset2 offset3 offset4 operandOffset order ordersSum p parameters resultOffset rhsOffset srcP vSize xOffset yOffset  	projects/Math10/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java	0.5773502691896258	1392	1394	1	add	
