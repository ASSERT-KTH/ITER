bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	19	6	replace
2	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	19	6	replace
3	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	19	6	replace
4	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  AssertionFailedError  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	19	6	replace
5	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	19	6	replace
6	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	19	6	replace
7	[BUG]  [BUGGY]  Node  c  =  tryBlock.next();  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.next();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock.next();	  Node    c    =    tryBlock.cloneTree();    	non-compiled	[CE]  cannot  find  symbol	190	None	replace
8	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);	  Preconditions.checkArgument(tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	166	6	replace
9	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);	  Preconditions.checkArgument(tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	166	6	replace
10	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkArgument(tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	166	6	replace
11	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkArgument(tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	166	6	replace
12	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkArgument(tryBlock.getType()!=  Token.EXPR_RESULT);	  Preconditions.checkArgument(tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	166	6	replace
13	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()!=  Token.EXPR_RESULT);  [FE]  AssertionFailedError  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()!=  Token.EXPR_RESULT);	  Preconditions.checkArgument(tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	166	6	replace
14	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(n.getType()!=  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	74	6	replace
15	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.EXPR_RESULT);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()!=  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	74	6	replace
16	[BUG]  [BUGGY]  Preconditions.checkState(tries.getType()!=  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  tries  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tries.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tries.getType()!=  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    	non-compiled	[CE]  cannot  find  symbol  tries	74	None	replace
17	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(exitType!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(exitType!=  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	74	6	replace
18	[BUG]  [BUGGY]  Preconditions.checkState(exitType!=  Token.EXPR_RESULT);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(exitType!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(exitType!=  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	74	6	replace
19	[BUG]  [BUGGY]  Node  escapeType  =  n.getEscapedChild();  [CE]  cannot  find  symbol  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  n.getEscapedChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  n.getEscapedChild();	  Node    escapeType    =    tryBlock.getEscapedChild();    	non-compiled	[CE]  cannot  find  symbol	28	None	replace
20	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getSecondChild();  [CE]  cannot  find  symbol  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getSecondChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getSecondChild();	  Node    escapeType    =    tryBlock.getEscapedChild();    	non-compiled	[CE]  cannot  find  symbol	28	None	replace
21	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getEscapedChild(),  labelName;  [CE]  cannot  find  symbol  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getEscapedChild(),  labelName;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getEscapedChild(),  labelName;	  Node    escapeType    =    tryBlock.getEscapedChild();    	non-compiled	[CE]  cannot  find  symbol	28	None	replace
22	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  null  :  tryBlock.getFalse();  [CE]  cannot  find  symbol  [FE]        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  null  :  tryBlock.getFalse();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  null  :  tryBlock.getFalse();	  Node    escapeType    =    tryBlock.getFalse();    	non-compiled	[CE]  cannot  find  symbol	27	None	replace
23	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getFalse(),  labelName;  [CE]  cannot  find  symbol  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getFalse(),  labelName;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getFalse(),  labelName;	  Node    escapeType    =    tryBlock.getFalse();    	non-compiled	[CE]  cannot  find  symbol	27	None	replace
24	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock  ==  null?  null  :  tryBlock.getFalse();  [CE]  cannot  find  symbol  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock  ==  null?  null  :  tryBlock.getFalse();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock  ==  null?  null  :  tryBlock.getFalse();	  Node    escapeType    =    tryBlock.getFalse();    	non-compiled	[CE]  cannot  find  symbol	27	None	replace
25	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getFalse()  :  null;  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getFalse()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getFalse()  :  null;	  Node    escapeType    =    tryBlock.getFalse();    	non-compiled	[CE]  ';'  expected	27	None	replace
26	[BUG]  [BUGGY]  NodeUtil.checkState(tryBlock.getType()  ==  Token.CATCH);  [CE]  cannot  find  symbol  [FE]              RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  NodeUtil.checkState(tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	NodeUtil.checkState(tryBlock.getType()  ==  Token.CATCH);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    NodeUtil.checkState(tryBlock.getType()    ==    Token.CATCH);    	non-compiled	[CE]  cannot  find  symbol	93	None	replace
27	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CATCH);  NodeUtil.checkState(tryBlock.getType()  ==  Token.CATCH);  [CE]  cannot  find  symbol  [FE]                RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CATCH);  NodeUtil.checkState(tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()  ==  Token.CATCH);  NodeUtil.checkState(tryBlock.getType()  ==  Token.CATCH);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    NodeUtil.checkState(tryBlock.getType()    ==    Token.CATCH);    	non-compiled	[CE]  cannot  find  symbol	93	None	replace
28	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  NodeUtil.checkState(tryBlock.getType()  ==  Token.CATCH);  [CE]  cannot  find  symbol  [FE]                  RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  NodeUtil.checkState(tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  NodeUtil.checkState(tryBlock.getType()  ==  Token.CATCH);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    NodeUtil.checkState(tryBlock.getType()    ==    Token.CATCH);    	non-compiled	[CE]  cannot  find  symbol	93	None	replace
29	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  NodeUtil.checkState(n.getType()  ==  Token.CATCH);  [CE]  cannot  find  symbol  [FE]                    RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  NodeUtil.checkState(n.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  NodeUtil.checkState(n.getType()  ==  Token.CATCH);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    NodeUtil.checkState(tryBlock.getType()    ==    Token.CATCH);    	non-compiled	[CE]  cannot  find  symbol	93	None	replace
30	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	75	6	add
31	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	75	6	add
32	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	75	6	add
33	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	75	6	add
34	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  NodeUtil.isExpressionNode(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  NodeUtil.isExpressionNode(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    NodeUtil.isExpressionNode(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	non-compiled	[CE]  cannot  find  symbol	75	None	add
35	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	75	6	add
36	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	75	6	add
37	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	non-compiled	[CE]  cannot  find  symbol	75	None	add
38	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]              RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	75	6	add
39	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  >=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]              RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	75	6	add
40	[BUG]  [BUGGY]  Node  labelName  =  tryBlock.getLabel();  [CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  tryBlock.getLabel();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  tryBlock.getLabel();	  Node    labelName    =    tryBlock.getLabelName();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	23	None	replace
41	[BUG]  [BUGGY]  Node  labelName  =  tryBlock.getLabelName()  +  1;  [CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  tryBlock.getLabelName()  +  1;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  tryBlock.getLabelName()  +  1;	  Node    labelName    =    tryBlock.getLabelName();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	23	None	replace
42	[BUG]  [BUGGY]  Node  labelName  =  tryBlock.getLabelName(),  exitType);  [CE]  ';'  expected  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  tryBlock.getLabelName(),  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  tryBlock.getLabelName(),  exitType);	  Node    labelName    =    tryBlock.getLabelName();    	non-compiled	[CE]  ';'  expected	23	None	replace
43	[BUG]  [BUGGY]  Node  labelName  =  tryBlock.getLabelName()  + ": ";  [CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                      AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  tryBlock.getLabelName()  + ": ";  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  tryBlock.getLabelName()  + ": ";	  Node    labelName    =    tryBlock.getLabelName();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	23	None	replace
44	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	63	6	add
45	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	63	6	add
46	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	63	6	add
47	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	63	6	add
48	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	63	6	add
49	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	63	6	add
50	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [CE]  cannot  find  symbol  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);	  	non-compiled	[CE]  cannot  find  symbol	63	None	add
51	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	63	6	add
52	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  [FE]  RuntimeException  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	63	6	add
53	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >>  Token.FUNCTION);  [CE]  no  suitable  method  found  for  checkState(int)  [FE]              RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >>  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >>  Token.FUNCTION);	  	non-compiled	[CE]  no  suitable  method  found  for  checkState(int)	63	None	add
54	[BUG]  [BUGGY]  NodeUtil.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [CE]  cannot  find  symbol  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  NodeUtil.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	NodeUtil.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    	non-compiled	[CE]  cannot  find  symbol	89	None	replace
55	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CATCH);  Preconditions.checkState(n.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(n.getType()  ==  Token.CATCH);  Preconditions.checkState(n.getType()  ==  Token.CATCH);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    	compilable	  [FE]  RuntimeException  	89	6	replace
56	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CATCH);  Preconditions.checkState(n.getType()  ==  Token.CATCH);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CATCH);  Preconditions.checkState(n.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()  ==  Token.CATCH);  Preconditions.checkState(n.getType()  ==  Token.CATCH);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    	compilable	  [FE]  RuntimeException  	89	6	replace
57	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	64	6	replace
58	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	64	6	replace
59	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	64	6	replace
60	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	64	6	replace
61	[BUG]  [BUGGY]  tryMinimizeExits(labelName,  n,  exitType,  labelName);  [CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(labelName,  n,  exitType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(labelName,  n,  exitType,  labelName);	  tryMinimizeExits(labelName,    n,    exitType,    exitType);    	non-compiled	[CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;	84	None	replace
62	[BUG]  [BUGGY]  tryMinimizeExits(labelName,  n,  exitType,  falseBlock);  [CE]  cannot  find  symbol  falseBlock  [FE]                      AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(labelName,  n,  exitType,  falseBlock);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(labelName,  n,  exitType,  falseBlock);	  tryMinimizeExits(labelName,    n,    exitType,    exitType);    	non-compiled	[CE]  cannot  find  symbol  falseBlock	84	None	replace
63	[BUG]  [BUGGY]  tryMinimizeExits(labelName,  null,  exitType,  exitType);  [CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;  [FE]                        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(labelName,  null,  exitType,  exitType);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(labelName,  null,  exitType,  exitType);	  tryMinimizeExits(labelName,    n,    exitType,    exitType);    	non-compiled	[CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;	84	None	replace
64	[BUG]  [BUGGY]  tryMinimizeExits(labelName,  node,  exitType,  exitType);  [CE]  cannot  find  symbol  node  [FE]                          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(labelName,  node,  exitType,  exitType);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(labelName,  node,  exitType,  exitType);	  tryMinimizeExits(labelName,    n,    exitType,    exitType);    	non-compiled	[CE]  cannot  find  symbol  node	84	None	replace
65	[BUG]  [BUGGY]  Preconditions.checkState(tries.getType()  ==  Token.CATCH);  [CE]  cannot  find  symbol  tries  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tries.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tries.getType()  ==  Token.CATCH);	  Preconditions.checkState(n.getType()    ==    Token.CATCH);    	non-compiled	[CE]  cannot  find  symbol  tries	113	None	replace
66	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	33	6	replace
67	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	33	6	replace
68	[BUG]  [BUGGY]  NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  cannot  find  symbol	33	None	replace
69	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	33	6	replace
70	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	33	6	replace
71	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  &&  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  &&  tryBlock.getType()!=  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	21	6	replace
72	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  &&  tryBlock.getType()!=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  &&  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  &&  tryBlock.getType()!=  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	21	6	replace
73	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	21	6	replace
74	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	21	6	replace
75	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(n.getType()!=  Token.FUNCTION);	  Preconditions.checkState(tryBlock.getType()!=    Token.FUNCTION);    	compilable	  [FE]  AssertionFailedError  	17	6	replace
76	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()!=  Token.FUNCTION);	  Preconditions.checkState(tryBlock.getType()!=    Token.FUNCTION);    	compilable	  [FE]  AssertionFailedError  	17	6	replace
77	[BUG]  [BUGGY]  Preconditions.checkState(tries.getType()!=  Token.FUNCTION);  [CE]  cannot  find  symbol  tries  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tries.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tries.getType()!=  Token.FUNCTION);	  Preconditions.checkState(tryBlock.getType()!=    Token.FUNCTION);    	non-compiled	[CE]  cannot  find  symbol  tries	17	None	replace
78	[BUG]  [BUGGY]  Preconditions.checkState(exitType.getType()  ==  Token.EXPR_RESULT);  [CE]  int  cannot  be  dereferenced  [FE]            RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(exitType.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(exitType.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(triesBlock.getType()    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  int  cannot  be  dereferenced	140	None	replace
79	[BUG]  [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnsType  =  tryBlock.getNext();  Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  tryBlock.getNext();  [CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnsType  =  tryBlock.getNext();  Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        returnType        =        tryBlock.getNext();        Node    returnsType    =    tryBlock.getNext();    Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  tryBlock.getNext();	  	non-compiled	[CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	121	None	add
80	[BUG]  [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnsType  =  tryBlock.getNext();  Node  returnedType  =  tryBlock.getNext();  Node  returnsType  =  tryBlock.getNext();  [CE]  variable  returnsType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnsType  =  tryBlock.getNext();  Node  returnedType  =  tryBlock.getNext();  Node  returnsType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        returnType        =        tryBlock.getNext();        Node    returnsType    =    tryBlock.getNext();    Node  returnedType  =  tryBlock.getNext();  Node  returnsType  =  tryBlock.getNext();	  	non-compiled	[CE]  variable  returnsType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	121	None	add
81	[BUG]  [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnsType  =  tryBlock.getNext();  Node  exitType  =  tryBlock.getNext();  Node  returnsType  =  tryBlock.getNext();  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnsType  =  tryBlock.getNext();  Node  exitType  =  tryBlock.getNext();  Node  returnsType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        returnType        =        tryBlock.getNext();        Node    returnsType    =    tryBlock.getNext();    Node  exitType  =  tryBlock.getNext();  Node  returnsType  =  tryBlock.getNext();	  	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	121	None	add
82	[BUG]  [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnsType  =  tryBlock.getNext();  Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  tryBlock.getNext();  [CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnsType  =  tryBlock.getNext();  Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        returnType        =        tryBlock.getNext();        Node    returnsType    =    tryBlock.getNext();    Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  tryBlock.getNext();	  	non-compiled	[CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	121	None	add
83	[BUG]  [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnsType  =  tryBlock.getNext();  node  =  tryBlock.getNext();  Node  returnsType  =  tryBlock.getNext();  [CE]  cannot  find  symbol  node  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnsType  =  tryBlock.getNext();  node  =  tryBlock.getNext();  Node  returnsType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        returnType        =        tryBlock.getNext();        Node    returnsType    =    tryBlock.getNext();    node  =  tryBlock.getNext();  Node  returnsType  =  tryBlock.getNext();	  	non-compiled	[CE]  cannot  find  symbol  node	121	None	add
84	[BUG]  [BUGGY]  tryMinimizeExits(catchNodes,  exitType,  labelName,  falseBlock);  [CE]  cannot  find  symbol  catchNodes  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(catchNodes,  exitType,  labelName,  falseBlock);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(catchNodes,  exitType,  labelName,  falseBlock);	  tryMinimizeExits(catchNodes,    exitType,    labelName,    escapeType);    	non-compiled	[CE]  cannot  find  symbol  catchNodes	168	None	replace
85	[BUG]  [BUGGY]  tryMinimizeExits(catchNodes,  exitType,  labelName,  null);  [CE]  cannot  find  symbol  catchNodes  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(catchNodes,  exitType,  labelName,  null);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(catchNodes,  exitType,  labelName,  null);	  tryMinimizeExits(catchNodes,    exitType,    labelName,    escapeType);    	non-compiled	[CE]  cannot  find  symbol  catchNodes	168	None	replace
86	[BUG]  [BUGGY]  tryMinimizeExits(catchNodes,  exitType,  labelName,  n);  [CE]  cannot  find  symbol  catchNodes  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(catchNodes,  exitType,  labelName,  n);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(catchNodes,  exitType,  labelName,  n);	  tryMinimizeExits(catchNodes,    exitType,    labelName,    escapeType);    	non-compiled	[CE]  cannot  find  symbol  catchNodes	168	None	replace
87	[BUG]  [BUGGY]  tryMinimizeExits(catchNodes,  exitType,  labelName,  trueBlock);  [CE]  cannot  find  symbol  catchNodes  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(catchNodes,  exitType,  labelName,  trueBlock);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(catchNodes,  exitType,  labelName,  trueBlock);	  tryMinimizeExits(catchNodes,    exitType,    labelName,    escapeType);    	non-compiled	[CE]  cannot  find  symbol  catchNodes	168	None	replace
88	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  Node  n  =  tryBlock.getNext();  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  [CE]  variable  n  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  Node  n  =  tryBlock.getNext();  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()    ==    Token.EXPR_RESULT);    Node  n  =  tryBlock.getNext();  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);	  	non-compiled	[CE]  variable  n  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	71	None	add
89	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(n.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(n.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(n.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	71	6	add
90	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(n.getType()!=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(n.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(n.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	71	6	add
91	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  Node  n  =  tryBlock.getFirstChild();  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  [CE]  variable  n  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  Node  n  =  tryBlock.getFirstChild();  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()    ==    Token.EXPR_RESULT);    Node  n  =  tryBlock.getFirstChild();  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);	  	non-compiled	[CE]  variable  n  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	71	None	add
92	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(n.getType()  >>  Token.EXPR_RESULT);  [CE]  no  suitable  method  found  for  checkState(int)  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(n.getType()  >>  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(n.getType()  >>  Token.EXPR_RESULT);	  	non-compiled	[CE]  no  suitable  method  found  for  checkState(int)	71	None	add
93	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(n.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(n.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(n.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	71	6	add
94	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(n.getType()  >=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(n.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(n.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	71	6	add
95	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getNext()?  null  :  tryBlock.getNext();  [CE]  incompatible  types  [FE]        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext()?  null  :  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getNext()?  null  :  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    returnType    =    tryBlock.getNext();    	non-compiled	[CE]  incompatible  types	40	None	replace
96	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getNext()  &&  tryBlock.getNext();  [CE]  bad  operand  types  for  binary  operator  '&&'  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext()  &&  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getNext()  &&  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    returnType    =    tryBlock.getNext();    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '&&'	40	None	replace
97	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getNext()  -  1;  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext()  -  1;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getNext()  -  1;	          Node    returnType    =    tryBlock.getNext();    Node    returnType    =    tryBlock.getNext();    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	40	None	replace
98	[BUG]  [BUGGY]          Node    escapeType    =    tryBlock.getNext();    Node  EscapeType  =  tryBlock.getNext();  Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  tryBlock.getNext();  [CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    escapeType    =    tryBlock.getNext();    Node  EscapeType  =  tryBlock.getNext();  Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        escapeType        =        tryBlock.getNext();        Node    EscapeType    =    tryBlock.getNext();    Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  tryBlock.getNext();	  	non-compiled	[CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	141	None	add
99	[BUG]  [BUGGY]          Node    escapeType    =    tryBlock.getNext();    Node  EscapeType  =  tryBlock.getNext();  Node  escapeType  =  tryBlock.getNext();  NodeExceptionType  =  tryBlock.getNext();  [CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    escapeType    =    tryBlock.getNext();    Node  EscapeType  =  tryBlock.getNext();  Node  escapeType  =  tryBlock.getNext();  NodeExceptionType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        escapeType        =        tryBlock.getNext();        Node    EscapeType    =    tryBlock.getNext();    Node  escapeType  =  tryBlock.getNext();  NodeExceptionType  =  tryBlock.getNext();	  	non-compiled	[CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	141	None	add
100	[BUG]  [BUGGY]          Node    escapeType    =    tryBlock.getNext();    Node  EscapeType  =  tryBlock.getNext();  Node  escapeType  =  tryBlock.getNext();  Node  ElementType  =  tryBlock.getNext();  [CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    escapeType    =    tryBlock.getNext();    Node  EscapeType  =  tryBlock.getNext();  Node  escapeType  =  tryBlock.getNext();  Node  ElementType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        escapeType        =        tryBlock.getNext();        Node    EscapeType    =    tryBlock.getNext();    Node  escapeType  =  tryBlock.getNext();  Node  ElementType  =  tryBlock.getNext();	  	non-compiled	[CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	141	None	add
101	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getParent();  Node  escapeType  =  tryBlock.getParent();  [CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getParent();  Node  escapeType  =  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    escapeType    =    tryBlock.getParent();    Node  escapeType  =  tryBlock.getParent();	  	non-compiled	[CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	29	None	add
102	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getParent();  Node  exitType  =  tryBlock.getParent();  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getParent();  Node  exitType  =  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    escapeType    =    tryBlock.getParent();    Node  exitType  =  tryBlock.getParent();	  	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	29	None	add
103	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getParent();  Node  escapeType  =  attemptBlock.getParent();  [CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getParent();  Node  escapeType  =  attemptBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    escapeType    =    tryBlock.getParent();    Node  escapeType  =  attemptBlock.getParent();	  	non-compiled	[CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	29	None	add
104	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getParent();  Node  escapeType  =  tryBlock.getNext();  [CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getParent();  Node  escapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    escapeType    =    tryBlock.getParent();    Node  escapeType  =  tryBlock.getNext();	  	non-compiled	[CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	29	None	add
105	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()!=    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	66	6	add
106	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()!=    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	66	6	add
107	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()!=    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	66	6	add
108	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()!=    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	66	6	add
109	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >>  Token.FUNCTION);  [CE]  no  suitable  method  found  for  checkState(int)  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >>  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()!=    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >>  Token.FUNCTION);	  	non-compiled	[CE]  no  suitable  method  found  for  checkState(int)	66	None	add
110	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >>  Token.FUNCTION);  [CE]  no  suitable  method  found  for  checkState(int)  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >>  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()!=    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >>  Token.FUNCTION);	  	non-compiled	[CE]  no  suitable  method  found  for  checkState(int)	66	None	add
111	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()!=    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	66	6	add
112	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [FE]  RuntimeException  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()!=    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	66	6	add
113	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]              RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()!=    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	66	6	add
114	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  [FE]  RuntimeException  [FE]              RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()!=    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	66	6	add
115	[BUG]  [BUGGY]  NodeUtil.checkState(tryBlock!=  null);  [CE]  cannot  find  symbol  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  NodeUtil.checkState(tryBlock!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	NodeUtil.checkState(tryBlock!=  null);	          Preconditions.checkState(tryBlock!=    null);    NodeUtil.checkState(tryBlock!=    null);    	non-compiled	[CE]  cannot  find  symbol	61	None	replace
116	[BUG]  [BUGGY]  Preconditions.checkState(n!=  null);  NodeUtil.checkState(tryBlock!=  null);  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n!=  null);  NodeUtil.checkState(tryBlock!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n!=  null);  NodeUtil.checkState(tryBlock!=  null);	          Preconditions.checkState(tryBlock!=    null);    NodeUtil.checkState(tryBlock!=    null);    	non-compiled	[CE]  cannot  find  symbol	61	None	replace
117	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null);  NodeUtil.checkState(tryBlock  ==  null);  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null);  NodeUtil.checkState(tryBlock  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=  null);  NodeUtil.checkState(tryBlock  ==  null);	          Preconditions.checkState(tryBlock!=    null);    NodeUtil.checkState(tryBlock!=    null);    	non-compiled	[CE]  cannot  find  symbol	61	None	replace
118	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock  ==  null);  NodeUtil.checkState(tryBlock!=  null);  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock  ==  null);  NodeUtil.checkState(tryBlock!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock  ==  null);  NodeUtil.checkState(tryBlock!=  null);	          Preconditions.checkState(tryBlock!=    null);    NodeUtil.checkState(tryBlock!=    null);    	non-compiled	[CE]  cannot  find  symbol	61	None	replace
119	[BUG]  [BUGGY]  Node  c  =  tryBlock.getFirstChild();  Node  c  =  tryBlock.getFirstChild();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getFirstChild();  Node  c  =  tryBlock.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.getFirstChild();    Node  c  =  tryBlock.getFirstChild();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	11	None	add
120	[BUG]  [BUGGY]  Node  c  =  tryBlock.getFirstChild();  Node  c  =  tryBlock.getLastChild();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getFirstChild();  Node  c  =  tryBlock.getLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.getFirstChild();    Node  c  =  tryBlock.getLastChild();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	11	None	add
121	[BUG]  [BUGGY]  Node  c  =  tryBlock.getFirstChild();  Node  c  =  attemptBlock.getFirstChild();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getFirstChild();  Node  c  =  attemptBlock.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.getFirstChild();    Node  c  =  attemptBlock.getFirstChild();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	11	None	add
122	[BUG]  [BUGGY]  Node  c  =  tryBlock.getFirstChild();  Node  c  =  startBlock.getFirstChild();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getFirstChild();  Node  c  =  startBlock.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.getFirstChild();    Node  c  =  startBlock.getFirstChild();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	11	None	add
123	[BUG]  [BUGGY]  Node  c  =  tryBlock.getFirstChild();  Node  c  =  triedBlock.getFirstChild();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getFirstChild();  Node  c  =  triedBlock.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.getFirstChild();    Node  c  =  triedBlock.getFirstChild();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	11	None	add
124	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  labelName);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH,    exitType);    	compilable	  [FE]  RuntimeException  	135	6	replace
125	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  labelName);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  labelName);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH,    exitType);    	compilable	  [FE]  RuntimeException  	135	6	replace
126	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CATCH,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(n.getType()  ==  Token.CATCH,  exitType);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH,    exitType);    	compilable	  [FE]  RuntimeException  	135	6	replace
127	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CATCH,  exitType);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CATCH,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()  ==  Token.CATCH,  exitType);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH,    exitType);    	compilable	  [FE]  RuntimeException  	135	6	replace
128	[BUG]  [BUGGY]  Preconditions.checkState(exitType.getType()  ==  Token.CATCH,  tryBlock);  [CE]  int  cannot  be  dereferenced  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(exitType.getType()  ==  Token.CATCH,  tryBlock);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(exitType.getType()  ==  Token.CATCH,  tryBlock);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH,    exitType);    	non-compiled	[CE]  int  cannot  be  dereferenced	135	None	replace
129	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()!=  Token.CATCH,  labelName);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH,    exitType);    	compilable	  [FE]  AssertionFailedError  	135	6	replace
130	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH,  labelName);  [FE]  AssertionFailedError  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=  Token.CATCH,  labelName);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH,    exitType);    	compilable	  [FE]  AssertionFailedError  	135	6	replace
131	[BUG]  [BUGGY]  Preconditions.checkState(tries.getType()  ==  Token.CATCH,  exitType);  [CE]  cannot  find  symbol  tries  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tries.getType()  ==  Token.CATCH,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tries.getType()  ==  Token.CATCH,  exitType);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH,    exitType);    	non-compiled	[CE]  cannot  find  symbol  tries	135	None	replace
132	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  ||  tryBlock.isExit());  [CE]  cannot  find  symbol  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  ||  tryBlock.isExit());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=  null  ||  tryBlock.isExit());	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.isExit());    	non-compiled	[CE]  cannot  find  symbol	181	None	replace
133	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.isExitType());  [CE]  cannot  find  symbol  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.isExitType());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=  null  &&  tryBlock.isExitType());	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.isExit());    	non-compiled	[CE]  cannot  find  symbol	181	None	replace
134	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.isExit());  [CE]  cannot  find  symbol  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.isExit());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.isExit());	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.isExit());    	non-compiled	[CE]  cannot  find  symbol	181	None	replace
135	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Node  labelName  =  tryBlock.getNext();  [CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Node  labelName  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Node  labelName  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    labelName    =    tryBlock.getNext();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	46	None	replace
136	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Node  labelName  =  tryBlock.getNext();  [CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Node  labelName  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Node  labelName  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    labelName    =    tryBlock.getNext();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	46	None	replace
137	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  labelName  =  tryBlock.getNext();  [CE]  incompatible  types  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  labelName  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  labelName  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    labelName    =    tryBlock.getNext();    	non-compiled	[CE]  incompatible  types	46	None	replace
138	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.NAME);  Node  labelName  =  tryBlock.getNext();  [CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                      AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.NAME);  Node  labelName  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.NAME);  Node  labelName  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    labelName    =    tryBlock.getNext();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	46	None	replace
139	[BUG]  [BUGGY]  NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [CE]  cannot  find  symbol  [FE]          RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    NodeUtil.checkState(tryBlock.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  cannot  find  symbol	65	None	replace
140	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION,  tryBlock.getType()  ==  Token.FUNCTION);  NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [CE]  cannot  find  symbol  [FE]            RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION,  tryBlock.getType()  ==  Token.FUNCTION);  NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION,  tryBlock.getType()  ==  Token.FUNCTION);  NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    NodeUtil.checkState(tryBlock.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  cannot  find  symbol	65	None	replace
141	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [CE]  cannot  find  symbol  [FE]              RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    NodeUtil.checkState(tryBlock.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  cannot  find  symbol	65	None	replace
142	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [CE]  cannot  find  symbol  [FE]                RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    NodeUtil.checkState(tryBlock.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  cannot  find  symbol	65	None	replace
143	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()    >=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	38	6	add
144	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()    >=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	38	6	add
145	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()    >=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	38	6	add
146	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()    >=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	38	6	add
147	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()    >=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	38	6	add
148	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()    >=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	38	6	add
149	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >>  Token.EXPR_RESULT);  [CE]  no  suitable  method  found  for  checkState(int)  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >>  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()    >=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >>  Token.EXPR_RESULT);	  	non-compiled	[CE]  no  suitable  method  found  for  checkState(int)	38	None	add
150	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >>  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  [CE]  no  suitable  method  found  for  checkState(int)  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >>  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()    >=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >>  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);	  	non-compiled	[CE]  no  suitable  method  found  for  checkState(int)	38	None	add
151	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >>  Token.EXPR_RESULT);  [CE]  no  suitable  method  found  for  checkState(int)  [FE]              RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >>  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()    >=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >>  Token.EXPR_RESULT);	  	non-compiled	[CE]  no  suitable  method  found  for  checkState(int)	38	None	add
152	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	118	6	add
153	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	118	6	add
154	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  NodeUtil.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  [CE]  cannot  find  symbol  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  NodeUtil.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.CATCH);    NodeUtil.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);	  	non-compiled	[CE]  cannot  find  symbol	118	None	add
155	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()!=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()!=  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	118	6	add
156	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()!=  Token.CATCH);  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()!=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()!=  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	118	6	add
157	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	118	6	add
158	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	118	6	add
159	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  >=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  >=  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	118	6	add
160	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  >=  Token.CATCH);  [FE]  RuntimeException  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  >=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  >=  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	118	6	add
161	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]              RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	118	6	add
162	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  [FE]  RuntimeException  [FE]              RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	118	6	add
163	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  null  :  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  c  =  tryBlock!=  null?  null  :  tryBlock.getNext();	          Node    c    =    tryBlock.getNext();    Node    c    =    tryingBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	106	6	replace
164	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  null  :  tryBlock.getNext();  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  null  :  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock!=  null?  null  :  tryBlock.getNext();	          Node    c    =    tryBlock.getNext();    Node    c    =    tryingBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	106	6	replace
165	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock  ==  null?  null  :  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  c  =  tryBlock  ==  null?  null  :  tryBlock.getNext();	          Node    c    =    tryBlock.getNext();    Node    c    =    tryingBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	106	6	replace
166	[BUG]  [BUGGY]  Node  c  =  tryBlock  ==  null?  null  :  tryBlock.getNext();  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock  ==  null?  null  :  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock  ==  null?  null  :  tryBlock.getNext();	          Node    c    =    tryBlock.getNext();    Node    c    =    tryingBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	106	6	replace
167	[BUG]  [BUGGY]  Node  c  =  tryingBlock.getNext();  [CE]  cannot  find  symbol  tryingBlock  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryingBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryingBlock.getNext();	          Node    c    =    tryBlock.getNext();    Node    c    =    tryingBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol  tryingBlock	106	None	replace
168	[BUG]  [BUGGY]  tryMinimizeExits(tryBlock,  labelName,  exitType);  [CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(tryBlock,  labelName,  exitType);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(tryBlock,  labelName,  exitType);	  tryMinimizeExits(exitType,    labelName,    tryBlock);    	non-compiled	[CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;	129	None	replace
169	[BUG]  [BUGGY]  tryMinimizeExits(labelName,  exitType,  tryBlock);  [CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(labelName,  exitType,  tryBlock);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(labelName,  exitType,  tryBlock);	  tryMinimizeExits(exitType,    labelName,    tryBlock);    	non-compiled	[CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;	129	None	replace
170	[BUG]  [BUGGY]  tryMinimizeExits(tree,  exitType,  labelName,  tryBlock);  [CE]  cannot  find  symbol  tree  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(tree,  exitType,  labelName,  tryBlock);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(tree,  exitType,  labelName,  tryBlock);	  tryMinimizeExits(exitType,    labelName,    tryBlock);    	non-compiled	[CE]  cannot  find  symbol  tree	129	None	replace
171	[BUG]  [BUGGY]  tryMinimizeExits(catchNode,  exitType,  labelName,  tryBlock);  [CE]  cannot  find  symbol  catchNode  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(catchNode,  exitType,  labelName,  tryBlock);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(catchNode,  exitType,  labelName,  tryBlock);	  tryMinimizeExits(exitType,    labelName,    tryBlock);    	non-compiled	[CE]  cannot  find  symbol  catchNode	129	None	replace
172	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.removeFirstChild();  Node  returnType  =  tryBlock.removeFirstChild();  [CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.removeFirstChild();  Node  returnType  =  tryBlock.removeFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    returnType    =    tryBlock.removeFirstChild();    Node  returnType  =  tryBlock.removeFirstChild();	  	non-compiled	[CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	176	None	add
173	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.removeFirstChild();  Node  exitType  =  tryBlock.removeFirstChild();  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.removeFirstChild();  Node  exitType  =  tryBlock.removeFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    returnType    =    tryBlock.removeFirstChild();    Node  exitType  =  tryBlock.removeFirstChild();	  	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	176	None	add
174	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.removeFirstChild();  Node  escapeType  =  tryBlock.removeFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node    returnType    =    tryBlock.removeFirstChild();    Node  escapeType  =  tryBlock.removeFirstChild();	  	compilable	  [FE]  AssertionFailedError  	176	6	add
175	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.removeFirstChild();  Node  escapeType  =  tryBlock.removeFirstChild();  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.removeFirstChild();  Node  escapeType  =  tryBlock.removeFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    returnType    =    tryBlock.removeFirstChild();    Node  escapeType  =  tryBlock.removeFirstChild();	  	compilable	  [FE]  AssertionFailedError  	176	6	add
176	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.removeFirstChild();  Node  labelName  =  tryBlock.removeFirstChild();  [CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.removeFirstChild();  Node  labelName  =  tryBlock.removeFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    returnType    =    tryBlock.removeFirstChild();    Node  labelName  =  tryBlock.removeFirstChild();	  	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	176	None	add
177	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.removeFirstChild();  Node  stopType  =  tryBlock.removeFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node    returnType    =    tryBlock.removeFirstChild();    Node  stopType  =  tryBlock.removeFirstChild();	  	compilable	  [FE]  AssertionFailedError  	176	6	add
178	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.removeFirstChild();  Node  stopType  =  tryBlock.removeFirstChild();  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.removeFirstChild();  Node  stopType  =  tryBlock.removeFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    returnType    =    tryBlock.removeFirstChild();    Node  stopType  =  tryBlock.removeFirstChild();	  	compilable	  [FE]  AssertionFailedError  	176	6	add
179	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.removeFirstChild();  Node  startType  =  tryBlock.removeFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node    returnType    =    tryBlock.removeFirstChild();    Node  startType  =  tryBlock.removeFirstChild();	  	compilable	  [FE]  AssertionFailedError  	176	6	add
180	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.removeFirstChild();  Node  startType  =  tryBlock.removeFirstChild();  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.removeFirstChild();  Node  startType  =  tryBlock.removeFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    returnType    =    tryBlock.removeFirstChild();    Node  startType  =  tryBlock.removeFirstChild();	  	compilable	  [FE]  AssertionFailedError  	176	6	add
181	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    	compilable	  [FE]  RuntimeException  	91	6	replace
182	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    	compilable	  [FE]  RuntimeException  	91	6	replace
183	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	117	6	replace
184	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	117	6	replace
185	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	117	6	replace
186	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [FE]  AssertionFailedError  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	117	6	replace
187	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()!=  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	117	6	replace
188	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  AssertionFailedError  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	117	6	replace
189	[BUG]  [BUGGY]  Preconditions.checkState(tries.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  tries  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tries.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tries.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  cannot  find  symbol  tries	117	None	replace
190	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT,  labelName);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    labelName);    	compilable	  [FE]  RuntimeException  	139	6	replace
191	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT,  labelName);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT,  labelName);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    labelName);    	compilable	  [FE]  RuntimeException  	139	6	replace
192	[BUG]  [BUGGY]  Preconditions.checkState(exitType.getType()  ==  Token.EXPR_RESULT,  labelName);  [CE]  int  cannot  be  dereferenced  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(exitType.getType()  ==  Token.EXPR_RESULT,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(exitType.getType()  ==  Token.EXPR_RESULT,  labelName);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    labelName);    	non-compiled	[CE]  int  cannot  be  dereferenced	139	None	replace
193	[BUG]  [BUGGY]  Preconditions.checkState(labelName.getType()  ==  Token.EXPR_RESULT,  tryBlock);  [CE]  cannot  find  symbol  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(labelName.getType()  ==  Token.EXPR_RESULT,  tryBlock);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(labelName.getType()  ==  Token.EXPR_RESULT,  tryBlock);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    labelName);    	non-compiled	[CE]  cannot  find  symbol	139	None	replace
194	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT,  labelName);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    labelName);    	compilable	  [FE]  AssertionFailedError  	139	6	replace
195	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT,  labelName);  [FE]  AssertionFailedError  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT,  labelName);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    labelName);    	compilable	  [FE]  AssertionFailedError  	139	6	replace
196	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	163	6	add
197	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	163	6	add
198	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkArgument(tryBlock.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkArgument(tryBlock.getType()!=  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	163	6	add
199	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkArgument(tryBlock.getType()!=  Token.FUNCTION);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkArgument(tryBlock.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkArgument(tryBlock.getType()!=  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	163	6	add
200	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkArgument(tryBlock.getType()  >>  Token.FUNCTION);  [CE]  no  suitable  method  found  for  checkArgument(int)  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkArgument(tryBlock.getType()  >>  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkArgument(tryBlock.getType()  >>  Token.FUNCTION);	  	non-compiled	[CE]  no  suitable  method  found  for  checkArgument(int)	163	None	add
201	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkArgument(tryBlock.getType()  >=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkArgument(tryBlock.getType()  >=  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	163	6	add
202	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkArgument(tryBlock.getType()  >=  Token.FUNCTION);  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkArgument(tryBlock.getType()  >=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkArgument(tryBlock.getType()  >=  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	163	6	add
203	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  [CE]  cannot  find  symbol  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);	  	non-compiled	[CE]  cannot  find  symbol	163	None	add
204	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkArgument(tryBlock.getType()  [Delete]  Token.FUNCTION);  [CE]  ')'  expected  [FE]              RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkArgument(tryBlock.getType()  [Delete]  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkArgument(tryBlock.getType()  [Delete]  Token.FUNCTION);	  	non-compiled	[CE]  ')'  expected	163	None	add
205	[BUG]  [BUGGY]  Node  tryBlock  =  tryBlock.getFirstChild();  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]        RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  tryBlock  =  tryBlock.getFirstChild();  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  tryBlock  =  tryBlock.getFirstChild();  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Node    tryBlock    =    tryBlock.getFirstChild();    Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	171	None	replace
206	[BUG]  [BUGGY]  Node  tryBlock  =  tryBlock.getFirstChild();  [CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]          RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  tryBlock  =  tryBlock.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  tryBlock  =  tryBlock.getFirstChild();	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Node    tryBlock    =    tryBlock.getFirstChild();    Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	171	None	replace
207	[BUG]  [BUGGY]  Node  tryBlock  =  tryBlock.getFirstChild();  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  [CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]            RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  tryBlock  =  tryBlock.getFirstChild();  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  tryBlock  =  tryBlock.getFirstChild();  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Node    tryBlock    =    tryBlock.getFirstChild();    Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	171	None	replace
208	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  Node  tryBlock  =  tryBlock.getFirstChild();  [CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]              RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  Node  tryBlock  =  tryBlock.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  Node  tryBlock  =  tryBlock.getFirstChild();	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Node    tryBlock    =    tryBlock.getFirstChild();    Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	171	None	replace
209	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	18	6	add
210	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	18	6	add
211	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	non-compiled	[CE]  cannot  find  symbol	18	None	add
212	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	18	6	add
213	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	18	6	add
214	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	18	6	add
215	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	18	6	add
216	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	18	6	add
217	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  >=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	18	6	add
218	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Node  tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  ';'  expected  [FE]              RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Node  tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Node  tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	non-compiled	[CE]  ';'  expected	18	None	add
219	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  escapeType  =  tryBlock.getLastChild();	  Node    escapeType    =    tryBlock.removeFirstChild();    	compilable	  [FE]  AssertionFailedError  	184	6	replace
220	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getLastChild();  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getLastChild();	  Node    escapeType    =    tryBlock.removeFirstChild();    	compilable	  [FE]  AssertionFailedError  	184	6	replace
221	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.removeLastChild();  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.removeLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.removeLastChild();	  Node    escapeType    =    tryBlock.removeFirstChild();    	non-compiled	[CE]  cannot  find  symbol	184	None	replace
222	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  AssertionFailedError  	73	2	add
223	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  AssertionFailedError  	73	2	add
224	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >>  Token.EXPR_RESULT);  [CE]  no  suitable  method  found  for  checkState(int)  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >>  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >>  Token.EXPR_RESULT);	  	non-compiled	[CE]  no  suitable  method  found  for  checkState(int)	73	None	add
225	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	73	6	add
226	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	73	6	add
227	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  NodeUtil.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  NodeUtil.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    NodeUtil.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);	  	non-compiled	[CE]  cannot  find  symbol	73	None	add
228	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  [Delete]  Token.EXPR_RESULT);  [CE]  ')'  expected  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  [Delete]  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  [Delete]  Token.EXPR_RESULT);	  	non-compiled	[CE]  ')'  expected	73	None	add
229	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	34	6	add
230	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	34	6	add
231	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	34	6	add
232	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	34	6	add
233	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >>  Token.EXPR_RESULT);  [CE]  no  suitable  method  found  for  checkState(int)  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >>  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >>  Token.EXPR_RESULT);	  	non-compiled	[CE]  no  suitable  method  found  for  checkState(int)	34	None	add
234	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	34	6	add
235	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	34	6	add
236	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >>  Token.EXPR_RESULT);  [CE]  no  suitable  method  found  for  checkState(int)  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >>  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >>  Token.EXPR_RESULT);	  	non-compiled	[CE]  no  suitable  method  found  for  checkState(int)	34	None	add
237	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >>  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  [CE]  no  suitable  method  found  for  checkState(int)  [FE]              RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >>  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >>  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);	  	non-compiled	[CE]  no  suitable  method  found  for  checkState(int)	34	None	add
238	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  Preconditions.checkState(n.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  Preconditions.checkState(n.getType()!=  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()    >=    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	69	6	replace
239	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  Preconditions.checkState(n.getType()!=  Token.FUNCTION);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  Preconditions.checkState(n.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  Preconditions.checkState(n.getType()!=  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()    >=    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	69	6	replace
240	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	76	6	replace
241	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	76	6	replace
242	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	76	6	replace
243	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  AssertionFailedError  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	76	6	replace
244	[BUG]  [BUGGY]  Preconditions.checkState(tries.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  tries  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tries.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tries.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  cannot  find  symbol  tries	76	None	replace
245	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock!=        null);        Preconditions.checkState(tryBlock    ==    null);    Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);	  	compilable	  [FE]  RuntimeException  	57	6	add
246	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock!=        null);        Preconditions.checkState(tryBlock    ==    null);    Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);	  	compilable	  [FE]  RuntimeException  	57	6	add
247	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock!=        null);        Preconditions.checkState(tryBlock    ==    null);    Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock  ==  null);	  	compilable	  [FE]  RuntimeException  	57	6	add
248	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock  ==  null);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock!=        null);        Preconditions.checkState(tryBlock    ==    null);    Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock  ==  null);	  	compilable	  [FE]  RuntimeException  	57	6	add
249	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock  ==  null);  Node  c  =  tryBlock.getNext();  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock!=        null);        Preconditions.checkState(tryBlock    ==    null);    Node  c  =  tryBlock.getNext();  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);	  	compilable	  [FE]  RuntimeException  	57	6	add
250	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock  ==  null);  Node  c  =  tryBlock.getNext();  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock  ==  null);  Node  c  =  tryBlock.getNext();  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock!=        null);        Preconditions.checkState(tryBlock    ==    null);    Node  c  =  tryBlock.getNext();  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);	  	compilable	  [FE]  RuntimeException  	57	6	add
251	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock  ==  null);  Node  elseBlock  =  tryBlock.getNext();  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock!=        null);        Preconditions.checkState(tryBlock    ==    null);    Node  elseBlock  =  tryBlock.getNext();  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);	  	compilable	  [FE]  RuntimeException  	57	6	add
252	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock  ==  null);  Node  elseBlock  =  tryBlock.getNext();  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock  ==  null);  Node  elseBlock  =  tryBlock.getNext();  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock!=        null);        Preconditions.checkState(tryBlock    ==    null);    Node  elseBlock  =  tryBlock.getNext();  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);	  	compilable	  [FE]  RuntimeException  	57	6	add
253	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock  ==  null);  Node  tryBlock  =  tryBlock.getNext();  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);  [CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock  ==  null);  Node  tryBlock  =  tryBlock.getNext();  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock!=        null);        Preconditions.checkState(tryBlock    ==    null);    Node  tryBlock  =  tryBlock.getNext();  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);	  	non-compiled	[CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	57	None	add
254	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock  ==  null);  NodeUtil.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);  [CE]  cannot  find  symbol  [FE]              RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock  ==  null);  NodeUtil.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock!=        null);        Preconditions.checkState(tryBlock    ==    null);    NodeUtil.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);	  	non-compiled	[CE]  cannot  find  symbol	57	None	add
255	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  returnType  =  tryBlock.getLastChild();	  Node    returnType    =    tryBlock.getFirstChild();    	compilable	  [FE]  AssertionFailedError  	6	6	replace
256	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getLastChild();  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getLastChild();	  Node    returnType    =    tryBlock.getFirstChild();    	compilable	  [FE]  AssertionFailedError  	6	6	replace
257	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  n.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  returnType  =  n.getFirstChild();	  Node    returnType    =    tryBlock.getFirstChild();    	compilable	  [FE]  AssertionFailedError  	6	6	replace
258	[BUG]  [BUGGY]  Node  returnType  =  n.getFirstChild();  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  n.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  n.getFirstChild();	  Node    returnType    =    tryBlock.getFirstChild();    	compilable	  [FE]  AssertionFailedError  	6	6	replace
259	[BUG]  [BUGGY]  tryMinimizeExit(tryBlock,  exitType,  labelName,  true);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExit(tryBlock,  exitType,  labelName,  true);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExit(tryBlock,  exitType,  labelName,  true);	  tryMinimizeExit(tryBlock,    exitType,    labelName,    false);    	non-compiled	[CE]  cannot  find  symbol	191	None	replace
260	[BUG]  [BUGGY]  tryMinimizeExits(tryBlock,  exitType,  labelName,  false);  [CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(tryBlock,  exitType,  labelName,  false);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(tryBlock,  exitType,  labelName,  false);	  tryMinimizeExit(tryBlock,    exitType,    labelName,    false);    	non-compiled	[CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;	191	None	replace
261	[BUG]  [BUGGY]  tryMinimizeExit(catchCodeBlock,  exitType,  labelName,  false);  [CE]  cannot  find  symbol  catchCodeBlock  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExit(catchCodeBlock,  exitType,  labelName,  false);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExit(catchCodeBlock,  exitType,  labelName,  false);	  tryMinimizeExit(tryBlock,    exitType,    labelName,    false);    	non-compiled	[CE]  cannot  find  symbol  catchCodeBlock	191	None	replace
262	[BUG]  [BUGGY]  tryMinimizeExit(catchNode,  exitType,  labelName,  false);  [CE]  cannot  find  symbol  catchNode  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExit(catchNode,  exitType,  labelName,  false);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExit(catchNode,  exitType,  labelName,  false);	  tryMinimizeExit(tryBlock,    exitType,    labelName,    false);    	non-compiled	[CE]  cannot  find  symbol  catchNode	191	None	replace
263	[BUG]  [BUGGY]  tryMinimizeExit(n,  exitType,  labelName);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExit(n,  exitType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExit(n,  exitType,  labelName);	  tryMinimizeExit(tree,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol	151	None	replace
264	[BUG]  [BUGGY]  tryMinimizeExit(labelName,  exitType,  exitType);  [CE]  cannot  find  symbol  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExit(labelName,  exitType,  exitType);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExit(labelName,  exitType,  exitType);	  tryMinimizeExit(tree,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol	151	None	replace
265	[BUG]  [BUGGY]  Preconditions.checkState(tries.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  tries  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tries.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tries.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(n.getType()    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  cannot  find  symbol  tries	72	None	replace
266	[BUG]  [BUGGY]  Node  labelName  =  tryBlock.getString(),  falseBlock);  [CE]  ';'  expected  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  tryBlock.getString(),  falseBlock);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  tryBlock.getString(),  falseBlock);	  Node    labelName    =    tryBlock.getString()    +    1;    	non-compiled	[CE]  ';'  expected	25	None	replace
267	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getType(),  labelName;  [CE]  incompatible  types  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getType(),  labelName;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getType(),  labelName;	  Node    returnType    =    tryBlock.getType();    	non-compiled	[CE]  incompatible  types	4	None	replace
268	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getType()  &&  labelName.equals(n.getString());  [CE]  bad  operand  types  for  binary  operator  '&&'  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getType()  &&  labelName.equals(n.getString());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getType()  &&  labelName.equals(n.getString());	  Node    returnType    =    tryBlock.getType();    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '&&'	4	None	replace
269	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getType(),  labelName);  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getType(),  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getType(),  labelName);	  Node    returnType    =    tryBlock.getType();    	non-compiled	[CE]  ';'  expected	4	None	replace
270	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getType()  ||  labelName.equals(n.getString());  [CE]  bad  operand  types  for  binary  operator  '||'  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getType()  ||  labelName.equals(n.getString());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getType()  ||  labelName.equals(n.getString());	  Node    returnType    =    tryBlock.getType();    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '||'	4	None	replace
271	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock!=  null  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	50	6	replace
272	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  AssertionFailedError  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=  null  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	50	6	replace
273	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	50	6	replace
274	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	50	6	replace
275	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock  ==  null  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock  ==  null  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	50	6	replace
276	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock  ==  null  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock  ==  null  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock  ==  null  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	50	6	replace
277	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(n!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	50	6	replace
278	[BUG]  [BUGGY]  Preconditions.checkState(n!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	50	6	replace
279	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  &&  tryBlock.hasChildren());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  &&  tryBlock.hasChildren());	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.hasChildren());    	compilable	  [FE]  RuntimeException  	154	6	replace
280	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  &&  tryBlock.hasChildren());  [FE]  RuntimeException  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  &&  tryBlock.hasChildren());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  &&  tryBlock.hasChildren());	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.hasChildren());    	compilable	  [FE]  RuntimeException  	154	6	replace
281	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.hasChildren());    	compilable	  [FE]  AssertionFailedError  	154	6	replace
282	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.hasChildren());    	compilable	  [FE]  AssertionFailedError  	154	6	replace
283	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.isExtern());  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.isExtern());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.isExtern());	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.hasChildren());    	non-compiled	[CE]  cannot  find  symbol	154	None	replace
284	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.isFunctionPrototype());  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.isFunctionPrototype());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.isFunctionPrototype());	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.hasChildren());    	non-compiled	[CE]  cannot  find  symbol	154	None	replace
285	[BUG]  [BUGGY]  Node  labelName  =  tryBlock.getNext(),  labelName);  [CE]  ';'  expected  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  tryBlock.getNext(),  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  tryBlock.getNext(),  labelName);	  Node    labelName    =    tryBlock.getNext(),    exitType);    	non-compiled	[CE]  ';'  expected	170	None	replace
286	[BUG]  [BUGGY]  Node  labelName  =  tryBlock.getLastChild(),  exitType);  [CE]  ';'  expected  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  tryBlock.getLastChild(),  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  tryBlock.getLastChild(),  exitType);	  Node    labelName    =    tryBlock.getNext(),    exitType);    	non-compiled	[CE]  ';'  expected	170	None	replace
287	[BUG]  [BUGGY]  Node  labelName  =  tryBlock.getFirstChild(),  exitType);  [CE]  ';'  expected  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  tryBlock.getFirstChild(),  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  tryBlock.getFirstChild(),  exitType);	  Node    labelName    =    tryBlock.getNext(),    exitType);    	non-compiled	[CE]  ';'  expected	170	None	replace
288	[BUG]  [BUGGY]  Node  labelName  =  tryBlock.getNext(),  exitType,  labelName);  [CE]  ';'  expected  [FE]                      AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  tryBlock.getNext(),  exitType,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  tryBlock.getNext(),  exitType,  labelName);	  Node    labelName    =    tryBlock.getNext(),    exitType);    	non-compiled	[CE]  ';'  expected	170	None	replace
289	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]                RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION,  labelName);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()    >>    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	70	6	replace
290	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION,  labelName);  [FE]  RuntimeException  [FE]                RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION,  labelName);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()    >>    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	70	6	replace
291	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]                  RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION,  tryBlock.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION,  tryBlock.getType()!=  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()    >>    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	70	6	replace
292	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION,  tryBlock.getType()!=  Token.FUNCTION);  [FE]  RuntimeException  [FE]                  RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION,  tryBlock.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION,  tryBlock.getType()!=  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()    >>    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	70	6	replace
293	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                    RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION,  labelName);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()    >>    Token.FUNCTION);    	compilable	  [FE]  AssertionFailedError  	70	6	replace
294	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION,  labelName);  [FE]  AssertionFailedError  [FE]                    RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION,  labelName);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()    >>    Token.FUNCTION);    	compilable	  [FE]  AssertionFailedError  	70	6	replace
295	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  ||  tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock!=  null  ||  tryBlock.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  AssertionFailedError  	52	6	replace
296	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  ||  tryBlock.getType()  ==  Token.FUNCTION);  [FE]  AssertionFailedError  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  ||  tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=  null  ||  tryBlock.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  AssertionFailedError  	52	6	replace
297	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	52	6	replace
298	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	52	6	replace
299	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock  ==  null  ||  tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock  ==  null  ||  tryBlock.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	52	6	replace
300	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock  ==  null  ||  tryBlock.getType()  ==  Token.FUNCTION);  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock  ==  null  ||  tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock  ==  null  ||  tryBlock.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	52	6	replace
301	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(n!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	52	6	replace
302	[BUG]  [BUGGY]  Preconditions.checkState(n!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	52	6	replace
303	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  returnType  =  tryBlock.getParent();  [CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  returnType  =  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    returnType    =    tryBlock.getParent();    Node  returnType  =  tryBlock.getParent();	  	non-compiled	[CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	131	None	add
304	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  exitType  =  tryBlock.getParent();  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  exitType  =  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    returnType    =    tryBlock.getParent();    Node  exitType  =  tryBlock.getParent();	  	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	131	None	add
305	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  escapeType  =  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node    returnType    =    tryBlock.getParent();    Node  escapeType  =  tryBlock.getParent();	  	compilable	  [FE]  AssertionFailedError  	131	2	add
306	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  escapeType  =  tryBlock.getParent();  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  escapeType  =  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    returnType    =    tryBlock.getParent();    Node  escapeType  =  tryBlock.getParent();	  	compilable	  [FE]  AssertionFailedError  	131	2	add
307	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  returnedType  =  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node    returnType    =    tryBlock.getParent();    Node  returnedType  =  tryBlock.getParent();	  	compilable	  [FE]  AssertionFailedError  	131	2	add
308	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  returnedType  =  tryBlock.getParent();  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  returnedType  =  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    returnType    =    tryBlock.getParent();    Node  returnedType  =  tryBlock.getParent();	  	compilable	  [FE]  AssertionFailedError  	131	2	add
309	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  labelName  =  tryBlock.getParent();  [CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  labelName  =  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    returnType    =    tryBlock.getParent();    Node  labelName  =  tryBlock.getParent();	  	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	131	None	add
310	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  stopType  =  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node    returnType    =    tryBlock.getParent();    Node  stopType  =  tryBlock.getParent();	  	compilable	  [FE]  AssertionFailedError  	131	2	add
311	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  stopType  =  tryBlock.getParent();  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  stopType  =  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    returnType    =    tryBlock.getParent();    Node  stopType  =  tryBlock.getParent();	  	compilable	  [FE]  AssertionFailedError  	131	2	add
312	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType.getNext();	          Node    escapeType    =    tryBlock.getNext();    Node    EscapeType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	142	6	replace
313	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType.getNext();  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType.getNext();	          Node    escapeType    =    tryBlock.getNext();    Node    EscapeType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	142	6	replace
314	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getFirstChild();  Node  EscapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  escapeType  =  tryBlock.getFirstChild();  Node  EscapeType  =  tryBlock.getNext();	          Node    escapeType    =    tryBlock.getNext();    Node    EscapeType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	142	6	replace
315	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getFirstChild();  Node  EscapeType  =  tryBlock.getNext();  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getFirstChild();  Node  EscapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getFirstChild();  Node  EscapeType  =  tryBlock.getNext();	          Node    escapeType    =    tryBlock.getNext();    Node    EscapeType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	142	6	replace
316	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getParent();  Node  EscapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  escapeType  =  tryBlock.getParent();  Node  EscapeType  =  tryBlock.getNext();	          Node    escapeType    =    tryBlock.getNext();    Node    EscapeType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	142	6	replace
317	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getParent();  Node  EscapeType  =  tryBlock.getNext();  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getParent();  Node  EscapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getParent();  Node  EscapeType  =  tryBlock.getNext();	          Node    escapeType    =    tryBlock.getNext();    Node    EscapeType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	142	6	replace
318	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType  <  0?  tryBlock.getNext()  :  null;  [CE]  bad  operand  types  for  binary  operator  '<'  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType  <  0?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType  <  0?  tryBlock.getNext()  :  null;	          Node    escapeType    =    tryBlock.getNext();    Node    EscapeType    =    tryBlock.getNext();    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '<'	142	None	replace
319	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType!=  null?  tryBlock.getNext()  :  escapeType;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType!=  null?  tryBlock.getNext()  :  escapeType;	          Node    escapeType    =    tryBlock.getNext();    Node    EscapeType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	142	6	replace
320	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType!=  null?  tryBlock.getNext()  :  escapeType;  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType!=  null?  tryBlock.getNext()  :  escapeType;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType!=  null?  tryBlock.getNext()  :  escapeType;	          Node    escapeType    =    tryBlock.getNext();    Node    EscapeType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	142	6	replace
321	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=    Token.FUNCTION);    	compilable	  [FE]  AssertionFailedError  	67	6	replace
322	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  [FE]  AssertionFailedError  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=    Token.FUNCTION);    	compilable	  [FE]  AssertionFailedError  	67	6	replace
323	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.removeFirstChild();  Node  escapeType  =  tryBlock.removeFirstChild();  [CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.removeFirstChild();  Node  escapeType  =  tryBlock.removeFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    escapeType    =    tryBlock.removeFirstChild();    Node  escapeType  =  tryBlock.removeFirstChild();	  	non-compiled	[CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	183	None	add
324	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.removeFirstChild();  Node  exitType  =  tryBlock.removeFirstChild();  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.removeFirstChild();  Node  exitType  =  tryBlock.removeFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    escapeType    =    tryBlock.removeFirstChild();    Node  exitType  =  tryBlock.removeFirstChild();	  	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	183	None	add
325	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.removeFirstChild();  Node  escapeType  =  attemptBlock.removeFirstChild();  [CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.removeFirstChild();  Node  escapeType  =  attemptBlock.removeFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    escapeType    =    tryBlock.removeFirstChild();    Node  escapeType  =  attemptBlock.removeFirstChild();	  	non-compiled	[CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	183	None	add
326	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.removeFirstChild();  Node  EscapeType  =  tryBlock.removeFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node    escapeType    =    tryBlock.removeFirstChild();    Node  EscapeType  =  tryBlock.removeFirstChild();	  	compilable	  [FE]  AssertionFailedError  	183	6	add
327	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.removeFirstChild();  Node  EscapeType  =  tryBlock.removeFirstChild();  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.removeFirstChild();  Node  EscapeType  =  tryBlock.removeFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    escapeType    =    tryBlock.removeFirstChild();    Node  EscapeType  =  tryBlock.removeFirstChild();	  	compilable	  [FE]  AssertionFailedError  	183	6	add
328	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.removeFirstChild();  node  escapeType  =  tryBlock.removeFirstChild();  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.removeFirstChild();  node  escapeType  =  tryBlock.removeFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    escapeType    =    tryBlock.removeFirstChild();    node  escapeType  =  tryBlock.removeFirstChild();	  	non-compiled	[CE]  cannot  find  symbol	183	None	add
329	[BUG]  [BUGGY]  NodeUtil.checkCatchHandler(tryBlock.getType()  ==  Token.CATCH);  [CE]  cannot  find  symbol  [FE]        RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  NodeUtil.checkCatchHandler(tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	NodeUtil.checkCatchHandler(tryBlock.getType()  ==  Token.CATCH);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    NodeUtil.checkCatchHandler(tryBlock.getType()    ==    Token.CATCH);    	non-compiled	[CE]  cannot  find  symbol	174	None	replace
330	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CATCH);  NodeUtil.checkCatchHandler(tryBlock.getType()  ==  Token.CATCH);  [CE]  cannot  find  symbol  [FE]          RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CATCH);  NodeUtil.checkCatchHandler(tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()  ==  Token.CATCH);  NodeUtil.checkCatchHandler(tryBlock.getType()  ==  Token.CATCH);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    NodeUtil.checkCatchHandler(tryBlock.getType()    ==    Token.CATCH);    	non-compiled	[CE]  cannot  find  symbol	174	None	replace
331	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  NodeUtil.checkCatchHandler(tryBlock,  tryBlock.getType()  ==  Token.CATCH);  [CE]  cannot  find  symbol  [FE]            RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  NodeUtil.checkCatchHandler(tryBlock,  tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  NodeUtil.checkCatchHandler(tryBlock,  tryBlock.getType()  ==  Token.CATCH);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    NodeUtil.checkCatchHandler(tryBlock.getType()    ==    Token.CATCH);    	non-compiled	[CE]  cannot  find  symbol	174	None	replace
332	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  NodeUtil.checkCatchHandler(tryBlock.getType()  ==  Token.CATCH);  [CE]  cannot  find  symbol  [FE]              RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  NodeUtil.checkCatchHandler(tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  NodeUtil.checkCatchHandler(tryBlock.getType()  ==  Token.CATCH);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    NodeUtil.checkCatchHandler(tryBlock.getType()    ==    Token.CATCH);    	non-compiled	[CE]  cannot  find  symbol	174	None	replace
333	[BUG]  [BUGGY]  Node  c  =  tryBlock.getType()  ==  Token.CATCH;  Preconditions.checkState(c.getType()  ==  Token.CATCH);  [CE]  incompatible  types  [FE]            RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getType()  ==  Token.CATCH;  Preconditions.checkState(c.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock.getType()  ==  Token.CATCH;  Preconditions.checkState(c.getType()  ==  Token.CATCH);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Node    c    =    tryBlock.getType()    ==    Token.CATCH;    Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    	non-compiled	[CE]  incompatible  types	92	None	replace
334	[BUG]  [BUGGY]  Node  c  =  tryBlock.getType()  >>  Token.CATCH;  Preconditions.checkState(c.getType()  ==  Token.CATCH);  [CE]  incompatible  types  [FE]              RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getType()  >>  Token.CATCH;  Preconditions.checkState(c.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock.getType()  >>  Token.CATCH;  Preconditions.checkState(c.getType()  ==  Token.CATCH);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Node    c    =    tryBlock.getType()    ==    Token.CATCH;    Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    	non-compiled	[CE]  incompatible  types	92	None	replace
335	[BUG]  [BUGGY]  Node  c  =  tryBlock.getType()  ==  Token.CATCH;  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [CE]  incompatible  types  [FE]                RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getType()  ==  Token.CATCH;  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock.getType()  ==  Token.CATCH;  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Node    c    =    tryBlock.getType()    ==    Token.CATCH;    Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    	non-compiled	[CE]  incompatible  types	92	None	replace
336	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Node  c  =  tryBlock.getType()  ==  Token.CATCH;  [CE]  incompatible  types  [FE]                  RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Node  c  =  tryBlock.getType()  ==  Token.CATCH;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Node  c  =  tryBlock.getType()  ==  Token.CATCH;	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Node    c    =    tryBlock.getType()    ==    Token.CATCH;    Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    	non-compiled	[CE]  incompatible  types	92	None	replace
337	[BUG]  [BUGGY]  Node  c  =  tryBlock.getType()  >>  Token.CATCH;  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [CE]  incompatible  types  [FE]                    RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getType()  >>  Token.CATCH;  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock.getType()  >>  Token.CATCH;  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Node    c    =    tryBlock.getType()    ==    Token.CATCH;    Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    	non-compiled	[CE]  incompatible  types	92	None	replace
338	[BUG]  [BUGGY]  Preconditions.checkState(tries.getType()  ==  Token.FUNCTION);  [CE]  cannot  find  symbol  tries  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tries.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tries.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  cannot  find  symbol  tries	15	None	replace
339	[BUG]  [BUGGY]  NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]            RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    NodeUtil.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  cannot  find  symbol	36	None	replace
340	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]              RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    NodeUtil.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  cannot  find  symbol	36	None	replace
341	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  tryBlock.getType()  ==  Token.EXPR_RESULT);  NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]                RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  tryBlock.getType()  ==  Token.EXPR_RESULT);  NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  tryBlock.getType()  ==  Token.EXPR_RESULT);  NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    NodeUtil.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  cannot  find  symbol	36	None	replace
342	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  tryBlock.getType()  ==  Token.EXPR_RESULT);  NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RES  [CE]  ')'  expected  [FE]                  RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  tryBlock.getType()  ==  Token.EXPR_RESULT);  NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RES  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  tryBlock.getType()  ==  Token.EXPR_RESULT);  NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RES	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    NodeUtil.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  ')'  expected	36	None	replace
343	[BUG]  [BUGGY]  Node  exitType  =  tryBlock.getExitType()  &&  labelName.equals(n.getString());  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock.getExitType()  &&  labelName.equals(n.getString());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock.getExitType()  &&  labelName.equals(n.getString());	  Node    exitType    =    tryBlock.getExitType();    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	144	None	replace
344	[BUG]  [BUGGY]  Node  exitType  =  tryBlock.getExitType(),  labelName);  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock.getExitType(),  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock.getExitType(),  labelName);	  Node    exitType    =    tryBlock.getExitType();    	non-compiled	[CE]  ';'  expected	144	None	replace
345	[BUG]  [BUGGY]  Node  exitType  =  tryBlock.getExitType()  ||  labelName.equals(n.getString());  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock.getExitType()  ||  labelName.equals(n.getString());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock.getExitType()  ||  labelName.equals(n.getString());	  Node    exitType    =    tryBlock.getExitType();    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	144	None	replace
346	[BUG]  [BUGGY]  Node  exitType  =  tryBlock.getExitType()  -  1;  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock.getExitType()  -  1;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock.getExitType()  -  1;	  Node    exitType    =    tryBlock.getExitType();    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	144	None	replace
347	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  AssertionFailedError  	77	2	add
348	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  AssertionFailedError  	77	2	add
349	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	77	6	add
350	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  >=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	77	6	add
351	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  >>  Token.EXPR_RESULT);  [CE]  bad  operand  types  for  binary  operator  '||'  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  >>  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  >>  Token.EXPR_RESULT);	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '||'	77	None	add
352	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  AssertionFailedError  	77	2	add
353	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  AssertionFailedError  	77	2	add
354	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  NodeUtil.isExpressionNode(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  NodeUtil.isExpressionNode(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    NodeUtil.isExpressionNode(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  	non-compiled	[CE]  cannot  find  symbol	77	None	add
355	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  	non-compiled	[CE]  cannot  find  symbol	77	None	add
356	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(n!=  null);	          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=    null);    	compilable	  [FE]  AssertionFailedError  	56	6	replace
357	[BUG]  [BUGGY]  Preconditions.checkState(n!=  null);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n!=  null);	          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=    null);    	compilable	  [FE]  AssertionFailedError  	56	6	replace
358	[BUG]  [BUGGY]  Preconditions.checkState(tries!=  null);  [CE]  cannot  find  symbol  tries  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tries!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tries!=  null);	          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=    null);    	non-compiled	[CE]  cannot  find  symbol  tries	56	None	replace
359	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  ||  tryBlock.getType()  ==  Token.NAME);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock!=  null  ||  tryBlock.getType()  ==  Token.NAME);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.NAME);    	compilable	  [FE]  AssertionFailedError  	54	6	replace
360	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  ||  tryBlock.getType()  ==  Token.NAME);  [FE]  AssertionFailedError  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  ||  tryBlock.getType()  ==  Token.NAME);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=  null  ||  tryBlock.getType()  ==  Token.NAME);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.NAME);    	compilable	  [FE]  AssertionFailedError  	54	6	replace
361	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.NAME);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.NAME);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.NAME);    	compilable	  [FE]  RuntimeException  	54	6	replace
362	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.NAME);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.NAME);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.NAME);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.NAME);    	compilable	  [FE]  RuntimeException  	54	6	replace
363	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock  ==  null  ||  tryBlock.getType()  ==  Token.NAME);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock  ==  null  ||  tryBlock.getType()  ==  Token.NAME);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.NAME);    	compilable	  [FE]  RuntimeException  	54	6	replace
364	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock  ==  null  ||  tryBlock.getType()  ==  Token.NAME);  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock  ==  null  ||  tryBlock.getType()  ==  Token.NAME);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock  ==  null  ||  tryBlock.getType()  ==  Token.NAME);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.NAME);    	compilable	  [FE]  RuntimeException  	54	6	replace
365	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkArgument(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.NAME);    	compilable	  [FE]  RuntimeException  	54	6	replace
366	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.NAME);    	compilable	  [FE]  RuntimeException  	54	6	replace
367	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CATCH);  Node  n  =  tryBlock.getNext();  Preconditions.checkState(n.getType()  ==  Token.CATCH);  [CE]  variable  n  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CATCH);  Node  n  =  tryBlock.getNext();  Preconditions.checkState(n.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()    ==    Token.CATCH);    Node  n  =  tryBlock.getNext();  Preconditions.checkState(n.getType()  ==  Token.CATCH);	  	non-compiled	[CE]  variable  n  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	112	None	add
368	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CATCH);  Preconditions.checkState(n.getType()!=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(n.getType()    ==    Token.CATCH);    Preconditions.checkState(n.getType()!=  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	112	6	add
369	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CATCH);  Preconditions.checkState(n.getType()!=  Token.CATCH);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CATCH);  Preconditions.checkState(n.getType()!=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()    ==    Token.CATCH);    Preconditions.checkState(n.getType()!=  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	112	6	add
370	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CATCH);  Preconditions.checkState(n.getType()  >>  Token.CATCH);  [CE]  no  suitable  method  found  for  checkState(int)  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CATCH);  Preconditions.checkState(n.getType()  >>  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()    ==    Token.CATCH);    Preconditions.checkState(n.getType()  >>  Token.CATCH);	  	non-compiled	[CE]  no  suitable  method  found  for  checkState(int)	112	None	add
371	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CATCH);  Preconditions.checkState(n.getType()  >=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(n.getType()    ==    Token.CATCH);    Preconditions.checkState(n.getType()  >=  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	112	6	add
372	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CATCH);  Preconditions.checkState(n.getType()  >=  Token.CATCH);  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CATCH);  Preconditions.checkState(n.getType()  >=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()    ==    Token.CATCH);    Preconditions.checkState(n.getType()  >=  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	112	6	add
373	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CATCH);  NodeUtil.checkState(n.getType()  ==  Token.CATCH);  [CE]  cannot  find  symbol  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CATCH);  NodeUtil.checkState(n.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()    ==    Token.CATCH);    NodeUtil.checkState(n.getType()  ==  Token.CATCH);	  	non-compiled	[CE]  cannot  find  symbol	112	None	add
374	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  &&  tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  &&  tryBlock.getType()  ==  Token.CATCH);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.CATCH);    	compilable	  [FE]  RuntimeException  	119	6	replace
375	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  &&  tryBlock.getType()  ==  Token.CATCH);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  &&  tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  &&  tryBlock.getType()  ==  Token.CATCH);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.CATCH);    	compilable	  [FE]  RuntimeException  	119	6	replace
376	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()!=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()!=  Token.CATCH);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.CATCH);    	compilable	  [FE]  AssertionFailedError  	119	6	replace
377	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()!=  Token.CATCH);  [FE]  AssertionFailedError  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()!=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()!=  Token.CATCH);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.CATCH);    	compilable	  [FE]  AssertionFailedError  	119	6	replace
378	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()!=  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.CATCH);    	compilable	  [FE]  AssertionFailedError  	119	6	replace
379	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  [FE]  AssertionFailedError  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.CATCH);    	compilable	  [FE]  AssertionFailedError  	119	6	replace
380	[BUG]  [BUGGY]  Preconditions.checkState(tries.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  [CE]  cannot  find  symbol  tries  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tries.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tries.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.CATCH);    	non-compiled	[CE]  cannot  find  symbol  tries	119	None	replace
381	[BUG]  [BUGGY]  Node  exitType  =  n.getFirstChild();  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  n.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  n.getFirstChild();	  Node    exitType    =    tryBlock.getFirstChild();    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	167	None	replace
382	[BUG]  [BUGGY]  Node  exitType  =  tryBlock.getString();  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock.getString();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock.getString();	  Node    exitType    =    tryBlock.getFirstChild();    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	167	None	replace
383	[BUG]  [BUGGY]  Node  tryBlock  =  tryBlock.getNext();  [CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]        RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  tryBlock  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  tryBlock  =  tryBlock.getNext();	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Node    tryBlock.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	120	None	replace
384	[BUG]  [BUGGY]  Node  tryBlock.getType()  ==  Token.FUNCTION);  [CE]  ';'  expected  [FE]          RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  tryBlock.getType()  ==  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Node    tryBlock.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  ';'  expected	120	None	replace
385	[BUG]  [BUGGY]  Node  tryBlock  =  tryBlock.getType();  [CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]            RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  tryBlock  =  tryBlock.getType();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  tryBlock  =  tryBlock.getType();	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Node    tryBlock.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	120	None	replace
386	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Node  tryBlock  =  tryBlock.getType();  [CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]              RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Node  tryBlock  =  tryBlock.getType();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Node  tryBlock  =  tryBlock.getType();	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Node    tryBlock.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	120	None	replace
387	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]              RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  tryBlock.getType()!=  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()    >>    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	37	6	replace
388	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  tryBlock.getType()!=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]              RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  tryBlock.getType()!=  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()    >>    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	37	6	replace
389	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]                RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  tryBlock.getType()  >>  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  tryBlock.getType()  >>  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()    >>    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	37	6	replace
390	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  tryBlock.getType()  >>  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]                RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  tryBlock.getType()  >>  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  tryBlock.getType()  >>  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()    >>    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	37	6	replace
391	[BUG]  [BUGGY]  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  [CE]  cannot  find  symbol  [FE]        RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    NodeUtil.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  cannot  find  symbol	173	None	replace
392	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  [CE]  cannot  find  symbol  [FE]          RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    NodeUtil.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  cannot  find  symbol	173	None	replace
393	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  [CE]  cannot  find  symbol  [FE]            RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    NodeUtil.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  cannot  find  symbol	173	None	replace
394	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION,  labelName);  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  [CE]  cannot  find  symbol  [FE]              RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION,  labelName);  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION,  labelName);  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    NodeUtil.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  cannot  find  symbol	173	None	replace
395	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  null  :  tryBlock.getCurrentStructure();  [CE]  cannot  find  symbol  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  null  :  tryBlock.getCurrentStructure();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock!=  null?  null  :  tryBlock.getCurrentStructure();	  Node    c    =    tryBlock.getCurrentStructure();    	non-compiled	[CE]  cannot  find  symbol	13	None	replace
396	[BUG]  [BUGGY]  Node  c  =  tryBlock.getStructure();  [CE]  cannot  find  symbol  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getStructure();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock.getStructure();	  Node    c    =    tryBlock.getCurrentStructure();    	non-compiled	[CE]  cannot  find  symbol	13	None	replace
397	[BUG]  [BUGGY]  Node  c  =  tryBlock.getNextStructure();  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getNextStructure();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock.getNextStructure();	  Node    c    =    tryBlock.getCurrentStructure();    	non-compiled	[CE]  cannot  find  symbol	13	None	replace
398	[BUG]  [BUGGY]  Node  c  =  tryBlock.getCurrentStructure()  ||  labelName.equals(n.getString());  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getCurrentStructure()  ||  labelName.equals(n.getString());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock.getCurrentStructure()  ||  labelName.equals(n.getString());	  Node    c    =    tryBlock.getCurrentStructure();    	non-compiled	[CE]  cannot  find  symbol	13	None	replace
399	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  null  :  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  escapeType  =  tryBlock!=  null?  null  :  tryBlock.getNext();	          Node    escapeType    =    tryBlock.getNext();    Node    escapeType    =    tryBlock.getParent();    	compilable	  [FE]  AssertionFailedError  	175	6	replace
400	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  null  :  tryBlock.getNext();  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  null  :  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  null  :  tryBlock.getNext();	          Node    escapeType    =    tryBlock.getNext();    Node    escapeType    =    tryBlock.getParent();    	compilable	  [FE]  AssertionFailedError  	175	6	replace
401	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  null  :  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  escapeType  =  tryBlock!=  null?  null  :  tryBlock.getParent();	          Node    escapeType    =    tryBlock.getNext();    Node    escapeType    =    tryBlock.getParent();    	compilable	  [FE]  AssertionFailedError  	175	6	replace
402	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  null  :  tryBlock.getParent();  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  null  :  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  null  :  tryBlock.getParent();	          Node    escapeType    =    tryBlock.getNext();    Node    escapeType    =    tryBlock.getParent();    	compilable	  [FE]  AssertionFailedError  	175	6	replace
403	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()    >=    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	68	6	add
404	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()    >=    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	68	6	add
405	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()    >=    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	68	6	add
406	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()    >=    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	68	6	add
407	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()    >=    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	68	6	add
408	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()    >=    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	68	6	add
409	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >>  Token.FUNCTION);  [CE]  no  suitable  method  found  for  checkState(int)  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >>  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()    >=    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >>  Token.FUNCTION);	  	non-compiled	[CE]  no  suitable  method  found  for  checkState(int)	68	None	add
410	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >>  Token.FUNCTION);  [CE]  no  suitable  method  found  for  checkState(int)  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >>  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()    >=    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >>  Token.FUNCTION);	  	non-compiled	[CE]  no  suitable  method  found  for  checkState(int)	68	None	add
411	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >>  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  [CE]  no  suitable  method  found  for  checkState(int)  [FE]              RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >>  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()    >=    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  >>  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);	  	non-compiled	[CE]  no  suitable  method  found  for  checkState(int)	68	None	add
412	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  returnedType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  returnType  =  tryBlock.getFirstChild();  Node  returnedType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    returnedType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	45	6	replace
413	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  returnedType  =  tryBlock.getNext();  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  returnedType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getFirstChild();  Node  returnedType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    returnedType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	45	6	replace
414	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  n.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  n.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    returnedType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	45	6	replace
415	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  n.getNext();  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  n.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  n.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    returnedType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	45	6	replace
416	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  tryBlock.getParent();	          Node    returnType    =    tryBlock.getNext();    Node    returnedType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	45	6	replace
417	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  tryBlock.getParent();  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  tryBlock.getParent();	          Node    returnType    =    tryBlock.getNext();    Node    returnedType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	45	6	replace
418	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getType();  Node  returnedType  =  tryBlock.getNext();  [CE]  incompatible  types  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getType();  Node  returnedType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getType();  Node  returnedType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    returnedType    =    tryBlock.getNext();    	non-compiled	[CE]  incompatible  types	45	None	replace
419	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.CATCH);        Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	88	6	add
420	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.CATCH);        Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	88	6	add
421	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.CATCH);        Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	88	6	add
422	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.CATCH);        Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	88	6	add
423	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.CATCH);        Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	88	6	add
424	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.CATCH);        Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	88	6	add
425	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Node  c  =  tryBlock.getNext();  Preconditions.checkState(c.getType()  ==  Token.CATCH);  Preconditions.checkState(c.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.CATCH);        Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Node  c  =  tryBlock.getNext();  Preconditions.checkState(c.getType()  ==  Token.CATCH);  Preconditions.checkState(c.getType()  ==  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	88	6	add
426	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Node  c  =  tryBlock.getNext();  Preconditions.checkState(c.getType()  ==  Token.CATCH);  Preconditions.checkState(c.getType()  ==  Token.CATCH);  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Node  c  =  tryBlock.getNext();  Preconditions.checkState(c.getType()  ==  Token.CATCH);  Preconditions.checkState(c.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.CATCH);        Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Node  c  =  tryBlock.getNext();  Preconditions.checkState(c.getType()  ==  Token.CATCH);  Preconditions.checkState(c.getType()  ==  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	88	6	add
427	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.CATCH);        Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	88	6	add
428	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH);  [FE]  RuntimeException  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.CATCH);        Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	88	6	add
429	[BUG]  [BUGGY]  tryMinimizeExits(exitType,  labelName,  exitType,  labelName);  [CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(exitType,  labelName,  exitType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(exitType,  labelName,  exitType,  labelName);	  tryMinimizeExits(exitType,    labelName,    exitType);    	non-compiled	[CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;	178	None	replace
430	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getFirstChild()!=    null);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);	  	compilable	  [FE]  AssertionFailedError  	155	2	add
431	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getFirstChild()!=    null);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);	  	compilable	  [FE]  AssertionFailedError  	155	2	add
432	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getFirstChild()!=    null);    NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);	  	non-compiled	[CE]  cannot  find  symbol	155	None	add
433	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getFirstChild()!=    null);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);	  	compilable	  [FE]  AssertionFailedError  	155	2	add
434	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getFirstChild()!=    null);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);	  	compilable	  [FE]  AssertionFailedError  	155	2	add
435	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  NodeUtil.checkFunction(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  NodeUtil.checkFunction(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getFirstChild()!=    null);    NodeUtil.checkFunction(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);	  	non-compiled	[CE]  cannot  find  symbol	155	None	add
436	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getLastChild()!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getFirstChild()!=    null);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getLastChild()!=  null);	  	compilable	  [FE]  AssertionFailedError  	155	2	add
437	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getLastChild()!=  null);  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getLastChild()!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getFirstChild()!=    null);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getLastChild()!=  null);	  	compilable	  [FE]  AssertionFailedError  	155	2	add
438	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()  >=  null);  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]              AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()  >=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getFirstChild()!=    null);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()  >=  null);	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	155	None	add
439	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  elseBlock  =  tryBlock.getNext();  [BUGGY]    null);  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  elseBlock  =  tryBlock.getNext();	          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock    	compilable	  [FE]  AssertionFailedError  	62	6	replace
440	[BUG]  [BUGGY]  Node  elseBlock  =  tryBlock.getNext();  [FE]  AssertionFailedError  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  elseBlock  =  tryBlock.getNext();  [BUGGY]    null);  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  elseBlock  =  tryBlock.getNext();	          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock    	compilable	  [FE]  AssertionFailedError  	62	6	replace
441	[BUG]  [BUGGY]  tryMinimizeExits(labelName,  exitType,  labelName,  catchNode);  [CE]  cannot  find  symbol  catchNode  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(labelName,  exitType,  labelName,  catchNode);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(labelName,  exitType,  labelName,  catchNode);	  tryMinimizeExits(labelName,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol  catchNode	83	None	replace
442	[BUG]  [BUGGY]  tryMinimizeExits(labelName,  exitType,  labelName,  false);  [CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(labelName,  exitType,  labelName,  false);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(labelName,  exitType,  labelName,  false);	  tryMinimizeExits(labelName,    exitType,    labelName);    	non-compiled	[CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;	83	None	replace
443	[BUG]  [BUGGY]  tryMinimizeExits(labelName,  exitType,  labelName,  n);  [CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;  [FE]                      AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(labelName,  exitType,  labelName,  n);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(labelName,  exitType,  labelName,  n);	  tryMinimizeExits(labelName,    exitType,    labelName);    	non-compiled	[CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;	83	None	replace
444	[BUG]  [BUGGY]  tryMinimizeExits(labelName,  n,  exitType);  [CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(labelName,  n,  exitType);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(labelName,  n,  exitType);	  tryMinimizeExits(labelName,    exitType);    	non-compiled	[CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;	96	None	replace
445	[BUG]  [BUGGY]  tryMinimizeExits(labelName,  escapeType,  labelName);  [CE]  cannot  find  symbol  escapeType  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(labelName,  escapeType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(labelName,  escapeType,  labelName);	  tryMinimizeExits(labelName,    exitType);    	non-compiled	[CE]  cannot  find  symbol  escapeType	96	None	replace
446	[BUG]  [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getNext()  :  labelName;  [CE]  incompatible  types  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getNext()  :  labelName;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock!=  null?  tryBlock.getNext()  :  labelName;	  Node    returnType    =    tryBlock!=    null?    tryBlock.getNext()    :    exitType;    	non-compiled	[CE]  incompatible  types	133	None	replace
447	[BUG]  [BUGGY]  Node  returnType  =  tryBlock  ==  null?  tryBlock.getNext()  :  exitType;  [CE]  incompatible  types  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock  ==  null?  tryBlock.getNext()  :  exitType;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock  ==  null?  tryBlock.getNext()  :  exitType;	  Node    returnType    =    tryBlock!=    null?    tryBlock.getNext()    :    exitType;    	non-compiled	[CE]  incompatible  types	133	None	replace
448	[BUG]  [BUGGY]  Node  returnType  =  tryBlock  ==  null?  tryBlock.getNext()  :  labelName;  [CE]  incompatible  types  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock  ==  null?  tryBlock.getNext()  :  labelName;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock  ==  null?  tryBlock.getNext()  :  labelName;	  Node    returnType    =    tryBlock!=    null?    tryBlock.getNext()    :    exitType;    	non-compiled	[CE]  incompatible  types	133	None	replace
449	[BUG]  [BUGGY]  Node  exitType  =  tryBlock!=  null?  tryBlock.getNext()  :  labelName;  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock!=  null?  tryBlock.getNext()  :  labelName;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock!=  null?  tryBlock.getNext()  :  labelName;	  Node    exitType    =    tryBlock!=    null?    tryBlock.getNext()    :    exitType;    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	145	None	replace
450	[BUG]  [BUGGY]  Node  exitType  =  tryBlock  ==  null?  tryBlock.getNext()  :  labelName;  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock  ==  null?  tryBlock.getNext()  :  labelName;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock  ==  null?  tryBlock.getNext()  :  labelName;	  Node    exitType    =    tryBlock!=    null?    tryBlock.getNext()    :    exitType;    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	145	None	replace
451	[BUG]  [BUGGY]  Node  exitType  =  tryBlock!=  null?  tryBlock.getNext()  :  LabelName;  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock!=  null?  tryBlock.getNext()  :  LabelName;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock!=  null?  tryBlock.getNext()  :  LabelName;	  Node    exitType    =    tryBlock!=    null?    tryBlock.getNext()    :    exitType;    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	145	None	replace
452	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	32	6	add
453	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	32	6	add
454	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	32	6	add
455	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	32	6	add
456	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	32	6	add
457	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	32	6	add
458	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(triesBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  triesBlock  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(triesBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(triesBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);	  	non-compiled	[CE]  cannot  find  symbol  triesBlock	32	None	add
459	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	32	6	add
460	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	32	6	add
461	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]              RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EMPTY);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EMPTY);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	32	6	add
462	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EMPTY);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]              RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EMPTY);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EMPTY);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	32	6	add
463	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getFirstChild();  Node  exitType  =  tryBlock.getNext();  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getFirstChild();  Node  exitType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getFirstChild();  Node  exitType  =  tryBlock.getNext();	          Node    escapeType    =    tryBlock.getNext();    Node    exitType    =    tryBlock.getNext();    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	108	None	replace
464	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getParent();  Node  exitType  =  tryBlock.getNext();  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getParent();  Node  exitType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getParent();  Node  exitType  =  tryBlock.getNext();	          Node    escapeType    =    tryBlock.getNext();    Node    exitType    =    tryBlock.getNext();    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	108	None	replace
465	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  &&  tryBlock.getFirstChild()!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  &&  tryBlock.getFirstChild()!=  null);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getFirstChild()!=    null);    	compilable	  [FE]  RuntimeException  	156	6	replace
466	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  &&  tryBlock.getFirstChild()!=  null);  [FE]  RuntimeException  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  &&  tryBlock.getFirstChild()!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  &&  tryBlock.getFirstChild()!=  null);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getFirstChild()!=    null);    	compilable	  [FE]  RuntimeException  	156	6	replace
467	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getLastChild()!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getLastChild()!=  null);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getFirstChild()!=    null);    	compilable	  [FE]  AssertionFailedError  	156	6	replace
468	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getLastChild()!=  null);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getLastChild()!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getLastChild()!=  null);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getFirstChild()!=    null);    	compilable	  [FE]  AssertionFailedError  	156	6	replace
469	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()  ==  null);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getFirstChild()!=    null);    	compilable	  [FE]  RuntimeException  	156	6	replace
470	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()  ==  null);  [FE]  RuntimeException  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()  ==  null);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getFirstChild()!=    null);    	compilable	  [FE]  RuntimeException  	156	6	replace
471	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getFirstChild()!=    null);    	compilable	  [FE]  AssertionFailedError  	156	6	replace
472	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getFirstChild()!=    null);    	compilable	  [FE]  AssertionFailedError  	156	6	replace
473	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getFunction();  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getFunction();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getFunction();	  Node    escapeType    =    tryBlock.getParent();    	non-compiled	[CE]  cannot  find  symbol	30	None	replace
474	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock  ==  null?  null  :  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  escapeType  =  tryBlock  ==  null?  null  :  tryBlock.getNext();	          Node    escapeType    =    tryBlock.getNext();    node    escapeType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	111	6	replace
475	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock  ==  null?  null  :  tryBlock.getNext();  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock  ==  null?  null  :  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock  ==  null?  null  :  tryBlock.getNext();	          Node    escapeType    =    tryBlock.getNext();    node    escapeType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	111	6	replace
476	[BUG]  [BUGGY]  node  escapeType  =  tryBlock.getNext();  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  node  escapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	node  escapeType  =  tryBlock.getNext();	          Node    escapeType    =    tryBlock.getNext();    node    escapeType    =    tryBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol	111	None	replace
477	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getNext();  nodeEscaped  =  tryBlock.getNext();  [CE]  cannot  find  symbol  nodeEscaped  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getNext();  nodeEscaped  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getNext();  nodeEscaped  =  tryBlock.getNext();	          Node    escapeType    =    tryBlock.getNext();    node    escapeType    =    tryBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol  nodeEscaped	111	None	replace
478	[BUG]  [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  escapeType  =  tryBlock.getNext();  Node  returnType  =  tryBlock.getNext();  Node  escapeType  =  tryBlock.getNext();  [CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  escapeType  =  tryBlock.getNext();  Node  returnType  =  tryBlock.getNext();  Node  escapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        returnType        =        tryBlock.getNext();        Node    escapeType    =    tryBlock.getNext();    Node  returnType  =  tryBlock.getNext();  Node  escapeType  =  tryBlock.getNext();	  	non-compiled	[CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	42	None	add
479	[BUG]  [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  escapeType  =  tryBlock.getNext();  Node  exitType  =  tryBlock.getNext();  Node  escapeType  =  tryBlock.getNext();  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  escapeType  =  tryBlock.getNext();  Node  exitType  =  tryBlock.getNext();  Node  escapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        returnType        =        tryBlock.getNext();        Node    escapeType    =    tryBlock.getNext();    Node  exitType  =  tryBlock.getNext();  Node  escapeType  =  tryBlock.getNext();	  	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	42	None	add
480	[BUG]  [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  escapeType  =  tryBlock.getNext();  Node  returnedType  =  tryBlock.getNext();  Node  escapeType  =  tryBlock.getNext();  [CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  escapeType  =  tryBlock.getNext();  Node  returnedType  =  tryBlock.getNext();  Node  escapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        returnType        =        tryBlock.getNext();        Node    escapeType    =    tryBlock.getNext();    Node  returnedType  =  tryBlock.getNext();  Node  escapeType  =  tryBlock.getNext();	  	non-compiled	[CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	42	None	add
481	[BUG]  [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  escapeType  =  tryBlock.getNext();  Node  returnType  =  startType.getNext();  Node  escapeType  =  tryBlock.getNext();  [CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  escapeType  =  tryBlock.getNext();  Node  returnType  =  startType.getNext();  Node  escapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        returnType        =        tryBlock.getNext();        Node    escapeType    =    tryBlock.getNext();    Node  returnType  =  startType.getNext();  Node  escapeType  =  tryBlock.getNext();	  	non-compiled	[CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	42	None	add
482	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    exitType);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);	  	compilable	  [FE]  RuntimeException  	136	6	add
483	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    exitType);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);	  	compilable	  [FE]  RuntimeException  	136	6	add
484	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    exitType);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT,  exitType);	  	compilable	  [FE]  RuntimeException  	136	6	add
485	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT,  exitType);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    exitType);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT,  exitType);	  	compilable	  [FE]  RuntimeException  	136	6	add
486	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);  NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);  [CE]  cannot  find  symbol  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);  NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    exitType);    NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);	  	non-compiled	[CE]  cannot  find  symbol	136	None	add
487	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);  Preconditions.checkState(tryBlock.getType()  >>  Token.EXPR_RESULT,  exitType);  [CE]  no  suitable  method  found  for  checkState(int,int)  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);  Preconditions.checkState(tryBlock.getType()  >>  Token.EXPR_RESULT,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    exitType);    Preconditions.checkState(tryBlock.getType()  >>  Token.EXPR_RESULT,  exitType);	  	non-compiled	[CE]  no  suitable  method  found  for  checkState(int,int)	136	None	add
488	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    exitType);    Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT,  exitType);	  	compilable	  [FE]  RuntimeException  	136	6	add
489	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT,  exitType);  [FE]  RuntimeException  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    exitType);    Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT,  exitType);	  	compilable	  [FE]  RuntimeException  	136	6	add
490	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >>  Token.FUNCTION);  [CE]  no  suitable  method  found  for  checkState(int)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >>  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  >>  Token.FUNCTION);	  	non-compiled	[CE]  no  suitable  method  found  for  checkState(int)	16	None	add
491	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()!=    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);	  	compilable	  [FE]  AssertionFailedError  	16	2	add
492	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);	  	compilable	  [FE]  AssertionFailedError  	16	2	add
493	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  NodeUtil.checkState(tryBlock.getType()!=  Token.FUNCTION);  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  NodeUtil.checkState(tryBlock.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=    Token.FUNCTION);    NodeUtil.checkState(tryBlock.getType()!=  Token.FUNCTION);	  	non-compiled	[CE]  cannot  find  symbol	16	None	add
494	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  [Delete]  Token.FUNCTION);  [CE]  ')'  expected  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  [Delete]  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  [Delete]  Token.FUNCTION);	  	non-compiled	[CE]  ')'  expected	16	None	add
495	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);	  	compilable	  [FE]  AssertionFailedError  	114	2	add
496	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);	  	compilable	  [FE]  AssertionFailedError  	114	2	add
497	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  >>  Token.CATCH);  [CE]  no  suitable  method  found  for  checkState(int)  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  >>  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  >>  Token.CATCH);	  	non-compiled	[CE]  no  suitable  method  found  for  checkState(int)	114	None	add
498	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH);	  	compilable	  [FE]  AssertionFailedError  	114	2	add
499	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH);	  	compilable	  [FE]  AssertionFailedError  	114	2	add
500	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  NodeUtil.checkState(tryBlock.getType()!=  Token.CATCH);  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  NodeUtil.checkState(tryBlock.getType()!=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    NodeUtil.checkState(tryBlock.getType()!=  Token.CATCH);	  	non-compiled	[CE]  cannot  find  symbol	114	None	add
501	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  [Delete]  Token.CATCH);  [CE]  ')'  expected  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  [Delete]  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  [Delete]  Token.CATCH);	  	non-compiled	[CE]  ')'  expected	114	None	add
502	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.CATCH);        Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	90	6	add
503	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.CATCH);        Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	90	6	add
504	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.CATCH);        Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	90	6	add
505	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.CATCH);        Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	90	6	add
506	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  >>  Token.CATCH);  [CE]  no  suitable  method  found  for  checkState(int)  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  >>  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.CATCH);        Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  >>  Token.CATCH);	  	non-compiled	[CE]  no  suitable  method  found  for  checkState(int)	90	None	add
507	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.CATCH);        Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	90	6	add
508	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.CATCH);        Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	90	6	add
509	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.CATCH);        Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	90	6	add
510	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH);  [FE]  RuntimeException  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.CATCH);        Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	90	6	add
511	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  >>  Token.CATCH);  [CE]  no  suitable  method  found  for  checkState(int)  [FE]              RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  >>  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.CATCH);        Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  >>  Token.CATCH);	  	non-compiled	[CE]  no  suitable  method  found  for  checkState(int)	90	None	add
512	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  null.getNext()  :  tryBlock.getNext();  [CE]  <null>  cannot  be  dereferenced  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  null.getNext()  :  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  null.getNext()  :  tryBlock.getNext();	          Node    escapeType    =    tryBlock.getNext();    NOde    escapeType    =    tryBlock.getNext();    	non-compiled	[CE]  <null>  cannot  be  dereferenced	143	None	replace
513	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock  ==  null?  null.getNext()  :  tryBlock.getNext();  [CE]  <null>  cannot  be  dereferenced  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock  ==  null?  null.getNext()  :  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock  ==  null?  null.getNext()  :  tryBlock.getNext();	          Node    escapeType    =    tryBlock.getNext();    NOde    escapeType    =    tryBlock.getNext();    	non-compiled	[CE]  <null>  cannot  be  dereferenced	143	None	replace
514	[BUG]  [BUGGY]  Preconditions.checkState(labelName.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(labelName.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]          RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(labelName.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(labelName.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(labelName.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(labelName.getType()  ==  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    }    else    {    tryMinimizeExits(tryBlock,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol	172	None	replace
515	[BUG]  [BUGGY]  NodeUtil.checkState(n.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]            RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  NodeUtil.checkState(n.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	NodeUtil.checkState(n.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    }    else    {    tryMinimizeExits(tryBlock,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol	172	None	replace
516	[BUG]  [BUGGY]  Preconditions.checkState(labelName.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(elseBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]              RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(labelName.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(elseBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(labelName.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(elseBlock.getType()  ==  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    }    else    {    tryMinimizeExits(tryBlock,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol	172	None	replace
517	[BUG]  [BUGGY]  Preconditions.checkState(labelName.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]                RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(labelName.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(labelName.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    }    else    {    tryMinimizeExits(tryBlock,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol	172	None	replace
518	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  AssertionFailedError  	20	2	add
519	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  AssertionFailedError  	20	2	add
520	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  >>  Token.EXPR_RESULT);  [CE]  bad  operand  types  for  binary  operator  '||'  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  >>  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  >>  Token.EXPR_RESULT);	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '||'	20	None	add
521	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	20	6	add
522	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  >=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	20	6	add
523	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  	non-compiled	[CE]  cannot  find  symbol	20	None	add
524	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  AssertionFailedError  	20	2	add
525	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  AssertionFailedError  	20	2	add
526	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  Node  tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [CE]  ';'  expected  [FE]              AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  Node  tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    Node  tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  	non-compiled	[CE]  ';'  expected	20	None	add
527	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.NAME);    Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);	  	compilable	  [FE]  RuntimeException  	53	6	add
528	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.NAME);    Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);	  	compilable	  [FE]  RuntimeException  	53	6	add
529	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);  Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.NAME);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.NAME);    Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.NAME);	  	compilable	  [FE]  RuntimeException  	53	6	add
530	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);  Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.NAME);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);  Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.NAME);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.NAME);    Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.NAME);	  	compilable	  [FE]  RuntimeException  	53	6	add
531	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);  Preconditions.checkState(tryBlock  >=  null  &&  tryBlock.getType()  ==  Token.NAME);  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);  Preconditions.checkState(tryBlock  >=  null  &&  tryBlock.getType()  ==  Token.NAME);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.NAME);    Preconditions.checkState(tryBlock  >=  null  &&  tryBlock.getType()  ==  Token.NAME);	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	53	None	add
532	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  >=  Token.NAME);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.NAME);    Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  >=  Token.NAME);	  	compilable	  [FE]  RuntimeException  	53	6	add
533	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  >=  Token.NAME);  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  >=  Token.NAME);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.NAME);    Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  >=  Token.NAME);	  	compilable	  [FE]  RuntimeException  	53	6	add
534	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);  Preconditions.checkState(tryBlock  >>  null  &&  tryBlock.getType()  ==  Token.NAME);  [CE]  bad  operand  types  for  binary  operator  '>>'  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);  Preconditions.checkState(tryBlock  >>  null  &&  tryBlock.getType()  ==  Token.NAME);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.NAME);    Preconditions.checkState(tryBlock  >>  null  &&  tryBlock.getType()  ==  Token.NAME);	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>>'	53	None	add
535	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);  Node  tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);  [CE]  ';'  expected  [FE]              RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);  Node  tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.NAME);    Node  tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);	  	non-compiled	[CE]  ';'  expected	53	None	add
536	[BUG]  [BUGGY]  Node  tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  ';'  expected  [FE]        RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  tryBlock.getType()  ==  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Node    tryBlock.getType()    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  ';'  expected	148	None	replace
537	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  exitType);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH,    exitType);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  exitType);	  	compilable	  [FE]  RuntimeException  	134	6	add
538	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  exitType);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  exitType);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  exitType);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH,    exitType);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  exitType);	  	compilable	  [FE]  RuntimeException  	134	6	add
539	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  exitType);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH,    exitType);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH,  exitType);	  	compilable	  [FE]  RuntimeException  	134	6	add
540	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  exitType);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH,  exitType);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  exitType);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH,    exitType);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH,  exitType);	  	compilable	  [FE]  RuntimeException  	134	6	add
541	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  exitType);  Preconditions.checkState(tryBlock.getType()  >>  Token.CATCH,  exitType);  [CE]  no  suitable  method  found  for  checkState(int,int)  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  exitType);  Preconditions.checkState(tryBlock.getType()  >>  Token.CATCH,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH,    exitType);    Preconditions.checkState(tryBlock.getType()  >>  Token.CATCH,  exitType);	  	non-compiled	[CE]  no  suitable  method  found  for  checkState(int,int)	134	None	add
542	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  exitType);  Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH,    exitType);    Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH,  exitType);	  	compilable	  [FE]  RuntimeException  	134	6	add
543	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  exitType);  Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH,  exitType);  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  exitType);  Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH,    exitType);    Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH,  exitType);	  	compilable	  [FE]  RuntimeException  	134	6	add
544	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  exitType);  NodeUtil.checkState(tryBlock.getType()  ==  Token.CATCH,  exitType);  [CE]  cannot  find  symbol  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  exitType);  NodeUtil.checkState(tryBlock.getType()  ==  Token.CATCH,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH,    exitType);    NodeUtil.checkState(tryBlock.getType()  ==  Token.CATCH,  exitType);	  	non-compiled	[CE]  cannot  find  symbol	134	None	add
545	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkArgument(tryBlock  ==  null);	  Preconditions.checkArgument(tryBlock!=    null);    	compilable	  [FE]  RuntimeException  	180	6	replace
546	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock  ==  null);  [FE]  RuntimeException  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock  ==  null);	  Preconditions.checkArgument(tryBlock!=    null);    	compilable	  [FE]  RuntimeException  	180	6	replace
547	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkArgument(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkArgument(tryBlock!=    null);    	compilable	  [FE]  RuntimeException  	180	6	replace
548	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkArgument(tryBlock!=    null);    	compilable	  [FE]  RuntimeException  	180	6	replace
549	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null);  preconditions.checkState(tryBlock!=  null);  [CE]  cannot  find  symbol  preconditions  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null);  preconditions.checkState(tryBlock!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=  null);  preconditions.checkState(tryBlock!=  null);	          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock    >=    null);    	non-compiled	[CE]  cannot  find  symbol  preconditions	59	None	replace
550	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    labelName);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);	  	compilable	  [FE]  RuntimeException  	138	6	add
551	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    labelName);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);	  	compilable	  [FE]  RuntimeException  	138	6	add
552	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    labelName);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT,  labelName);	  	compilable	  [FE]  RuntimeException  	138	6	add
553	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT,  labelName);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    labelName);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT,  labelName);	  	compilable	  [FE]  RuntimeException  	138	6	add
554	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    labelName);    Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT,  labelName);	  	compilable	  [FE]  RuntimeException  	138	6	add
555	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT,  labelName);  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    labelName);    Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT,  labelName);	  	compilable	  [FE]  RuntimeException  	138	6	add
556	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  [CE]  cannot  find  symbol  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    labelName);    NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);	  	non-compiled	[CE]  cannot  find  symbol	138	None	add
557	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  Preconditions.checkState(tryBlock.getType()  >>  Token.EXPR_RESULT,  labelName);  [CE]  no  suitable  method  found  for  checkState(int,String)  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  Preconditions.checkState(tryBlock.getType()  >>  Token.EXPR_RESULT,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    labelName);    Preconditions.checkState(tryBlock.getType()  >>  Token.EXPR_RESULT,  labelName);	  	non-compiled	[CE]  no  suitable  method  found  for  checkState(int,String)	138	None	add
558	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getString(),  labelName;  [CE]  incompatible  types  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getString(),  labelName;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getString(),  labelName;	  Node    returnType    =    tryBlock.getString();    	non-compiled	[CE]  incompatible  types	7	None	replace
559	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getString(),  labelName);  [CE]  ';'  expected  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getString(),  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getString(),  labelName);	  Node    returnType    =    tryBlock.getString();    	non-compiled	[CE]  ';'  expected	7	None	replace
560	[BUG]  [BUGGY]  Node  labelName  =  n.getLastChild();  [CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  n.getLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  n.getLastChild();	  Node    labelName    =    tryBlock.getLastChild();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	1	None	replace
561	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.isExitType());  [CE]  cannot  find  symbol  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.isExitType());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=  null,  tryBlock.isExitType());	  Preconditions.checkState(tryBlock!=    null,    tryBlock.isExit());    	non-compiled	[CE]  cannot  find  symbol	182	None	replace
562	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock  ==  null,  tryBlock.isExit());  [CE]  cannot  find  symbol  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock  ==  null,  tryBlock.isExit());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock  ==  null,  tryBlock.isExit());	  Preconditions.checkState(tryBlock!=    null,    tryBlock.isExit());    	non-compiled	[CE]  cannot  find  symbol	182	None	replace
563	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null,  n.isExit());  [CE]  cannot  find  symbol  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null,  n.isExit());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=  null,  n.isExit());	  Preconditions.checkState(tryBlock!=    null,    tryBlock.isExit());    	non-compiled	[CE]  cannot  find  symbol	182	None	replace
564	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.getParent().isExit());  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.getParent().isExit());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=  null,  tryBlock.getParent().isExit());	  Preconditions.checkState(tryBlock!=    null,    tryBlock.isExit());    	non-compiled	[CE]  cannot  find  symbol	182	None	replace
565	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  returnType  =  tryBlock.getFirstChild();  [CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  returnType  =  tryBlock.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    returnType    =    tryBlock.getFirstChild();    Node  returnType  =  tryBlock.getFirstChild();	  	non-compiled	[CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	5	None	add
566	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  exitType  =  tryBlock.getFirstChild();  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  exitType  =  tryBlock.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    returnType    =    tryBlock.getFirstChild();    Node  exitType  =  tryBlock.getFirstChild();	  	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	5	None	add
567	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  returnType  =  tryBlock.getLastChild();  [CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  returnType  =  tryBlock.getLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    returnType    =    tryBlock.getFirstChild();    Node  returnType  =  tryBlock.getLastChild();	  	non-compiled	[CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	5	None	add
568	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  escapeType  =  tryBlock.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node    returnType    =    tryBlock.getFirstChild();    Node  escapeType  =  tryBlock.getFirstChild();	  	compilable	  [FE]  AssertionFailedError  	5	2	add
569	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  escapeType  =  tryBlock.getFirstChild();  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  escapeType  =  tryBlock.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    returnType    =    tryBlock.getFirstChild();    Node  escapeType  =  tryBlock.getFirstChild();	  	compilable	  [FE]  AssertionFailedError  	5	2	add
570	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  labelName  =  tryBlock.getFirstChild();  [CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  labelName  =  tryBlock.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    returnType    =    tryBlock.getFirstChild();    Node  labelName  =  tryBlock.getFirstChild();	  	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	5	None	add
571	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  returnedType  =  tryBlock.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node    returnType    =    tryBlock.getFirstChild();    Node  returnedType  =  tryBlock.getFirstChild();	  	compilable	  [FE]  AssertionFailedError  	5	2	add
572	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  returnedType  =  tryBlock.getFirstChild();  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  returnedType  =  tryBlock.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    returnType    =    tryBlock.getFirstChild();    Node  returnedType  =  tryBlock.getFirstChild();	  	compilable	  [FE]  AssertionFailedError  	5	2	add
573	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock!=        null);        Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock!=  null);	  	compilable	  [FE]  AssertionFailedError  	55	2	add
574	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock!=  null);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock!=        null);        Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock!=  null);	  	compilable	  [FE]  AssertionFailedError  	55	2	add
575	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  >>  null);  [CE]  bad  operand  types  for  binary  operator  '>>'  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  >>  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock!=        null);        Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  >>  null);	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>>'	55	None	add
576	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  >=  null);  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  >=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock!=        null);        Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  >=  null);	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	55	None	add
577	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock!=        null);        Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock!=  null);	  	compilable	  [FE]  RuntimeException  	55	6	add
578	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock!=  null);  [FE]  RuntimeException  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock!=        null);        Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock!=  null);	  	compilable	  [FE]  RuntimeException  	55	6	add
579	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock!=        null);        Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);	  	compilable	  [FE]  RuntimeException  	55	6	add
580	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);  [FE]  RuntimeException  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock!=        null);        Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);	  	compilable	  [FE]  RuntimeException  	55	6	add
581	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  >=  null);  Preconditions.checkState(tryBlock!=  null);  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]              AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  >=  null);  Preconditions.checkState(tryBlock!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock!=        null);        Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock  >=  null);  Preconditions.checkState(tryBlock!=  null);	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	55	None	add
582	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock!=  null);  Preconditions.checkArgument(tryBlock!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkArgument(tryBlock!=    null);    Preconditions.checkArgument(tryBlock!=  null);	  	compilable	  [FE]  AssertionFailedError  	179	2	add
583	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock!=  null);  Preconditions.checkArgument(tryBlock!=  null);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock!=  null);  Preconditions.checkArgument(tryBlock!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock!=    null);    Preconditions.checkArgument(tryBlock!=  null);	  	compilable	  [FE]  AssertionFailedError  	179	2	add
584	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock!=  null);  Preconditions.checkArgument(tryBlock  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkArgument(tryBlock!=    null);    Preconditions.checkArgument(tryBlock  ==  null);	  	compilable	  [FE]  RuntimeException  	179	6	add
585	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock!=  null);  Preconditions.checkArgument(tryBlock  ==  null);  [FE]  RuntimeException  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock!=  null);  Preconditions.checkArgument(tryBlock  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock!=    null);    Preconditions.checkArgument(tryBlock  ==  null);	  	compilable	  [FE]  RuntimeException  	179	6	add
586	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock!=  null);  Preconditions.checkArgument(tryBlock  >>  null);  [CE]  bad  operand  types  for  binary  operator  '>>'  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock!=  null);  Preconditions.checkArgument(tryBlock  >>  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock!=    null);    Preconditions.checkArgument(tryBlock  >>  null);	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>>'	179	None	add
587	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock!=  null);  Preconditions.checkArgument(tryBlock  >=  null);  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock!=  null);  Preconditions.checkArgument(tryBlock  >=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock!=    null);    Preconditions.checkArgument(tryBlock  >=  null);	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	179	None	add
588	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock!=  null);  Preconditions.checkArgument(tryBlock  [BUGGY]  null);  [CE]  ')'  expected  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock!=  null);  Preconditions.checkArgument(tryBlock  [BUGGY]  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock!=    null);    Preconditions.checkArgument(tryBlock  [BUGGY]  null);	  	non-compiled	[CE]  ')'  expected	179	None	add
589	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock!=  null);  Preconditions.checkArgument(tryBlock  [Delete]  null);  [CE]  ')'  expected  [FE]              AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock!=  null);  Preconditions.checkArgument(tryBlock  [Delete]  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock!=    null);    Preconditions.checkArgument(tryBlock  [Delete]  null);	  	non-compiled	[CE]  ')'  expected	179	None	add
590	[BUG]  [BUGGY]  Node  c  =  tryBlock.getLastChild();  Node  c  =  tryBlock.getLastChild();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getLastChild();  Node  c  =  tryBlock.getLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.getLastChild();    Node  c  =  tryBlock.getLastChild();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	9	None	add
591	[BUG]  [BUGGY]  Node  c  =  tryBlock.getLastChild();  Node  c  =  attemptBlock.getLastChild();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getLastChild();  Node  c  =  attemptBlock.getLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.getLastChild();    Node  c  =  attemptBlock.getLastChild();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	9	None	add
592	[BUG]  [BUGGY]  Node  c  =  tryBlock.getLastChild();  Node  c  =  triedBlock.getLastChild();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getLastChild();  Node  c  =  triedBlock.getLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.getLastChild();    Node  c  =  triedBlock.getLastChild();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	9	None	add
593	[BUG]  [BUGGY]  Node  c  =  tryBlock.getLastChild();  Node  c  =  startBlock.getLastChild();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getLastChild();  Node  c  =  startBlock.getLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.getLastChild();    Node  c  =  startBlock.getLastChild();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	9	None	add
594	[BUG]  [BUGGY]  Node  c  =  tryBlock.getLastChild();  Node  c  =  tryingBlock.getLastChild();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getLastChild();  Node  c  =  tryingBlock.getLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.getLastChild();    Node  c  =  tryingBlock.getLastChild();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	9	None	add
595	[BUG]  [BUGGY]  Node  exitType  =  tryBlock.getParent()  -  1;  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock.getParent()  -  1;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock.getParent()  -  1;	  Node    exitType    =    tryBlock.getNext()    -    1;    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	80	None	replace
596	[BUG]  [BUGGY]  Node  exitType  =  n.getNext()  -  1;  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  n.getNext()  -  1;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  n.getNext()  -  1;	  Node    exitType    =    tryBlock.getNext()    -    1;    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	80	None	replace
597	[BUG]  [BUGGY]  Node  exitType  =  tryBlock.getPrevious();  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock.getPrevious();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock.getPrevious();	  Node    exitType    =    tryBlock.getNext()    -    1;    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	80	None	replace
598	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getEscaped(),  labelName;  [CE]  cannot  find  symbol  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getEscaped(),  labelName;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getEscaped(),  labelName;	  Node    escapeType    =    tryBlock.getEscaped();    	non-compiled	[CE]  cannot  find  symbol	147	None	replace
599	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getEscaped(),  labelName);  [CE]  ';'  expected  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getEscaped(),  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getEscaped(),  labelName);	  Node    escapeType    =    tryBlock.getEscaped();    	non-compiled	[CE]  ';'  expected	147	None	replace
600	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getSecond();  [CE]  cannot  find  symbol  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getSecond();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getSecond();	  Node    escapeType    =    tryBlock.getEscaped();    	non-compiled	[CE]  cannot  find  symbol	147	None	replace
601	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  escapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  returnType  =  tryBlock.getFirstChild();  Node  escapeType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    escapeType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	43	6	replace
602	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  escapeType  =  tryBlock.getNext();  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  escapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getFirstChild();  Node  escapeType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    escapeType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	43	6	replace
603	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getType();  Node  escapeType  =  tryBlock.getNext();  [CE]  incompatible  types  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getType();  Node  escapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getType();  Node  escapeType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    escapeType    =    tryBlock.getNext();    	non-compiled	[CE]  incompatible  types	43	None	replace
604	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getReturnType();  Node  escapeType  =  tryBlock.getNext();  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getReturnType();  Node  escapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getReturnType();  Node  escapeType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    escapeType    =    tryBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol	43	None	replace
605	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  escapeType  =  n.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  returnType  =  tryBlock.getNext();  Node  escapeType  =  n.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    escapeType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	43	6	replace
606	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  escapeType  =  n.getNext();  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  escapeType  =  n.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getNext();  Node  escapeType  =  n.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    escapeType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	43	6	replace
607	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  returnsType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  returnType  =  tryBlock.getFirstChild();  Node  returnsType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    returnsType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	122	6	replace
608	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  returnsType  =  tryBlock.getNext();  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  returnsType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getFirstChild();  Node  returnsType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    returnsType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	122	6	replace
609	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getType();  Node  returnsType  =  tryBlock.getNext();  [CE]  incompatible  types  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getType();  Node  returnsType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getType();  Node  returnsType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    returnsType    =    tryBlock.getNext();    	non-compiled	[CE]  incompatible  types	122	None	replace
610	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  tryBlock.getParent();	          Node    returnType    =    tryBlock.getNext();    Node    returnsType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	122	6	replace
611	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  tryBlock.getParent();  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  tryBlock.getParent();	          Node    returnType    =    tryBlock.getNext();    Node    returnsType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	122	6	replace
612	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  returnsType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  returnType  =  tryBlock.getParent();  Node  returnsType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    returnsType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	122	6	replace
613	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  returnsType  =  tryBlock.getNext();  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  returnsType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getParent();  Node  returnsType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    returnsType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	122	6	replace
614	[BUG]  [BUGGY]  Node  c  =  startBlock.getNext();  [CE]  cannot  find  symbol  startBlock  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  startBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  startBlock.getNext();	          Node    c    =    tryBlock.getNext();    Node    c    =    startBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol  startBlock	104	None	replace
615	[BUG]  [BUGGY]  tryMinimizeExits(tryBlock,  labelName,  exitType,  exitType);  [CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(tryBlock,  labelName,  exitType,  exitType);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(tryBlock,  labelName,  exitType,  exitType);	  tryMinimizeExits(tree,    labelName,    exitType,    exitType);    	non-compiled	[CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;	127	None	replace
616	[BUG]  [BUGGY]  tryMinimizeExits(catchNode,  labelName,  exitType,  exitType);  [CE]  cannot  find  symbol  catchNode  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(catchNode,  labelName,  exitType,  exitType);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(catchNode,  labelName,  exitType,  exitType);	  tryMinimizeExits(tree,    labelName,    exitType,    exitType);    	non-compiled	[CE]  cannot  find  symbol  catchNode	127	None	replace
617	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getReturnType(),  labelName;  [CE]  cannot  find  symbol  [FE]        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getReturnType(),  labelName;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getReturnType(),  labelName;	  Node    returnType    =    tryBlock.getReturnType();    	non-compiled	[CE]  cannot  find  symbol	3	None	replace
618	[BUG]  [BUGGY]  Node  returnType  =  tryBlock!=  null?  null  :  tryBlock.getReturnType();  [CE]  cannot  find  symbol  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock!=  null?  null  :  tryBlock.getReturnType();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock!=  null?  null  :  tryBlock.getReturnType();	  Node    returnType    =    tryBlock.getReturnType();    	non-compiled	[CE]  cannot  find  symbol	3	None	replace
619	[BUG]  [BUGGY]  Node  returnType  =  tryBlock  ==  null?  null  :  tryBlock.getReturnType();  [CE]  cannot  find  symbol  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock  ==  null?  null  :  tryBlock.getReturnType();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock  ==  null?  null  :  tryBlock.getReturnType();	  Node    returnType    =    tryBlock.getReturnType();    	non-compiled	[CE]  cannot  find  symbol	3	None	replace
620	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getReturnType()  &&  labelName.equals(n.getString());  [CE]  cannot  find  symbol  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getReturnType()  &&  labelName.equals(n.getString());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getReturnType()  &&  labelName.equals(n.getString());	  Node    returnType    =    tryBlock.getReturnType();    	non-compiled	[CE]  cannot  find  symbol	3	None	replace
621	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkArgument(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	165	6	add
622	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	165	6	add
623	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkArgument(tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkArgument(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkArgument(tryBlock.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	165	6	add
624	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkArgument(tryBlock.getType()!=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkArgument(tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkArgument(tryBlock.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	165	6	add
625	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkArgument(tryBlock.getType()  >>  Token.EXPR_RESULT);  [CE]  no  suitable  method  found  for  checkArgument(int)  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkArgument(tryBlock.getType()  >>  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkArgument(tryBlock.getType()  >>  Token.EXPR_RESULT);	  	non-compiled	[CE]  no  suitable  method  found  for  checkArgument(int)	165	None	add
626	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkArgument(tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkArgument(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkArgument(tryBlock.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	165	6	add
627	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkArgument(tryBlock.getType()  >=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkArgument(tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkArgument(tryBlock.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	165	6	add
628	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()    ==    Token.EXPR_RESULT);    NodeUtil.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);	  	non-compiled	[CE]  cannot  find  symbol	165	None	add
629	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkArgument(tryBlock.getType()  [Delete]  Token.EXPR_RESULT);  [CE]  ')'  expected  [FE]              RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkArgument(tryBlock.getType()  [Delete]  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkArgument(tryBlock.getType()  [Delete]  Token.EXPR_RESULT);	  	non-compiled	[CE]  ')'  expected	165	None	add
630	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	51	6	add
631	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	51	6	add
632	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	51	6	add
633	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	51	6	add
634	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock  >=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock  >=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock  >=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	51	None	add
635	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  >=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  >=  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	51	6	add
636	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  >=  Token.FUNCTION);  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  >=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  >=  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	51	6	add
637	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock  >>  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  [CE]  bad  operand  types  for  binary  operator  '>>'  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock  >>  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock  >>  null  &&  tryBlock.getType()  ==  Token.FUNCTION);	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>>'	51	None	add
638	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  Node  tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  [CE]  ';'  expected  [FE]              RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  Node  tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.FUNCTION);    Node  tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);	  	non-compiled	[CE]  ';'  expected	51	None	add
639	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  Node  n  =  tryBlock.getNext();  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  [CE]  variable  n  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  Node  n  =  tryBlock.getNext();  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()    ==    Token.FUNCTION);    Node  n  =  tryBlock.getNext();  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);	  	non-compiled	[CE]  variable  n  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	14	None	add
640	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  Preconditions.checkState(n.getType()  >>  Token.FUNCTION);  [CE]  no  suitable  method  found  for  checkState(int)  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  Preconditions.checkState(n.getType()  >>  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()    ==    Token.FUNCTION);    Preconditions.checkState(n.getType()  >>  Token.FUNCTION);	  	non-compiled	[CE]  no  suitable  method  found  for  checkState(int)	14	None	add
641	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  Preconditions.checkState(n.getType()  >=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(n.getType()    ==    Token.FUNCTION);    Preconditions.checkState(n.getType()  >=  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	14	6	add
642	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  Preconditions.checkState(n.getType()  >=  Token.FUNCTION);  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  Preconditions.checkState(n.getType()  >=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()    ==    Token.FUNCTION);    Preconditions.checkState(n.getType()  >=  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	14	6	add
643	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  NodeUtil.checkState(n.getType()  ==  Token.FUNCTION);  [CE]  cannot  find  symbol  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  NodeUtil.checkState(n.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()    ==    Token.FUNCTION);    NodeUtil.checkState(n.getType()  ==  Token.FUNCTION);	  	non-compiled	[CE]  cannot  find  symbol	14	None	add
644	[BUG]  [BUGGY]  Node  c  =  tryBlock.removeFirstChild();  Node  c  =  tryBlock.removeFirstChild();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.removeFirstChild();  Node  c  =  tryBlock.removeFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.removeFirstChild();    Node  c  =  tryBlock.removeFirstChild();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	187	None	add
645	[BUG]  [BUGGY]  Node  c  =  tryBlock.removeFirstChild();  Node  c  =  tryBlock.removeLastChild();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.removeFirstChild();  Node  c  =  tryBlock.removeLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.removeFirstChild();    Node  c  =  tryBlock.removeLastChild();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	187	None	add
646	[BUG]  [BUGGY]  Node  c  =  tryBlock.removeFirstChild();  Node  c  =  attemptBlock.removeFirstChild();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.removeFirstChild();  Node  c  =  attemptBlock.removeFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.removeFirstChild();    Node  c  =  attemptBlock.removeFirstChild();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	187	None	add
647	[BUG]  [BUGGY]  Node  c  =  tryBlock.removeFirstChild();  Node  c  =  triedBlock.removeFirstChild();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.removeFirstChild();  Node  c  =  triedBlock.removeFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.removeFirstChild();    Node  c  =  triedBlock.removeFirstChild();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	187	None	add
648	[BUG]  [BUGGY]  Node  c  =  tryBlock.removeFirstChild();  Node  c  =  startBlock.removeFirstChild();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.removeFirstChild();  Node  c  =  startBlock.removeFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.removeFirstChild();    Node  c  =  startBlock.removeFirstChild();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	187	None	add
649	[BUG]  [BUGGY]  tryMinimizeExit(peekNode,  exitType,  labelName);  [CE]  cannot  find  symbol  peekNode  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExit(peekNode,  exitType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExit(peekNode,  exitType,  labelName);	  tryMinimizeExit(catchNode,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol  peekNode	100	None	replace
650	[BUG]  [BUGGY]  tryMinimizeExit(tryBlock,  exitType,  labelName,  finallyBlock);  [CE]  cannot  find  symbol  finallyBlock  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExit(tryBlock,  exitType,  labelName,  finallyBlock);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExit(tryBlock,  exitType,  labelName,  finallyBlock);	  tryMinimizeExit(tryBlock,    exitType,    labelName,    falseBlock);    	non-compiled	[CE]  cannot  find  symbol  finallyBlock	101	None	replace
651	[BUG]  [BUGGY]  tryMinimizeExit(tryBlock,  exitType,  labelName,  elseBlock);  [CE]  cannot  find  symbol  elseBlock  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExit(tryBlock,  exitType,  labelName,  elseBlock);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExit(tryBlock,  exitType,  labelName,  elseBlock);	  tryMinimizeExit(tryBlock,    exitType,    labelName,    falseBlock);    	non-compiled	[CE]  cannot  find  symbol  elseBlock	101	None	replace
652	[BUG]  [BUGGY]  tryMinimizeExit(tryBlock,  exitType,  labelName,  trueBlock);  [CE]  cannot  find  symbol  trueBlock  [FE]                      AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExit(tryBlock,  exitType,  labelName,  trueBlock);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExit(tryBlock,  exitType,  labelName,  trueBlock);	  tryMinimizeExit(tryBlock,    exitType,    labelName,    falseBlock);    	non-compiled	[CE]  cannot  find  symbol  trueBlock	101	None	replace
653	[BUG]  [BUGGY]  tryMinimizeExit(tryBlock,  exitType,  labelName,  catchNode);  [CE]  cannot  find  symbol  catchNode  [FE]                        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExit(tryBlock,  exitType,  labelName,  catchNode);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExit(tryBlock,  exitType,  labelName,  catchNode);	  tryMinimizeExit(tryBlock,    exitType,    labelName,    falseBlock);    	non-compiled	[CE]  cannot  find  symbol  catchNode	101	None	replace
654	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  &&  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  &&  tryBlock.getType()!=  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	78	6	replace
655	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  &&  tryBlock.getType()!=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  &&  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  &&  tryBlock.getType()!=  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	78	6	replace
656	[BUG]  [BUGGY]  Preconditions.checkState(tries.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  tries  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tries.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tries.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    	non-compiled	[CE]  cannot  find  symbol  tries	78	None	replace
657	[BUG]  [BUGGY]  Node  exitType  =  tryBlock.getLastChild(),  labelName);  [CE]  ';'  expected  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock.getLastChild(),  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock.getLastChild(),  labelName);	  Node    exitType    =    tryBlock.getLastChild();    	non-compiled	[CE]  ';'  expected	82	None	replace
658	[BUG]  [BUGGY]  Node  exitType  =  tryBlock.getLastChild()  -  1;  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock.getLastChild()  -  1;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock.getLastChild()  -  1;	  Node    exitType    =    tryBlock.getLastChild();    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	82	None	replace
659	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock!=    null?    tryBlock.getNext()    :    null;    Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  null;	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	157	None	add
660	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  Node  c  =  tryBlock  ==  null?  tryBlock.getNext()  :  null;  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  Node  c  =  tryBlock  ==  null?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock!=    null?    tryBlock.getNext()    :    null;    Node  c  =  tryBlock  ==  null?  tryBlock.getNext()  :  null;	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	157	None	add
661	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  Node  c  =  tryBlock  >>  null?  tryBlock.getNext()  :  null;  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  Node  c  =  tryBlock  >>  null?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock!=    null?    tryBlock.getNext()    :    null;    Node  c  =  tryBlock  >>  null?  tryBlock.getNext()  :  null;	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	157	None	add
662	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  Node  c  =  tryBlock  >=  null?  tryBlock.getNext()  :  null;  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  Node  c  =  tryBlock  >=  null?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock!=    null?    tryBlock.getNext()    :    null;    Node  c  =  tryBlock  >=  null?  tryBlock.getNext()  :  null;	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	157	None	add
663	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  Node  c  =  tryBlock  [Delete]  null?  tryBlock.getNext()  :  null;  [CE]  ';'  expected  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  Node  c  =  tryBlock  [Delete]  null?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock!=    null?    tryBlock.getNext()    :    null;    Node  c  =  tryBlock  [Delete]  null?  tryBlock.getNext()  :  null;	  	non-compiled	[CE]  ';'  expected	157	None	add
664	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  Node  c  =  tryBlock  [BUGGY]  null?  tryBlock.getNext()  :  null;  [CE]  ';'  expected  [FE]              AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  Node  c  =  tryBlock  [BUGGY]  null?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock!=    null?    tryBlock.getNext()    :    null;    Node  c  =  tryBlock  [BUGGY]  null?  tryBlock.getNext()  :  null;	  	non-compiled	[CE]  ';'  expected	157	None	add
665	[BUG]  [BUGGY]  Node  c  =  triedBlock.getNext();  [CE]  cannot  find  symbol  triedBlock  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  triedBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  triedBlock.getNext();	          Node    c    =    tryBlock.getNext();    Node    c    =    triedBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol  triedBlock	105	None	replace
666	[BUG]  [BUGGY]  Node  returnType  =  tryBlock!=  null?  null  :  tryBlock.getNext();  node  returnType  =  tryBlock.getNext();  [CE]  cannot  find  symbol  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock!=  null?  null  :  tryBlock.getNext();  node  returnType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock!=  null?  null  :  tryBlock.getNext();  node  returnType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    node    returnType    =    tryBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol	123	None	replace
667	[BUG]  [BUGGY]  Node  returnType  =  tryBlock  ==  null?  null  :  tryBlock.getNext();  node  returnType  =  tryBlock.getNext();  [CE]  cannot  find  symbol  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock  ==  null?  null  :  tryBlock.getNext();  node  returnType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock  ==  null?  null  :  tryBlock.getNext();  node  returnType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    node    returnType    =    tryBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol	123	None	replace
668	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getNext();  node  returnType  =  n.getNext();  [CE]  cannot  find  symbol  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  node  returnType  =  n.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getNext();  node  returnType  =  n.getNext();	          Node    returnType    =    tryBlock.getNext();    node    returnType    =    tryBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol	123	None	replace
669	[BUG]  [BUGGY]  Node  labelName  =  tryBlock.getString(),  labelName);  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  tryBlock.getString(),  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  tryBlock.getString(),  labelName);	  Node    labelName    =    tryBlock.getString(),    exitType);    	non-compiled	[CE]  ';'  expected	22	None	replace
670	[BUG]  [BUGGY]  Node  labelName  =  tryBlock.getString(),  exitType,  labelName);  [CE]  ';'  expected  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  tryBlock.getString(),  exitType,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  tryBlock.getString(),  exitType,  labelName);	  Node    labelName    =    tryBlock.getString(),    exitType);    	non-compiled	[CE]  ';'  expected	22	None	replace
671	[BUG]  [BUGGY]  Node  labelName  =  tryBlock.getString(),  null);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  tryBlock.getString(),  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  tryBlock.getString(),  null);	  Node    labelName    =    tryBlock.getString(),    exitType);    	non-compiled	[CE]  <identifier>  expected	22	None	replace
672	[BUG]  [BUGGY]  Node  labelName  =  tryBlock.getString(),  label);  [CE]  ';'  expected  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  tryBlock.getString(),  label);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  tryBlock.getString(),  label);	  Node    labelName    =    tryBlock.getString(),    exitType);    	non-compiled	[CE]  ';'  expected	22	None	replace
673	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	164	6	replace
674	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	164	6	replace
675	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkArgument(tryBlock.getType()!=  Token.FUNCTION);	  Preconditions.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  AssertionFailedError  	164	6	replace
676	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()!=  Token.FUNCTION);  [FE]  AssertionFailedError  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()!=  Token.FUNCTION);	  Preconditions.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  AssertionFailedError  	164	6	replace
677	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  Preconditions.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  AssertionFailedError  	164	6	replace
678	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [FE]  AssertionFailedError  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  Preconditions.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  AssertionFailedError  	164	6	replace
679	[BUG]  [BUGGY]  tryMinimizeExits(catchNode,  n,  labelName,  exitType,  exitType);  [CE]  cannot  find  symbol  catchNode  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(catchNode,  n,  labelName,  exitType,  exitType);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(catchNode,  n,  labelName,  exitType,  exitType);	  tryMinimizeExits(n,    labelName,    exitType,    exitType);    	non-compiled	[CE]  cannot  find  symbol  catchNode	128	None	replace
680	[BUG]  [BUGGY]  tryMinimizeExits(catchNodes,  n,  labelName,  exitType,  exitType);  [CE]  cannot  find  symbol  catchNodes  [FE]                      AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(catchNodes,  n,  labelName,  exitType,  exitType);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(catchNodes,  n,  labelName,  exitType,  exitType);	  tryMinimizeExits(n,    labelName,    exitType,    exitType);    	non-compiled	[CE]  cannot  find  symbol  catchNodes	128	None	replace
681	[BUG]  [BUGGY]  tryMinimizeExits(tryBlock,  n,  labelName,  exitType,  exitType);  [CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;  [FE]                        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(tryBlock,  n,  labelName,  exitType,  exitType);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(tryBlock,  n,  labelName,  exitType,  exitType);	  tryMinimizeExits(n,    labelName,    exitType,    exitType);    	non-compiled	[CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;	128	None	replace
682	[BUG]  [BUGGY]  Node  c  =  tryBlock.getParent();  Node  c  =  tryBlock.getParent();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getParent();  Node  c  =  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.getParent();    Node  c  =  tryBlock.getParent();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	159	None	add
683	[BUG]  [BUGGY]  Node  c  =  tryBlock.getParent();  Node  c  =  tryBlock.getNext();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getParent();  Node  c  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.getParent();    Node  c  =  tryBlock.getNext();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	159	None	add
684	[BUG]  [BUGGY]  Node  c  =  tryBlock.getParent();  Node  c  =  attemptBlock.getParent();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getParent();  Node  c  =  attemptBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.getParent();    Node  c  =  attemptBlock.getParent();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	159	None	add
685	[BUG]  [BUGGY]  Node  c  =  tryBlock.getParent();  Node  c  =  startBlock.getParent();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getParent();  Node  c  =  startBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.getParent();    Node  c  =  startBlock.getParent();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	159	None	add
686	[BUG]  [BUGGY]  Node  c  =  tryBlock.getParent();  Node  c  =  triedBlock.getParent();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getParent();  Node  c  =  triedBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.getParent();    Node  c  =  triedBlock.getParent();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	159	None	add
687	[BUG]  [BUGGY]  Node  escapeType  =  attemptBlock.getNext();  [CE]  cannot  find  symbol  attemptBlock  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  attemptBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  attemptBlock.getNext();	          Node    escapeType    =    tryBlock.getNext();    Node    escapeType    =    attemptBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol  attemptBlock	109	None	replace
688	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  escapeType  =  tryBlock!=  null?  tryBlock.getNext()  :  null;	          Node    escapeType    =    tryBlock.getNext();    Node    escapeType    =    attemptBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	109	6	replace
689	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  tryBlock.getNext()  :  null;	          Node    escapeType    =    tryBlock.getNext();    Node    escapeType    =    attemptBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	109	6	replace
690	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getNext()  &&  attemptBlock.getNext();  [CE]  cannot  find  symbol  attemptBlock  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getNext()  &&  attemptBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getNext()  &&  attemptBlock.getNext();	          Node    escapeType    =    tryBlock.getNext();    Node    escapeType    =    attemptBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol  attemptBlock	109	None	replace
691	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getNext()  &&  tryBlock.getNext();  [CE]  bad  operand  types  for  binary  operator  '&&'  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getNext()  &&  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getNext()  &&  tryBlock.getNext();	          Node    escapeType    =    tryBlock.getNext();    Node    escapeType    =    attemptBlock.getNext();    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '&&'	109	None	replace
692	[BUG]  [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnedType  =  tryBlock.getNext();  Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  tryBlock.getNext();  [CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnedType  =  tryBlock.getNext();  Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        returnType        =        tryBlock.getNext();        Node    returnedType    =    tryBlock.getNext();    Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  tryBlock.getNext();	  	non-compiled	[CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	44	None	add
693	[BUG]  [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnedType  =  tryBlock.getNext();  Node  returnedType  =  tryBlock.getNext();  Node  returnedType  =  tryBlock.getNext();  [CE]  variable  returnedType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnedType  =  tryBlock.getNext();  Node  returnedType  =  tryBlock.getNext();  Node  returnedType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        returnType        =        tryBlock.getNext();        Node    returnedType    =    tryBlock.getNext();    Node  returnedType  =  tryBlock.getNext();  Node  returnedType  =  tryBlock.getNext();	  	non-compiled	[CE]  variable  returnedType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	44	None	add
694	[BUG]  [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnedType  =  tryBlock.getNext();  Node  exitType  =  tryBlock.getNext();  Node  returnedType  =  tryBlock.getNext();  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnedType  =  tryBlock.getNext();  Node  exitType  =  tryBlock.getNext();  Node  returnedType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        returnType        =        tryBlock.getNext();        Node    returnedType    =    tryBlock.getNext();    Node  exitType  =  tryBlock.getNext();  Node  returnedType  =  tryBlock.getNext();	  	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	44	None	add
695	[BUG]  [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnedType  =  tryBlock.getNext();  Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  triedBlock.getNext();  [CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnedType  =  tryBlock.getNext();  Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  triedBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        returnType        =        tryBlock.getNext();        Node    returnedType    =    tryBlock.getNext();    Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  triedBlock.getNext();	  	non-compiled	[CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	44	None	add
696	[BUG]  [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnedType  =  tryBlock.getNext();  Node  returnType  =  triedBlock.getNext();  Node  returnedType  =  tryBlock.getNext();  [CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnedType  =  tryBlock.getNext();  Node  returnType  =  triedBlock.getNext();  Node  returnedType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        returnType        =        tryBlock.getNext();        Node    returnedType    =    tryBlock.getNext();    Node  returnType  =  triedBlock.getNext();  Node  returnedType  =  tryBlock.getNext();	  	non-compiled	[CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	44	None	add
697	[BUG]  [BUGGY]  [FE]  StackOverflowError  [FE]    StackOverflowError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(n,  exitType,  labelName);  tryMinimizeExits(n,  exitType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	tryMinimizeExits(n,    exitType,    labelName);    tryMinimizeExits(n,  exitType,  labelName);	  	compilable	  [FE]  StackOverflowError  	97	6	add
698	[BUG]  [BUGGY]  tryMinimizeExits(n,  exitType,  labelName);  tryMinimizeExits(n,  exitType,  labelName);  [FE]  StackOverflowError  [FE]    StackOverflowError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(n,  exitType,  labelName);  tryMinimizeExits(n,  exitType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(n,    exitType,    labelName);    tryMinimizeExits(n,  exitType,  labelName);	  	compilable	  [FE]  StackOverflowError  	97	6	add
699	[BUG]  [BUGGY]  tryMinimizeExits(n,  exitType,  labelName);  TryMinimizeExits(n,  exitType,  labelName);  [CE]  cannot  find  symbol  [FE]      StackOverflowError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(n,  exitType,  labelName);  TryMinimizeExits(n,  exitType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(n,    exitType,    labelName);    TryMinimizeExits(n,  exitType,  labelName);	  	non-compiled	[CE]  cannot  find  symbol	97	None	add
700	[BUG]  [BUGGY]  tryMinimizeExits(n,  exitType,  labelName);  ifMinimizeExits(n,  exitType,  labelName);  [CE]  cannot  find  symbol  [FE]        StackOverflowError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(n,  exitType,  labelName);  ifMinimizeExits(n,  exitType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(n,    exitType,    labelName);    ifMinimizeExits(n,  exitType,  labelName);	  	non-compiled	[CE]  cannot  find  symbol	97	None	add
701	[BUG]  [BUGGY]  tryMinimizeExits(n,  exitType,  labelName);  tryMinimizeExits(n,  exitType,  labelName);  }  [CE]  illegal  start  of  type  [FE]          StackOverflowError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(n,  exitType,  labelName);  tryMinimizeExits(n,  exitType,  labelName);  }  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(n,    exitType,    labelName);    tryMinimizeExits(n,  exitType,  labelName);  }	  	non-compiled	[CE]  illegal  start  of  type	97	None	add
702	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.removeLastChild();  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.removeLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.removeLastChild();	  Node    returnType    =    tryBlock.removeFirstChild();    	non-compiled	[CE]  cannot  find  symbol	177	None	replace
703	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock  >=  null);  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock  >=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock  >=  null);	          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock    ==    null);    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	58	None	replace
704	[BUG]  [BUGGY]  Node  c  =  tryBlock.cloneTree();  Node  c  =  tryBlock.cloneTree();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.cloneTree();  Node  c  =  tryBlock.cloneTree();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.cloneTree();    Node  c  =  tryBlock.cloneTree();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	189	None	add
705	[BUG]  [BUGGY]  Node  c  =  tryBlock.cloneTree();  Node  c  =  attemptBlock.cloneTree();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.cloneTree();  Node  c  =  attemptBlock.cloneTree();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.cloneTree();    Node  c  =  attemptBlock.cloneTree();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	189	None	add
706	[BUG]  [BUGGY]  Node  c  =  tryBlock.cloneTree();  Node  c  =  triedBlock.cloneTree();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.cloneTree();  Node  c  =  triedBlock.cloneTree();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.cloneTree();    Node  c  =  triedBlock.cloneTree();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	189	None	add
707	[BUG]  [BUGGY]  Node  c  =  tryBlock.cloneTree();  Node  c  =  startBlock.cloneTree();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.cloneTree();  Node  c  =  startBlock.cloneTree();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.cloneTree();    Node  c  =  startBlock.cloneTree();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	189	None	add
708	[BUG]  [BUGGY]  Node  c  =  tryBlock.cloneTree();  Node  c  =  tryBlock.cloneTree());  [CE]  ';'  expected  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.cloneTree();  Node  c  =  tryBlock.cloneTree());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.cloneTree();    Node  c  =  tryBlock.cloneTree());	  	non-compiled	[CE]  ';'  expected	189	None	add
709	[BUG]  [BUGGY]  Node  c  =  tryBlock.removeLastChild();  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.removeLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock.removeLastChild();	  Node    c    =    tryBlock.removeFirstChild();    	non-compiled	[CE]  cannot  find  symbol	188	None	replace
710	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock    ==    null);    Preconditions.checkState(tryBlock  ==  null);	  	compilable	  [FE]  RuntimeException  	47	6	add
711	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock  ==  null);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock    ==    null);    Preconditions.checkState(tryBlock  ==  null);	  	compilable	  [FE]  RuntimeException  	47	6	add
712	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock    ==    null);    Preconditions.checkState(tryBlock!=  null);	  	compilable	  [FE]  RuntimeException  	47	6	add
713	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock!=  null);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock    ==    null);    Preconditions.checkState(tryBlock!=  null);	  	compilable	  [FE]  RuntimeException  	47	6	add
714	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock  >=  null);  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock  >=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock    ==    null);    Preconditions.checkState(tryBlock  >=  null);	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	47	None	add
715	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock  ==  null);  NodeUtil.checkState(tryBlock  ==  null);  [CE]  cannot  find  symbol  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock  ==  null);  NodeUtil.checkState(tryBlock  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock    ==    null);    NodeUtil.checkState(tryBlock  ==  null);	  	non-compiled	[CE]  cannot  find  symbol	47	None	add
716	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock  >>  null);  [CE]  bad  operand  types  for  binary  operator  '>>'  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock  >>  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock    ==    null);    Preconditions.checkState(tryBlock  >>  null);	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>>'	47	None	add
717	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock  [BUGGY]  null);  [CE]  ')'  expected  [FE]              RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock  [BUGGY]  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock    ==    null);    Preconditions.checkState(tryBlock  [BUGGY]  null);	  	non-compiled	[CE]  ')'  expected	47	None	add
718	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	49	6	add
719	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	49	6	add
720	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	49	6	add
721	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock  ==  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	49	6	add
722	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock  >=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock  >=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock  >=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	49	None	add
723	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	49	6	add
724	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  >=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	49	6	add
725	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  >>  Token.EXPR_RESULT);  [CE]  bad  operand  types  for  binary  operator  '&&'  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  >>  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  >>  Token.EXPR_RESULT);	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '&&'	49	None	add
726	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  Node  tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  ';'  expected  [FE]              RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  Node  tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.EXPR_RESULT);    Node  tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	non-compiled	[CE]  ';'  expected	49	None	add
727	[BUG]  [BUGGY]  Node  c  =  tryBlock.getNext();  node  c  =  c.getNext();  [CE]  cannot  find  symbol  [FE]        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getNext();  node  c  =  c.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock.getNext();  node  c  =  c.getNext();	          Node    c    =    tryBlock.getNext();    node    c    =    tryBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol	149	None	replace
728	[BUG]  [BUGGY]  Node  c  =  tryBlock.getNext();  node  c  =  n.getNext();  [CE]  cannot  find  symbol  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getNext();  node  c  =  n.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock.getNext();  node  c  =  n.getNext();	          Node    c    =    tryBlock.getNext();    node    c    =    tryBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol	149	None	replace
729	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  null  :  tryBlock.getNext();  node  c  =  tryBlock.getNext();  [CE]  cannot  find  symbol  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  null  :  tryBlock.getNext();  node  c  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock!=  null?  null  :  tryBlock.getNext();  node  c  =  tryBlock.getNext();	          Node    c    =    tryBlock.getNext();    node    c    =    tryBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol	149	None	replace
730	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getNext();  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getNext();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getNext();  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock!=    null?    tryBlock.getNext()    :    tryBlock.getNext();    Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getNext();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	161	None	add
731	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getNext();  Node  c  =  tryBlock  ==  null?  tryBlock.getNext()  :  tryBlock.getNext();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getNext();  Node  c  =  tryBlock  ==  null?  tryBlock.getNext()  :  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock!=    null?    tryBlock.getNext()    :    tryBlock.getNext();    Node  c  =  tryBlock  ==  null?  tryBlock.getNext()  :  tryBlock.getNext();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	161	None	add
732	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getNext();  Node  c  =  tryBlock  >>  null?  tryBlock.getNext()  :  tryBlock.getNext();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getNext();  Node  c  =  tryBlock  >>  null?  tryBlock.getNext()  :  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock!=    null?    tryBlock.getNext()    :    tryBlock.getNext();    Node  c  =  tryBlock  >>  null?  tryBlock.getNext()  :  tryBlock.getNext();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	161	None	add
733	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getNext();  Node  c  =  tryBlock  >=  null?  tryBlock.getNext()  :  tryBlock.getNext();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getNext();  Node  c  =  tryBlock  >=  null?  tryBlock.getNext()  :  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock!=    null?    tryBlock.getNext()    :    tryBlock.getNext();    Node  c  =  tryBlock  >=  null?  tryBlock.getNext()  :  tryBlock.getNext();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	161	None	add
734	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getNext();  Node  c  =  tryBlock  [Delete]  null?  tryBlock.getNext()  :  tryBlock.getNext();  [CE]  ';'  expected  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getNext();  Node  c  =  tryBlock  [Delete]  null?  tryBlock.getNext()  :  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock!=    null?    tryBlock.getNext()    :    tryBlock.getNext();    Node  c  =  tryBlock  [Delete]  null?  tryBlock.getNext()  :  tryBlock.getNext();	  	non-compiled	[CE]  ';'  expected	161	None	add
735	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getNext();  Node  c  =  tryBlock  [BUGGY]  null?  tryBlock.getNext()  :  tryBlock.getNext();  [CE]  ';'  expected  [FE]              AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getNext();  Node  c  =  tryBlock  [BUGGY]  null?  tryBlock.getNext()  :  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock!=    null?    tryBlock.getNext()    :    tryBlock.getNext();    Node  c  =  tryBlock  [BUGGY]  null?  tryBlock.getNext()  :  tryBlock.getNext();	  	non-compiled	[CE]  ';'  expected	161	None	add
736	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getNext()  -  1;  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getNext()  -  1;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getNext()  -  1;	          Node    escapeType    =    tryBlock.getNext();    Node    escapeType    =    tryBlock.getNext();    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	107	None	replace
737	[BUG]  [BUGGY]  Node  labelName  =  tryBlock.getQualifiedName()  +  1;  [CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  tryBlock.getQualifiedName()  +  1;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  tryBlock.getQualifiedName()  +  1;	  Node    labelName    =    tryBlock.getQualifiedName();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	24	None	replace
738	[BUG]  [BUGGY]  Node  labelName  =  tryBlock.getQualifiedName(),  exitType);  [CE]  ';'  expected  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  tryBlock.getQualifiedName(),  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  tryBlock.getQualifiedName(),  exitType);	  Node    labelName    =    tryBlock.getQualifiedName();    	non-compiled	[CE]  ';'  expected	24	None	replace
739	[BUG]  [BUGGY]  Node  labelName  =  tryBlock.getQualifiedName()  + ": ";  [CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                      AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  tryBlock.getQualifiedName()  + ": ";  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  tryBlock.getQualifiedName()  + ": ";	  Node    labelName    =    tryBlock.getQualifiedName();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	24	None	replace
740	[BUG]  [BUGGY]  Node  labelName  =  tryBlock.getQualifiedName()  + "n ";  [CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  tryBlock.getQualifiedName()  + "n ";  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  tryBlock.getQualifiedName()  + "n ";	  Node    labelName    =    tryBlock.getQualifiedName();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	24	None	replace
741	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getExitType(),  labelName;  [CE]  cannot  find  symbol  [FE]        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getExitType(),  labelName;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getExitType(),  labelName;	  Node    escapeType    =    tryBlock.getExitType();    	non-compiled	[CE]  cannot  find  symbol	146	None	replace
742	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getExitType()  &&  labelName.equals(n.getString());  [CE]  cannot  find  symbol  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getExitType()  &&  labelName.equals(n.getString());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getExitType()  &&  labelName.equals(n.getString());	  Node    escapeType    =    tryBlock.getExitType();    	non-compiled	[CE]  cannot  find  symbol	146	None	replace
743	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  null  :  tryBlock.getExitType();  [CE]  cannot  find  symbol  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  null  :  tryBlock.getExitType();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  null  :  tryBlock.getExitType();	  Node    escapeType    =    tryBlock.getExitType();    	non-compiled	[CE]  cannot  find  symbol	146	None	replace
744	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getExitType(),  labelName);  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getExitType(),  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getExitType(),  labelName);	  Node    escapeType    =    tryBlock.getExitType();    	non-compiled	[CE]  ';'  expected	146	None	replace
745	[BUG]  [BUGGY]  Node  exitType  =  tryBlock.getNext(),  labelName  +  1);  [CE]  ';'  expected  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock.getNext(),  labelName  +  1);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock.getNext(),  labelName  +  1);	  Node    exitType    =    tryBlock.getNext(),    labelName);    	non-compiled	[CE]  ';'  expected	81	None	replace
746	[BUG]  [BUGGY]  Node  exitType  =  tryBlock.getNext(),  labelName,  falseBlock);  [CE]  ';'  expected  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock.getNext(),  labelName,  falseBlock);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock.getNext(),  labelName,  falseBlock);	  Node    exitType    =    tryBlock.getNext(),    labelName);    	non-compiled	[CE]  ';'  expected	81	None	replace
747	[BUG]  [BUGGY]  Node  exitType  =  tryBlock.getNext(),  labelName,  escapeType);  [CE]  ';'  expected  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock.getNext(),  labelName,  escapeType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock.getNext(),  labelName,  escapeType);	  Node    exitType    =    tryBlock.getNext(),    labelName);    	non-compiled	[CE]  ';'  expected	81	None	replace
748	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getType();  [CE]  incompatible  types  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getType();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getType();	  Node    escapeType    =    tryBlock.getFirstChild();    	non-compiled	[CE]  incompatible  types	186	None	replace
749	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  n.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  escapeType  =  n.getFirstChild();	  Node    escapeType    =    tryBlock.getFirstChild();    	compilable	  [FE]  AssertionFailedError  	186	6	replace
750	[BUG]  [BUGGY]  Node  escapeType  =  n.getFirstChild();  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  n.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  n.getFirstChild();	  Node    escapeType    =    tryBlock.getFirstChild();    	compilable	  [FE]  AssertionFailedError  	186	6	replace
751	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT,  exitType);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    exitType);    	compilable	  [FE]  RuntimeException  	137	6	replace
752	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT,  exitType);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT,  exitType);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    exitType);    	compilable	  [FE]  RuntimeException  	137	6	replace
753	[BUG]  [BUGGY]  Preconditions.checkState(exitType.getType()  ==  Token.EXPR_RESULT,  tryBlock);  [CE]  int  cannot  be  dereferenced  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(exitType.getType()  ==  Token.EXPR_RESULT,  tryBlock);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(exitType.getType()  ==  Token.EXPR_RESULT,  tryBlock);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    exitType);    	non-compiled	[CE]  int  cannot  be  dereferenced	137	None	replace
754	[BUG]  [BUGGY]  Preconditions.checkState(tries.getType()  ==  Token.EXPR_RESULT,  exitType);  [CE]  cannot  find  symbol  tries  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tries.getType()  ==  Token.EXPR_RESULT,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tries.getType()  ==  Token.EXPR_RESULT,  exitType);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    exitType);    	non-compiled	[CE]  cannot  find  symbol  tries	137	None	replace
755	[BUG]  [BUGGY]  Node  c  =  tryBlock.getType()!=  Token.CATCH;  Preconditions.checkState(c.getType()  ==  Token.CATCH);  [CE]  incompatible  types  [FE]                RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getType()!=  Token.CATCH;  Preconditions.checkState(c.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock.getType()!=  Token.CATCH;  Preconditions.checkState(c.getType()  ==  Token.CATCH);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Node    c    =    tryBlock.getType()    ==    Token.CATCH;    Preconditions.checkState(c.getType()    ==    Token.CATCH);    	non-compiled	[CE]  incompatible  types	94	None	replace
756	[BUG]  [BUGGY]  Node  c  =  tryBlock.getType()  [Delete]  Token.CATCH;  Preconditions.checkState(c.getType()  ==  Token.CATCH);  [CE]  ';'  expected  [FE]                  RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getType()  [Delete]  Token.CATCH;  Preconditions.checkState(c.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock.getType()  [Delete]  Token.CATCH;  Preconditions.checkState(c.getType()  ==  Token.CATCH);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Node    c    =    tryBlock.getType()    ==    Token.CATCH;    Preconditions.checkState(c.getType()    ==    Token.CATCH);    	non-compiled	[CE]  ';'  expected	94	None	replace
757	[BUG]  [BUGGY]  tryMinimizeExits(labelName,  exitType,  escapeType);  [CE]  cannot  find  symbol  escapeType  [FE]                      AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(labelName,  exitType,  escapeType);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(labelName,  exitType,  escapeType);	  tryMinimizeExits(labelName,    entryType,    exitType);    	non-compiled	[CE]  cannot  find  symbol  escapeType	85	None	replace
758	[BUG]  [BUGGY]  tryMinimizeExits(labelName,  escapeType,  exitType);  [CE]  cannot  find  symbol  escapeType  [FE]                        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(labelName,  escapeType,  exitType);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(labelName,  escapeType,  exitType);	  tryMinimizeExits(labelName,    entryType,    exitType);    	non-compiled	[CE]  cannot  find  symbol  escapeType	85	None	replace
759	[BUG]  [BUGGY]  Node  c  =  attemptBlock.getNext();  [CE]  cannot  find  symbol  attemptBlock  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  attemptBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  attemptBlock.getNext();	          Node    c    =    tryBlock.getNext();    Node    c    =    attemptBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol  attemptBlock	103	None	replace
760	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  exitType  =  tryBlock.getNext();  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  exitType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getFirstChild();  Node  exitType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    exitType    =    tryBlock.getNext();    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	41	None	replace
761	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getNext()  -  1;  Node  exitType  =  tryBlock.getNext();  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext()  -  1;  Node  exitType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getNext()  -  1;  Node  exitType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    exitType    =    tryBlock.getNext();    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	41	None	replace
762	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	116	6	add
763	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	116	6	add
764	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	116	6	add
765	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	116	6	add
766	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  NodeUtil.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  NodeUtil.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    NodeUtil.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	non-compiled	[CE]  cannot  find  symbol	116	None	add
767	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	116	6	add
768	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]          RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	116	6	add
769	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	116	6	add
770	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  >=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]            RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	116	6	add
771	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Node  tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  ';'  expected  [FE]              RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Node  tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Node  tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	non-compiled	[CE]  ';'  expected	116	None	add
772	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.hasChildren());    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());	  	compilable	  [FE]  AssertionFailedError  	153	2	add
773	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.hasChildren());    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());	  	compilable	  [FE]  AssertionFailedError  	153	2	add
774	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.hasChildren());    NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());	  	non-compiled	[CE]  cannot  find  symbol	153	None	add
775	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.hasChildren());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.hasChildren());    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.hasChildren());	  	compilable	  [FE]  AssertionFailedError  	153	2	add
776	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.hasChildren());  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.hasChildren());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.hasChildren());    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.hasChildren());	  	compilable	  [FE]  AssertionFailedError  	153	2	add
777	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  NodeUtil.checkFunction(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  NodeUtil.checkFunction(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.hasChildren());    NodeUtil.checkFunction(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());	  	non-compiled	[CE]  cannot  find  symbol	153	None	add
778	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.hasChildren());    NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());	  	non-compiled	[CE]  cannot  find  symbol	153	None	add
779	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION  ||  tryBlock.hasChildren());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.hasChildren());    Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION  ||  tryBlock.hasChildren());	  	compilable	  [FE]  AssertionFailedError  	153	2	add
780	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION  ||  tryBlock.hasChildren());  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION  ||  tryBlock.hasChildren());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.hasChildren());    Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION  ||  tryBlock.hasChildren());	  	compilable	  [FE]  AssertionFailedError  	153	2	add
781	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getParent()  :  null;  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getParent()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getParent()  :  null;	  Node    escapeType    =    tryBlock.getNext()    :    null;    	non-compiled	[CE]  ';'  expected	31	None	replace
782	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getFirstChild()  :  null;  [CE]  ';'  expected  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getFirstChild()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getFirstChild()  :  null;	  Node    escapeType    =    tryBlock.getNext()    :    null;    	non-compiled	[CE]  ';'  expected	31	None	replace
783	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getExternalState()  :  null;  [CE]  ';'  expected  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getExternalState()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getExternalState()  :  null;	  Node    escapeType    =    tryBlock.getNext()    :    null;    	non-compiled	[CE]  ';'  expected	31	None	replace
784	[BUG]  [BUGGY]  Node  c  =  tryBlock.getNextNode();  [CE]  cannot  find  symbol  [FE]        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getNextNode();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock.getNextNode();	  Node    c    =    tryBlock.getCurrentNode();    	non-compiled	[CE]  cannot  find  symbol	8	None	replace
785	[BUG]  [BUGGY]  Node  exitType  =  tryBlock.getNext()  ||  labelName.equals(n.getString());  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock.getNext()  ||  labelName.equals(n.getString());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock.getNext()  ||  labelName.equals(n.getString());	  Node    exitType    =    tryBlock.getNext()    &&    labelName.equals(n.getString());    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	79	None	replace
786	[BUG]  [BUGGY]  Node  exitType  =  tryBlock.getNext()  &&  labelName.equals(n.getString())&&  labelName.equals(n.getString());  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock.getNext()  &&  labelName.equals(n.getString())&&  labelName.equals(n.getString());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock.getNext()  &&  labelName.equals(n.getString())&&  labelName.equals(n.getString());	  Node    exitType    =    tryBlock.getNext()    &&    labelName.equals(n.getString());    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	79	None	replace
787	[BUG]  [BUGGY]  Node  exitType  =  tryBlock.getNext()  &&  labelName.equals(n.getString()  +  1);  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock.getNext()  &&  labelName.equals(n.getString()  +  1);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock.getNext()  &&  labelName.equals(n.getString()  +  1);	  Node    exitType    =    tryBlock.getNext()    &&    labelName.equals(n.getString());    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	79	None	replace
788	[BUG]  [BUGGY]  Node  exitType  =  tryBlock.getNext()  &&  labelName.equals(n.getString()));  [CE]  ';'  expected  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock.getNext()  &&  labelName.equals(n.getString()));  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock.getNext()  &&  labelName.equals(n.getString()));	  Node    exitType    =    tryBlock.getNext()    &&    labelName.equals(n.getString());    	non-compiled	[CE]  ';'  expected	79	None	replace
789	[BUG]  [BUGGY]  Node  tryBlock.getType()  ==  Token.CATCH);  [CE]  ';'  expected  [FE]        RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  tryBlock.getType()  ==  Token.CATCH);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Node    tryBlock.getType()    ==    Token.CATCH);    	non-compiled	[CE]  ';'  expected	124	None	replace
790	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Node  tryBlock  =  tryBlock.getType();  [CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]          RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Node  tryBlock  =  tryBlock.getType();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Node  tryBlock  =  tryBlock.getType();	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Node    tryBlock.getType()    ==    Token.CATCH);    	non-compiled	[CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	124	None	replace
791	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()!=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(n.getType()!=  Token.CATCH);	  Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    	compilable	  [FE]  AssertionFailedError  	115	6	replace
792	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.CATCH);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()!=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()!=  Token.CATCH);	  Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    	compilable	  [FE]  AssertionFailedError  	115	6	replace
793	[BUG]  [BUGGY]  Preconditions.checkState(tries.getType()!=  Token.CATCH);  [CE]  cannot  find  symbol  tries  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tries.getType()!=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tries.getType()!=  Token.CATCH);	  Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    	non-compiled	[CE]  cannot  find  symbol  tries	115	None	replace
794	[BUG]  [BUGGY]  Preconditions.checkState(t.getType()!=  Token.CATCH);  [CE]  cannot  find  symbol  t  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(t.getType()!=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(t.getType()!=  Token.CATCH);	  Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    	non-compiled	[CE]  cannot  find  symbol  t	115	None	replace
795	[BUG]  [BUGGY]  tryMinimizeExits(catchNodes,  exitType,  labelName,  true);  [CE]  cannot  find  symbol  catchNodes  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(catchNodes,  exitType,  labelName,  true);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(catchNodes,  exitType,  labelName,  true);	  tryMinimizeExits(catchNodes,    exitType,    labelName,    false);    	non-compiled	[CE]  cannot  find  symbol  catchNodes	169	None	replace
796	[BUG]  [BUGGY]  tryMinimizeExits(tree,  exitType,  labelName,  false);  [CE]  cannot  find  symbol  tree  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(tree,  exitType,  labelName,  false);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(tree,  exitType,  labelName,  false);	  tryMinimizeExits(catchNodes,    exitType,    labelName,    false);    	non-compiled	[CE]  cannot  find  symbol  tree	169	None	replace
797	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock  ==  null?  tryBlock.getNext()  :  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  c  =  tryBlock  ==  null?  tryBlock.getNext()  :  tryBlock.getNext();	  Node    c    =    tryBlock!=    null?    tryBlock.getNext()    :    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	162	6	replace
798	[BUG]  [BUGGY]  Node  c  =  tryBlock  ==  null?  tryBlock.getNext()  :  tryBlock.getNext();  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock  ==  null?  tryBlock.getNext()  :  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock  ==  null?  tryBlock.getNext()  :  tryBlock.getNext();	  Node    c    =    tryBlock!=    null?    tryBlock.getNext()    :    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	162	6	replace
799	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getLastChild();	  Node    c    =    tryBlock!=    null?    tryBlock.getNext()    :    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	162	6	replace
800	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getLastChild();  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getLastChild();	  Node    c    =    tryBlock!=    null?    tryBlock.getNext()    :    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	162	6	replace
801	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getParent();	  Node    c    =    tryBlock!=    null?    tryBlock.getNext()    :    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	162	6	replace
802	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getParent();  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getParent();	  Node    c    =    tryBlock!=    null?    tryBlock.getNext()    :    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	162	6	replace
803	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getFirstChild();  Node  escapeType  =  tryBlock.getFirstChild();  [CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getFirstChild();  Node  escapeType  =  tryBlock.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    escapeType    =    tryBlock.getFirstChild();    Node  escapeType  =  tryBlock.getFirstChild();	  	non-compiled	[CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	185	None	add
804	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getFirstChild();  Node  escapeType  =  tryBlock.getLastChild();  [CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getFirstChild();  Node  escapeType  =  tryBlock.getLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    escapeType    =    tryBlock.getFirstChild();    Node  escapeType  =  tryBlock.getLastChild();	  	non-compiled	[CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	185	None	add
805	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getFirstChild();  Node  exitType  =  tryBlock.getFirstChild();  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getFirstChild();  Node  exitType  =  tryBlock.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    escapeType    =    tryBlock.getFirstChild();    Node  exitType  =  tryBlock.getFirstChild();	  	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	185	None	add
806	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getFirstChild();  Node  escapeType  =  attemptBlock.getFirstChild();  [CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getFirstChild();  Node  escapeType  =  attemptBlock.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    escapeType    =    tryBlock.getFirstChild();    Node  escapeType  =  attemptBlock.getFirstChild();	  	non-compiled	[CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	185	None	add
807	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getFirstChild();  Node  escapeType  =  triedBlock.getFirstChild();  [CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getFirstChild();  Node  escapeType  =  triedBlock.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    escapeType    =    tryBlock.getFirstChild();    Node  escapeType  =  triedBlock.getFirstChild();	  	non-compiled	[CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	185	None	add
808	[BUG]  [BUGGY]  Node  escapeType  =  triedBlock.getNext();  [CE]  cannot  find  symbol  triedBlock  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  triedBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  triedBlock.getNext();	          Node    escapeType    =    tryBlock.getNext();    Node    escapeType    =    triedBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol  triedBlock	110	None	replace
809	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  triedBlock.getNext()  :  null;  [CE]  cannot  find  symbol  triedBlock  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  triedBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  triedBlock.getNext()  :  null;	          Node    escapeType    =    tryBlock.getNext();    Node    escapeType    =    triedBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol  triedBlock	110	None	replace
810	[BUG]  [BUGGY]  Node  escapeType  =  failedBlock.getNext();  [CE]  cannot  find  symbol  failedBlock  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  failedBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  failedBlock.getNext();	          Node    escapeType    =    tryBlock.getNext();    Node    escapeType    =    triedBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol  failedBlock	110	None	replace
811	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock  ==  null?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  c  =  tryBlock  ==  null?  tryBlock.getNext()  :  null;	  Node    c    =    tryBlock!=    null?    tryBlock.getNext()    :    null;    	compilable	  [FE]  AssertionFailedError  	158	6	replace
812	[BUG]  [BUGGY]  Node  c  =  tryBlock  ==  null?  tryBlock.getNext()  :  null;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock  ==  null?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock  ==  null?  tryBlock.getNext()  :  null;	  Node    c    =    tryBlock!=    null?    tryBlock.getNext()    :    null;    	compilable	  [FE]  AssertionFailedError  	158	6	replace
813	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getParent()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  c  =  tryBlock!=  null?  tryBlock.getParent()  :  null;	  Node    c    =    tryBlock!=    null?    tryBlock.getNext()    :    null;    	compilable	  [FE]  AssertionFailedError  	158	6	replace
814	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getParent()  :  null;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getParent()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock!=  null?  tryBlock.getParent()  :  null;	  Node    c    =    tryBlock!=    null?    tryBlock.getNext()    :    null;    	compilable	  [FE]  AssertionFailedError  	158	6	replace
815	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getCurrent()  :  null;  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getCurrent()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock!=  null?  tryBlock.getCurrent()  :  null;	  Node    c    =    tryBlock!=    null?    tryBlock.getNext()    :    null;    	non-compiled	[CE]  cannot  find  symbol	158	None	replace
816	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkArgument(tryBlock.getType()  ==  Token.CATCH);	  Preconditions.checkState(n.getType()    ==    Token.CATCH);    	compilable	  [FE]  RuntimeException  	113	6	replace
817	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.CATCH);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()  ==  Token.CATCH);	  Preconditions.checkState(n.getType()    ==    Token.CATCH);    	compilable	  [FE]  RuntimeException  	113	6	replace
818	[BUG]  [BUGGY]  Preconditions.checkState(triesBlock.getType()  ==  Token.CATCH);  [CE]  cannot  find  symbol  triesBlock  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(triesBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(triesBlock.getType()  ==  Token.CATCH);	  Preconditions.checkState(n.getType()    ==    Token.CATCH);    	non-compiled	[CE]  cannot  find  symbol  triesBlock	113	None	replace
819	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.removeFirstChild();  Node  escapeType  =  tryBlock.removeLastChild();  [CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.removeFirstChild();  Node  escapeType  =  tryBlock.removeLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    escapeType    =    tryBlock.removeFirstChild();    Node  escapeType  =  tryBlock.removeLastChild();	  	non-compiled	[CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	183	None	add
820	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkArgument(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	52	6	replace
821	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	52	6	replace
822	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getCurrentNode()  :  null;  [CE]  cannot  find  symbol  [FE]        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getCurrentNode()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock!=  null?  tryBlock.getCurrentNode()  :  null;	  Node    c    =    tryBlock.getCurrentNode();    	non-compiled	[CE]  cannot  find  symbol	8	None	replace
823	[BUG]  [BUGGY]  Node  c  =  tryBlock.nextNode();  [CE]  cannot  find  symbol  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.nextNode();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock.nextNode();	  Node    c    =    tryBlock.getCurrentNode();    	non-compiled	[CE]  cannot  find  symbol	8	None	replace
824	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.NAME);  Node  tryBlock.getType()  ==  Token.CATCH);  [CE]  ';'  expected  [FE]        RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.NAME);  Node  tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.NAME);  Node  tryBlock.getType()  ==  Token.CATCH);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Node    tryBlock.getType()    ==    Token.CATCH);    	non-compiled	[CE]  ';'  expected	124	None	replace
825	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  falseBlock  :  tryBlock.getNext();  [CE]  cannot  find  symbol  falseBlock  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  falseBlock  :  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock!=  null?  falseBlock  :  tryBlock.getNext();	          Node    c    =    tryBlock.getNext();    Node    c    =    tryingBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol  falseBlock	106	None	replace
826	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  labelName!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  labelName!=  null);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    labelName);    	compilable	  [FE]  RuntimeException  	139	6	replace
827	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  labelName!=  null);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  labelName!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  labelName!=  null);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    labelName);    	compilable	  [FE]  RuntimeException  	139	6	replace
828	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  n.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  n.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    returnsType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	122	6	replace
829	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  n.getNext();  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  n.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  n.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    returnsType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	122	6	replace
830	[BUG]  [BUGGY]  tryMinimizeExits(n,  exitType,  labelName);  ifTree!=  tryMinimizeExits(n,  exitType,  labelName);  [CE]  not  a  statement  [FE]    StackOverflowError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(n,  exitType,  labelName);  ifTree!=  tryMinimizeExits(n,  exitType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(n,    exitType,    labelName);    ifTree!=  tryMinimizeExits(n,  exitType,  labelName);	  	non-compiled	[CE]  not  a  statement	97	None	add
831	[BUG]  [BUGGY]  [FE]  StackOverflowError  [FE]      StackOverflowError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(n,  exitType,  labelName);  tryMinimizeExits(n,  exitType,  labelName);  Preconditions.checkState(tryBlock.getFirstChild()  ==  null);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	tryMinimizeExits(n,    exitType,    labelName);    tryMinimizeExits(n,  exitType,  labelName);  Preconditions.checkState(tryBlock.getFirstChild()  ==  null);	  	compilable	  [FE]  StackOverflowError  	97	6	add
832	[BUG]  [BUGGY]  tryMinimizeExits(n,  exitType,  labelName);  tryMinimizeExits(n,  exitType,  labelName);  Preconditions.checkState(tryBlock.getFirstChild()  ==  null);  [FE]  StackOverflowError  [FE]      StackOverflowError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(n,  exitType,  labelName);  tryMinimizeExits(n,  exitType,  labelName);  Preconditions.checkState(tryBlock.getFirstChild()  ==  null);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(n,    exitType,    labelName);    tryMinimizeExits(n,  exitType,  labelName);  Preconditions.checkState(tryBlock.getFirstChild()  ==  null);	  	compilable	  [FE]  StackOverflowError  	97	6	add
833	[BUG]  [BUGGY]  [FE]  StackOverflowError  [FE]        StackOverflowError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(n,  exitType,  labelName);  tryMinimizeExits(n,  exitType,  labelName);  Preconditions.checkState(tryBlock.getFirstChild()!=  null);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	tryMinimizeExits(n,    exitType,    labelName);    tryMinimizeExits(n,  exitType,  labelName);  Preconditions.checkState(tryBlock.getFirstChild()!=  null);	  	compilable	  [FE]  StackOverflowError  	97	6	add
834	[BUG]  [BUGGY]  tryMinimizeExits(n,  exitType,  labelName);  tryMinimizeExits(n,  exitType,  labelName);  Preconditions.checkState(tryBlock.getFirstChild()!=  null);  [FE]  StackOverflowError  [FE]        StackOverflowError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(n,  exitType,  labelName);  tryMinimizeExits(n,  exitType,  labelName);  Preconditions.checkState(tryBlock.getFirstChild()!=  null);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(n,    exitType,    labelName);    tryMinimizeExits(n,  exitType,  labelName);  Preconditions.checkState(tryBlock.getFirstChild()!=  null);	  	compilable	  [FE]  StackOverflowError  	97	6	add
835	[BUG]  [BUGGY]  [FE]  StackOverflowError  [FE]          StackOverflowError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(n,  exitType,  labelName);  tryMinimizeExits(n,  exitType,  labelName);  Preconditions.checkState(tryBlock!=  null);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	tryMinimizeExits(n,    exitType,    labelName);    tryMinimizeExits(n,  exitType,  labelName);  Preconditions.checkState(tryBlock!=  null);	  	compilable	  [FE]  StackOverflowError  	97	6	add
836	[BUG]  [BUGGY]  tryMinimizeExits(n,  exitType,  labelName);  tryMinimizeExits(n,  exitType,  labelName);  Preconditions.checkState(tryBlock!=  null);  [FE]  StackOverflowError  [FE]          StackOverflowError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(n,  exitType,  labelName);  tryMinimizeExits(n,  exitType,  labelName);  Preconditions.checkState(tryBlock!=  null);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(n,    exitType,    labelName);    tryMinimizeExits(n,  exitType,  labelName);  Preconditions.checkState(tryBlock!=  null);	  	compilable	  [FE]  StackOverflowError  	97	6	add
837	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  	non-compiled	[CE]  cannot  find  symbol	20	None	add
838	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock  ==  null?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  escapeType  =  tryBlock  ==  null?  tryBlock.getNext()  :  null;	          Node    escapeType    =    tryBlock.getNext();    Node    escapeType    =    attemptBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	109	6	replace
839	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock  ==  null?  tryBlock.getNext()  :  null;  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock  ==  null?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock  ==  null?  tryBlock.getNext()  :  null;	          Node    escapeType    =    tryBlock.getNext();    Node    escapeType    =    attemptBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	109	6	replace
840	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getNext()  :  falseBlock;  [CE]  cannot  find  symbol  falseBlock  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getNext()  :  falseBlock;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  tryBlock.getNext()  :  falseBlock;	          Node    escapeType    =    tryBlock.getNext();    Node    escapeType    =    attemptBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol  falseBlock	109	None	replace
841	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  tryBlock.getType()  ==  Token.CATCH);  NodeUtil.checkCatchHandler(tryBlock.getType()  ==  Token.CATCH);  [CE]  cannot  find  symbol  [FE]        RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  tryBlock.getType()  ==  Token.CATCH);  NodeUtil.checkCatchHandler(tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  tryBlock.getType()  ==  Token.CATCH);  NodeUtil.checkCatchHandler(tryBlock.getType()  ==  Token.CATCH);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    NodeUtil.checkCatchHandler(tryBlock.getType()    ==    Token.CATCH);    	non-compiled	[CE]  cannot  find  symbol	174	None	replace
842	[BUG]  [BUGGY]  Node  exitType  =  tryBlock  ==  null?  tryBlock.getNext()  :  exitType;  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock  ==  null?  tryBlock.getNext()  :  exitType;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock  ==  null?  tryBlock.getNext()  :  exitType;	  Node    exitType    =    tryBlock!=    null?    tryBlock.getNext()    :    exitType;    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	145	None	replace
843	[BUG]  [BUGGY]  Node  exitType  =  tryBlock!=  null?  tryBlock.getNext()  :  falseBlock;  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock!=  null?  tryBlock.getNext()  :  falseBlock;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock!=  null?  tryBlock.getNext()  :  falseBlock;	  Node    exitType    =    tryBlock!=    null?    tryBlock.getNext()    :    exitType;    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	145	None	replace
844	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkNotNull(tryBlock);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkNotNull(tryBlock);	          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock    ==    null);    	compilable	  [FE]  AssertionFailedError  	58	6	replace
845	[BUG]  [BUGGY]  Preconditions.checkNotNull(tryBlock);  [FE]  AssertionFailedError  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkNotNull(tryBlock);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkNotNull(tryBlock);	          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock    ==    null);    	compilable	  [FE]  AssertionFailedError  	58	6	replace
846	[BUG]  [BUGGY]  Node  tryBlock  =  n.getFirstChild();  [CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  tryBlock  =  n.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  tryBlock  =  n.getFirstChild();	          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock    ==    null);    	non-compiled	[CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	58	None	replace
847	[BUG]  [BUGGY]  Preconditions.checkState(triesBlock!=  null);  [CE]  cannot  find  symbol  triesBlock  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(triesBlock!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(triesBlock!=  null);	          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock    ==    null);    	non-compiled	[CE]  cannot  find  symbol  triesBlock	58	None	replace
848	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(triesBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [CE]  cannot  find  symbol  triesBlock  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(triesBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(triesBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);	  	non-compiled	[CE]  cannot  find  symbol  triesBlock	63	None	add
849	[BUG]  [BUGGY]  NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  [CE]  cannot  find  symbol  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	NodeUtil.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=    Token.FUNCTION);    	non-compiled	[CE]  cannot  find  symbol	67	None	replace
850	[BUG]  [BUGGY]  Preconditions.checkState(triesBlock.getType()!=  Token.FUNCTION);  [CE]  cannot  find  symbol  triesBlock  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(triesBlock.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(triesBlock.getType()!=  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=    Token.FUNCTION);    	non-compiled	[CE]  cannot  find  symbol  triesBlock	67	None	replace
851	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT)  [CE]  ';'  expected  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT)  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT)	  	non-compiled	[CE]  ';'  expected	165	None	add
852	[BUG]  [BUGGY]  Node  exitType  =  n.getLastChild();  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  n.getLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  n.getLastChild();	  Node    exitType    =    tryBlock.getLastChild();    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	82	None	replace
853	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock  ==  null);  Node  tryBlock  =  n.getFirstChild();  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);  [CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock  ==  null);  Node  tryBlock  =  n.getFirstChild();  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock!=        null);        Preconditions.checkState(tryBlock    ==    null);    Node  tryBlock  =  n.getFirstChild();  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);	  	non-compiled	[CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	57	None	add
854	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  node  c  =  tryBlock.getNext();  [CE]  cannot  find  symbol  [FE]        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  node  c  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  node  c  =  tryBlock.getNext();	          Node    c    =    tryBlock.getNext();    node    c    =    tryBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol	149	None	replace
855	[BUG]  [BUGGY]  Preconditions.checkState(triesBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  triesBlock  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(triesBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(triesBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  cannot  find  symbol  triesBlock	117	None	replace
856	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION,  tryBlock.getType()  ==  Token.FUNCTION);  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  [CE]  cannot  find  symbol  [FE]        RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION,  tryBlock.getType()  ==  Token.FUNCTION);  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION,  tryBlock.getType()  ==  Token.FUNCTION);  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    NodeUtil.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  cannot  find  symbol	173	None	replace
857	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  NodeUtil.checkArgument(tryBlock,  tryBlock.getType()  ==  Token.FUNCTION);  [CE]  cannot  find  symbol  [FE]          RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  NodeUtil.checkArgument(tryBlock,  tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  NodeUtil.checkArgument(tryBlock,  tryBlock.getType()  ==  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    NodeUtil.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  cannot  find  symbol	173	None	replace
858	[BUG]  [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getNext()  :  escapeType;  [CE]  cannot  find  symbol  escapeType  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getNext()  :  escapeType;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock!=  null?  tryBlock.getNext()  :  escapeType;	  Node    returnType    =    tryBlock!=    null?    tryBlock.getNext()    :    exitType;    	non-compiled	[CE]  cannot  find  symbol  escapeType	133	None	replace
859	[BUG]  [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getNext()  :  exitType  +  1;  [CE]  incompatible  types  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getNext()  :  exitType  +  1;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock!=  null?  tryBlock.getNext()  :  exitType  +  1;	  Node    returnType    =    tryBlock!=    null?    tryBlock.getNext()    :    exitType;    	non-compiled	[CE]  incompatible  types	133	None	replace
860	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Node  tryBlock.getType()!=  Token.EXPR_RESULT);  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Node  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    Node  tryBlock.getType()!=  Token.EXPR_RESULT);	  	non-compiled	[CE]  ';'  expected	73	None	add
861	[BUG]  [BUGGY]  Preconditions.checkState(triesBlock.getType()!=  Token.CATCH);  [CE]  cannot  find  symbol  triesBlock  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(triesBlock.getType()!=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(triesBlock.getType()!=  Token.CATCH);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    	non-compiled	[CE]  cannot  find  symbol  triesBlock	91	None	replace
862	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.SCRIPT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.SCRIPT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    	compilable	  [FE]  RuntimeException  	91	6	replace
863	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.SCRIPT);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.SCRIPT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.SCRIPT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    	compilable	  [FE]  RuntimeException  	91	6	replace
864	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getParent()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  escapeType  =  tryBlock!=  null?  tryBlock.getParent()  :  null;	  Node    escapeType    =    tryBlock.getParent();    	compilable	  [FE]  AssertionFailedError  	30	6	replace
865	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getParent()  :  null;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getParent()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  tryBlock.getParent()  :  null;	  Node    escapeType    =    tryBlock.getParent();    	compilable	  [FE]  AssertionFailedError  	30	6	replace
866	[BUG]  [BUGGY]  tryMinimizeExits(exitType,  labelName,  exitType,  catchCodeBlock);  [CE]  cannot  find  symbol  catchCodeBlock  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(exitType,  labelName,  exitType,  catchCodeBlock);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(exitType,  labelName,  exitType,  catchCodeBlock);	  tryMinimizeExits(exitType,    labelName,    exitType);    	non-compiled	[CE]  cannot  find  symbol  catchCodeBlock	178	None	replace
867	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  escapeType  =  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  returnType  =  tryBlock.getNext();  Node  escapeType  =  tryBlock.getParent();	          Node    returnType    =    tryBlock.getNext();    Node    escapeType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	43	6	replace
868	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  escapeType  =  tryBlock.getParent();  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  escapeType  =  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getNext();  Node  escapeType  =  tryBlock.getParent();	          Node    returnType    =    tryBlock.getNext();    Node    escapeType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	43	6	replace
869	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  n.getNext();  Node  escapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  returnType  =  n.getNext();  Node  escapeType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    escapeType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	43	6	replace
870	[BUG]  [BUGGY]  Node  returnType  =  n.getNext();  Node  escapeType  =  tryBlock.getNext();  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  n.getNext();  Node  escapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  n.getNext();  Node  escapeType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    escapeType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	43	6	replace
871	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  escapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  returnType  =  tryBlock.getParent();  Node  escapeType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    escapeType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	43	6	replace
872	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  escapeType  =  tryBlock.getNext();  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  escapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getParent();  Node  escapeType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    escapeType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	43	6	replace
873	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.removeFirstChild();  Node  returnedType  =  tryBlock.removeFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node    returnType    =    tryBlock.removeFirstChild();    Node  returnedType  =  tryBlock.removeFirstChild();	  	compilable	  [FE]  AssertionFailedError  	176	6	add
874	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.removeFirstChild();  Node  returnedType  =  tryBlock.removeFirstChild();  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.removeFirstChild();  Node  returnedType  =  tryBlock.removeFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    returnType    =    tryBlock.removeFirstChild();    Node  returnedType  =  tryBlock.removeFirstChild();	  	compilable	  [FE]  AssertionFailedError  	176	6	add
875	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EMPTY);  Node  tryBlock.getType()  ==  Token.FUNCTION);  [CE]  ';'  expected  [FE]        RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EMPTY);  Node  tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.EMPTY);  Node  tryBlock.getType()  ==  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Node    tryBlock.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  ';'  expected	120	None	replace
876	[BUG]  [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  escapeType  =  tryBlock.getNext();  node  returnType  =  tryBlock.getNext();  Node  escapeType  =  tryBlock.getNext();  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  escapeType  =  tryBlock.getNext();  node  returnType  =  tryBlock.getNext();  Node  escapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        returnType        =        tryBlock.getNext();        Node    escapeType    =    tryBlock.getNext();    node  returnType  =  tryBlock.getNext();  Node  escapeType  =  tryBlock.getNext();	  	non-compiled	[CE]  cannot  find  symbol	42	None	add
877	[BUG]  [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  escapeType  =  tryBlock.getNext();  Node  returnType  =  tryBlock.getNext();  Node  EscapeType  =  tryBlock.getNext();  [CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  escapeType  =  tryBlock.getNext();  Node  returnType  =  tryBlock.getNext();  Node  EscapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        returnType        =        tryBlock.getNext();        Node    escapeType    =    tryBlock.getNext();    Node  returnType  =  tryBlock.getNext();  Node  EscapeType  =  tryBlock.getNext();	  	non-compiled	[CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	42	None	add
878	[BUG]  [BUGGY]  tryMinimizeExits(treeNode,  exitType,  labelName);  [CE]  cannot  find  symbol  treeNode  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(treeNode,  exitType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(treeNode,  exitType,  labelName);	  tryMinimizeExits(peekNode,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol  treeNode	86	None	replace
879	[BUG]  [BUGGY]  tryMinimizeExits(testNode,  exitType,  labelName);  [CE]  cannot  find  symbol  testNode  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(testNode,  exitType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(testNode,  exitType,  labelName);	  tryMinimizeExits(peekNode,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol  testNode	86	None	replace
880	[BUG]  [BUGGY]  tryMinimizeExits(triesBlock,  exitType,  labelName);  [CE]  cannot  find  symbol  triesBlock  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(triesBlock,  exitType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(triesBlock,  exitType,  labelName);	  tryMinimizeExits(peekNode,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol  triesBlock	86	None	replace
881	[BUG]  [BUGGY]  tryMinimizeExits(treeBlock,  exitType,  labelName);  [CE]  cannot  find  symbol  treeBlock  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(treeBlock,  exitType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(treeBlock,  exitType,  labelName);	  tryMinimizeExits(testBlock,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol  treeBlock	125	None	replace
882	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  Node  tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  [CE]  ';'  expected  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  Node  tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.CATCH);    Node  tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);	  	non-compiled	[CE]  ';'  expected	118	None	add
883	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(triesBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  [CE]  cannot  find  symbol  triesBlock  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.checkState(triesBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()!=    Token.FUNCTION);    Preconditions.checkState(triesBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);	  	non-compiled	[CE]  cannot  find  symbol  triesBlock	66	None	add
884	[BUG]  [BUGGY]  Node  c  =  tryBlock  ==  null?  falseBlock  :  tryBlock.getNext();  [CE]  cannot  find  symbol  falseBlock  [FE]        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock  ==  null?  falseBlock  :  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock  ==  null?  falseBlock  :  tryBlock.getNext();	          Node    c    =    tryBlock.getNext();    Node    c    =    tryBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol  falseBlock	102	None	replace
885	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getNext()  :  falseBlock;  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getNext()  :  falseBlock;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getNext()  :  falseBlock;	  Node    escapeType    =    tryBlock.getNext()    :    null;    	non-compiled	[CE]  ';'  expected	31	None	replace
886	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getNext()  :  exitType;  [CE]  ';'  expected  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getNext()  :  exitType;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getNext()  :  exitType;	  Node    escapeType    =    tryBlock.getNext()    :    null;    	non-compiled	[CE]  ';'  expected	31	None	replace
887	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  Node  n  =  tryBlock.getFirstChild();  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  [CE]  variable  n  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  Node  n  =  tryBlock.getFirstChild();  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()    ==    Token.FUNCTION);    Node  n  =  tryBlock.getFirstChild();  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);	  	non-compiled	[CE]  variable  n  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	14	None	add
888	[BUG]  [BUGGY]  Node  c  =  tryBlock.getType()  ==  Token.CATCH;  [CE]  incompatible  types  [FE]            RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getType()  ==  Token.CATCH;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock.getType()  ==  Token.CATCH;	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Node    c    =    tryBlock.getType()    ==    Token.CATCH;    Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    	non-compiled	[CE]  incompatible  types	92	None	replace
889	[BUG]  [BUGGY]  Node  c  =  tryBlock.getType()  {  Token.CATCH;  Preconditions.checkState(c.getType()  ==  Token.CATCH);  [CE]  ';'  expected  [FE]              RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getType()  {  Token.CATCH;  Preconditions.checkState(c.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock.getType()  {  Token.CATCH;  Preconditions.checkState(c.getType()  ==  Token.CATCH);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Node    c    =    tryBlock.getType()    ==    Token.CATCH;    Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    	non-compiled	[CE]  ';'  expected	92	None	replace
890	[BUG]  [BUGGY]  Node  returnType  =  n.getNext();  Node  exitType  =  tryBlock.getNext();  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  n.getNext();  Node  exitType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  n.getNext();  Node  exitType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    exitType    =    tryBlock.getNext();    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	41	None	replace
891	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getNext(),  exitType  =  tryBlock.getNext();  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext(),  exitType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getNext(),  exitType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    exitType    =    tryBlock.getNext();    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	41	None	replace
892	[BUG]  [BUGGY]  tryMinimizeExit(trBlock,  exitType,  labelName);  [CE]  cannot  find  symbol  trBlock  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExit(trBlock,  exitType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExit(trBlock,  exitType,  labelName);	  tryMinimizeExit(catchNode,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol  trBlock	100	None	replace
893	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  NodeUtil.checkState(tryBlock.getType()  >>  Token.CATCH);  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  NodeUtil.checkState(tryBlock.getType()  >>  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    NodeUtil.checkState(tryBlock.getType()  >>  Token.CATCH);	  	non-compiled	[CE]  cannot  find  symbol	114	None	add
894	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getParent();  Node  EscapeType  =  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node    escapeType    =    tryBlock.getParent();    Node  EscapeType  =  tryBlock.getParent();	  	compilable	  [FE]  AssertionFailedError  	29	2	add
895	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getParent();  Node  EscapeType  =  tryBlock.getParent();  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getParent();  Node  EscapeType  =  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    escapeType    =    tryBlock.getParent();    Node  EscapeType  =  tryBlock.getParent();	  	compilable	  [FE]  AssertionFailedError  	29	2	add
896	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getParent();  node  escapeType  =  tryBlock.getParent();  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getParent();  node  escapeType  =  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    escapeType    =    tryBlock.getParent();    node  escapeType  =  tryBlock.getParent();	  	non-compiled	[CE]  cannot  find  symbol	29	None	add
897	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CATCH);  Node  c  =  tryBlock.getNext();  Preconditions.checkState(n.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(n.getType()    ==    Token.CATCH);    Node  c  =  tryBlock.getNext();  Preconditions.checkState(n.getType()  ==  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	112	6	add
898	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CATCH);  Node  c  =  tryBlock.getNext();  Preconditions.checkState(n.getType()  ==  Token.CATCH);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CATCH);  Node  c  =  tryBlock.getNext();  Preconditions.checkState(n.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()    ==    Token.CATCH);    Node  c  =  tryBlock.getNext();  Preconditions.checkState(n.getType()  ==  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	112	6	add
899	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()    >=    Token.FUNCTION);    	compilable	  [FE]  AssertionFailedError  	69	6	replace
900	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  [FE]  AssertionFailedError  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()    >=    Token.FUNCTION);    	compilable	  [FE]  AssertionFailedError  	69	6	replace
901	[BUG]  [BUGGY]  Preconditions.checkState(triesBlock.getType()  >=  Token.FUNCTION);  [CE]  cannot  find  symbol  triesBlock  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(triesBlock.getType()  >=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(triesBlock.getType()  >=  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()    >=    Token.FUNCTION);    	non-compiled	[CE]  cannot  find  symbol  triesBlock	69	None	replace
902	[BUG]  [BUGGY]  Preconditions.checkState(ifBlock!=  null);  [CE]  cannot  find  symbol  ifBlock  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(ifBlock!=  null);  [BUGGY]    null);  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(ifBlock!=  null);	          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock    	non-compiled	[CE]  cannot  find  symbol  ifBlock	62	None	replace
903	[BUG]  [BUGGY]  Preconditions.checkState(triesBlock.getType()!=  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  triesBlock  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(triesBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(triesBlock.getType()!=  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    	non-compiled	[CE]  cannot  find  symbol  triesBlock	74	None	replace
904	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock!=  null,  tryBlock);	          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock    >>    null);    	compilable	  [FE]  AssertionFailedError  	60	6	replace
905	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock);  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=  null,  tryBlock);	          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock    >>    null);    	compilable	  [FE]  AssertionFailedError  	60	6	replace
906	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  exitType,  labelName);  [CE]  no  suitable  method  found  for  checkState(boolean,int,String)  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  exitType,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  exitType,  labelName);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH,    exitType);    	non-compiled	[CE]  no  suitable  method  found  for  checkState(boolean,int,String)	135	None	replace
907	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getNext()!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getNext()!=  null);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getFirstChild()!=    null);    	compilable	  [FE]  AssertionFailedError  	156	6	replace
908	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getNext()!=  null);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getNext()!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getNext()!=  null);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getFirstChild()!=    null);    	compilable	  [FE]  AssertionFailedError  	156	6	replace
909	[BUG]  [BUGGY]  Node  c  =  tryBlock.removeFirstChild();  node  c  =  tryBlock.removeFirstChild();  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.removeFirstChild();  node  c  =  tryBlock.removeFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.removeFirstChild();    node  c  =  tryBlock.removeFirstChild();	  	non-compiled	[CE]  cannot  find  symbol	187	None	add
910	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getNext(),  labelName  =  tryBlock.getNext();  [CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext(),  labelName  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getNext(),  labelName  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    labelName    =    tryBlock.getNext();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	46	None	replace
911	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  labelName  =  n.getNext();  [CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  labelName  =  n.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getNext();  Node  labelName  =  n.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    labelName    =    tryBlock.getNext();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	46	None	replace
912	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(triesBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  [CE]  cannot  find  symbol  triesBlock  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.checkState(triesBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.CATCH);        Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    Preconditions.checkState(triesBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);	  	non-compiled	[CE]  cannot  find  symbol  triesBlock	90	None	add
913	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Node  tryBlock  =  tryBlock.getFirstChild();  [CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]        RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Node  tryBlock  =  tryBlock.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Node  tryBlock  =  tryBlock.getFirstChild();	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Node    tryBlock    =    tryBlock.getFirstChild();    Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	171	None	replace
914	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getFirstChild()  :  tryBlock.getLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  escapeType  =  tryBlock!=  null?  tryBlock.getFirstChild()  :  tryBlock.getLastChild();	  Node    escapeType    =    tryBlock.getFirstChild();    	compilable	  [FE]  AssertionFailedError  	186	6	replace
915	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getFirstChild()  :  tryBlock.getLastChild();  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getFirstChild()  :  tryBlock.getLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  tryBlock.getFirstChild()  :  tryBlock.getLastChild();	  Node    escapeType    =    tryBlock.getFirstChild();    	compilable	  [FE]  AssertionFailedError  	186	6	replace
916	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getLastChild()  :  tryBlock.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  escapeType  =  tryBlock!=  null?  tryBlock.getLastChild()  :  tryBlock.getFirstChild();	  Node    escapeType    =    tryBlock.getFirstChild();    	compilable	  [FE]  AssertionFailedError  	186	6	replace
917	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getLastChild()  :  tryBlock.getFirstChild();  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getLastChild()  :  tryBlock.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  tryBlock.getLastChild()  :  tryBlock.getFirstChild();	  Node    escapeType    =    tryBlock.getFirstChild();    	compilable	  [FE]  AssertionFailedError  	186	6	replace
918	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getLastChild()  :  tryBlock.getLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  escapeType  =  tryBlock!=  null?  tryBlock.getLastChild()  :  tryBlock.getLastChild();	  Node    escapeType    =    tryBlock.getFirstChild();    	compilable	  [FE]  AssertionFailedError  	186	6	replace
919	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getLastChild()  :  tryBlock.getLastChild();  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getLastChild()  :  tryBlock.getLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  tryBlock.getLastChild()  :  tryBlock.getLastChild();	  Node    escapeType    =    tryBlock.getFirstChild();    	compilable	  [FE]  AssertionFailedError  	186	6	replace
920	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(triesBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [CE]  cannot  find  symbol  triesBlock  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(triesBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.CATCH);        Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(triesBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);	  	non-compiled	[CE]  cannot  find  symbol  triesBlock	88	None	add
921	[BUG]  [BUGGY]  tryMinimizeExits(testNodes,  exitType,  labelName);  [CE]  cannot  find  symbol  testNodes  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(testNodes,  exitType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(testNodes,  exitType,  labelName);	  tryMinimizeExits(callNodes,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol  testNodes	87	None	replace
922	[BUG]  [BUGGY]  tryMinimizeExits(throwBlock,  exitType,  labelName);  [CE]  cannot  find  symbol  throwBlock  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(throwBlock,  exitType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(throwBlock,  exitType,  labelName);	  tryMinimizeExits(callNodes,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol  throwBlock	87	None	replace
923	[BUG]  [BUGGY]  tryMinimizeExits(tries,  exitType,  labelName);  [CE]  cannot  find  symbol  tries  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(tries,  exitType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(tries,  exitType,  labelName);	  tryMinimizeExits(callNodes,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol  tries	87	None	replace
924	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	34	6	add
925	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	34	6	add
926	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT  &&  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT  &&  tryBlock.getType()!=  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	78	6	replace
927	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT  &&  tryBlock.getType()!=  Token.EXPR_RESULT);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT  &&  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT  &&  tryBlock.getType()!=  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	78	6	replace
928	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.GETPROP);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.GETPROP);	  Preconditions.checkState(tryBlock    ==    null);    	compilable	  [FE]  RuntimeException  	48	6	replace
929	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.GETPROP);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.GETPROP);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.GETPROP);	  Preconditions.checkState(tryBlock    ==    null);    	compilable	  [FE]  RuntimeException  	48	6	replace
930	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getNext()  -  1;  Node  exitType  =  tryBlock.getNext();  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getNext()  -  1;  Node  exitType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getNext()  -  1;  Node  exitType  =  tryBlock.getNext();	          Node    escapeType    =    tryBlock.getNext();    Node    exitType    =    tryBlock.getNext();    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	108	None	replace
931	[BUG]  [BUGGY]  Node  escapeType  =  n.getNext();  Node  exitType  =  tryBlock.getNext();  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  n.getNext();  Node  exitType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  n.getNext();  Node  exitType  =  tryBlock.getNext();	          Node    escapeType    =    tryBlock.getNext();    Node    exitType    =    tryBlock.getNext();    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	108	None	replace
932	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]            RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    NodeUtil.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  cannot  find  symbol	36	None	replace
933	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]              RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  tryBlock.getType()  ==  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    NodeUtil.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	36	6	replace
934	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]              RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  tryBlock.getType()  ==  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    NodeUtil.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	36	6	replace
935	[BUG]  [BUGGY]  Node  c  =  tryBlock  ==  null?  null  :  tryBlock.getCurrentStructure();  [CE]  cannot  find  symbol  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock  ==  null?  null  :  tryBlock.getCurrentStructure();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock  ==  null?  null  :  tryBlock.getCurrentStructure();	  Node    c    =    tryBlock.getCurrentStructure();    	non-compiled	[CE]  cannot  find  symbol	13	None	replace
936	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getCurrentStructure()  :  null;  [CE]  cannot  find  symbol  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getCurrentStructure()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock!=  null?  tryBlock.getCurrentStructure()  :  null;	  Node    c    =    tryBlock.getCurrentStructure();    	non-compiled	[CE]  cannot  find  symbol	13	None	replace
937	[BUG]  [BUGGY]  Node  c  =  tryBlock.nextStructure();  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.nextStructure();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock.nextStructure();	  Node    c    =    tryBlock.getCurrentStructure();    	non-compiled	[CE]  cannot  find  symbol	13	None	replace
938	[BUG]  [BUGGY]  Node  c  =  tryBlock.getFirstChild();  Node  c  =  tryBlock.getfirstChild();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getFirstChild();  Node  c  =  tryBlock.getfirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.getFirstChild();    Node  c  =  tryBlock.getfirstChild();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	11	None	add
939	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  NodeUtil.checkState(tryBlock,  tryBlock.getType()  ==  Token.FUNCTION);  [CE]  cannot  find  symbol  [FE]          RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  NodeUtil.checkState(tryBlock,  tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  NodeUtil.checkState(tryBlock,  tryBlock.getType()  ==  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    NodeUtil.checkState(tryBlock.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  cannot  find  symbol	65	None	replace
940	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getEscaped()  :  null;  [CE]  cannot  find  symbol  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getEscaped()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  tryBlock.getEscaped()  :  null;	  Node    escapeType    =    tryBlock.getEscaped();    	non-compiled	[CE]  cannot  find  symbol	147	None	replace
941	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getEscaped()  :  Integer.parseInt(tryBlock.getLastChild());  [CE]  cannot  find  symbol  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getEscaped()  :  Integer.parseInt(tryBlock.getLastChild());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  tryBlock.getEscaped()  :  Integer.parseInt(tryBlock.getLastChild());	  Node    escapeType    =    tryBlock.getEscaped();    	non-compiled	[CE]  cannot  find  symbol	147	None	replace
942	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getEscaped()  :  falseBlock;  [CE]  cannot  find  symbol  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getEscaped()  :  falseBlock;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  tryBlock.getEscaped()  :  falseBlock;	  Node    escapeType    =    tryBlock.getEscaped();    	non-compiled	[CE]  cannot  find  symbol	147	None	replace
943	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getEscaped()  :  exitType;  [CE]  cannot  find  symbol  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getEscaped()  :  exitType;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  tryBlock.getEscaped()  :  exitType;	  Node    escapeType    =    tryBlock.getEscaped();    	non-compiled	[CE]  cannot  find  symbol	147	None	replace
944	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  NodeUtil.checkState(tryBlock,  tryBlock.getType()  ==  Token.CATCH);  [CE]  cannot  find  symbol  [FE]              RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  NodeUtil.checkState(tryBlock,  tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  NodeUtil.checkState(tryBlock,  tryBlock.getType()  ==  Token.CATCH);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    NodeUtil.checkState(tryBlock.getType()    ==    Token.CATCH);    	non-compiled	[CE]  cannot  find  symbol	93	None	replace
945	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()!=  Token.CATCH,  exitType);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()    >>    Token.CATCH);    	compilable	  [FE]  AssertionFailedError  	95	6	replace
946	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH,  exitType);  [FE]  AssertionFailedError  [FE]                  RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=  Token.CATCH,  exitType);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()    >>    Token.CATCH);    	compilable	  [FE]  AssertionFailedError  	95	6	replace
947	[BUG]  [BUGGY]  Preconditions.checkState(tree.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  tree  [FE]            RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tree.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tree.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(triesBlock.getType()    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  cannot  find  symbol  tree	140	None	replace
948	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  n.getNext();  Node  returnedType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  returnType  =  n.getNext();  Node  returnedType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    returnedType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	45	6	replace
949	[BUG]  [BUGGY]  Node  returnType  =  n.getNext();  Node  returnedType  =  tryBlock.getNext();  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  n.getNext();  Node  returnedType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  n.getNext();  Node  returnedType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    returnedType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	45	6	replace
950	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  returnedType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  returnType  =  tryBlock.getParent();  Node  returnedType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    returnedType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	45	6	replace
951	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  returnedType  =  tryBlock.getNext();  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  returnedType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getParent();  Node  returnedType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    returnedType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	45	6	replace
952	[BUG]  [BUGGY]  Node  exitType  =  tryBlock!=  null?  tryBlock.getFirstChild()  :  tryBlock.getLastChild();  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock!=  null?  tryBlock.getFirstChild()  :  tryBlock.getLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock!=  null?  tryBlock.getFirstChild()  :  tryBlock.getLastChild();	  Node    exitType    =    tryBlock.getFirstChild();    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	167	None	replace
953	[BUG]  [BUGGY]  Node  exitType  =  tryBlock!=  null?  tryBlock.getLastChild()  :  tryBlock.getFirstChild();  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock!=  null?  tryBlock.getLastChild()  :  tryBlock.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock!=  null?  tryBlock.getLastChild()  :  tryBlock.getFirstChild();	  Node    exitType    =    tryBlock.getFirstChild();    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	167	None	replace
954	[BUG]  [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  node  returnType  =  tryBlock.getNext();  [CE]  cannot  find  symbol  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  node  returnType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  node  returnType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    node    returnType    =    tryBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol	123	None	replace
955	[BUG]  [BUGGY]  Node  returnType  =  n.getNext();  node  returnType  =  tryBlock.getNext();  [CE]  cannot  find  symbol  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  n.getNext();  node  returnType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  n.getNext();  node  returnType  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    node    returnType    =    tryBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol	123	None	replace
956	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getFirstChild()  :  tryBlock.getLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  returnType  =  tryBlock!=  null?  tryBlock.getFirstChild()  :  tryBlock.getLastChild();	  Node    returnType    =    tryBlock.getFirstChild();    	compilable	  [FE]  AssertionFailedError  	6	6	replace
957	[BUG]  [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getFirstChild()  :  tryBlock.getLastChild();  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getFirstChild()  :  tryBlock.getLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock!=  null?  tryBlock.getFirstChild()  :  tryBlock.getLastChild();	  Node    returnType    =    tryBlock.getFirstChild();    	compilable	  [FE]  AssertionFailedError  	6	6	replace
958	[BUG]  [BUGGY]  Preconditions.checkState(triesBlock.getType()  ==  Token.FUNCTION);  [CE]  cannot  find  symbol  triesBlock  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(triesBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(triesBlock.getType()  ==  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  cannot  find  symbol  triesBlock	64	None	replace
959	[BUG]  [BUGGY]  tryMinimizeExits(tryBlock,  n,  exitType,  labelName);  [CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(tryBlock,  n,  exitType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(tryBlock,  n,  exitType,  labelName);	  tryMinimizeExits(n,    labelName,    exitType,    exitType);    	non-compiled	[CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;	128	None	replace
960	[BUG]  [BUGGY]  tryMinimizeExits(tree,  n,  labelName,  exitType,  exitType);  [CE]  cannot  find  symbol  tree  [FE]                      AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(tree,  n,  labelName,  exitType,  exitType);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(tree,  n,  labelName,  exitType,  exitType);	  tryMinimizeExits(n,    labelName,    exitType,    exitType);    	non-compiled	[CE]  cannot  find  symbol  tree	128	None	replace
961	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  Node  tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  Node  tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getFirstChild()!=    null);    Node  tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);	  	non-compiled	[CE]  ';'  expected	155	None	add
962	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  NodeUtil.copyName(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  NodeUtil.copyName(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getFirstChild()!=    null);    NodeUtil.copyName(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);	  	non-compiled	[CE]  cannot  find  symbol	155	None	add
963	[BUG]  [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnsType  =  tryBlock.getNext();  node  returnType  =  tryBlock.getNext();  Node  returnsType  =  tryBlock.getNext();  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnsType  =  tryBlock.getNext();  node  returnType  =  tryBlock.getNext();  Node  returnsType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        returnType        =        tryBlock.getNext();        Node    returnsType    =    tryBlock.getNext();    node  returnType  =  tryBlock.getNext();  Node  returnsType  =  tryBlock.getNext();	  	non-compiled	[CE]  cannot  find  symbol	121	None	add
964	[BUG]  [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnsType  =  tryBlock.getNext();  Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  TryBlock.getNext();  [CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnsType  =  tryBlock.getNext();  Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  TryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        returnType        =        tryBlock.getNext();        Node    returnsType    =    tryBlock.getNext();    Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  TryBlock.getNext();	  	non-compiled	[CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	121	None	add
965	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  returnType  =  tryBlock.getNext();  [CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  returnType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    returnType    =    tryBlock.getParent();    Node  returnType  =  tryBlock.getNext();	  	non-compiled	[CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	131	None	add
966	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  startType  =  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node    returnType    =    tryBlock.getParent();    Node  startType  =  tryBlock.getParent();	  	compilable	  [FE]  AssertionFailedError  	131	2	add
967	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  startType  =  tryBlock.getParent();  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getParent();  Node  startType  =  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    returnType    =    tryBlock.getParent();    Node  startType  =  tryBlock.getParent();	  	compilable	  [FE]  AssertionFailedError  	131	2	add
968	[BUG]  [BUGGY]          Node    escapeType    =    tryBlock.getNext();    Node  EscapeType  =  tryBlock.getNext();  Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  TryBlock.getNext();  [CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    escapeType    =    tryBlock.getNext();    Node  EscapeType  =  tryBlock.getNext();  Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  TryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        escapeType        =        tryBlock.getNext();        Node    EscapeType    =    tryBlock.getNext();    Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  TryBlock.getNext();	  	non-compiled	[CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	141	None	add
969	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.replaceChild(n,  falseBlock);  [CE]  cannot  find  symbol  falseBlock  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.replaceChild(n,  falseBlock);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.replaceChild(n,  falseBlock);	  Node    returnType    =    tryBlock.removeFirstChild();    	non-compiled	[CE]  cannot  find  symbol  falseBlock	177	None	replace
970	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getFalse()  :  null;  [CE]  cannot  find  symbol  [FE]        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getFalse()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  tryBlock.getFalse()  :  null;	  Node    escapeType    =    tryBlock.getFalse();    	non-compiled	[CE]  cannot  find  symbol	27	None	replace
971	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getFalse()  :  exitType;  [CE]  cannot  find  symbol  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getFalse()  :  exitType;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  tryBlock.getFalse()  :  exitType;	  Node    escapeType    =    tryBlock.getFalse();    	non-compiled	[CE]  cannot  find  symbol	27	None	replace
972	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getFalse()  :  false;  [CE]  cannot  find  symbol  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getFalse()  :  false;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  tryBlock.getFalse()  :  false;	  Node    escapeType    =    tryBlock.getFalse();    	non-compiled	[CE]  cannot  find  symbol	27	None	replace
973	[BUG]  [BUGGY]  tryMinimizeExit(tryBlock,  exitType,  labelName,  null);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExit(tryBlock,  exitType,  labelName,  null);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExit(tryBlock,  exitType,  labelName,  null);	  tryMinimizeExit(tryBlock,    exitType,    labelName,    false);    	non-compiled	[CE]  cannot  find  symbol	191	None	replace
974	[BUG]  [BUGGY]  tryMinimizeExit(tree,  exitType,  labelName,  false);  [CE]  cannot  find  symbol  tree  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExit(tree,  exitType,  labelName,  false);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExit(tree,  exitType,  labelName,  false);	  tryMinimizeExit(tryBlock,    exitType,    labelName,    false);    	non-compiled	[CE]  cannot  find  symbol  tree	191	None	replace
975	[BUG]  [BUGGY]  Node  exitType  =  tryBlock!=  null?  tryBlock.getExitType()  :  exitType;  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock!=  null?  tryBlock.getExitType()  :  exitType;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock!=  null?  tryBlock.getExitType()  :  exitType;	  Node    exitType    =    tryBlock.getExitType();    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	144	None	replace
976	[BUG]  [BUGGY]  Node  exitType  =  tryBlock!=  null?  tryBlock.getExitType()  :  escapeType;  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock!=  null?  tryBlock.getExitType()  :  escapeType;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock!=  null?  tryBlock.getExitType()  :  escapeType;	  Node    exitType    =    tryBlock.getExitType();    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	144	None	replace
977	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  Node  escapeType  =  tryBlock.getParent();  [CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  Node  escapeType  =  tryBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  Node  escapeType  =  tryBlock.getParent();	          Node    escapeType    =    tryBlock.getNext();    Node    escapeType    =    tryBlock.getParent();    	non-compiled	[CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	175	None	replace
978	[BUG]  [BUGGY]  NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	NodeUtil.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    	non-compiled	[CE]  cannot  find  symbol	35	None	replace
979	[BUG]  [BUGGY]  tryMinimizeExits(peekNode,  exitType,  labelName,  false);  [CE]  cannot  find  symbol  peekNode  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(peekNode,  exitType,  labelName,  false);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(peekNode,  exitType,  labelName,  false);	  tryMinimizeExits(catchNodes,    exitType,    labelName,    false);    	non-compiled	[CE]  cannot  find  symbol  peekNode	169	None	replace
980	[BUG]  [BUGGY]  Node  labelName  =  tryBlock.getNext(),  falseBlock);  [CE]  ';'  expected  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  tryBlock.getNext(),  falseBlock);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  tryBlock.getNext(),  falseBlock);	  Node    labelName    =    tryBlock.getNext(),    exitType);    	non-compiled	[CE]  ';'  expected	170	None	replace
981	[BUG]  [BUGGY]  tryMinimizeExits(labelName,  exitType,  labelName,  tryBlock);  [CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(labelName,  exitType,  labelName,  tryBlock);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(labelName,  exitType,  labelName,  tryBlock);	  tryMinimizeExits(labelName,    exitType,    labelName);    	non-compiled	[CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;	83	None	replace
982	[BUG]  [BUGGY]  tryMinimizeExits(tree,  labelName,  exitType,  labelName);  [CE]  cannot  find  symbol  tree  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(tree,  labelName,  exitType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(tree,  labelName,  exitType,  labelName);	  tryMinimizeExits(labelName,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol  tree	83	None	replace
983	[BUG]  [BUGGY]  tryMinimizeExits(labelName,  n,  exitType,  catchCodeBlock);  [CE]  cannot  find  symbol  catchCodeBlock  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(labelName,  n,  exitType,  catchCodeBlock);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(labelName,  n,  exitType,  catchCodeBlock);	  tryMinimizeExits(labelName,    n,    exitType,    exitType);    	non-compiled	[CE]  cannot  find  symbol  catchCodeBlock	84	None	replace
984	[BUG]  [BUGGY]  tryMinimizeExits(labelName,  n,  exitType,  escapeType);  [CE]  cannot  find  symbol  escapeType  [FE]                      AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(labelName,  n,  exitType,  escapeType);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(labelName,  n,  exitType,  escapeType);	  tryMinimizeExits(labelName,    n,    exitType,    exitType);    	non-compiled	[CE]  cannot  find  symbol  escapeType	84	None	replace
985	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getExitType()  :  null;  [CE]  cannot  find  symbol  [FE]        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getExitType()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  tryBlock.getExitType()  :  null;	  Node    escapeType    =    tryBlock.getExitType();    	non-compiled	[CE]  cannot  find  symbol	146	None	replace
986	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getExitType()  :  exitType;  [CE]  cannot  find  symbol  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getExitType()  :  exitType;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  tryBlock.getExitType()  :  exitType;	  Node    escapeType    =    tryBlock.getExitType();    	non-compiled	[CE]  cannot  find  symbol	146	None	replace
987	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock  ==  null?  tryBlock.getExitType()  :  null;  [CE]  cannot  find  symbol  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock  ==  null?  tryBlock.getExitType()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock  ==  null?  tryBlock.getExitType()  :  null;	  Node    escapeType    =    tryBlock.getExitType();    	non-compiled	[CE]  cannot  find  symbol	146	None	replace
988	[BUG]  [BUGGY]  Preconditions.checkState(triesBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  triesBlock  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(triesBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(triesBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  cannot  find  symbol  triesBlock	76	None	replace
989	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  node  escapeType  =  tryBlock.getNext();  [CE]  cannot  find  symbol  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  node  escapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  node  escapeType  =  tryBlock.getNext();	          Node    escapeType    =    tryBlock.getNext();    node    escapeType    =    tryBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol	111	None	replace
990	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getNext();  nodeEscapeType  =  tryBlock.getNext();  [CE]  cannot  find  symbol  nodeEscapeType  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getNext();  nodeEscapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getNext();  nodeEscapeType  =  tryBlock.getNext();	          Node    escapeType    =    tryBlock.getNext();    node    escapeType    =    tryBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol  nodeEscapeType	111	None	replace
991	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getNext();  node,  escapeType  =  tryBlock.getNext();  [CE]  not  a  statement  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getNext();  node,  escapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getNext();  node,  escapeType  =  tryBlock.getNext();	          Node    escapeType    =    tryBlock.getNext();    node    escapeType    =    tryBlock.getNext();    	non-compiled	[CE]  not  a  statement	111	None	replace
992	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getFirstChild();  Node  EscapeType  =  tryBlock.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node    escapeType    =    tryBlock.getFirstChild();    Node  EscapeType  =  tryBlock.getFirstChild();	  	compilable	  [FE]  AssertionFailedError  	185	2	add
993	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getFirstChild();  Node  EscapeType  =  tryBlock.getFirstChild();  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getFirstChild();  Node  EscapeType  =  tryBlock.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    escapeType    =    tryBlock.getFirstChild();    Node  EscapeType  =  tryBlock.getFirstChild();	  	compilable	  [FE]  AssertionFailedError  	185	2	add
994	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getFirstChild();  Node  escapeType  =  tryBlock.getfirstChild();  [CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getFirstChild();  Node  escapeType  =  tryBlock.getfirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    escapeType    =    tryBlock.getFirstChild();    Node  escapeType  =  tryBlock.getfirstChild();	  	non-compiled	[CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	185	None	add
995	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()    >=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	38	6	add
996	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()    >=    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	38	6	add
997	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  returnType  =  tryBlock!=  null?  tryBlock.getNext()  :  null;	  Node    returnType    =    tryBlock.getParent();    	compilable	  [FE]  AssertionFailedError  	132	6	replace
998	[BUG]  [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock!=  null?  tryBlock.getNext()  :  null;	  Node    returnType    =    tryBlock.getParent();    	compilable	  [FE]  AssertionFailedError  	132	6	replace
999	[BUG]  [BUGGY]  tryMinimizeExit(testBlock,  exitType,  labelName);  [CE]  cannot  find  symbol  testBlock  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExit(testBlock,  exitType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExit(testBlock,  exitType,  labelName);	  tryMinimizeExit(tree,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol  testBlock	151	None	replace
1000	[BUG]  [BUGGY]  tryMinimizeExit(triesBlock,  exitType,  labelName);  [CE]  cannot  find  symbol  triesBlock  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExit(triesBlock,  exitType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExit(triesBlock,  exitType,  labelName);	  tryMinimizeExit(tree,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol  triesBlock	151	None	replace
1001	[BUG]  [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnedType  =  tryBlock.getNext();  Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  TryBlock.getNext();  [CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnedType  =  tryBlock.getNext();  Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  TryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        returnType        =        tryBlock.getNext();        Node    returnedType    =    tryBlock.getNext();    Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  TryBlock.getNext();	  	non-compiled	[CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	44	None	add
1002	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getNext()?  tryBlock.getNext()  :  null;  [CE]  incompatible  types  [FE]        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext()?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getNext()?  tryBlock.getNext()  :  null;	          Node    returnType    =    tryBlock.getNext();    Node    returnType    =    tryBlock.getNext();    	non-compiled	[CE]  incompatible  types	40	None	replace
1003	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Node  tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  ';'  expected  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Node  tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Node  tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	non-compiled	[CE]  ';'  expected	75	None	add
1004	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  Node  tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  Node  tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.hasChildren());    Node  tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());	  	non-compiled	[CE]  ';'  expected	153	None	add
1005	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  NodeUtil.copyName(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  NodeUtil.copyName(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.hasChildren());    NodeUtil.copyName(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());	  	non-compiled	[CE]  cannot  find  symbol	153	None	add
1006	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  triedBlock.getNext()  :  null;  [CE]  cannot  find  symbol  triedBlock  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  triedBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock!=  null?  triedBlock.getNext()  :  null;	          Node    c    =    tryBlock.getNext();    Node    c    =    triedBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol  triedBlock	105	None	replace
1007	[BUG]  [BUGGY]  Node  c  =  tryBlock.cloneTree(n);  [CE]  method  cloneTree  in  class  Node  cannot  be  applied  to  given  types;  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.cloneTree(n);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock.cloneTree(n);	  Node    c    =    tryBlock.cloneTree();    	non-compiled	[CE]  method  cloneTree  in  class  Node  cannot  be  applied  to  given  types;	190	None	replace
1008	[BUG]  [BUGGY]  Preconditions.checkState(triesBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  triesBlock  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(triesBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(triesBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  cannot  find  symbol  triesBlock	19	None	replace
1009	[BUG]  [BUGGY]  Node  exitType  =  tryBlock.getNext()  +  1;  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock.getNext()  +  1;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock.getNext()  +  1;	  Node    exitType    =    tryBlock.getNext()    -    1;    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	80	None	replace
1010	[BUG]  [BUGGY]  Node  exitType  =  tryBlock.getNext()  -  1L;  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock.getNext()  -  1L;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock.getNext()  -  1L;	  Node    exitType    =    tryBlock.getNext()    -    1;    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	80	None	replace
1011	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  exitType);  Node  tryBlock.getType()  ==  Token.CATCH,  exitType);  [CE]  ';'  expected  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH,  exitType);  Node  tryBlock.getType()  ==  Token.CATCH,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH,    exitType);    Node  tryBlock.getType()  ==  Token.CATCH,  exitType);	  	non-compiled	[CE]  ';'  expected	134	None	add
1012	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	18	6	add
1013	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	18	6	add
1014	[BUG]  [BUGGY]  tryMinimizeExits(tree,  labelName,  exitType);  [CE]  cannot  find  symbol  tree  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(tree,  labelName,  exitType);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(tree,  labelName,  exitType);	  tryMinimizeExits(labelName,    exitType);    	non-compiled	[CE]  cannot  find  symbol  tree	96	None	replace
1015	[BUG]  [BUGGY]  tryMinimizeExits(t,  labelName,  exitType);  [CE]  cannot  find  symbol  t  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(t,  labelName,  exitType);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(t,  labelName,  exitType);	  tryMinimizeExits(labelName,    exitType);    	non-compiled	[CE]  cannot  find  symbol  t	96	None	replace
1016	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getNext()  ==  null);  Node  c  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getNext()  ==  null);  Node  c  =  tryBlock.getNext();	          Node    c    =    tryBlock.getNext();    Node    c    =    tryBlock.getNext();    }    	compilable	  [FE]  RuntimeException  	150	6	replace
1017	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getNext()  ==  null);  Node  c  =  tryBlock.getNext();  [FE]  RuntimeException  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getNext()  ==  null);  Node  c  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getNext()  ==  null);  Node  c  =  tryBlock.getNext();	          Node    c    =    tryBlock.getNext();    Node    c    =    tryBlock.getNext();    }    	compilable	  [FE]  RuntimeException  	150	6	replace
1018	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getNext()!=  null);  Node  c  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getNext()!=  null);  Node  c  =  tryBlock.getNext();	          Node    c    =    tryBlock.getNext();    Node    c    =    tryBlock.getNext();    }    	compilable	  [FE]  AssertionFailedError  	150	6	replace
1019	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getNext()!=  null);  Node  c  =  tryBlock.getNext();  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getNext()!=  null);  Node  c  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getNext()!=  null);  Node  c  =  tryBlock.getNext();	          Node    c    =    tryBlock.getNext();    Node    c    =    tryBlock.getNext();    }    	compilable	  [FE]  AssertionFailedError  	150	6	replace
1020	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()    >=    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	68	6	add
1021	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()    >=    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);	  	compilable	  [FE]  RuntimeException  	68	6	add
1022	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  startBlock.getNext();  [CE]  cannot  find  symbol  startBlock  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  startBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  startBlock.getNext();	          Node    c    =    tryBlock.getNext();    Node    c    =    startBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol  startBlock	104	None	replace
1023	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  Node  c  =  startBlock.getNext();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  Node  c  =  startBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  Node  c  =  startBlock.getNext();	          Node    c    =    tryBlock.getNext();    Node    c    =    startBlock.getNext();    	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	104	None	replace
1024	[BUG]  [BUGGY]  Node  c  =  tryBlock.getParent();  Node  c  =  tryBlock.getParent();  preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getParent();  Node  c  =  tryBlock.getParent();  preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.getParent();    Node  c  =  tryBlock.getParent();  preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	159	None	add
1025	[BUG]  [BUGGY]  Node  c  =  tryBlock.getParent();  Node  c  =  tryBlock.getParent();  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getParent();  Node  c  =  tryBlock.getParent();  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.getParent();    Node  c  =  tryBlock.getParent();  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	159	None	add
1026	[BUG]  [BUGGY]  Node  c  =  tryBlock.getParent();  Node  c  =  tryBlock.getParent();  Preconditions.checkState(tryBlock.getParent()!=  null);  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getParent();  Node  c  =  tryBlock.getParent();  Preconditions.checkState(tryBlock.getParent()!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.getParent();    Node  c  =  tryBlock.getParent();  Preconditions.checkState(tryBlock.getParent()!=  null);	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	159	None	add
1027	[BUG]  [BUGGY]  Node  c  =  tryBlock.getParent();  Node  c  =  tryBlock.getParent();  Preconditions.checkState(tryBlock.getParent()  ==  null);  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getParent();  Node  c  =  tryBlock.getParent();  Preconditions.checkState(tryBlock.getParent()  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.getParent();    Node  c  =  tryBlock.getParent();  Preconditions.checkState(tryBlock.getParent()  ==  null);	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	159	None	add
1028	[BUG]  [BUGGY]  Node  c  =  tryBlock.getParent();  Node  c  =  tryBlock.getParent();  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getParent();  Node  c  =  tryBlock.getParent();  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.getParent();    Node  c  =  tryBlock.getParent();  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	159	None	add
1029	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock  >>  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  bad  operand  types  for  binary  operator  '>>'  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock  >>  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock  >>  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>>'	49	None	add
1030	[BUG]  [BUGGY]  tryMinimizeExitPoints(tryBlock,  exitType,  labelName);  [CE]  cannot  find  symbol  [FE]    StackOverflowError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExitPoints(tryBlock,  exitType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExitPoints(tryBlock,  exitType,  labelName);	  tryMinimizeExits(n,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol	98	None	replace
1031	[BUG]  [BUGGY]  tryMinimizeTree(tryBlock,  exitType,  labelName);  [CE]  cannot  find  symbol  [FE]      StackOverflowError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeTree(tryBlock,  exitType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeTree(tryBlock,  exitType,  labelName);	  tryMinimizeExits(n,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol	98	None	replace
1032	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.cloneTree();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  escapeType  =  tryBlock.cloneTree();	  Node    escapeType    =    tryBlock.removeFirstChild();    	compilable	  [FE]  AssertionFailedError  	184	6	replace
1033	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.cloneTree();  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.cloneTree();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.cloneTree();	  Node    escapeType    =    tryBlock.removeFirstChild();    	compilable	  [FE]  AssertionFailedError  	184	6	replace
1034	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkArgument(tryBlock.getType()  {  Token.FUNCTION);  [CE]  ')'  expected  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkArgument(tryBlock.getType()  {  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkArgument(tryBlock.getType()  {  Token.FUNCTION);	  	non-compiled	[CE]  ')'  expected	163	None	add
1035	[BUG]  [BUGGY]  Preconditions.checkArgument(triesBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  triesBlock  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(triesBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(triesBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkArgument(tryBlock.getType()    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  cannot  find  symbol  triesBlock	166	None	replace
1036	[BUG]  [BUGGY]  tryMinimizeExit(tryBlock,  labelName,  exitType);  [CE]  cannot  find  symbol  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExit(tryBlock,  labelName,  exitType);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExit(tryBlock,  labelName,  exitType);	  tryMinimizeExit(tryBlock,    escapeType,    labelName);    	non-compiled	[CE]  cannot  find  symbol	152	None	replace
1037	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  Node  EscapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  escapeType  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  Node  EscapeType  =  tryBlock.getNext();	          Node    escapeType    =    tryBlock.getNext();    Node    EscapeType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	142	6	replace
1038	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  Node  EscapeType  =  tryBlock.getNext();  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  Node  EscapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  tryBlock.getNext()  :  null;  Node  EscapeType  =  tryBlock.getNext();	          Node    escapeType    =    tryBlock.getNext();    Node    EscapeType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	142	6	replace
1039	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.isExit());  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.isExit());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.isExit());	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.hasChildren());    	non-compiled	[CE]  cannot  find  symbol	154	None	replace
1040	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock!=  null);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.hasChildren());    	compilable	  [FE]  AssertionFailedError  	154	6	replace
1041	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock!=  null);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock!=  null);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.hasChildren());    	compilable	  [FE]  AssertionFailedError  	154	6	replace
1042	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.isTree());  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.isTree());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.isTree());	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.hasChildren());    	non-compiled	[CE]  cannot  find  symbol	154	None	replace
1043	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EMPTY);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.EMPTY);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	15	6	replace
1044	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EMPTY);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EMPTY);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.EMPTY);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	15	6	replace
1045	[BUG]  [BUGGY]  Node  exitType  =  tryBlock.getNext()  &&  labelName.equals(n.getString(),  exitType);  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock.getNext()  &&  labelName.equals(n.getString(),  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock.getNext()  &&  labelName.equals(n.getString(),  exitType);	  Node    exitType    =    tryBlock.getNext()    &&    labelName.equals(n.getString());    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	79	None	replace
1046	[BUG]  [BUGGY]  Preconditions.checkState(labelName.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]          RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(labelName.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(labelName.getType()  ==  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    }    else    {    tryMinimizeExits(tryBlock,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol	172	None	replace
1047	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  preconditions  [FE]            RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    }    else    {    tryMinimizeExits(tryBlock,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol  preconditions	172	None	replace
1048	[BUG]  [BUGGY]  Preconditions.checkState(labelName.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]              RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(labelName.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(labelName.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    }    else    {    tryMinimizeExits(tryBlock,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol	172	None	replace
1049	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getEscapedChild()  :  null;  [CE]  cannot  find  symbol  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getEscapedChild()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  tryBlock.getEscapedChild()  :  null;	  Node    escapeType    =    tryBlock.getEscapedChild();    	non-compiled	[CE]  cannot  find  symbol	28	None	replace
1050	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getEscapedChild()  :  tryBlock.getEscapedChild();  [CE]  cannot  find  symbol  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getEscapedChild()  :  tryBlock.getEscapedChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  tryBlock.getEscapedChild()  :  tryBlock.getEscapedChild();	  Node    escapeType    =    tryBlock.getEscapedChild();    	non-compiled	[CE]  cannot  find  symbol	28	None	replace
1051	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getEscapedChild()  :  decodeEscapedChild(n);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getEscapedChild()  :  decodeEscapedChild(n);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  tryBlock.getEscapedChild()  :  decodeEscapedChild(n);	  Node    escapeType    =    tryBlock.getEscapedChild();    	non-compiled	[CE]  cannot  find  symbol	28	None	replace
1052	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  Node  tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  Node  tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    Node  tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  	non-compiled	[CE]  ';'  expected	77	None	add
1053	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.FUNCTION);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	21	6	replace
1054	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.FUNCTION);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.FUNCTION);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	21	6	replace
1055	[BUG]  [BUGGY]  tryMinimizeExits(t,  tryBlock,  exitType,  labelName);  [CE]  cannot  find  symbol  t  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(t,  tryBlock,  exitType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(t,  tryBlock,  exitType,  labelName);	  tryMinimizeExits(t,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol  t	130	None	replace
1056	[BUG]  [BUGGY]  tryMinimizeExits(t,  tryBlock,  labelName);  [CE]  cannot  find  symbol  t  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(t,  tryBlock,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(t,  tryBlock,  labelName);	  tryMinimizeExits(t,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol  t	130	None	replace
1057	[BUG]  [BUGGY]  Node  exitType  =  tryBlock.getNext(),  labelName  +  1;  [CE]  ';'  expected  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock.getNext(),  labelName  +  1;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock.getNext(),  labelName  +  1;	  Node    exitType    =    tryBlock.getNext(),    labelName);    	non-compiled	[CE]  ';'  expected	81	None	replace
1058	[BUG]  [BUGGY]  Node  exitType  =  tryBlock.getNext(),  labelName,  exitType);  [CE]  ';'  expected  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock.getNext(),  labelName,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock.getNext(),  labelName,  exitType);	  Node    exitType    =    tryBlock.getNext(),    labelName);    	non-compiled	[CE]  ';'  expected	81	None	replace
1059	[BUG]  [BUGGY]  Node  exitType  =  tryBlock.getNext(),  labelName;  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock.getNext(),  labelName;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock.getNext(),  labelName;	  Node    exitType    =    tryBlock.getNext(),    labelName);    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	81	None	replace
1060	[BUG]  [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getReturnType()  :  exitType;  [CE]  cannot  find  symbol  [FE]        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getReturnType()  :  exitType;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock!=  null?  tryBlock.getReturnType()  :  exitType;	  Node    returnType    =    tryBlock.getReturnType();    	non-compiled	[CE]  cannot  find  symbol	3	None	replace
1061	[BUG]  [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getReturnType()  :  null;  [CE]  cannot  find  symbol  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getReturnType()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock!=  null?  tryBlock.getReturnType()  :  null;	  Node    returnType    =    tryBlock.getReturnType();    	non-compiled	[CE]  cannot  find  symbol	3	None	replace
1062	[BUG]  [BUGGY]  Node  labelName  =  attemptBlock.getString();  [CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  attemptBlock.getString();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  attemptBlock.getString();	  Node    labelName    =    tryBlock.getString()    +    1;    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	25	None	replace
1063	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()    >=    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	39	6	replace
1064	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  >=  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()    >=    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	39	6	replace
1065	[BUG]  [BUGGY]  Preconditions.checkState(triesBlock.getType()  >=  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  triesBlock  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(triesBlock.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(triesBlock.getType()  >=  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()    >=    Token.EXPR_RESULT);    	non-compiled	[CE]  cannot  find  symbol  triesBlock	39	None	replace
1066	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.END);  [CE]  cannot  find  symbol  END  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.END);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.END);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.CATCH);    	non-compiled	[CE]  cannot  find  symbol  END	119	None	replace
1067	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Node  tryBlock  =  tryBlock.getType();  [CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]        RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Node  tryBlock  =  tryBlock.getType();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Node  tryBlock  =  tryBlock.getType();	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Node    tryBlock.getType()    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	148	None	replace
1068	[BUG]  [BUGGY]  Node  c  =  tryBlock.cloneTree();  Node  c  =  tryBlock.cloneTree();  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.cloneTree();  Node  c  =  tryBlock.cloneTree();  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.cloneTree();    Node  c  =  tryBlock.cloneTree();  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	189	None	add
1069	[BUG]  [BUGGY]  Node  c  =  tryBlock.cloneTree();  Node  c  =  tryBlock.cloneTree();  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.cloneTree();  Node  c  =  tryBlock.cloneTree();  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.cloneTree();    Node  c  =  tryBlock.cloneTree();  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	189	None	add
1070	[BUG]  [BUGGY]  Node  c  =  tryBlock.cloneTree();  Node  c  =  tryBlock.cloneTree();  Preconditions.checkState(tryBlock.getType()  ==  Token.GETPROP);  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.cloneTree();  Node  c  =  tryBlock.cloneTree();  Preconditions.checkState(tryBlock.getType()  ==  Token.GETPROP);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.cloneTree();    Node  c  =  tryBlock.cloneTree();  Preconditions.checkState(tryBlock.getType()  ==  Token.GETPROP);	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	189	None	add
1071	[BUG]  [BUGGY]  Node  c  =  tryBlock.cloneTree();  Node  c  =  tryBlock.cloneTree();  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.cloneTree();  Node  c  =  tryBlock.cloneTree();  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.cloneTree();    Node  c  =  tryBlock.cloneTree();  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	189	None	add
1072	[BUG]  [BUGGY]  Node  c  =  tryBlock.cloneTree();  Node  c  =  tryBlock.cloneTree();  Preconditions.checkState(tryBlock!=  null);  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]            AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.cloneTree();  Node  c  =  tryBlock.cloneTree();  Preconditions.checkState(tryBlock!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.cloneTree();    Node  c  =  tryBlock.cloneTree();  Preconditions.checkState(tryBlock!=  null);	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	189	None	add
1073	[BUG]  [BUGGY]  tryMinimizeExits(testNode,  exitType,  labelName,  tryBlock);  [CE]  cannot  find  symbol  testNode  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(testNode,  exitType,  labelName,  tryBlock);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(testNode,  exitType,  labelName,  tryBlock);	  tryMinimizeExits(exitType,    labelName,    tryBlock);    	non-compiled	[CE]  cannot  find  symbol  testNode	129	None	replace
1074	[BUG]  [BUGGY]  tryMinimizeExits(exitType,  labelName,  tryBlock,  exitType);  [CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(exitType,  labelName,  tryBlock,  exitType);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(exitType,  labelName,  tryBlock,  exitType);	  tryMinimizeExits(exitType,    labelName,    tryBlock);    	non-compiled	[CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;	129	None	replace
1075	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getType()  -  1;  [CE]  incompatible  types  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getType()  -  1;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getType()  -  1;	  Node    returnType    =    tryBlock.getType();    	non-compiled	[CE]  incompatible  types	4	None	replace
1076	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getType(),  exitType;  [CE]  incompatible  types  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getType(),  exitType;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getType(),  exitType;	  Node    returnType    =    tryBlock.getType();    	non-compiled	[CE]  incompatible  types	4	None	replace
1077	[BUG]  [BUGGY]  Node  c  =  tryBlock.getLastChild();  node  c  =  tryBlock.getLastChild();  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getLastChild();  node  c  =  tryBlock.getLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.getLastChild();    node  c  =  tryBlock.getLastChild();	  	non-compiled	[CE]  cannot  find  symbol	9	None	add
1078	[BUG]  [BUGGY]  Node  c  =  tryBlock.getLastChild();  Node  c  =  tryBlock.getLastChild());  [CE]  ';'  expected  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getLastChild();  Node  c  =  tryBlock.getLastChild());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.getLastChild();    Node  c  =  tryBlock.getLastChild());	  	non-compiled	[CE]  ';'  expected	9	None	add
1079	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());	  Preconditions.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  AssertionFailedError  	164	6	replace
1080	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  [FE]  AssertionFailedError  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());	  Preconditions.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  AssertionFailedError  	164	6	replace
1081	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);	  Preconditions.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  AssertionFailedError  	164	6	replace
1082	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  [FE]  AssertionFailedError  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);	  Preconditions.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  AssertionFailedError  	164	6	replace
1083	[BUG]  [BUGGY]  Node  labelName  =  tryBlock!=  null?  tryBlock.getLabelName()  :  null;  [CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  tryBlock!=  null?  tryBlock.getLabelName()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  tryBlock!=  null?  tryBlock.getLabelName()  :  null;	  Node    labelName    =    tryBlock.getLabelName();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	23	None	replace
1084	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);  Node  tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);  [CE]  ';'  expected  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);  Node  tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    exitType);    Node  tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);	  	non-compiled	[CE]  ';'  expected	136	None	add
1085	[BUG]  [BUGGY]  Node  labelName  =  n.getFirstChild().getString();  [CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  n.getFirstChild().getString();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  n.getFirstChild().getString();	  Node    labelName    =    n.getFirstChild();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	2	None	replace
1086	[BUG]  [BUGGY]  tryMinimizeExits(tryBlock,  exitType,  labelName,  escapeType);  [CE]  cannot  find  symbol  escapeType  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(tryBlock,  exitType,  labelName,  escapeType);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(tryBlock,  exitType,  labelName,  escapeType);	  tryMinimizeExits(catchNodes,    exitType,    labelName,    escapeType);    	non-compiled	[CE]  cannot  find  symbol  escapeType	168	None	replace
1087	[BUG]  [BUGGY]  Node  labelName  =  tryBlock.getQualifiedName()  +  exitType;  [CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  tryBlock.getQualifiedName()  +  exitType;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  tryBlock.getQualifiedName()  +  exitType;	  Node    labelName    =    tryBlock.getQualifiedName();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	24	None	replace
1088	[BUG]  [BUGGY]  Node  labelName  =  tryBlock.getQualifiedName()  +  n.getLastChild();  [CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  tryBlock.getQualifiedName()  +  n.getLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  tryBlock.getQualifiedName()  +  n.getLastChild();	  Node    labelName    =    tryBlock.getQualifiedName();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	24	None	replace
1089	[BUG]  [BUGGY]  Node  labelName  =  tryBlock.getQualifiedName()  +  n.getFirstChild();  [CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                      AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  tryBlock.getQualifiedName()  +  n.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  tryBlock.getQualifiedName()  +  n.getFirstChild();	  Node    labelName    =    tryBlock.getQualifiedName();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	24	None	replace
1090	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  Node  tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  [CE]  ';'  expected  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  Node  tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    labelName);    Node  tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);	  	non-compiled	[CE]  ';'  expected	138	None	add
1091	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock!=  null);  NodeUtil.checkArgument(tryBlock!=  null);  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock!=  null);  NodeUtil.checkArgument(tryBlock!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock!=    null);    NodeUtil.checkArgument(tryBlock!=  null);	  	non-compiled	[CE]  cannot  find  symbol	179	None	add
1092	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  falseBlock;  [CE]  cannot  find  symbol  falseBlock  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  falseBlock;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  falseBlock;	  Node    c    =    tryBlock!=    null?    tryBlock.getNext()    :    null;    	non-compiled	[CE]  cannot  find  symbol  falseBlock	158	None	replace
1093	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.getParent(),  tryBlock.isExit());  [CE]  cannot  find  symbol  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.getParent(),  tryBlock.isExit());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=  null,  tryBlock.getParent(),  tryBlock.isExit());	  Preconditions.checkState(tryBlock!=    null,    tryBlock.isExit());    	non-compiled	[CE]  cannot  find  symbol	182	None	replace
1094	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.getType());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock!=  null,  tryBlock.getType());	  Preconditions.checkState(tryBlock!=    null,    tryBlock.isExit());    	compilable	  [FE]  AssertionFailedError  	182	6	replace
1095	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.getType());  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.getType());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=  null,  tryBlock.getType());	  Preconditions.checkState(tryBlock!=    null,    tryBlock.isExit());    	compilable	  [FE]  AssertionFailedError  	182	6	replace
1096	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.getParent());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock!=  null,  tryBlock.getParent());	  Preconditions.checkState(tryBlock!=    null,    tryBlock.isExit());    	compilable	  [FE]  AssertionFailedError  	182	6	replace
1097	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.getParent());  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.getParent());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=  null,  tryBlock.getParent());	  Preconditions.checkState(tryBlock!=    null,    tryBlock.isExit());    	compilable	  [FE]  AssertionFailedError  	182	6	replace
1098	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  NodeUtil.checkState(n.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT);  NodeUtil.checkState(n.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()    ==    Token.EXPR_RESULT);    NodeUtil.checkState(n.getType()  ==  Token.EXPR_RESULT);	  	non-compiled	[CE]  cannot  find  symbol	71	None	add
1099	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getNext();  Preconditions.checkState(c  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  c  =  tryBlock.getNext();  Preconditions.checkState(c  ==  null);	          Node    c    =    tryBlock.getNext();    Node    c    =    tryBlock.getParent();    	compilable	  [FE]  RuntimeException  	192	6	replace
1100	[BUG]  [BUGGY]  Node  c  =  tryBlock.getNext();  Preconditions.checkState(c  ==  null);  [FE]  RuntimeException  [FE]        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getNext();  Preconditions.checkState(c  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock.getNext();  Preconditions.checkState(c  ==  null);	          Node    c    =    tryBlock.getNext();    Node    c    =    tryBlock.getParent();    	compilable	  [FE]  RuntimeException  	192	6	replace
1101	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=  null);  Node  tryBlock  =  tryBlock.getNext();  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock!=  null);  [CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=  null);  Node  tryBlock  =  tryBlock.getNext();  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock!=        null);        Preconditions.checkState(tryBlock!=    null);    Node  tryBlock  =  tryBlock.getNext();  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock!=  null);	  	non-compiled	[CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	55	None	add
1102	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=  null);  Node  tryBlock  =  n.getFirstChild();  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock!=  null);  [CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock!=  null);  Node  tryBlock  =  n.getFirstChild();  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock!=        null);        Preconditions.checkState(tryBlock!=    null);    Node  tryBlock  =  n.getFirstChild();  Preconditions.checkState(tryBlock!=  null);  Preconditions.checkState(tryBlock!=  null);	  	non-compiled	[CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	55	None	add
1103	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock!=  null,  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	50	6	replace
1104	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  AssertionFailedError  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=  null,  tryBlock.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	50	6	replace
1105	[BUG]  [BUGGY]  Node  c  =  tryBlock.getFirstChild();  Node  c  =  tryingBlock.getFirstChild();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getFirstChild();  Node  c  =  tryingBlock.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.getFirstChild();    Node  c  =  tryingBlock.getFirstChild();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	11	None	add
1106	[BUG]  [BUGGY]  Preconditions.checkState(triesBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  [CE]  cannot  find  symbol  triesBlock  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(triesBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(triesBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.CATCH);    	non-compiled	[CE]  cannot  find  symbol  triesBlock	119	None	replace
1107	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  >>  Token.FUNCTION);  [CE]  bad  operand  types  for  binary  operator  '&&'  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  >>  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  >>  Token.FUNCTION);	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '&&'	51	None	add
1108	[BUG]  [BUGGY]  Node  returnType  =  tryBlock  ==  null?  tryBlock.getReturnType()  :  exitType;  [CE]  cannot  find  symbol  [FE]        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock  ==  null?  tryBlock.getReturnType()  :  exitType;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock  ==  null?  tryBlock.getReturnType()  :  exitType;	  Node    returnType    =    tryBlock.getReturnType();    	non-compiled	[CE]  cannot  find  symbol	3	None	replace
1109	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.returnType();  [CE]  cannot  find  symbol  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.returnType();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.returnType();	  Node    returnType    =    tryBlock.getReturnType();    	non-compiled	[CE]  cannot  find  symbol	3	None	replace
1110	[BUG]  [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getReturnType()  :  escapeType;  [CE]  cannot  find  symbol  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getReturnType()  :  escapeType;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock!=  null?  tryBlock.getReturnType()  :  escapeType;	  Node    returnType    =    tryBlock.getReturnType();    	non-compiled	[CE]  cannot  find  symbol	3	None	replace
1111	[BUG]  [BUGGY]  Node  c  =  tryBlock.getNext();  node  c  =  this.tryBlock.getNext();  [CE]  cannot  find  symbol  [FE]        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getNext();  node  c  =  this.tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock.getNext();  node  c  =  this.tryBlock.getNext();	          Node    c    =    tryBlock.getNext();    node    c    =    tryBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol	149	None	replace
1112	[BUG]  [BUGGY]  Node  exitType  =  tryBlock.getNext()  &&  labelName.equalsIgnoreCase(n.getString());  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock.getNext()  &&  labelName.equalsIgnoreCase(n.getString());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock.getNext()  &&  labelName.equalsIgnoreCase(n.getString());	  Node    exitType    =    tryBlock.getNext()    &&    labelName.equals(n.getString());    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	79	None	replace
1113	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()!=  Token.CATCH  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    	compilable	  [FE]  AssertionFailedError  	115	6	replace
1114	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=  Token.CATCH  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    	compilable	  [FE]  AssertionFailedError  	115	6	replace
1115	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()    >=    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	69	6	replace
1116	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  >=  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()    >=    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	69	6	replace
1117	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()    >=    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	69	6	replace
1118	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()    >=    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	69	6	replace
1119	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  null;	          Node    returnType    =    tryBlock.getNext();    Node    returnedType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	45	6	replace
1120	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  null;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  null;	          Node    returnType    =    tryBlock.getNext();    Node    returnedType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	45	6	replace
1121	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  throwable.getNext();  [CE]  cannot  find  symbol  throwable  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  throwable.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getNext();  Node  returnedType  =  throwable.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    returnedType    =    tryBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol  throwable	45	None	replace
1122	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.getType()  ==  Token.NAME);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock!=  null,  tryBlock.getType()  ==  Token.NAME);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.NAME);    	compilable	  [FE]  AssertionFailedError  	54	6	replace
1123	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.getType()  ==  Token.NAME);  [FE]  AssertionFailedError  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.getType()  ==  Token.NAME);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=  null,  tryBlock.getType()  ==  Token.NAME);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.NAME);    	compilable	  [FE]  AssertionFailedError  	54	6	replace
1124	[BUG]  [BUGGY]  tryMinimizeExits(labelName,  n,  exitType,  exitType,  labelName);  [CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(labelName,  n,  exitType,  exitType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(labelName,  n,  exitType,  exitType,  labelName);	  tryMinimizeExits(labelName,    n,    exitType,    exitType);    	non-compiled	[CE]  method  tryMinimizeExits  in  class  MinimizeExitPoints  cannot  be  applied  to  given  types;	84	None	replace
1125	[BUG]  [BUGGY]  tryMinimizeExits(catchCodeBlock,  exitType,  labelName,  tryBlock);  [CE]  cannot  find  symbol  catchCodeBlock  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(catchCodeBlock,  exitType,  labelName,  tryBlock);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(catchCodeBlock,  exitType,  labelName,  tryBlock);	  tryMinimizeExits(exitType,    labelName,    tryBlock);    	non-compiled	[CE]  cannot  find  symbol  catchCodeBlock	129	None	replace
1126	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]            RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(exitType  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(exitType  ==  Token.EXPR_RESULT);	  Preconditions.checkState(triesBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	140	6	replace
1127	[BUG]  [BUGGY]  Preconditions.checkState(exitType  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]            RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(exitType  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(exitType  ==  Token.EXPR_RESULT);	  Preconditions.checkState(triesBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	140	6	replace
1128	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  preconditions  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    	non-compiled	[CE]  cannot  find  symbol  preconditions	35	None	replace
1129	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.isTree());  [CE]  cannot  find  symbol  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.isTree());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=  null,  tryBlock.isTree());	          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock    >>    null);    	non-compiled	[CE]  cannot  find  symbol	60	None	replace
1130	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.removeFirstChild()  :  null;  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.removeFirstChild()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.removeFirstChild()  :  null;	  Node    escapeType    =    tryBlock.getNext()    :    null;    	non-compiled	[CE]  ';'  expected	31	None	replace
1131	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock  ==  null?  tryBlock.getEscapedChild()  :  null;  [CE]  cannot  find  symbol  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock  ==  null?  tryBlock.getEscapedChild()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock  ==  null?  tryBlock.getEscapedChild()  :  null;	  Node    escapeType    =    tryBlock.getEscapedChild();    	non-compiled	[CE]  cannot  find  symbol	28	None	replace
1132	[BUG]  [BUGGY]  Node  exitType  =  tryBlock.removeFirstChild();  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock.removeFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock.removeFirstChild();	  Node    exitType    =    tryBlock.getFirstChild();    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	167	None	replace
1133	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getNext();  node  returnType  =  attemptBlock.getNext();  [CE]  cannot  find  symbol  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  node  returnType  =  attemptBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getNext();  node  returnType  =  attemptBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    node    returnType    =    tryBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol	123	None	replace
1134	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getNext();  node  returnType  =  startType.getNext();  [CE]  cannot  find  symbol  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  node  returnType  =  startType.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getNext();  node  returnType  =  startType.getNext();	          Node    returnType    =    tryBlock.getNext();    node    returnType    =    tryBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol	123	None	replace
1135	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getNext();  node  returnType  =  exitType.getNext();  [CE]  cannot  find  symbol  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  node  returnType  =  exitType.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getNext();  node  returnType  =  exitType.getNext();	          Node    returnType    =    tryBlock.getNext();    node    returnType    =    tryBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol	123	None	replace
1136	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getNext()  ==  null);  Node  labelName  =  tryBlock.getNext();  [CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getNext()  ==  null);  Node  labelName  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getNext()  ==  null);  Node  labelName  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    labelName    =    tryBlock.getNext();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	46	None	replace
1137	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.RETURN);  Node  labelName  =  tryBlock.getNext();  [CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.RETURN);  Node  labelName  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.RETURN);  Node  labelName  =  tryBlock.getNext();	          Node    returnType    =    tryBlock.getNext();    Node    labelName    =    tryBlock.getNext();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	46	None	replace
1138	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  Node  tryBlock  =  tryBlock.getNext();  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  Node  tryBlock  =  tryBlock.getNext();  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.EXPR_RESULT);    Node  tryBlock  =  tryBlock.getNext();  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	non-compiled	[CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	49	None	add
1139	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	78	6	replace
1140	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	78	6	replace
1141	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  NodeUtil.checkCatch(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  NodeUtil.checkCatch(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    NodeUtil.checkCatch(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	non-compiled	[CE]  cannot  find  symbol	116	None	add
1142	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]                RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION,  exitType);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()    >>    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	70	6	replace
1143	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION,  exitType);  [FE]  RuntimeException  [FE]                RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION,  exitType);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()    >>    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	70	6	replace
1144	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.cloneTree();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  returnType  =  tryBlock.cloneTree();	  Node    returnType    =    tryBlock.removeFirstChild();    	compilable	  [FE]  AssertionFailedError  	177	6	replace
1145	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.cloneTree();  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.cloneTree();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.cloneTree();	  Node    returnType    =    tryBlock.removeFirstChild();    	compilable	  [FE]  AssertionFailedError  	177	6	replace
1146	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.check(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.check(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.check(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);	  	non-compiled	[CE]  cannot  find  symbol	34	None	add
1147	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(triesBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  triesBlock  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  Preconditions.checkState(triesBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()!=    Token.EXPR_RESULT);    Preconditions.checkState(triesBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT);	  	non-compiled	[CE]  cannot  find  symbol  triesBlock	34	None	add
1148	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getParent()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  returnType  =  tryBlock!=  null?  tryBlock.getParent()  :  null;	  Node    returnType    =    tryBlock.getParent();    	compilable	  [FE]  AssertionFailedError  	132	6	replace
1149	[BUG]  [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getParent()  :  null;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getParent()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock!=  null?  tryBlock.getParent()  :  null;	  Node    returnType    =    tryBlock.getParent();    	compilable	  [FE]  AssertionFailedError  	132	6	replace
1150	[BUG]  [BUGGY]  Node  labelName  =  tryBlock.getString(),  exitType  +  1);  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  tryBlock.getString(),  exitType  +  1);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  tryBlock.getString(),  exitType  +  1);	  Node    labelName    =    tryBlock.getString(),    exitType);    	non-compiled	[CE]  ';'  expected	22	None	replace
1151	[BUG]  [BUGGY]  Node  c  =  tryBlock.getParent();  Node  c  =  tryingBlock.getParent();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getParent();  Node  c  =  tryingBlock.getParent();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.getParent();    Node  c  =  tryingBlock.getParent();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	159	None	add
1152	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkArgument(tryBlock.getType()  {  Token.EXPR_RESULT);  [CE]  ')'  expected  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkArgument(tryBlock.getType()  {  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkArgument(tryBlock.getType()  {  Token.EXPR_RESULT);	  	non-compiled	[CE]  ')'  expected	165	None	add
1153	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	67	6	replace
1154	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	67	6	replace
1155	[BUG]  [BUGGY]  tryMinimizeExits(n,  exitType,  labelName);  Node  n  =  tryBlock.getNext();  [CE]  variable  n  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    StackOverflowError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(n,  exitType,  labelName);  Node  n  =  tryBlock.getNext();  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(n,    exitType,    labelName);    Node  n  =  tryBlock.getNext();	  	non-compiled	[CE]  variable  n  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	97	None	add
1156	[BUG]  [BUGGY]  [FE]  StackOverflowError  [FE]      StackOverflowError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(n,  exitType,  labelName);  Node  c  =  tryBlock.getNext();  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	tryMinimizeExits(n,    exitType,    labelName);    Node  c  =  tryBlock.getNext();	  	compilable	  [FE]  StackOverflowError  	97	6	add
1157	[BUG]  [BUGGY]  tryMinimizeExits(n,  exitType,  labelName);  Node  c  =  tryBlock.getNext();  [FE]  StackOverflowError  [FE]      StackOverflowError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(n,  exitType,  labelName);  Node  c  =  tryBlock.getNext();  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(n,    exitType,    labelName);    Node  c  =  tryBlock.getNext();	  	compilable	  [FE]  StackOverflowError  	97	6	add
1158	[BUG]  [BUGGY]          Node    escapeType    =    tryBlock.getNext();    Node  EscapeType  =  tryBlock.getNext();  Node  escapeType  =  attemptBlock.getNext();  Node  EscapeType  =  tryBlock.getNext();  [CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    escapeType    =    tryBlock.getNext();    Node  EscapeType  =  tryBlock.getNext();  Node  escapeType  =  attemptBlock.getNext();  Node  EscapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        escapeType        =        tryBlock.getNext();        Node    EscapeType    =    tryBlock.getNext();    Node  escapeType  =  attemptBlock.getNext();  Node  EscapeType  =  tryBlock.getNext();	  	non-compiled	[CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	141	None	add
1159	[BUG]  [BUGGY]          Node    escapeType    =    tryBlock.getNext();    Node  EscapeType  =  tryBlock.getNext();  Node  escapeType  =  triedBlock.getNext();  Node  EscapeType  =  tryBlock.getNext();  [CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    escapeType    =    tryBlock.getNext();    Node  EscapeType  =  tryBlock.getNext();  Node  escapeType  =  triedBlock.getNext();  Node  EscapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        escapeType        =        tryBlock.getNext();        Node    EscapeType    =    tryBlock.getNext();    Node  escapeType  =  triedBlock.getNext();  Node  EscapeType  =  tryBlock.getNext();	  	non-compiled	[CE]  variable  escapeType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	141	None	add
1160	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()    >>    Token.CATCH);    	compilable	  [FE]  AssertionFailedError  	95	6	replace
1161	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH);  [FE]  AssertionFailedError  [FE]                  RuntimeException      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  >=  Token.CATCH);	          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()    >>    Token.CATCH);    	compilable	  [FE]  AssertionFailedError  	95	6	replace
1162	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getNext();  Preconditions.checkState(c!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  c  =  tryBlock.getNext();  Preconditions.checkState(c!=  null);	          Node    c    =    tryBlock.getNext();    Node    c    =    tryBlock.getNext();    }    	compilable	  [FE]  AssertionFailedError  	150	6	replace
1163	[BUG]  [BUGGY]  Node  c  =  tryBlock.getNext();  Preconditions.checkState(c!=  null);  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getNext();  Preconditions.checkState(c!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock.getNext();  Preconditions.checkState(c!=  null);	          Node    c    =    tryBlock.getNext();    Node    c    =    tryBlock.getNext();    }    	compilable	  [FE]  AssertionFailedError  	150	6	replace
1164	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Node  tryBlock  =  n.getFirstChild();  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Node  tryBlock  =  n.getFirstChild();  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.CATCH);        Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Node  tryBlock  =  n.getFirstChild();  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);	  	non-compiled	[CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	88	None	add
1165	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.check(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [CE]  cannot  find  symbol  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.check(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.CATCH);        Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.check(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);	  	non-compiled	[CE]  cannot  find  symbol	88	None	add
1166	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkArgument(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.CATCH);        Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkArgument(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	88	6	add
1167	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkArgument(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkArgument(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.CATCH);        Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkArgument(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH);	  	compilable	  [FE]  RuntimeException  	88	6	add
1168	[BUG]  [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  escapeType  =  tryBlock.getNext();  Node  returnType  =  attemptBlock.getNext();  Node  escapeType  =  tryBlock.getNext();  [CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  escapeType  =  tryBlock.getNext();  Node  returnType  =  attemptBlock.getNext();  Node  escapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        returnType        =        tryBlock.getNext();        Node    escapeType    =    tryBlock.getNext();    Node  returnType  =  attemptBlock.getNext();  Node  escapeType  =  tryBlock.getNext();	  	non-compiled	[CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	42	None	add
1169	[BUG]  [BUGGY]  Node  c  =  tryBlock.getLastChild();  Node  c  =  tryBlock.getFirstChild();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.getLastChild();  Node  c  =  tryBlock.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.getLastChild();    Node  c  =  tryBlock.getFirstChild();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	9	None	add
1170	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	21	6	replace
1171	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    	compilable	  [FE]  AssertionFailedError  	21	6	replace
1172	[BUG]  [BUGGY]  Preconditions.checkState(triesBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  triesBlock  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(triesBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(triesBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()!=  Token.EXPR_RESULT);	  Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()!=    Token.EXPR_RESULT);    	non-compiled	[CE]  cannot  find  symbol  triesBlock	21	None	replace
1173	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock  <  null?  tryBlock.getNext()  :  null;  [CE]  bad  operand  types  for  binary  operator  '<'  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock  <  null?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock  <  null?  tryBlock.getNext()  :  null;	          Node    escapeType    =    tryBlock.getNext();    NOde    escapeType    =    tryBlock.getNext();    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '<'	143	None	replace
1174	[BUG]  [BUGGY]  Node  labelName  =  tryBlock.getNext(),  exitType  +  1);  [CE]  ';'  expected  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  tryBlock.getNext(),  exitType  +  1);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  tryBlock.getNext(),  exitType  +  1);	  Node    labelName    =    tryBlock.getNext(),    exitType);    	non-compiled	[CE]  ';'  expected	170	None	replace
1175	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    NodeUtil.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	non-compiled	[CE]  cannot  find  symbol	75	None	add
1176	[BUG]  [BUGGY]  tryMinimizeExits(peekBlock,  exitType,  labelName);  [CE]  cannot  find  symbol  peekBlock  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(peekBlock,  exitType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(peekBlock,  exitType,  labelName);	  tryMinimizeExits(catchBlock,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol  peekBlock	26	None	replace
1177	[BUG]  [BUGGY]  Node  c  =  tryBlock.removeChild(n);  [CE]  incompatible  types  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.removeChild(n);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock.removeChild(n);	  Node    c    =    tryBlock.cloneTree();    	non-compiled	[CE]  incompatible  types	190	None	replace
1178	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock  ==  null?  tryBlock.getFalse()  :  null;  [CE]  cannot  find  symbol  [FE]        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock  ==  null?  tryBlock.getFalse()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock  ==  null?  tryBlock.getFalse()  :  null;	  Node    escapeType    =    tryBlock.getFalse();    	non-compiled	[CE]  cannot  find  symbol	27	None	replace
1179	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock!=  null);  NodeUtil.checkState(tryBlock!=  null);  [CE]  cannot  find  symbol  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock!=  null);  NodeUtil.checkState(tryBlock!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock!=  null);  NodeUtil.checkState(tryBlock!=  null);	          Preconditions.checkState(tryBlock!=    null);    NodeUtil.checkState(tryBlock!=    null);    	non-compiled	[CE]  cannot  find  symbol	61	None	replace
1180	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.check(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.check(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.check(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);	  	non-compiled	[CE]  cannot  find  symbol	32	None	add
1181	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	32	6	add
1182	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);	  	compilable	  [FE]  RuntimeException  	32	6	add
1183	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Node  tryBlock  =  n.getFirstChild();  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]        RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Node  tryBlock  =  n.getFirstChild();  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.EXPR_RESULT);        Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Node  tryBlock  =  n.getFirstChild();  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT);	  	non-compiled	[CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	32	None	add
1184	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.check(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  [CE]  cannot  find  symbol  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH);    Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  Preconditions.check(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.CATCH);        Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    Preconditions.check(tryBlock.getType()  ==  Token.CATCH);  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);	  	non-compiled	[CE]  cannot  find  symbol	90	None	add
1185	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CATCH);  Node  n.getType()  ==  Token.CATCH);  [CE]  ';'  expected  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CATCH);  Node  n.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()    ==    Token.CATCH);    Node  n.getType()  ==  Token.CATCH);	  	non-compiled	[CE]  ';'  expected	112	None	add
1186	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.hasExit());  [CE]  cannot  find  symbol  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.hasExit());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=  null  &&  tryBlock.hasExit());	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.isExit());    	non-compiled	[CE]  cannot  find  symbol	181	None	replace
1187	[BUG]  [BUGGY]  tryMinimizeExits(labelName,  exitType,  labelName,  escapeType);  [CE]  cannot  find  symbol  escapeType  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(labelName,  exitType,  labelName,  escapeType);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(labelName,  exitType,  labelName,  escapeType);	  tryMinimizeExits(labelName,    exitType,    labelName);    	non-compiled	[CE]  cannot  find  symbol  escapeType	83	None	replace
1188	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkArgument(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock!=        null);        Preconditions.checkState(tryBlock    ==    null);    Preconditions.checkArgument(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);	  	compilable	  [FE]  RuntimeException  	57	6	add
1189	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkArgument(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkArgument(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock!=        null);        Preconditions.checkState(tryBlock    ==    null);    Preconditions.checkArgument(tryBlock!=  null);  Preconditions.checkState(tryBlock  ==  null);	  	compilable	  [FE]  RuntimeException  	57	6	add
1190	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkNotNull(tryBlock);  Preconditions.checkState(tryBlock  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	                Preconditions.checkState(tryBlock!=        null);        Preconditions.checkState(tryBlock    ==    null);    Preconditions.checkNotNull(tryBlock);  Preconditions.checkState(tryBlock  ==  null);	  	compilable	  [FE]  RuntimeException  	57	6	add
1191	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkNotNull(tryBlock);  Preconditions.checkState(tryBlock  ==  null);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock!=    null);    Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkNotNull(tryBlock);  Preconditions.checkState(tryBlock  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock!=        null);        Preconditions.checkState(tryBlock    ==    null);    Preconditions.checkNotNull(tryBlock);  Preconditions.checkState(tryBlock  ==  null);	  	compilable	  [FE]  RuntimeException  	57	6	add
1192	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getExitType()  :  DEFAULT_EXIT_TYPE;  [CE]  cannot  find  symbol  [FE]        AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getExitType()  :  DEFAULT_EXIT_TYPE;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  tryBlock.getExitType()  :  DEFAULT_EXIT_TYPE;	  Node    escapeType    =    tryBlock.getExitType();    	non-compiled	[CE]  cannot  find  symbol	146	None	replace
1193	[BUG]  [BUGGY]  Node  labelName  =  tryBlock.getQualifiedName()  + ": "  +  n.getFirstChild();  [CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                  AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  tryBlock.getQualifiedName()  + ": "  +  n.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  tryBlock.getQualifiedName()  + ": "  +  n.getFirstChild();	  Node    labelName    =    tryBlock.getQualifiedName();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	24	None	replace
1194	[BUG]  [BUGGY]  Node  labelName  =  tryBlock.getQualifiedName()  + ": "  +  n.getLastChild();  [CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                    AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  tryBlock.getQualifiedName()  + ": "  +  n.getLastChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  tryBlock.getQualifiedName()  + ": "  +  n.getLastChild();	  Node    labelName    =    tryBlock.getQualifiedName();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	24	None	replace
1195	[BUG]  [BUGGY]  tryMinimizeExits(catchNodes,  exitType,  labelName,  exitType);  [CE]  cannot  find  symbol  catchNodes  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(catchNodes,  exitType,  labelName,  exitType);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(catchNodes,  exitType,  labelName,  exitType);	  tryMinimizeExits(catchNodes,    exitType,    labelName,    escapeType);    	non-compiled	[CE]  cannot  find  symbol  catchNodes	168	None	replace
1196	[BUG]  [BUGGY]  tryMinimizeExits(catchNodes,  exitType,  labelName,  escapeType,  labelName);  [CE]  cannot  find  symbol  catchNodes  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  tryMinimizeExits(catchNodes,  exitType,  labelName,  escapeType,  labelName);  [BUGGY]      Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	tryMinimizeExits(catchNodes,  exitType,  labelName,  escapeType,  labelName);	  tryMinimizeExits(catchNodes,    exitType,    labelName,    escapeType);    	non-compiled	[CE]  cannot  find  symbol  catchNodes	168	None	replace
1197	[BUG]  [BUGGY]  Node  exitType  =  tryBlock!=  null?  tryBlock.getNext()  :  endType;  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock!=  null?  tryBlock.getNext()  :  endType;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock!=  null?  tryBlock.getNext()  :  endType;	  Node    exitType    =    tryBlock!=    null?    tryBlock.getNext()    :    exitType;    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	145	None	replace
1198	[BUG]  [BUGGY]  Node  c  =  tryBlock.cloneTree();  Node  c  =  tryingBlock.cloneTree();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.cloneTree();  Node  c  =  tryingBlock.cloneTree();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.cloneTree();    Node  c  =  tryingBlock.cloneTree();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	189	None	add
1199	[BUG]  [BUGGY]  Node  c  =  tryBlock.cloneTree();  node  c  =  tryBlock.cloneTree();  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.cloneTree();  node  c  =  tryBlock.cloneTree();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.cloneTree();    node  c  =  tryBlock.cloneTree();	  	non-compiled	[CE]  cannot  find  symbol	189	None	add
1200	[BUG]  [BUGGY]  Node  c  =  startNode.getNext();  [CE]  cannot  find  symbol  startNode  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  startNode.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  startNode.getNext();	          Node    c    =    tryBlock.getNext();    Node    c    =    startBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol  startNode	104	None	replace
1201	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Node  tryBlock  =  n.getFirstChild();  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Node  tryBlock  =  n.getFirstChild();  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Node  tryBlock  =  n.getFirstChild();  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);	  	non-compiled	[CE]  variable  tryBlock  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	63	None	add
1202	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.check(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [CE]  cannot  find  symbol  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.check(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.check(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION);	  	non-compiled	[CE]  cannot  find  symbol	63	None	add
1203	[BUG]  [BUGGY]  Node  c  =  tryBlock.currentStructure();  [CE]  cannot  find  symbol  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.currentStructure();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock.currentStructure();	  Node    c    =    tryBlock.getCurrentStructure();    	non-compiled	[CE]  cannot  find  symbol	13	None	replace
1204	[BUG]  [BUGGY]  Node  exitType  =  attemptBlock.getNext();  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  attemptBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  attemptBlock.getNext();	  Node    exitType    =    tryBlock.getNext()    -    1;    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	80	None	replace
1205	[BUG]  [BUGGY]  Node  c  =  tryBlock.removeFirstChild();  Node  c  =  tryingBlock.removeFirstChild();  [CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock.removeFirstChild();  Node  c  =  tryingBlock.removeFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock.removeFirstChild();    Node  c  =  tryingBlock.removeFirstChild();	  	non-compiled	[CE]  variable  c  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	187	None	add
1206	[BUG]  [BUGGY]  Node  labelName  =  tryBlock.getLabelName()  + ": "  +  n.getFirstChild();  [CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  labelName  =  tryBlock.getLabelName()  + ": "  +  n.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  labelName  =  tryBlock.getLabelName()  + ": "  +  n.getFirstChild();	  Node    labelName    =    tryBlock.getLabelName();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	23	None	replace
1207	[BUG]  [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getNext()  :  exitType,  labelName;  [CE]  incompatible  types  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getNext()  :  exitType,  labelName;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock!=  null?  tryBlock.getNext()  :  exitType,  labelName;	  Node    returnType    =    tryBlock!=    null?    tryBlock.getNext()    :    exitType;    	non-compiled	[CE]  incompatible  types	133	None	replace
1208	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getFirstChild()!=    null);    NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);	  	non-compiled	[CE]  cannot  find  symbol	155	None	add
1209	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  NodeUtil.checkType(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  NodeUtil.checkType(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getFirstChild()!=    null);    NodeUtil.checkType(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()!=  null);	  	non-compiled	[CE]  cannot  find  symbol	155	None	add
1210	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  returnType  ==  null?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  returnType  ==  null?  tryBlock.getNext()  :  null;	          Node    returnType    =    tryBlock.getNext();    Node    returnsType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	122	6	replace
1211	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  returnType  ==  null?  tryBlock.getNext()  :  null;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  returnType  ==  null?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  returnType  ==  null?  tryBlock.getNext()  :  null;	          Node    returnType    =    tryBlock.getNext();    Node    returnsType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	122	6	replace
1212	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  returnType!=  null?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  returnType!=  null?  tryBlock.getNext()  :  null;	          Node    returnType    =    tryBlock.getNext();    Node    returnsType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	122	6	replace
1213	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  returnType!=  null?  tryBlock.getNext()  :  null;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  returnType!=  null?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  returnType!=  null?  tryBlock.getNext()  :  null;	          Node    returnType    =    tryBlock.getNext();    Node    returnsType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	122	6	replace
1214	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  returnType  ==  Token.RETURN?  tryBlock.getNext()  :  null;  [CE]  incomparable  types:  Node  and  int  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  returnType  ==  Token.RETURN?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getNext();  Node  returnsType  =  returnType  ==  Token.RETURN?  tryBlock.getNext()  :  null;	          Node    returnType    =    tryBlock.getNext();    Node    returnsType    =    tryBlock.getNext();    	non-compiled	[CE]  incomparable  types:  Node  and  int	122	None	replace
1215	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);	  Preconditions.checkArgument(tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	166	6	replace
1216	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT,  exitType);	  Preconditions.checkArgument(tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	166	6	replace
1217	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.FUNCTION);	  Preconditions.checkArgument(tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	166	6	replace
1218	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.FUNCTION);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.FUNCTION);	  Preconditions.checkArgument(tryBlock.getType()    ==    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	166	6	replace
1219	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock  ==  null  ||  tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock  ==  null  ||  tryBlock.getType()  ==  Token.CATCH);	  Preconditions.checkState(tryBlock    ==    null);    	compilable	  [FE]  RuntimeException  	48	6	replace
1220	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock  ==  null  ||  tryBlock.getType()  ==  Token.CATCH);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock  ==  null  ||  tryBlock.getType()  ==  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock  ==  null  ||  tryBlock.getType()  ==  Token.CATCH);	  Preconditions.checkState(tryBlock    ==    null);    	compilable	  [FE]  RuntimeException  	48	6	replace
1221	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getNext();  node  =  escapeType  =  tryBlock.getNext();  [CE]  cannot  find  symbol  node  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getNext();  node  =  escapeType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getNext();  node  =  escapeType  =  tryBlock.getNext();	          Node    escapeType    =    tryBlock.getNext();    node    escapeType    =    tryBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol  node	111	None	replace
1222	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  NodeUtil.checkType(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  NodeUtil.checkType(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.hasChildren());    NodeUtil.checkType(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.hasChildren());	  	non-compiled	[CE]  cannot  find  symbol	153	None	add
1223	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  tryingBlock.getNext()  :  null;  [CE]  cannot  find  symbol  tryingBlock  [FE]                AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  tryingBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  c  =  tryBlock!=  null?  tryingBlock.getNext()  :  null;	          Node    c    =    tryBlock.getNext();    Node    c    =    tryingBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol  tryingBlock	106	None	replace
1224	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType  ==  null?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType  ==  null?  tryBlock.getNext()  :  null;	          Node    escapeType    =    tryBlock.getNext();    Node    EscapeType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	142	6	replace
1225	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType  ==  null?  tryBlock.getNext()  :  null;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType  ==  null?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType  ==  null?  tryBlock.getNext()  :  null;	          Node    escapeType    =    tryBlock.getNext();    Node    EscapeType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	142	6	replace
1226	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType!=  null?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType!=  null?  tryBlock.getNext()  :  null;	          Node    escapeType    =    tryBlock.getNext();    Node    EscapeType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	142	6	replace
1227	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType!=  null?  tryBlock.getNext()  :  null;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType!=  null?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType!=  null?  tryBlock.getNext()  :  null;	          Node    escapeType    =    tryBlock.getNext();    Node    EscapeType    =    tryBlock.getNext();    	compilable	  [FE]  AssertionFailedError  	142	6	replace
1228	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType  >=  null?  tryBlock.getNext()  :  null;  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType  >=  null?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType  >=  null?  tryBlock.getNext()  :  null;	          Node    escapeType    =    tryBlock.getNext();    Node    EscapeType    =    tryBlock.getNext();    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	142	None	replace
1229	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType  ==  null?  tryBlock.getNext()  :  falseBlock;  [CE]  cannot  find  symbol  falseBlock  [FE]          AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType  ==  null?  tryBlock.getNext()  :  falseBlock;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock.getNext();  Node  EscapeType  =  escapeType  ==  null?  tryBlock.getNext()  :  falseBlock;	          Node    escapeType    =    tryBlock.getNext();    Node    EscapeType    =    tryBlock.getNext();    	non-compiled	[CE]  cannot  find  symbol  falseBlock	142	None	replace
1230	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.removeFirstChild();  Node  returnType  =  attemptBlock.removeFirstChild();  [CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.removeFirstChild();  Node  returnType  =  attemptBlock.removeFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    returnType    =    tryBlock.removeFirstChild();    Node  returnType  =  attemptBlock.removeFirstChild();	  	non-compiled	[CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	176	None	add
1231	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock!=  null,  tryBlock.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  AssertionFailedError  	52	6	replace
1232	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.getType()  ==  Token.FUNCTION);  [FE]  AssertionFailedError  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=  null,  tryBlock.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  AssertionFailedError  	52	6	replace
1233	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock  {  null);  [CE]  ')'  expected  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock  ==  null);  Preconditions.checkState(tryBlock  {  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock    ==    null);    Preconditions.checkState(tryBlock  {  null);	  	non-compiled	[CE]  ')'  expected	47	None	add
1234	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  escapeType  =  escapeType  ==  null?  tryBlock.getNext()  :  null;  [CE]  variable  escapeType  might  not  have  been  initialized  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  escapeType  =  escapeType  ==  null?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getNext();  Node  escapeType  =  escapeType  ==  null?  tryBlock.getNext()  :  null;	          Node    returnType    =    tryBlock.getNext();    Node    escapeType    =    tryBlock.getNext();    	non-compiled	[CE]  variable  escapeType  might  not  have  been  initialized	43	None	replace
1235	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  escapeType  =  escapeType!=  null?  tryBlock.getNext()  :  null;  [CE]  variable  escapeType  might  not  have  been  initialized  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  escapeType  =  escapeType!=  null?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getNext();  Node  escapeType  =  escapeType!=  null?  tryBlock.getNext()  :  null;	          Node    returnType    =    tryBlock.getNext();    Node    escapeType    =    tryBlock.getNext();    	non-compiled	[CE]  variable  escapeType  might  not  have  been  initialized	43	None	replace
1236	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  escapeType  =  escapeType  >>  null?  tryBlock.getNext()  :  null;  [CE]  bad  operand  types  for  binary  operator  '>>'  [FE]        AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getNext();  Node  escapeType  =  escapeType  >>  null?  tryBlock.getNext()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getNext();  Node  escapeType  =  escapeType  >>  null?  tryBlock.getNext()  :  null;	          Node    returnType    =    tryBlock.getNext();    Node    escapeType    =    tryBlock.getNext();    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>>'	43	None	replace
1237	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getEscaped()  :  Collections.EMPTY_LIST;  [CE]  cannot  find  symbol  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getEscaped()  :  Collections.EMPTY_LIST;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  tryBlock.getEscaped()  :  Collections.EMPTY_LIST;	  Node    escapeType    =    tryBlock.getEscaped();    	non-compiled	[CE]  cannot  find  symbol	147	None	replace
1238	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock  ==  null?  tryBlock.getEscaped()  :  null;  [CE]  cannot  find  symbol  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock  ==  null?  tryBlock.getEscaped()  :  null;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock  ==  null?  tryBlock.getEscaped()  :  null;	  Node    escapeType    =    tryBlock.getEscaped();    	non-compiled	[CE]  cannot  find  symbol	147	None	replace
1239	[BUG]  [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getEscaped()  :  DEFAULT_EXIT_TYPE;  [CE]  cannot  find  symbol  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  escapeType  =  tryBlock!=  null?  tryBlock.getEscaped()  :  DEFAULT_EXIT_TYPE;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  escapeType  =  tryBlock!=  null?  tryBlock.getEscaped()  :  DEFAULT_EXIT_TYPE;	  Node    escapeType    =    tryBlock.getEscaped();    	non-compiled	[CE]  cannot  find  symbol	147	None	replace
1240	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  >>  Token.NAME);  [CE]  bad  operand  types  for  binary  operator  '&&'  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  ==  Token.NAME);  Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  >>  Token.NAME);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=    null    &&    tryBlock.getType()    ==    Token.NAME);    Preconditions.checkState(tryBlock!=  null  &&  tryBlock.getType()  >>  Token.NAME);	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '&&'	53	None	add
1241	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT,  exitType);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    exitType);    	compilable	  [FE]  AssertionFailedError  	137	6	replace
1242	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT,  exitType);  [FE]  AssertionFailedError  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=  Token.EXPR_RESULT,  exitType);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    exitType);    	compilable	  [FE]  AssertionFailedError  	137	6	replace
1243	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    exitType);    	compilable	  [FE]  RuntimeException  	137	6	replace
1244	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.EXPR_RESULT  ||  tryBlock.getType()  ==  Token.EXPR_RESULT,  labelName);	  Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT,    exitType);    	compilable	  [FE]  RuntimeException  	137	6	replace
1245	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH,  exitType);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH,    exitType);    	compilable	  [FE]  RuntimeException  	135	6	replace
1246	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH,  exitType);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH,  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.CATCH  ||  tryBlock.getType()  ==  Token.CATCH,  exitType);	  Preconditions.checkState(tryBlock.getType()    ==    Token.CATCH,    exitType);    	compilable	  [FE]  RuntimeException  	135	6	replace
1247	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getString(),  exitType);  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getString(),  exitType);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock.getString(),  exitType);	  Node    returnType    =    tryBlock.getString();    	non-compiled	[CE]  ';'  expected	7	None	replace
1248	[BUG]  [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnsType  =  tryBlock.getNext();  Node  returnType  =  startType.getNext();  Node  returnsType  =  tryBlock.getNext();  [CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnsType  =  tryBlock.getNext();  Node  returnType  =  startType.getNext();  Node  returnsType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        returnType        =        tryBlock.getNext();        Node    returnsType    =    tryBlock.getNext();    Node  returnType  =  startType.getNext();  Node  returnsType  =  tryBlock.getNext();	  	non-compiled	[CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	121	None	add
1249	[BUG]  [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnsType  =  tryBlock.getNext();  Node  returnType  =  attemptBlock.getNext();  Node  returnsType  =  tryBlock.getNext();  [CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]      AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnsType  =  tryBlock.getNext();  Node  returnType  =  attemptBlock.getNext();  Node  returnsType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        returnType        =        tryBlock.getNext();        Node    returnsType    =    tryBlock.getNext();    Node  returnType  =  attemptBlock.getNext();  Node  returnsType  =  tryBlock.getNext();	  	non-compiled	[CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	121	None	add
1250	[BUG]  [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnedType  =  tryBlock.getNext();  Node  returnType  =  startType.getNext();  Node  returnedType  =  tryBlock.getNext();  [CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Node    returnType    =    tryBlock.getNext();    Node  returnedType  =  tryBlock.getNext();  Node  returnType  =  startType.getNext();  Node  returnedType  =  tryBlock.getNext();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Node        returnType        =        tryBlock.getNext();        Node    returnedType    =    tryBlock.getNext();    Node  returnType  =  startType.getNext();  Node  returnedType  =  tryBlock.getNext();	  	non-compiled	[CE]  variable  returnType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	44	None	add
1251	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  returnsType  =  tryBlock.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Node    returnType    =    tryBlock.getFirstChild();    Node  returnsType  =  tryBlock.getFirstChild();	  	compilable	  [FE]  AssertionFailedError  	5	2	add
1252	[BUG]  [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  returnsType  =  tryBlock.getFirstChild();  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock.getFirstChild();  Node  returnsType  =  tryBlock.getFirstChild();  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    returnType    =    tryBlock.getFirstChild();    Node  returnsType  =  tryBlock.getFirstChild();	  	compilable	  [FE]  AssertionFailedError  	5	2	add
1253	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(n.getType()  >=  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()    >=    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	39	6	replace
1254	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  >=  Token.EXPR_RESULT);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(n.getType()  >=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(n.getType()  >=  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()    >=    Token.EXPR_RESULT);    	compilable	  [FE]  RuntimeException  	39	6	replace
1255	[BUG]  [BUGGY]  Node  exitType  =  tryBlock.getFirstChild();  Preconditions.checkState(exitType!=  Token.EXPR_RESULT);  [CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)  [FE]      RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  exitType  =  tryBlock.getFirstChild();  Preconditions.checkState(exitType!=  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  exitType  =  tryBlock.getFirstChild();  Preconditions.checkState(exitType!=  Token.EXPR_RESULT);	          Preconditions.checkState(tryBlock.getType()    ==    Token.EXPR_RESULT);    Preconditions.checkState(tryBlock.getType()    >=    Token.EXPR_RESULT);    	non-compiled	[CE]  variable  exitType  is  already  defined  in  method  tryMinimizeExits(Node,int,String)	39	None	replace
1256	[BUG]  [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getNext();  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getNext());  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getNext();  Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getNext());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node    c    =    tryBlock!=    null?    tryBlock.getNext()    :    tryBlock.getNext();    Node  c  =  tryBlock!=  null?  tryBlock.getNext()  :  tryBlock.getNext());	  	non-compiled	[CE]  ';'  expected	161	None	add
1257	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	64	6	replace
1258	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.FUNCTION);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.FUNCTION);	          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	64	6	replace
1259	[BUG]  [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getType()  :  DEFAULT_RETURN_TYPE;  [CE]  cannot  find  symbol  DEFAULT_RETURN_TYPE  [FE]          AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getType()  :  DEFAULT_RETURN_TYPE;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock!=  null?  tryBlock.getType()  :  DEFAULT_RETURN_TYPE;	  Node    returnType    =    tryBlock.getType();    	non-compiled	[CE]  cannot  find  symbol  DEFAULT_RETURN_TYPE	4	None	replace
1260	[BUG]  [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getType()  :  DEFAULT_TYPE;  [CE]  cannot  find  symbol  DEFAULT_TYPE  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Node  returnType  =  tryBlock!=  null?  tryBlock.getType()  :  DEFAULT_TYPE;  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Node  returnType  =  tryBlock!=  null?  tryBlock.getType()  :  DEFAULT_TYPE;	  Node    returnType    =    tryBlock.getType();    	non-compiled	[CE]  cannot  find  symbol  DEFAULT_TYPE	4	None	replace
1261	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  NodeUtil.checkType(tryBlock.getType()!=  Token.CATCH);  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()!=  Token.CATCH);  NodeUtil.checkType(tryBlock.getType()!=  Token.CATCH);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()!=    Token.CATCH);    NodeUtil.checkType(tryBlock.getType()!=  Token.CATCH);	  	non-compiled	[CE]  cannot  find  symbol	114	None	add
1262	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [CE]  cannot  find  symbol  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION    ||    tryBlock.getType()    ==    Token.EXPR_RESULT);    NodeUtil.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getType()  ==  Token.EXPR_RESULT);	  	non-compiled	[CE]  cannot  find  symbol	18	None	add
1263	[BUG]  [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.check(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  [CE]  cannot  find  symbol  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]          Preconditions.checkState(tryBlock.getType()    ==    Token.FUNCTION);    Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  Preconditions.check(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	                Preconditions.checkState(tryBlock.getType()        ==        Token.FUNCTION);        Preconditions.checkState(tryBlock.getType()!=    Token.FUNCTION);    Preconditions.check(tryBlock.getType()  ==  Token.FUNCTION);  Preconditions.checkState(tryBlock.getType()!=  Token.FUNCTION);	  	non-compiled	[CE]  cannot  find  symbol	66	None	add
1264	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.getNext());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkState(tryBlock!=  null,  tryBlock.getNext());	  Preconditions.checkState(tryBlock!=    null,    tryBlock.isExit());    	compilable	  [FE]  AssertionFailedError  	182	6	replace
1265	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.getNext());  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.getNext());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=  null,  tryBlock.getNext());	  Preconditions.checkState(tryBlock!=    null,    tryBlock.isExit());    	compilable	  [FE]  AssertionFailedError  	182	6	replace
1266	[BUG]  [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.getExit());  [CE]  cannot  find  symbol  [FE]              AssertionFailedError      [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkState(tryBlock!=  null,  tryBlock.getExit());  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkState(tryBlock!=  null,  tryBlock.getExit());	  Preconditions.checkState(tryBlock!=    null,    tryBlock.isExit());    	non-compiled	[CE]  cannot  find  symbol	182	None	replace
1267	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	add	Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()  ==  null);	  Preconditions.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	164	6	replace
1268	[BUG]  [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()  ==  null);  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]      Node  elseBlock  =  ifBlock.getNext();  if  (elseBlock  !=  null)  {  tryMinimizeExits(elseBlock,  exitType,  labelName);  }  return;  }  if  (n.isTry())  {  Node  tryBlock  =  n.getFirstChild();      [BUGGY]  Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()  ==  null);  [BUGGY]      tryMinimizeExits(tryBlock,  exitType,  labelName);  Node  allCatchNodes  =  NodeUtil.getCatchBlock(n);  if  (NodeUtil.hasCatchHandler(allCatchNodes))  {  Preconditions.checkState(allCatchNodes.hasOneChild());  Node  catchNode  =  allCatchNodes.getFirstChild();  Node  catchCodeBlock  =  catchNode.getLastChild();  tryMinimizeExits(catchCodeBlock,  exitType,  labelName);  }    [CLASS]  MinimizeExitPoints  [METHOD]  tryMinimizeExits  [RETURN_TYPE]  void  Node  n  int  exitType  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  exitType  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.5773502691896258	129	129	2	replace	Preconditions.checkArgument(tryBlock.getType()  ==  Token.FUNCTION  ||  tryBlock.getFirstChild()  ==  null);	  Preconditions.checkArgument(tryBlock.getType()    ==    Token.FUNCTION);    	compilable	  [FE]  RuntimeException  	164	6	replace
