bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  LabelName  labelName  =  n.getLastChild().getString();  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  LabelName  labelName  =  n.getLastChild().getString();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	LabelName  labelName  =  n.getLastChild().getString();	      LabelName    labelName    =    n.getFirstChild().getString();    	non-compiled	[CE]  cannot  find  symbol	1	None	replace
2	[BUG]  [BUGGY]  LabelName  labelName  =  n.getFirstChild().getQualifiedName();  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  LabelName  labelName  =  n.getFirstChild().getQualifiedName();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	LabelName  labelName  =  n.getFirstChild().getQualifiedName();	      LabelName    labelName    =    n.getFirstChild().getString();    	non-compiled	[CE]  cannot  find  symbol	1	None	replace
3	[BUG]  [BUGGY]  LabelName  labelName  =  n.getFirstChild().getLabelName();  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  LabelName  labelName  =  n.getFirstChild().getLabelName();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	LabelName  labelName  =  n.getFirstChild().getLabelName();	      LabelName    labelName    =    n.getFirstChild().getString();    	non-compiled	[CE]  cannot  find  symbol	1	None	replace
4	[BUG]  [BUGGY]  LabelName  labelName  =  n,  type.getFirstChild().getString();  [CE]  ';'  expected  [FE]              AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  LabelName  labelName  =  n,  type.getFirstChild().getString();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	LabelName  labelName  =  n,  type.getFirstChild().getString();	      LabelName    labelName    =    n.getFirstChild().getString();    	non-compiled	[CE]  ';'  expected	1	None	replace
5	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	add	return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());	  return!n.hasChildren()    &&    labelName.equals(n.getFirstChild().getString());    	compilable	  [FE]  RuntimeException  	8	3	replace
6	[BUG]  [BUGGY]  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  [FE]  RuntimeException  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());	  return!n.hasChildren()    &&    labelName.equals(n.getFirstChild().getString());    	compilable	  [FE]  RuntimeException  	8	3	replace
7	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return  n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	add	return  n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());	  return!n.hasChildren()    &&    labelName.equals(n.getFirstChild().getString());    	compilable	  [FE]  RuntimeException  	8	3	replace
8	[BUG]  [BUGGY]  return  n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  [FE]  RuntimeException  [FE]      AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return  n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return  n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());	  return!n.hasChildren()    &&    labelName.equals(n.getFirstChild().getString());    	compilable	  [FE]  RuntimeException  	8	3	replace
9	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	add	return!n.hasChildren()  &&  labelName.equals(n.getString());	  return!n.hasChildren()    &&    labelName.equals(n.getFirstChild().getString());    	compilable	  [FE]  AssertionFailedError  	8	3	replace
10	[BUG]  [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getString());  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()  &&  labelName.equals(n.getString());	  return!n.hasChildren()    &&    labelName.equals(n.getFirstChild().getString());    	compilable	  [FE]  AssertionFailedError  	8	3	replace
11	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  labelName  =  n.getLastChild().getString();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	add	labelName  =  n.getLastChild().getString();	      labelName    =    n.getFirstChild().getString();    	compilable	  [FE]  RuntimeException  	16	3	replace
12	[BUG]  [BUGGY]  labelName  =  n.getLastChild().getString();  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  labelName  =  n.getLastChild().getString();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	labelName  =  n.getLastChild().getString();	      labelName    =    n.getFirstChild().getString();    	compilable	  [FE]  RuntimeException  	16	3	replace
13	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  labelName  =  n.getFirstChild().getString()  +  1;  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	add	labelName  =  n.getFirstChild().getString()  +  1;	      labelName    =    n.getFirstChild().getString();    	compilable	  [FE]  RuntimeException  	16	3	replace
14	[BUG]  [BUGGY]  labelName  =  n.getFirstChild().getString()  +  1;  [FE]  RuntimeException  [FE]      RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  labelName  =  n.getFirstChild().getString()  +  1;  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	labelName  =  n.getFirstChild().getString()  +  1;	      labelName    =    n.getFirstChild().getString();    	compilable	  [FE]  RuntimeException  	16	3	replace
15	[BUG]  [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  [CE]  unreachable  statement  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&    labelName.equals(n.getFirstChild().getString());    return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());	  	non-compiled	[CE]  unreachable  statement	7	None	add
16	[BUG]  [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  [CE]  not  a  statement  [FE]      AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&    labelName.equals(n.getFirstChild().getString());    n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());	  	non-compiled	[CE]  not  a  statement	7	None	add
17	[BUG]  [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  [CE]  unreachable  statement  [FE]        AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&    labelName.equals(n.getFirstChild().getString());    if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }	  	non-compiled	[CE]  unreachable  statement	7	None	add
18	[BUG]  [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  String  labelName  =  n.getFirstChild().getString();  [CE]  variable  labelName  is  already  defined  in  method  matchingExitNode(Node,int,String)  [FE]          AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  String  labelName  =  n.getFirstChild().getString();  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&    labelName.equals(n.getFirstChild().getString());    String  labelName  =  n.getFirstChild().getString();	  	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  matchingExitNode(Node,int,String)	7	None	add
19	[BUG]  [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild  [CE]  ')'  expected  [FE]            AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&    labelName.equals(n.getFirstChild().getString());    if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild	  	non-compiled	[CE]  ')'  expected	7	None	add
20	[BUG]  [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.get  [CE]  ')'  expected  [FE]              AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.get  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&    labelName.equals(n.getFirstChild().getString());    if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.get	  	non-compiled	[CE]  ')'  expected	7	None	add
21	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  n  =  n.getLastChild();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	add	n  =  n.getLastChild();	      n    =    n.getFirstChild();    	compilable	  [FE]  AssertionFailedError  	18	3	replace
22	[BUG]  [BUGGY]  n  =  n.getLastChild();  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  n  =  n.getLastChild();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	n  =  n.getLastChild();	      n    =    n.getFirstChild();    	compilable	  [FE]  AssertionFailedError  	18	3	replace
23	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  n  =  n.getNext();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	add	n  =  n.getNext();	      n    =    n.getFirstChild();    	compilable	  [FE]  AssertionFailedError  	18	3	replace
24	[BUG]  [BUGGY]  n  =  n.getNext();  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  n  =  n.getNext();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	n  =  n.getNext();	      n    =    n.getFirstChild();    	compilable	  [FE]  AssertionFailedError  	18	3	replace
25	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  n  =  n.getFirstChild().getNext();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	add	n  =  n.getFirstChild().getNext();	      n    =    n.getFirstChild();    	compilable	  [FE]  AssertionFailedError  	18	3	replace
26	[BUG]  [BUGGY]  n  =  n.getFirstChild().getNext();  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  n  =  n.getFirstChild().getNext();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	n  =  n.getFirstChild().getNext();	      n    =    n.getFirstChild();    	compilable	  [FE]  AssertionFailedError  	18	3	replace
27	[BUG]  [BUGGY]  String  labelName  =  n.getLastChild().getString();  [CE]  variable  labelName  is  already  defined  in  method  matchingExitNode(Node,int,String)  [FE]              AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  String  labelName  =  n.getLastChild().getString();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	String  labelName  =  n.getLastChild().getString();	      String    labelName    =    n.getFirstChild().getString();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  matchingExitNode(Node,int,String)	4	None	replace
28	[BUG]  [BUGGY]  String  labelName  =  n.getFirstChild().getString()  +  1;  [CE]  variable  labelName  is  already  defined  in  method  matchingExitNode(Node,int,String)  [FE]                AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  String  labelName  =  n.getFirstChild().getString()  +  1;  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	String  labelName  =  n.getFirstChild().getString()  +  1;	      String    labelName    =    n.getFirstChild().getString();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  matchingExitNode(Node,int,String)	4	None	replace
29	[BUG]  [BUGGY]  String  labelName  =  n.getFirstChild().getString()  + ": ";  [CE]  variable  labelName  is  already  defined  in  method  matchingExitNode(Node,int,String)  [FE]                  AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  String  labelName  =  n.getFirstChild().getString()  + ": ";  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	String  labelName  =  n.getFirstChild().getString()  + ": ";	      String    labelName    =    n.getFirstChild().getString();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  matchingExitNode(Node,int,String)	4	None	replace
30	[BUG]  [BUGGY]  String  labelName  =  n.getFirstChild().getQualifiedName();  [CE]  variable  labelName  is  already  defined  in  method  matchingExitNode(Node,int,String)  [FE]                    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  String  labelName  =  n.getFirstChild().getQualifiedName();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	String  labelName  =  n.getFirstChild().getQualifiedName();	      String    labelName    =    n.getFirstChild().getString();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  matchingExitNode(Node,int,String)	4	None	replace
31	[BUG]  [BUGGY]  &&  LabelName.equals(n.getFirstChild().getString());  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  &&  LabelName.equals(n.getFirstChild().getString());  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	&&  LabelName.equals(n.getFirstChild().getString());	      &&    labelName.equals(n.getLastChild().getString());    	non-compiled	[CE]  illegal  start  of  expression	6	None	replace
32	[BUG]  [BUGGY]  &&  labelName.equals(n.getString());  [CE]  illegal  start  of  expression  [FE]                    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  &&  labelName.equals(n.getString());  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	&&  labelName.equals(n.getString());	      &&    labelName.equals(n.getLastChild().getString());    	non-compiled	[CE]  illegal  start  of  expression	6	None	replace
33	[BUG]  [BUGGY]  &&  labelName.equals(n.getLastChild().getString()  +  1);  [CE]  illegal  start  of  expression  [FE]                      AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  &&  labelName.equals(n.getLastChild().getString()  +  1);  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	&&  labelName.equals(n.getLastChild().getString()  +  1);	      &&    labelName.equals(n.getLastChild().getString());    	non-compiled	[CE]  illegal  start  of  expression	6	None	replace
34	[BUG]  [BUGGY]  &&  labelName.equals(n.getLastChild().getString()))  {  return  false;  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  &&  labelName.equals(n.getLastChild().getString()))  {  return  false;  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	&&  labelName.equals(n.getLastChild().getString()))  {  return  false;	      &&    labelName.equals(n.getFirstChild().getString()))    {    return    true;    	non-compiled	[CE]  illegal  start  of  expression	3	None	replace
35	[BUG]  [BUGGY]  &&  labelName.equals(n.getLastChild().getString()))  {  return  true;  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  &&  labelName.equals(n.getLastChild().getString()))  {  return  true;  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	&&  labelName.equals(n.getLastChild().getString()))  {  return  true;	      &&    labelName.equals(n.getFirstChild().getString()))    {    return    true;    	non-compiled	[CE]  illegal  start  of  expression	3	None	replace
36	[BUG]  [BUGGY]  &&  labelName.equals(n.getString()))  {  return  false;  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  &&  labelName.equals(n.getString()))  {  return  false;  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	&&  labelName.equals(n.getString()))  {  return  false;	      &&    labelName.equals(n.getFirstChild().getString()))    {    return    true;    	non-compiled	[CE]  illegal  start  of  expression	3	None	replace
37	[BUG]  [BUGGY]  &&  labelName.equals(n.getNext().getString());  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  &&  labelName.equals(n.getNext().getString());  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	&&  labelName.equals(n.getNext().getString());	      &&    labelName.equals(n.getFirstChild().getString());    	non-compiled	[CE]  illegal  start  of  expression	2	None	replace
38	[BUG]  [BUGGY]  &&  labelName.equals(n.getFirstChild().getString()  +  1);  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  &&  labelName.equals(n.getFirstChild().getString()  +  1);  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	&&  labelName.equals(n.getFirstChild().getString()  +  1);	      &&    labelName.equals(n.getFirstChild().getString());    	non-compiled	[CE]  illegal  start  of  expression	2	None	replace
39	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return  n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	add	return  n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());	  return!n.hasChildren()    ||    labelName.equals(n.getFirstChild().getString());    	compilable	  [FE]  AssertionFailedError  	10	3	replace
40	[BUG]  [BUGGY]  return  n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  [FE]  AssertionFailedError  [FE]    RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return  n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return  n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());	  return!n.hasChildren()    ||    labelName.equals(n.getFirstChild().getString());    	compilable	  [FE]  AssertionFailedError  	10	3	replace
41	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return  n.getFirstChild().hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	add	return  n.getFirstChild().hasChildren()  &&  labelName.equals(n.getFirstChild().getString());	  return!n.hasChildren()    ||    labelName.equals(n.getFirstChild().getString());    	compilable	  [FE]  AssertionFailedError  	10	3	replace
42	[BUG]  [BUGGY]  return  n.getFirstChild().hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  [FE]  AssertionFailedError  [FE]      RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return  n.getFirstChild().hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return  n.getFirstChild().hasChildren()  &&  labelName.equals(n.getFirstChild().getString());	  return!n.hasChildren()    ||    labelName.equals(n.getFirstChild().getString());    	compilable	  [FE]  AssertionFailedError  	10	3	replace
43	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]      labelName  =  n.getFirstChild().getString();  labelName  =  n.getFirstChild().getString();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	add	        labelName    =    n.getFirstChild().getString();    labelName  =  n.getFirstChild().getString();	  	compilable	  [FE]  RuntimeException  	15	3	add
44	[BUG]  [BUGGY]      labelName  =  n.getFirstChild().getString();  labelName  =  n.getFirstChild().getString();  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]      labelName  =  n.getFirstChild().getString();  labelName  =  n.getFirstChild().getString();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	        labelName    =    n.getFirstChild().getString();    labelName  =  n.getFirstChild().getString();	  	compilable	  [FE]  RuntimeException  	15	3	add
45	[BUG]  [BUGGY]      labelName  =  n.getFirstChild().getString();  LabelName  =  n.getFirstChild().getString();  [CE]  cannot  find  symbol  LabelName  [FE]      RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]      labelName  =  n.getFirstChild().getString();  LabelName  =  n.getFirstChild().getString();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	        labelName    =    n.getFirstChild().getString();    LabelName  =  n.getFirstChild().getString();	  	non-compiled	[CE]  cannot  find  symbol  LabelName	15	None	add
46	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]      labelName  =  n.getFirstChild().getString();  labelName  =  n.getLastChild().getString();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	add	        labelName    =    n.getFirstChild().getString();    labelName  =  n.getLastChild().getString();	  	compilable	  [FE]  RuntimeException  	15	3	add
47	[BUG]  [BUGGY]      labelName  =  n.getFirstChild().getString();  labelName  =  n.getLastChild().getString();  [FE]  RuntimeException  [FE]        RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]      labelName  =  n.getFirstChild().getString();  labelName  =  n.getLastChild().getString();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	        labelName    =    n.getFirstChild().getString();    labelName  =  n.getLastChild().getString();	  	compilable	  [FE]  RuntimeException  	15	3	add
48	[BUG]  [BUGGY]      labelName  =  n.getFirstChild().getString();  LabelName  =  n.getLastChild().getString();  [CE]  cannot  find  symbol  LabelName  [FE]          RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]      labelName  =  n.getFirstChild().getString();  LabelName  =  n.getLastChild().getString();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	        labelName    =    n.getFirstChild().getString();    LabelName  =  n.getLastChild().getString();	  	non-compiled	[CE]  cannot  find  symbol  LabelName	15	None	add
49	[BUG]  [BUGGY]      labelName  =  n.getFirstChild().getString();  String  labelName  =  n.getFirstChild().getString();  [CE]  variable  labelName  is  already  defined  in  method  matchingExitNode(Node,int,String)  [FE]            RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]      labelName  =  n.getFirstChild().getString();  String  labelName  =  n.getFirstChild().getString();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	        labelName    =    n.getFirstChild().getString();    String  labelName  =  n.getFirstChild().getString();	  	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  matchingExitNode(Node,int,String)	15	None	add
50	[BUG]  [BUGGY]      labelName  =  n.getFirstChild().getString();  labelName  =  n.getFirstChild().getString());  [CE]  ';'  expected  [FE]              RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]      labelName  =  n.getFirstChild().getString();  labelName  =  n.getFirstChild().getString());  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	        labelName    =    n.getFirstChild().getString();    labelName  =  n.getFirstChild().getString());	  	non-compiled	[CE]  ';'  expected	15	None	add
51	[BUG]  [BUGGY]  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  [CE]  not  a  statement  [FE]    RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    ||    labelName.equals(n.getFirstChild().getString());    n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());	  	non-compiled	[CE]  not  a  statement	9	None	add
52	[BUG]  [BUGGY]  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  [CE]  unreachable  statement  [FE]      RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    ||    labelName.equals(n.getFirstChild().getString());    return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());	  	non-compiled	[CE]  unreachable  statement	9	None	add
53	[BUG]  [BUGGY]  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  }  [CE]  unreachable  statement  [FE]        RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  }  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    ||    labelName.equals(n.getFirstChild().getString());    if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  }	  	non-compiled	[CE]  unreachable  statement	9	None	add
54	[BUG]  [BUGGY]  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  ||  labelName.equals(n.getFirstChild().getString());  [CE]  illegal  start  of  expression  [FE]          RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  ||  labelName.equals(n.getFirstChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    ||    labelName.equals(n.getFirstChild().getString());    ||  labelName.equals(n.getFirstChild().getString());	  	non-compiled	[CE]  illegal  start  of  expression	9	None	add
55	[BUG]  [BUGGY]  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  type)  {  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  }  [CE]  unreachable  statement  [FE]            RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  type)  {  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  }  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    ||    labelName.equals(n.getFirstChild().getString());    if(n.getType()  ==  type)  {  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  }	  	non-compiled	[CE]  unreachable  statement	9	None	add
56	[BUG]  [BUGGY]  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  n.hasChildren()  ||  labelName.equals(n.getLastChild().getString());  [CE]  not  a  statement  [FE]              RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  n.hasChildren()  ||  labelName.equals(n.getLastChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    ||    labelName.equals(n.getFirstChild().getString());    n.hasChildren()  ||  labelName.equals(n.getLastChild().getString());	  	non-compiled	[CE]  not  a  statement	9	None	add
57	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return  n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	add	return  n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());	  return!n.hasChildren()    &&!labelName.equals(n.getFirstChild().getString());    	compilable	  [FE]  RuntimeException  	14	3	replace
58	[BUG]  [BUGGY]  return  n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  [FE]  RuntimeException  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return  n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return  n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());	  return!n.hasChildren()    &&!labelName.equals(n.getFirstChild().getString());    	compilable	  [FE]  RuntimeException  	14	3	replace
59	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return  n.hasChildren()  &&!labelName.equals(n.getLastChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	add	return  n.hasChildren()  &&!labelName.equals(n.getLastChild().getString());	  return!n.hasChildren()    &&!labelName.equals(n.getFirstChild().getString());    	compilable	  [FE]  RuntimeException  	14	3	replace
60	[BUG]  [BUGGY]  return  n.hasChildren()  &&!labelName.equals(n.getLastChild().getString());  [FE]  RuntimeException  [FE]      AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return  n.hasChildren()  &&!labelName.equals(n.getLastChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return  n.hasChildren()  &&!labelName.equals(n.getLastChild().getString());	  return!n.hasChildren()    &&!labelName.equals(n.getFirstChild().getString());    	compilable	  [FE]  RuntimeException  	14	3	replace
61	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]        AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return  n.hasChildren()  &&!labelName.equals(n.getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	add	return  n.hasChildren()  &&!labelName.equals(n.getString());	  return!n.hasChildren()    &&!labelName.equals(n.getFirstChild().getString());    	compilable	  [FE]  RuntimeException  	14	3	replace
62	[BUG]  [BUGGY]  return  n.hasChildren()  &&!labelName.equals(n.getString());  [FE]  RuntimeException  [FE]        AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return  n.hasChildren()  &&!labelName.equals(n.getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return  n.hasChildren()  &&!labelName.equals(n.getString());	  return!n.hasChildren()    &&!labelName.equals(n.getFirstChild().getString());    	compilable	  [FE]  RuntimeException  	14	3	replace
63	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return  n.getFirstChild().hasChildren()  &&  labelName.equals(n.getLastChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	add	return  n.getFirstChild().hasChildren()  &&  labelName.equals(n.getLastChild().getString());	  return!n.hasChildren()    &&    labelName.equals(n.getLastChild().getString());    	compilable	  [FE]  AssertionFailedError  	12	3	replace
64	[BUG]  [BUGGY]  return  n.getFirstChild().hasChildren()  &&  labelName.equals(n.getLastChild().getString());  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return  n.getFirstChild().hasChildren()  &&  labelName.equals(n.getLastChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return  n.getFirstChild().hasChildren()  &&  labelName.equals(n.getLastChild().getString());	  return!n.hasChildren()    &&    labelName.equals(n.getLastChild().getString());    	compilable	  [FE]  AssertionFailedError  	12	3	replace
65	[BUG]  [BUGGY]  n.removeChild(labelName,  type);  [CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]        AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  n.removeChild(labelName,  type);  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	n.removeChild(labelName,  type);	      n.removeChild(labelName);    	non-compiled	[CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;	20	None	replace
66	[BUG]  [BUGGY]  n.removeChild(type,  labelName);  [CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]          AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  n.removeChild(type,  labelName);  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	n.removeChild(type,  labelName);	      n.removeChild(labelName);    	non-compiled	[CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;	20	None	replace
67	[BUG]  [BUGGY]  n.removeChild(labelName,  labelName);  [CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]            AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  n.removeChild(labelName,  labelName);  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	n.removeChild(labelName,  labelName);	      n.removeChild(labelName);    	non-compiled	[CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;	20	None	replace
68	[BUG]  [BUGGY]  n.removeChild(labelName,  name);  [CE]  cannot  find  symbol  name  [FE]              AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  n.removeChild(labelName,  name);  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	n.removeChild(labelName,  name);	      n.removeChild(labelName);    	non-compiled	[CE]  cannot  find  symbol  name	20	None	replace
69	[BUG]  [BUGGY]  n.removeChild(type);  [CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  n.removeChild(type);  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	n.removeChild(type);	      n.removeChild(labelName);    	non-compiled	[CE]  method  removeChild  in  class  Node  cannot  be  applied  to  given  types;	20	None	replace
70	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]      n  =  n.getFirstChild();  n  =  n.getFirstChild();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	add	        n    =    n.getFirstChild();    n  =  n.getFirstChild();	  	compilable	  [FE]  RuntimeException  	17	3	add
71	[BUG]  [BUGGY]      n  =  n.getFirstChild();  n  =  n.getFirstChild();  [FE]  RuntimeException  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]      n  =  n.getFirstChild();  n  =  n.getFirstChild();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	        n    =    n.getFirstChild();    n  =  n.getFirstChild();	  	compilable	  [FE]  RuntimeException  	17	3	add
72	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]      AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]      n  =  n.getFirstChild();  n  =  n.getLastChild();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	add	        n    =    n.getFirstChild();    n  =  n.getLastChild();	  	compilable	  [FE]  RuntimeException  	17	3	add
73	[BUG]  [BUGGY]      n  =  n.getFirstChild();  n  =  n.getLastChild();  [FE]  RuntimeException  [FE]      AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]      n  =  n.getFirstChild();  n  =  n.getLastChild();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	        n    =    n.getFirstChild();    n  =  n.getLastChild();	  	compilable	  [FE]  RuntimeException  	17	3	add
74	[BUG]  [BUGGY]      n  =  n.getFirstChild();  int  n  =  n.getFirstChild();  [CE]  variable  n  is  already  defined  in  method  matchingExitNode(Node,int,String)  [FE]        AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]      n  =  n.getFirstChild();  int  n  =  n.getFirstChild();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	        n    =    n.getFirstChild();    int  n  =  n.getFirstChild();	  	non-compiled	[CE]  variable  n  is  already  defined  in  method  matchingExitNode(Node,int,String)	17	None	add
75	[BUG]  [BUGGY]      n  =  n.getFirstChild();  Node  n  =  n.getFirstChild();  [CE]  variable  n  is  already  defined  in  method  matchingExitNode(Node,int,String)  [FE]          AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]      n  =  n.getFirstChild();  Node  n  =  n.getFirstChild();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	        n    =    n.getFirstChild();    Node  n  =  n.getFirstChild();	  	non-compiled	[CE]  variable  n  is  already  defined  in  method  matchingExitNode(Node,int,String)	17	None	add
76	[BUG]  [BUGGY]      n  =  n.getFirstChild();  n  =  n.getFirstChild());  [CE]  ';'  expected  [FE]            AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]      n  =  n.getFirstChild();  n  =  n.getFirstChild());  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	        n    =    n.getFirstChild();    n  =  n.getFirstChild());	  	non-compiled	[CE]  ';'  expected	17	None	add
77	[BUG]  [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  [CE]  unreachable  statement  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&!labelName.equals(n.getFirstChild().getString());    return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());	  	non-compiled	[CE]  unreachable  statement	13	None	add
78	[BUG]  [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  [CE]  not  a  statement  [FE]      AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&!labelName.equals(n.getFirstChild().getString());    n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());	  	non-compiled	[CE]  not  a  statement	13	None	add
79	[BUG]  [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  }  [CE]  unreachable  statement  [FE]        AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  }  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&!labelName.equals(n.getFirstChild().getString());    if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  }	  	non-compiled	[CE]  unreachable  statement	13	None	add
80	[BUG]  [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  Token.FUNCTION)  {  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  }  [CE]  unreachable  statement  [FE]          AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  Token.FUNCTION)  {  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  }  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&!labelName.equals(n.getFirstChild().getString());    if(n.getType()  ==  Token.FUNCTION)  {  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  }	  	non-compiled	[CE]  unreachable  statement	13	None	add
81	[BUG]  [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  }  else  {  return  n.hasChildren()  &&  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  }  else  {  return  n.hasChildren()  &&  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&!labelName.equals(n.getFirstChild().getString());    if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  }  else  {  return  n.hasChildren()  &&	  	non-compiled	[CE]  illegal  start  of  expression	13	None	add
82	[BUG]  [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  Token.FUNCTION)  {  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  }  else  {  return  n.hasChildren()  &&  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  Token.FUNCTION)  {  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  }  else  {  return  n.hasChildren()  &&  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&!labelName.equals(n.getFirstChild().getString());    if(n.getType()  ==  Token.FUNCTION)  {  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  }  else  {  return  n.hasChildren()  &&	  	non-compiled	[CE]  illegal  start  of  expression	13	None	add
83	[BUG]  [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  [CE]  unreachable  statement  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&    labelName.equals(n.getLastChild().getString());    return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());	  	non-compiled	[CE]  unreachable  statement	11	None	add
84	[BUG]  [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  [CE]  not  a  statement  [FE]      AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&    labelName.equals(n.getLastChild().getString());    n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());	  	non-compiled	[CE]  not  a  statement	11	None	add
85	[BUG]  [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  if(labelName!=  null)  {  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  }  [CE]  unreachable  statement  [FE]        AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  if(labelName!=  null)  {  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  }  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&    labelName.equals(n.getLastChild().getString());    if(labelName!=  null)  {  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  }	  	non-compiled	[CE]  unreachable  statement	11	None	add
86	[BUG]  [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  }  [CE]  unreachable  statement  [FE]          AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  }  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&    labelName.equals(n.getLastChild().getString());    if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  }	  	non-compiled	[CE]  unreachable  statement	11	None	add
87	[BUG]  [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  if(labelName!=  null)  {  return  n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  }  [CE]  unreachable  statement  [FE]            AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  if(labelName!=  null)  {  return  n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  }  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&    labelName.equals(n.getLastChild().getString());    if(labelName!=  null)  {  return  n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  }	  	non-compiled	[CE]  unreachable  statement	11	None	add
88	[BUG]  [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  String  labelName  =  n.getLastChild().getString();  [CE]  variable  labelName  is  already  defined  in  method  matchingExitNode(Node,int,String)  [FE]              AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  String  labelName  =  n.getLastChild().getString();  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&    labelName.equals(n.getLastChild().getString());    String  labelName  =  n.getLastChild().getString();	  	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  matchingExitNode(Node,int,String)	11	None	add
89	[BUG]  [BUGGY]  return  n.hasChildren()  &&  LabelName.equals(labelName.getFirstChild().getString());  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return  n.hasChildren()  &&  LabelName.equals(labelName.getFirstChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return  n.hasChildren()  &&  LabelName.equals(labelName.getFirstChild().getString());	  return!n.hasChildren()    &&    LabelName.equals(n.getFirstChild().getString());    	non-compiled	[CE]  cannot  find  symbol	19	None	replace
90	[BUG]  [BUGGY]  return  n.hasChildren()  &&  LabelName.equals(n.getFirstChild().getString());  [CE]  cannot  find  symbol  LabelName  [FE]          AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return  n.hasChildren()  &&  LabelName.equals(n.getFirstChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return  n.hasChildren()  &&  LabelName.equals(n.getFirstChild().getString());	  return!n.hasChildren()    &&    LabelName.equals(n.getFirstChild().getString());    	non-compiled	[CE]  cannot  find  symbol  LabelName	19	None	replace
91	[BUG]  [BUGGY]  return!n.hasChildren()  &&  LabelName.equals(labelName.getFirstChild().getString());  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  LabelName.equals(labelName.getFirstChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()  &&  LabelName.equals(labelName.getFirstChild().getString());	  return!n.hasChildren()    &&    LabelName.equals(n.getFirstChild().getString());    	non-compiled	[CE]  cannot  find  symbol	19	None	replace
92	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  labelName  =  n.getFirstChild().getQualifiedName();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	add	labelName  =  n.getFirstChild().getQualifiedName();	      labelName    =    n.getFirstChild().getString();    	compilable	  [FE]  AssertionFailedError  	16	3	replace
93	[BUG]  [BUGGY]  labelName  =  n.getFirstChild().getQualifiedName();  [FE]  AssertionFailedError  [FE]    RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  labelName  =  n.getFirstChild().getQualifiedName();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	labelName  =  n.getFirstChild().getQualifiedName();	      labelName    =    n.getFirstChild().getString();    	compilable	  [FE]  AssertionFailedError  	16	3	replace
94	[BUG]  [BUGGY]      labelName  =  n.getFirstChild().getString();  LabelName  labelName  =  n.getFirstChild().getString();  [CE]  cannot  find  symbol  [FE]    RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]      labelName  =  n.getFirstChild().getString();  LabelName  labelName  =  n.getFirstChild().getString();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	        labelName    =    n.getFirstChild().getString();    LabelName  labelName  =  n.getFirstChild().getString();	  	non-compiled	[CE]  cannot  find  symbol	15	None	add
95	[BUG]  [BUGGY]      labelName  =  n.getFirstChild().getString();  labelName  =  n.getfirstChild().getString();  [CE]  cannot  find  symbol  [FE]      RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]      labelName  =  n.getFirstChild().getString();  labelName  =  n.getfirstChild().getString();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	        labelName    =    n.getFirstChild().getString();    labelName  =  n.getfirstChild().getString();	  	non-compiled	[CE]  cannot  find  symbol	15	None	add
96	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	add	return!n.hasChildren()  &&!labelName.equals(n.getString());	  return!n.hasChildren()    &&!labelName.equals(n.getFirstChild().getString());    	compilable	  [FE]  AssertionFailedError  	14	3	replace
97	[BUG]  [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getString());  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()  &&!labelName.equals(n.getString());	  return!n.hasChildren()    &&!labelName.equals(n.getFirstChild().getString());    	compilable	  [FE]  AssertionFailedError  	14	3	replace
98	[BUG]  [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  [CE]  unreachable  statement  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&!labelName.equals(n.getFirstChild().getString());    if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }	  	non-compiled	[CE]  unreachable  statement	13	None	add
99	[BUG]  [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  [CE]  unreachable  statement  [FE]      AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&!labelName.equals(n.getFirstChild().getString());    return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());	  	non-compiled	[CE]  unreachable  statement	13	None	add
100	[BUG]  [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  return!n.hasChildren()  &&!labelName.equals(n.getLastChild().getString());  [CE]  unreachable  statement  [FE]        AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  return!n.hasChildren()  &&!labelName.equals(n.getLastChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&!labelName.equals(n.getFirstChild().getString());    return!n.hasChildren()  &&!labelName.equals(n.getLastChild().getString());	  	non-compiled	[CE]  unreachable  statement	13	None	add
101	[BUG]  [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  else  {  return  false;  }  [CE]  unreachable  statement  [FE]          AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  else  {  return  false;  }  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&!labelName.equals(n.getFirstChild().getString());    if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  else  {  return  false;  }	  	non-compiled	[CE]  unreachable  statement	13	None	add
102	[BUG]  [BUGGY]  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  if(labelName!=  null)  {  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  }  [CE]  unreachable  statement  [FE]    RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  if(labelName!=  null)  {  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  }  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    ||    labelName.equals(n.getFirstChild().getString());    if(labelName!=  null)  {  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  }	  	non-compiled	[CE]  unreachable  statement	9	None	add
103	[BUG]  [BUGGY]  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  if(labelName  ==  null)  {  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  }  [CE]  unreachable  statement  [FE]      RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  if(labelName  ==  null)  {  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  }  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    ||    labelName.equals(n.getFirstChild().getString());    if(labelName  ==  null)  {  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  }	  	non-compiled	[CE]  unreachable  statement	9	None	add
104	[BUG]  [BUGGY]  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  return!n.hasChildren()  ||  labelName.equals(n.getLastChild().getString());  [CE]  unreachable  statement  [FE]        RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  return!n.hasChildren()  ||  labelName.equals(n.getLastChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    ||    labelName.equals(n.getFirstChild().getString());    return!n.hasChildren()  ||  labelName.equals(n.getLastChild().getString());	  	non-compiled	[CE]  unreachable  statement	9	None	add
105	[BUG]  [BUGGY]  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  }  else  {  return  false;  }  [CE]  unreachable  statement  [FE]          RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  }  else  {  return  false;  }  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    ||    labelName.equals(n.getFirstChild().getString());    if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  }  else  {  return  false;  }	  	non-compiled	[CE]  unreachable  statement	9	None	add
106	[BUG]  [BUGGY]  &&  labelName.equals(n.getfirstChild().getString());  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  &&  labelName.equals(n.getfirstChild().getString());  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	&&  labelName.equals(n.getfirstChild().getString());	      &&    labelName.equals(n.getLastChild().getString());    	non-compiled	[CE]  illegal  start  of  expression	6	None	replace
107	[BUG]  [BUGGY]  LabelName  labelName  =  n.getFirstChild().getLastChild().getString();  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  LabelName  labelName  =  n.getFirstChild().getLastChild().getString();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	LabelName  labelName  =  n.getFirstChild().getLastChild().getString();	      LabelName    labelName    =    n.getFirstChild().getString();    	non-compiled	[CE]  cannot  find  symbol	1	None	replace
108	[BUG]  [BUGGY]  LabelName  labelName  =  n,  n.getFirstChild().getString();  [CE]  ';'  expected  [FE]          AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  LabelName  labelName  =  n,  n.getFirstChild().getString();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	LabelName  labelName  =  n,  n.getFirstChild().getString();	      LabelName    labelName    =    n.getFirstChild().getString();    	non-compiled	[CE]  ';'  expected	1	None	replace
109	[BUG]  [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  [CE]  unreachable  statement  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&    labelName.equals(n.getFirstChild().getString());    return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());	  	non-compiled	[CE]  unreachable  statement	7	None	add
110	[BUG]  [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  else  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild  [CE]  ')'  expected  [FE]      AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  else  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&    labelName.equals(n.getFirstChild().getString());    if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  else  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild	  	non-compiled	[CE]  ')'  expected	7	None	add
111	[BUG]  [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  else  {  return!n.hasChildren()  &&  labelName.equals(n.get  [CE]  ')'  expected  [FE]        AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  else  {  return!n.hasChildren()  &&  labelName.equals(n.get  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&    labelName.equals(n.getFirstChild().getString());    if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  else  {  return!n.hasChildren()  &&  labelName.equals(n.get	  	non-compiled	[CE]  ')'  expected	7	None	add
112	[BUG]  [BUGGY]  &&  labelName.equals(n.getFirstChild().getString())||  labelName.equals(n.getLastChild().getString());  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  &&  labelName.equals(n.getFirstChild().getString())||  labelName.equals(n.getLastChild().getString());  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	&&  labelName.equals(n.getFirstChild().getString())||  labelName.equals(n.getLastChild().getString());	      &&    labelName.equals(n.getFirstChild().getString());    	non-compiled	[CE]  illegal  start  of  expression	2	None	replace
113	[BUG]  [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  [CE]  unreachable  statement  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&    labelName.equals(n.getLastChild().getString());    return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());	  	non-compiled	[CE]  unreachable  statement	11	None	add
114	[BUG]  [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  }  else  {  return!n.hasChildren()  &&  labelName.equals(n.get  [CE]  ')'  expected  [FE]      AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  }  else  {  return!n.hasChildren()  &&  labelName.equals(n.get  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&    labelName.equals(n.getLastChild().getString());    if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  }  else  {  return!n.hasChildren()  &&  labelName.equals(n.get	  	non-compiled	[CE]  ')'  expected	11	None	add
115	[BUG]  [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  }  else  {  return!n.hasChildren()  &&  labelName.equals(n.getLastChild  [CE]  ')'  expected  [FE]        AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  }  else  {  return!n.hasChildren()  &&  labelName.equals(n.getLastChild  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&    labelName.equals(n.getLastChild().getString());    if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  }  else  {  return!n.hasChildren()  &&  labelName.equals(n.getLastChild	  	non-compiled	[CE]  ')'  expected	11	None	add
116	[BUG]  [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  }  else  {  return!n.hasChildren()  &&  labelName.equals(n  [CE]  ')'  expected  [FE]          AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  }  else  {  return!n.hasChildren()  &&  labelName.equals(n  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&    labelName.equals(n.getLastChild().getString());    if(n.getType()  ==  Token.RETURN)  {  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  }  else  {  return!n.hasChildren()  &&  labelName.equals(n	  	non-compiled	[CE]  ')'  expected	11	None	add
117	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return  n.getType()  ==  Token.RETURN  &&  labelName.equals(n.getLastChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	add	return  n.getType()  ==  Token.RETURN  &&  labelName.equals(n.getLastChild().getString());	  return!n.hasChildren()    &&    labelName.equals(n.getLastChild().getString());    	compilable	  [FE]  RuntimeException  	12	3	replace
118	[BUG]  [BUGGY]  return  n.getType()  ==  Token.RETURN  &&  labelName.equals(n.getLastChild().getString());  [FE]  RuntimeException  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return  n.getType()  ==  Token.RETURN  &&  labelName.equals(n.getLastChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return  n.getType()  ==  Token.RETURN  &&  labelName.equals(n.getLastChild().getString());	  return!n.hasChildren()    &&    labelName.equals(n.getLastChild().getString());    	compilable	  [FE]  RuntimeException  	12	3	replace
119	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  n  =  n.getFirstChild().getLastChild();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	add	n  =  n.getFirstChild().getLastChild();	      n    =    n.getFirstChild();    	compilable	  [FE]  AssertionFailedError  	18	3	replace
120	[BUG]  [BUGGY]  n  =  n.getFirstChild().getLastChild();  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  n  =  n.getFirstChild().getLastChild();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	n  =  n.getFirstChild().getLastChild();	      n    =    n.getFirstChild();    	compilable	  [FE]  AssertionFailedError  	18	3	replace
121	[BUG]  [BUGGY]      n  =  n.getFirstChild();  Integer  n  =  n.getFirstChild();  [CE]  variable  n  is  already  defined  in  method  matchingExitNode(Node,int,String)  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]      n  =  n.getFirstChild();  Integer  n  =  n.getFirstChild();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	        n    =    n.getFirstChild();    Integer  n  =  n.getFirstChild();	  	non-compiled	[CE]  variable  n  is  already  defined  in  method  matchingExitNode(Node,int,String)	17	None	add
122	[BUG]  [BUGGY]      n  =  n.getFirstChild();  (n  =  n.getFirstChild();  [CE]  ')'  expected  [FE]      AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]      n  =  n.getFirstChild();  (n  =  n.getFirstChild();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	        n    =    n.getFirstChild();    (n  =  n.getFirstChild();	  	non-compiled	[CE]  ')'  expected	17	None	add
123	[BUG]  [BUGGY]  String  labelName  =  n.getFirstChild().getLabelName();  [CE]  variable  labelName  is  already  defined  in  method  matchingExitNode(Node,int,String)  [FE]              AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  String  labelName  =  n.getFirstChild().getLabelName();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	String  labelName  =  n.getFirstChild().getLabelName();	      String    labelName    =    n.getFirstChild().getString();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  matchingExitNode(Node,int,String)	4	None	replace
124	[BUG]  [BUGGY]  return!labelName.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  [CE]  cannot  find  symbol  [FE]    RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!labelName.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!labelName.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());	  return!n.hasChildren()    ||    labelName.equals(n.getFirstChild().getString());    	non-compiled	[CE]  cannot  find  symbol	10	None	replace
125	[BUG]  [BUGGY]  n  =  n.getFirstChild()  ||  labelName.equals(n.getFirstChild().getString());  [CE]  bad  operand  types  for  binary  operator  '||'  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  n  =  n.getFirstChild()  ||  labelName.equals(n.getFirstChild().getString());  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	n  =  n.getFirstChild()  ||  labelName.equals(n.getFirstChild().getString());	      n    =    n.getFirstChild();    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '||'	18	None	replace
126	[BUG]  [BUGGY]  n  =  n.getFirstChild()  ||  labelName.equals(n.getLastChild());  [CE]  bad  operand  types  for  binary  operator  '||'  [FE]      AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  n  =  n.getFirstChild()  ||  labelName.equals(n.getLastChild());  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	n  =  n.getFirstChild()  ||  labelName.equals(n.getLastChild());	      n    =    n.getFirstChild();    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '||'	18	None	replace
127	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getLastChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	add	return!n.hasChildren()  &&!labelName.equals(n.getLastChild().getString());	  return!n.hasChildren()    &&!labelName.equals(n.getFirstChild().getString());    	compilable	  [FE]  AssertionFailedError  	14	3	replace
128	[BUG]  [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getLastChild().getString());  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getLastChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()  &&!labelName.equals(n.getLastChild().getString());	  return!n.hasChildren()    &&!labelName.equals(n.getFirstChild().getString());    	compilable	  [FE]  AssertionFailedError  	14	3	replace
129	[BUG]  [BUGGY]  return!n.hasChildren()  &&  LabelName.equals(n.getLastChild().getString());  [CE]  cannot  find  symbol  LabelName  [FE]        AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  LabelName.equals(n.getLastChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()  &&  LabelName.equals(n.getLastChild().getString());	  return!n.hasChildren()    &&    LabelName.equals(n.getFirstChild().getString());    	non-compiled	[CE]  cannot  find  symbol  LabelName	19	None	replace
130	[BUG]  [BUGGY]  &&  labelName.equals(n.getFirstChild().getString())||  labelName.equals(n.getLastChild().getString()))  {  return  false;  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  &&  labelName.equals(n.getFirstChild().getString())||  labelName.equals(n.getLastChild().getString()))  {  return  false;  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	&&  labelName.equals(n.getFirstChild().getString())||  labelName.equals(n.getLastChild().getString()))  {  return  false;	      &&    labelName.equals(n.getFirstChild().getString()))    {    return    true;    	non-compiled	[CE]  illegal  start  of  expression	3	None	replace
131	[BUG]  [BUGGY]  &&  labelName.equals(n.getFirstChild().getString())||  labelName.equals(n.getFirstChild().getString()))  {  return  false;  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  &&  labelName.equals(n.getFirstChild().getString())||  labelName.equals(n.getFirstChild().getString()))  {  return  false;  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	&&  labelName.equals(n.getFirstChild().getString())||  labelName.equals(n.getFirstChild().getString()))  {  return  false;	      &&    labelName.equals(n.getFirstChild().getString()))    {    return    true;    	non-compiled	[CE]  illegal  start  of  expression	3	None	replace
132	[BUG]  [BUGGY]  String  labelName  =  n.getFirstChild().getString()  + ": "  +  n.getLastChild();  [CE]  variable  labelName  is  already  defined  in  method  matchingExitNode(Node,int,String)  [FE]              AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  String  labelName  =  n.getFirstChild().getString()  + ": "  +  n.getLastChild();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	String  labelName  =  n.getFirstChild().getString()  + ": "  +  n.getLastChild();	      String    labelName    =    n.getFirstChild().getString();    	non-compiled	[CE]  variable  labelName  is  already  defined  in  method  matchingExitNode(Node,int,String)	4	None	replace
133	[BUG]  [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  if(labelName!=  null)  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  [CE]  unreachable  statement  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  if(labelName!=  null)  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&    labelName.equals(n.getFirstChild().getString());    if(labelName!=  null)  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }	  	non-compiled	[CE]  unreachable  statement	7	None	add
134	[BUG]  [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  if(labelName  ==  null)  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  [CE]  unreachable  statement  [FE]      AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  if(labelName  ==  null)  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&    labelName.equals(n.getFirstChild().getString());    if(labelName  ==  null)  {  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }	  	non-compiled	[CE]  unreachable  statement	7	None	add
135	[BUG]  [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  return!n.hasChildren()  &&  LabelName.equals(n.getFirstChild().getString());  [CE]  cannot  find  symbol  LabelName  [FE]        AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  return!n.hasChildren()  &&  LabelName.equals(n.getFirstChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&    labelName.equals(n.getFirstChild().getString());    return!n.hasChildren()  &&  LabelName.equals(n.getFirstChild().getString());	  	non-compiled	[CE]  cannot  find  symbol  LabelName	7	None	add
136	[BUG]  [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  Return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  [CE]  not  a  statement  [FE]          AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  Return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&    labelName.equals(n.getFirstChild().getString());    Return!n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());	  	non-compiled	[CE]  not  a  statement	7	None	add
137	[BUG]  [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  if(labelName  ==  null)  {  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  }  [CE]  unreachable  statement  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  if(labelName  ==  null)  {  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  }  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&    labelName.equals(n.getLastChild().getString());    if(labelName  ==  null)  {  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  }	  	non-compiled	[CE]  unreachable  statement	11	None	add
138	[BUG]  [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  return!n.hasChildren()  &&  LabelName.equals(n.getLastChild().getString());  [CE]  cannot  find  symbol  LabelName  [FE]      AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  return!n.hasChildren()  &&  LabelName.equals(n.getLastChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&    labelName.equals(n.getLastChild().getString());    return!n.hasChildren()  &&  LabelName.equals(n.getLastChild().getString());	  	non-compiled	[CE]  cannot  find  symbol  LabelName	11	None	add
139	[BUG]  [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  Return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  [CE]  not  a  statement  [FE]        AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  Return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&    labelName.equals(n.getLastChild().getString());    Return!n.hasChildren()  &&  labelName.equals(n.getLastChild().getString());	  	non-compiled	[CE]  not  a  statement	11	None	add
140	[BUG]  [BUGGY]  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  labelName  =  n.getFirstChild().getString()  + ": "  +  n.getLastChild();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	add	labelName  =  n.getFirstChild().getString()  + ": "  +  n.getLastChild();	      labelName    =    n.getFirstChild().getString();    	compilable	  [FE]  RuntimeException  	16	3	replace
141	[BUG]  [BUGGY]  labelName  =  n.getFirstChild().getString()  + ": "  +  n.getLastChild();  [FE]  RuntimeException  [FE]    RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  labelName  =  n.getFirstChild().getString()  + ": "  +  n.getLastChild();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	labelName  =  n.getFirstChild().getString()  + ": "  +  n.getLastChild();	      labelName    =    n.getFirstChild().getString();    	compilable	  [FE]  RuntimeException  	16	3	replace
142	[BUG]  [BUGGY]  &&  labelName.equals(n.getString()))  {  return  true;  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  &&  labelName.equals(n.getString()))  {  return  true;  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	&&  labelName.equals(n.getString()))  {  return  true;	      &&    labelName.equals(n.getFirstChild().getString()))    {    return    false;    	non-compiled	[CE]  illegal  start  of  expression	5	None	replace
143	[BUG]  [BUGGY]  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  if(!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  [CE]  ')'  expected  [FE]    RuntimeException    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  if(!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    ||    labelName.equals(n.getFirstChild().getString());    if(!n.hasChildren()  ||  labelName.equals(n.getFirstChild().getString());	  	non-compiled	[CE]  ')'  expected	9	None	add
144	[BUG]  [BUGGY]  &&  labelName.equals(n.getFirstChild().getQualifiedName());  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  &&  labelName.equals(n.getFirstChild().getQualifiedName());  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	&&  labelName.equals(n.getFirstChild().getQualifiedName());	      &&    labelName.equals(n.getFirstChild().getString());    	non-compiled	[CE]  illegal  start  of  expression	2	None	replace
145	[BUG]  [BUGGY]  LabelName  labelName  =  n.getFirstChild().getLastChild();  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  LabelName  labelName  =  n.getFirstChild().getLastChild();  [BUGGY]    return  !n.hasChildren();  }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	LabelName  labelName  =  n.getFirstChild().getLastChild();	      LabelName    labelName    =    n.getFirstChild().getString();    	non-compiled	[CE]  cannot  find  symbol	1	None	replace
146	[BUG]  [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  if(labelName  ==  null)  {  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  }  [CE]  unreachable  statement  [FE]    AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  if(labelName  ==  null)  {  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  }  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&!labelName.equals(n.getFirstChild().getString());    if(labelName  ==  null)  {  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  }	  	non-compiled	[CE]  unreachable  statement	13	None	add
147	[BUG]  [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  return!n.hasChildren()  &&! "labelName.equals(n.getFirstChild().getString());  [CE]  unclosed  string  literal  [FE]      AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  return!n.hasChildren()  &&! "labelName.equals(n.getFirstChild().getString());  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&!labelName.equals(n.getFirstChild().getString());    return!n.hasChildren()  &&! "labelName.equals(n.getFirstChild().getString());	  	non-compiled	[CE]  unclosed  string  literal	13	None	add
148	[BUG]  [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  if(!n.hasChildren())  {  return!labelName.equals(n.getFirstChild().getString());  }  [CE]  unreachable  statement  [FE]        AssertionFailedError    [CONTEXT]    private  static  boolean  matchingExitNode(Node  n,  int  type,  String  labelName)  {  if  (n.getType()  ==  type)  {  if  (type  ==  Token.RETURN)  {      [BUGGY]  return!n.hasChildren()  &&!labelName.equals(n.getFirstChild().getString());  if(!n.hasChildren())  {  return!labelName.equals(n.getFirstChild().getString());  }  [BUGGY]    }  else  {  if  (labelName  ==  null)  {  return  !n.hasChildren();  }  else  {  return  n.hasChildren()  &&  labelName.equals(n.getFirstChild().getString());  }  }  }  return  false;  [CLASS]  MinimizeExitPoints  [METHOD]  matchingExitNode  [RETURN_TYPE]  boolean  Node  n  int  type  String  labelName  [VARIABLES]  AbstractCompiler  compiler  String  labelName  boolean  int  type  Node  n  	projects/Closure126/src/com/google/javascript/jscomp/MinimizeExitPoints.java	0.8164965809277261	280	280	2	replace	return!n.hasChildren()    &&!labelName.equals(n.getFirstChild().getString());    if(!n.hasChildren())  {  return!labelName.equals(n.getFirstChild().getString());  }	  	non-compiled	[CE]  unreachable  statement	13	None	add
