bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  n  =  scope.getLastChild();  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  scope.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  scope.getLastChild();	  n    =    scope.getFirstChild();    	non-compiled	[CE]  orphaned  case	124	None	replace
2	[BUG]  [BUGGY]  n  =  scope.getParent();  [CE]  orphaned  case  [FE]                                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  scope.getParent();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  scope.getParent();	  n    =    scope.getFirstChild();    	non-compiled	[CE]  orphaned  case	124	None	replace
3	[BUG]  [BUGGY]  n  =  scope.getNext();  [CE]  orphaned  case  [FE]                                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  scope.getNext();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  scope.getNext();	  n    =    scope.getFirstChild();    	non-compiled	[CE]  orphaned  case	124	None	replace
4	[BUG]  [BUGGY]  n  =  scope.getLocalPart();  [CE]  orphaned  case  [FE]                                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  scope.getLocalPart();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  scope.getLocalPart();	  n    =    scope.getFirstChild();    	non-compiled	[CE]  orphaned  case	124	None	replace
5	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  &&  n.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  &&  n.getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  &&  n.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	72	None	replace
6	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  n.getType()!=  Token.FUNCTION);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  n.getType()!=  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  ||  n.getType()!=  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	72	None	replace
7	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getType()  ==  Token.VAR);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	72	None	replace
8	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.VAR  ||  n.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()!=  Token.VAR  ||  n.getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()!=  Token.VAR  ||  n.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	72	None	replace
9	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.VAR  ||  parent.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.VAR  ||  parent.getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.VAR  ||  parent.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	72	None	replace
10	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.VAR  &&  n.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()!=  Token.VAR  &&  n.getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()!=  Token.VAR  &&  n.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	72	None	replace
11	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR  ||  scope.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR  ||  scope.getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()  ==  Token.VAR  ||  scope.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	72	None	replace
12	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getLastChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getLastChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent.getLastChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getLastChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	92	None	replace
13	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getLastChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getLastChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getLastChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getLastChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	92	None	replace
14	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  parent.getLastChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  parent.getLastChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  parent.getLastChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getLastChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	92	None	replace
15	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  node.getLastChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  node.getLastChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  node.getLastChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getLastChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	92	None	replace
16	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getLastChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getLastChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  n.getLastChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getLastChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	92	None	replace
17	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  type  ==  Token.NAME,  scope);  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  type  ==  Token.NAME,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  ||  type  ==  Token.NAME,  scope);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	232	None	replace
18	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  &&  type  ==  Token.NAME);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  &&  type  ==  Token.NAME);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  &&  type  ==  Token.NAME);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	232	None	replace
19	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.NAME  ||  type  ==  Token.VAR);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.NAME  ||  type  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.NAME  ||  type  ==  Token.VAR);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	232	None	replace
20	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.VAR  ||  type  ==  Token.NAME);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.VAR  ||  type  ==  Token.NAME);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.VAR  ||  type  ==  Token.NAME);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	232	None	replace
21	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.VAR  ||  type  ==  Token.NAME);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()!=  Token.VAR  ||  type  ==  Token.NAME);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()!=  Token.VAR  ||  type  ==  Token.NAME);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	232	None	replace
22	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  type  ==  Token.NAME,  parent);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  type  ==  Token.NAME,  parent);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  ||  type  ==  Token.NAME,  parent);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	232	None	replace
23	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  type!=  Token.NAME);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  type!=  Token.NAME);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  ||  type!=  Token.NAME);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	232	None	replace
24	[BUG]  [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)&&  NodeUtil.isExpressionNode(parent))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)&&  NodeUtil.isExpressionNode(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isConstructorDeclaration(n)&&  NodeUtil.isExpressionNode(parent))  {	  if(NodeUtil.isConstructorDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	78	None	replace
25	[BUG]  [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isConstructorDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	78	None	replace
26	[BUG]  [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isConstructorDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	78	None	replace
27	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  NodeUtil.isConstructorDeclaration(n))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  NodeUtil.isConstructorDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)||  NodeUtil.isConstructorDeclaration(n))  {	  if(NodeUtil.isConstructorDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	78	None	replace
28	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isExpressionNode(parent))  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isExpressionNode(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  NodeUtil.isExpressionNode(parent))  {	  if(NodeUtil.isConstructorDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	78	None	replace
29	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)&&  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isAssignmentOp(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	38	None	replace
30	[BUG]  [BUGGY]  if(NodeUtil.isFunctionAnswer(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionAnswer(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionAnswer(n)&&  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isAssignmentOp(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	38	None	replace
31	[BUG]  [BUGGY]  if(NodeUtil.isFunctionAnonymous(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionAnonymous(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionAnonymous(n)&&  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isAssignmentOp(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	38	None	replace
32	[BUG]  [BUGGY]  if(NodeUtil.isFunction(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunction(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunction(n)&&  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isAssignmentOp(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	38	None	replace
33	[BUG]  [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	22	None	replace
34	[BUG]  [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	22	None	replace
35	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	22	None	replace
36	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	22	None	replace
37	[BUG]  [BUGGY]  if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	22	None	replace
38	[BUG]  [BUGGY]  if(scope  ==  null  &&  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope  ==  null  &&  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope  ==  null  &&  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	22	None	replace
39	[BUG]  [BUGGY]  if(scope!=  null  &&  nodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  nodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  nodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	22	None	replace
40	[BUG]  [BUGGY]  Node  c  =  parent.getParent();  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  parent.getParent();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  parent.getParent();	  Node    c    =    n.getParent();    	non-compiled	[CE]  orphaned  case	66	None	replace
41	[BUG]  [BUGGY]  Node  c  =  parent.getNext();  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  parent.getNext();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  parent.getNext();	  Node    c    =    n.getParent();    	non-compiled	[CE]  orphaned  case	66	None	replace
42	[BUG]  [BUGGY]  Node  c  =  n.getPreviousChild();  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.getPreviousChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getPreviousChild();	  Node    c    =    n.getParent();    	non-compiled	[CE]  orphaned  case	66	None	replace
43	[BUG]  [BUGGY]  Node  c  =  n.getCurrentParent();  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.getCurrentParent();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getCurrentParent();	  Node    c    =    n.getParent();    	non-compiled	[CE]  orphaned  case	66	None	replace
44	[BUG]  [BUGGY]  n  =  parent.getNext();  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  parent.getNext();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  parent.getNext();	  n    =    n.getNext();    	non-compiled	[CE]  orphaned  case	123	None	replace
45	[BUG]  [BUGGY]  n  =  n.getNext()  ||  parent.getType()  ==  Token.FUNCTION;  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.getNext()  ||  parent.getType()  ==  Token.FUNCTION;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getNext()  ||  parent.getType()  ==  Token.FUNCTION;	  n    =    n.getNext();    	non-compiled	[CE]  orphaned  case	123	None	replace
46	[BUG]  [BUGGY]  n  =  n.getNext()  ||  type  ==  Token.FUNCTION;  [CE]  orphaned  case  [FE]                                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.getNext()  ||  type  ==  Token.FUNCTION;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getNext()  ||  type  ==  Token.FUNCTION;	  n    =    n.getNext();    	non-compiled	[CE]  orphaned  case	123	None	replace
47	[BUG]  [BUGGY]  n  =  n.getNext()  ||  parent.getType()!=  Token.FUNCTION;  [CE]  orphaned  case  [FE]                                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.getNext()  ||  parent.getType()!=  Token.FUNCTION;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getNext()  ||  parent.getType()!=  Token.FUNCTION;	  n    =    n.getNext();    	non-compiled	[CE]  orphaned  case	123	None	replace
48	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(scope))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(parent))    {    	non-compiled	[CE]  	286	None	replace
49	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(parent))    {    	non-compiled	[CE]  	286	None	replace
50	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  NodeUtil.mayHaveSideEffects(parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  NodeUtil.mayHaveSideEffects(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  NodeUtil.mayHaveSideEffects(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(parent))    {    	non-compiled	[CE]  	286	None	replace
51	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(parent))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(parent))    {    	non-compiled	[CE]  	286	None	replace
52	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  NodeUtil.mayHaveSideEffects(scope))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  NodeUtil.mayHaveSideEffects(scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  NodeUtil.mayHaveSideEffects(scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(parent))    {    	non-compiled	[CE]  	286	None	replace
53	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(parent))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(parent))    {    	non-compiled	[CE]  	286	None	replace
54	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(type))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(type))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(type))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(parent))    {    	non-compiled	[CE]  	286	None	replace
55	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.mayHaveSideEffects(scope))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.mayHaveSideEffects(scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.mayHaveSideEffects(scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(parent))    {    	non-compiled	[CE]  	286	None	replace
56	[BUG]  [BUGGY]  Preconditions.checkState(type!=  Token.FUNCTION  ||  type  ==  Token.VAR);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type!=  Token.FUNCTION  ||  type  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type!=  Token.FUNCTION  ||  type  ==  Token.VAR);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	107	None	replace
57	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  &&  type  ==  Token.VAR);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  &&  type  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  &&  type  ==  Token.VAR);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	107	None	replace
58	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type!=  Token.VAR);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type!=  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type!=  Token.VAR);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	107	None	replace
59	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.VAR,  scope);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.VAR,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.VAR,  scope);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	107	None	replace
60	[BUG]  [BUGGY]  Preconditions.checkArgument(type  ==  Token.FUNCTION  ||  type  ==  Token.VAR);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(type  ==  Token.FUNCTION  ||  type  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(type  ==  Token.FUNCTION  ||  type  ==  Token.VAR);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	107	None	replace
61	[BUG]  [BUGGY]  Preconditions.checkState(type  >=  Token.FUNCTION  ||  type  ==  Token.VAR);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  >=  Token.FUNCTION  ||  type  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  >=  Token.FUNCTION  ||  type  ==  Token.VAR);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	107	None	replace
62	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getType()  ==  Token.VAR)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	159	None	replace
63	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.VAR)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	159	None	replace
64	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR  ||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR  ||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR  ||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	159	None	replace
65	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()!=  Token.VAR)  {  [CE]  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()!=  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()!=  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	159	None	replace
66	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  parent.getType()  ==  Token.VAR)  {  [CE]  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  parent.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  parent.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	159	None	replace
67	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getType()!=  Token.VAR)  {  [CE]  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getType()!=  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getType()!=  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	159	None	replace
68	[BUG]  [BUGGY]  if(NodeUtil.isName(parent)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(parent)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(parent)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isName(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	199	None	replace
69	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isName(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	199	None	replace
70	[BUG]  [BUGGY]  Node  n  =  getFunctionScope().getParent();  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  getFunctionScope().getParent();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  getFunctionScope().getParent();	  Node    n    =    getFunctionScope().getFirstChild();    	non-compiled	[CE]  orphaned  case	273	None	replace
71	[BUG]  [BUGGY]  Node  n  =  getFunctionScope().getLastChild();  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  getFunctionScope().getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  getFunctionScope().getLastChild();	  Node    n    =    getFunctionScope().getFirstChild();    	non-compiled	[CE]  orphaned  case	273	None	replace
72	[BUG]  [BUGGY]  Node  n  =  getFunctionScope().getNativeType(UNKNOWN_TYPE);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  getFunctionScope().getNativeType(UNKNOWN_TYPE);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  getFunctionScope().getNativeType(UNKNOWN_TYPE);	  Node    n    =    getFunctionScope().getFirstChild();    	non-compiled	[CE]  orphaned  case	273	None	replace
73	[BUG]  [BUGGY]  Node  n  =  getFunctionScope().getOwnScope();  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  getFunctionScope().getOwnScope();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  getFunctionScope().getOwnScope();	  Node    n    =    getFunctionScope().getFirstChild();    	non-compiled	[CE]  orphaned  case	273	None	replace
74	[BUG]  [BUGGY]  Node  n  =  getFunctionScope().getNext();  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  getFunctionScope().getNext();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  getFunctionScope().getNext();	  Node    n    =    getFunctionScope().getFirstChild();    	non-compiled	[CE]  orphaned  case	273	None	replace
75	[BUG]  [BUGGY]  Node  n  =  getFunctionScope().getVar(n.getFirstChild());  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  getFunctionScope().getVar(n.getFirstChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  getFunctionScope().getVar(n.getFirstChild());	  Node    n    =    getFunctionScope().getFirstChild();    	non-compiled	[CE]  orphaned  case	273	None	replace
76	[BUG]  [BUGGY]  Node  n  =  getFunctionScope().getCurrentNode();  [CE]  orphaned  case  [FE]                                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  getFunctionScope().getCurrentNode();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  getFunctionScope().getCurrentNode();	  Node    n    =    getFunctionScope().getFirstChild();    	non-compiled	[CE]  orphaned  case	273	None	replace
77	[BUG]  [BUGGY]  var  =  scope.getVar(n.getString(),  type);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getString(),  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getString(),  type);	  var    =    scope.getVar(n.getString());    	non-compiled	[CE]  orphaned  case	105	None	replace
78	[BUG]  [BUGGY]  var  =  scope.getVar(n.getString()  +  1);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getString()  +  1);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getString()  +  1);	  var    =    scope.getVar(n.getString());    	non-compiled	[CE]  orphaned  case	105	None	replace
79	[BUG]  [BUGGY]  var  =  scope.getVar(n.getString(),  parent);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getString(),  parent);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getString(),  parent);	  var    =    scope.getVar(n.getString());    	non-compiled	[CE]  orphaned  case	105	None	replace
80	[BUG]  [BUGGY]  var  =  scope.getVar(n.getString(),  n.getLastChild());  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getString(),  n.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getString(),  n.getLastChild());	  var    =    scope.getVar(n.getString());    	non-compiled	[CE]  orphaned  case	105	None	replace
81	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  &&!NodeUtil.isFunctionDeclaration(n));  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  &&!NodeUtil.isFunctionDeclaration(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  &&!NodeUtil.isFunctionDeclaration(n));	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||!NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	202	None	replace
82	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(parent));  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(parent));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(parent));	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||!NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	202	None	replace
83	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n));  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n));	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||!NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	202	None	replace
84	[BUG]  [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(n));  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()!=  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(n));	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||!NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	202	None	replace
85	[BUG]  [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(n));  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(parent.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(n));	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||!NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	202	None	replace
86	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  node.getFirstChild().getString().equals( "function "));  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  node.getFirstChild().getString().equals( "function "));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  node.getFirstChild().getString().equals( "function "));	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||!NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	202	None	replace
87	[BUG]  [BUGGY]  Preconditions.checkState(type!=  Token.FUNCTION  ||  type  ==  Token.SCRIPT);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type!=  Token.FUNCTION  ||  type  ==  Token.SCRIPT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type!=  Token.FUNCTION  ||  type  ==  Token.SCRIPT);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.SCRIPT);    	non-compiled	[CE]  orphaned  case	169	None	replace
88	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type!=  Token.SCRIPT);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type!=  Token.SCRIPT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type!=  Token.SCRIPT);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.SCRIPT);    	non-compiled	[CE]  orphaned  case	169	None	replace
89	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  &&  type  ==  Token.SCRIPT);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  &&  type  ==  Token.SCRIPT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  &&  type  ==  Token.SCRIPT);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.SCRIPT);    	non-compiled	[CE]  orphaned  case	169	None	replace
90	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.SCRIPT,  scope);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.SCRIPT,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.SCRIPT,  scope);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.SCRIPT);    	non-compiled	[CE]  orphaned  case	169	None	replace
91	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.SCRIPT);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.SCRIPT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.SCRIPT);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.SCRIPT);    	non-compiled	[CE]  orphaned  case	169	None	replace
92	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.SCRIPT,  n);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.SCRIPT,  n);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.SCRIPT,  n);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.SCRIPT);    	non-compiled	[CE]  orphaned  case	169	None	replace
93	[BUG]  [BUGGY]  Preconditions.checkState(type  >=  Token.FUNCTION  ||  type  ==  Token.SCRIPT);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  >=  Token.FUNCTION  ||  type  ==  Token.SCRIPT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  >=  Token.FUNCTION  ||  type  ==  Token.SCRIPT);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.SCRIPT);    	non-compiled	[CE]  orphaned  case	169	None	replace
94	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  type!=  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  type!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  type!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type!=    Token.FUNCTION)    {    	non-compiled	[CE]  	54	None	replace
95	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  type!=  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  type!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  type!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type!=    Token.FUNCTION)    {    	non-compiled	[CE]  	54	None	replace
96	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  type!=  Token.FUNCTION)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  type!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  type!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type!=    Token.FUNCTION)    {    	non-compiled	[CE]  	54	None	replace
97	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  type!=  Token.FUNCTION)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  type!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  type!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type!=    Token.FUNCTION)    {    	non-compiled	[CE]  	54	None	replace
98	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.VAR)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type!=    Token.FUNCTION)    {    	non-compiled	[CE]  	54	None	replace
99	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)&&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isVar(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	132	None	replace
100	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isVar(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	132	None	replace
101	[BUG]  [BUGGY]  if(NodeUtil.isVar(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(parent)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isVar(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	132	None	replace
102	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isVar(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	132	None	replace
103	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	56	None	replace
104	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  &&  parent.getType()  ==  Token.VAR)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  &&  parent.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  &&  parent.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	56	None	replace
105	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  parent.getType()!=  Token.VAR)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  parent.getType()!=  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  parent.getType()!=  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	56	None	replace
106	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR)  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	56	None	replace
107	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR)  {  [CE]  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	56	None	replace
108	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR)  {  [CE]  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	56	None	replace
109	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  type  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR)  {  [CE]  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  type  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  type  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	56	None	replace
110	[BUG]  [BUGGY]  Preconditions.checkState(type!=  Token.FUNCTION  ||  type  ==  Token.GETPROP);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type!=  Token.FUNCTION  ||  type  ==  Token.GETPROP);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type!=  Token.FUNCTION  ||  type  ==  Token.GETPROP);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.GETPROP);    	non-compiled	[CE]  orphaned  case	170	None	replace
111	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  &&  type  ==  Token.GETPROP);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  &&  type  ==  Token.GETPROP);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  &&  type  ==  Token.GETPROP);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.GETPROP);    	non-compiled	[CE]  orphaned  case	170	None	replace
112	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type!=  Token.GETPROP);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type!=  Token.GETPROP);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type!=  Token.GETPROP);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.GETPROP);    	non-compiled	[CE]  orphaned  case	170	None	replace
113	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.GETPROP,  scope);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.GETPROP,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.GETPROP,  scope);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.GETPROP);    	non-compiled	[CE]  orphaned  case	170	None	replace
114	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.GETPROP);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.GETPROP);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.GETPROP);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.GETPROP);    	non-compiled	[CE]  orphaned  case	170	None	replace
115	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.GETPROP,  n);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.GETPROP,  n);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.GETPROP,  n);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.GETPROP);    	non-compiled	[CE]  orphaned  case	170	None	replace
116	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.GETPROP  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.GETPROP  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.GETPROP  ||  type  ==  Token.FUNCTION);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.GETPROP);    	non-compiled	[CE]  orphaned  case	170	None	replace
117	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  type  ==  Token.FUNCTION)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)&&  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(parent)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	57	None	replace
118	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(parent)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	57	None	replace
119	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent  ==  null  ||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent  ==  null  ||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent  ==  null  ||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(parent)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	57	None	replace
120	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(parent)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	57	None	replace
121	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(parent)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	57	None	replace
122	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(parent)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	57	None	replace
123	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getFirstChild().getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	24	None	replace
124	[BUG]  [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getFirstChild().getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	24	None	replace
125	[BUG]  [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getFirstChild().getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	24	None	replace
126	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getFirstChild().getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	24	None	replace
127	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getLastChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getLastChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getLastChild().getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getFirstChild().getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	24	None	replace
128	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild().getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getFirstChild().getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	24	None	replace
129	[BUG]  [BUGGY]  if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getFirstChild().getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	24	None	replace
130	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isExpressionNode(n)||  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isExpressionNode(n)||  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isExpressionNode(n)||  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getFirstChild().getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	24	None	replace
131	[BUG]  [BUGGY]  Node  node  =  n.getLastChild();  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  node  =  n.getLastChild();  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  node  =  n.getLastChild();	  Node    node    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	140	None	replace
132	[BUG]  [BUGGY]  Node  node  =  parent.getFirstChild();  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  node  =  parent.getFirstChild();  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  node  =  parent.getFirstChild();	  Node    node    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	140	None	replace
133	[BUG]  [BUGGY]  Node  node  =  n.getNext();  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  node  =  n.getNext();  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  node  =  n.getNext();	  Node    node    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	140	None	replace
134	[BUG]  [BUGGY]  Node  node  =  scope.getFirstChild();  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  node  =  scope.getFirstChild();  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  node  =  scope.getFirstChild();	  Node    node    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	140	None	replace
135	[BUG]  [BUGGY]  Node  node  =  nameNode.getFirstChild();  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  node  =  nameNode.getFirstChild();  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  node  =  nameNode.getFirstChild();	  Node    node    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	140	None	replace
136	[BUG]  [BUGGY]  Node  node  =  n.getPreviousChild();  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  node  =  n.getPreviousChild();  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  node  =  n.getPreviousChild();	  Node    node    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	140	None	replace
137	[BUG]  [BUGGY]  Node  node  =  n.getParent();  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  node  =  n.getParent();  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  node  =  n.getParent();	  Node    node    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	140	None	replace
138	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  n.getLastChild()  :  n.getString();  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  n.getLastChild()  :  n.getString();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()!=  null)?  n.getLastChild()  :  n.getString();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n.getString();    	non-compiled	[CE]  orphaned  case	258	None	replace
139	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  parent.getLastChild()  :  n.getString();  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  parent.getLastChild()  :  n.getString();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()  ==  null)?  parent.getLastChild()  :  n.getString();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n.getString();    	non-compiled	[CE]  orphaned  case	258	None	replace
140	[BUG]  [BUGGY]  Node  scope  =(n.getLastChild()  ==  null)?  n.getFirstChild()  :  n.getString();  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getLastChild()  ==  null)?  n.getFirstChild()  :  n.getString();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getLastChild()  ==  null)?  n.getFirstChild()  :  n.getString();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n.getString();    	non-compiled	[CE]  orphaned  case	258	None	replace
141	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  parent.getLastChild()  :  n.getString();  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  parent.getLastChild()  :  n.getString();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()!=  null)?  parent.getLastChild()  :  n.getString();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n.getString();    	non-compiled	[CE]  orphaned  case	258	None	replace
142	[BUG]  [BUGGY]  Node  scope  =(n.getLastChild()  ==  null)?  n.getLastChild()  :  n.getString();  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getLastChild()  ==  null)?  n.getLastChild()  :  n.getString();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getLastChild()  ==  null)?  n.getLastChild()  :  n.getString();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n.getString();    	non-compiled	[CE]  orphaned  case	258	None	replace
143	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  parent.getString();  [CE]  orphaned  case  [FE]                                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  parent.getString();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  parent.getString();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n.getString();    	non-compiled	[CE]  orphaned  case	258	None	replace
144	[BUG]  [BUGGY]  Node  scope  =  n.getFirstChild()  ==  null?  n.getLastChild()  :  n.getString();  [CE]  orphaned  case  [FE]                                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  n.getFirstChild()  ==  null?  n.getLastChild()  :  n.getString();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  n.getFirstChild()  ==  null?  n.getLastChild()  :  n.getString();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n.getString();    	non-compiled	[CE]  orphaned  case	258	None	replace
145	[BUG]  [BUGGY]  Node  var  =  parent.removeFirstChild();  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  parent.removeFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  parent.removeFirstChild();	  Node    var    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	254	None	replace
146	[BUG]  [BUGGY]  Node  var  =  scope.removeFirstChild();  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  scope.removeFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.removeFirstChild();	  Node    var    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	254	None	replace
147	[BUG]  [BUGGY]  Node  var  =  node.removeFirstChild();  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  node.removeFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  node.removeFirstChild();	  Node    var    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	254	None	replace
148	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	164	None	replace
149	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)&&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	164	None	replace
150	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	164	None	replace
151	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	164	None	replace
152	[BUG]  [BUGGY]  if(NodeUtil.isName(n)&&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)&&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)&&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	164	None	replace
153	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)&&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)&&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)&&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	164	None	replace
154	[BUG]  [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(parent!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	27	None	replace
155	[BUG]  [BUGGY]  if(n  ==  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n  ==  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n  ==  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(parent!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	27	None	replace
156	[BUG]  [BUGGY]  if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(parent!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	27	None	replace
157	[BUG]  [BUGGY]  if(n  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(parent!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	27	None	replace
158	[BUG]  [BUGGY]  if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild().getType()  ==  Token.FUNCTION)  {	  if(parent!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	27	None	replace
159	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	46	None	replace
160	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	46	None	replace
161	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	46	None	replace
162	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION,  scope);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION,  scope);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	46	None	replace
163	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.FUNCTION);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	46	None	replace
164	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	46	None	replace
165	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	46	None	replace
166	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild().getString().equals( "function "))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild().getString().equals( "function "))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild().getString().equals( "function "))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    n.getFirstChild().getString().equals(   "function   "))    {    	non-compiled	[CE]  	284	None	replace
167	[BUG]  [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getString().equals( "function "))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getString().equals( "function "))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getString().equals( "function "))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    n.getFirstChild().getString().equals(   "function   "))    {    	non-compiled	[CE]  	284	None	replace
168	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild().getString().equals( "function "))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild().getString().equals( "function "))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild().getString().equals( "function "))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    n.getFirstChild().getString().equals(   "function   "))    {    	non-compiled	[CE]  	284	None	replace
169	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild().getString().equals( "function "))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild().getString().equals( "function "))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild().getString().equals( "function "))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    n.getFirstChild().getString().equals(   "function   "))    {    	non-compiled	[CE]  	284	None	replace
170	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getLastChild().getString().equals( "function "))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getLastChild().getString().equals( "function "))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getLastChild().getString().equals( "function "))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    n.getFirstChild().getString().equals(   "function   "))    {    	non-compiled	[CE]  	284	None	replace
171	[BUG]  [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getString().equals( "function "))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getString().equals( "function "))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getString().equals( "function "))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    n.getFirstChild().getString().equals(   "function   "))    {    	non-compiled	[CE]  	284	None	replace
172	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	52	None	replace
173	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.VAR)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	52	None	replace
174	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  type  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	52	None	replace
175	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  type!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	52	None	replace
176	[BUG]  [BUGGY]  Node  n  =  scope.getNext();  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  scope.getNext();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  scope.getNext();	  Node    n    =    scope.getParent();    	non-compiled	[CE]  orphaned  case	4	None	replace
177	[BUG]  [BUGGY]  Node  scope  =  parent.removeFirstChild();  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  parent.removeFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  parent.removeFirstChild();	  Node    scope    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	201	None	replace
178	[BUG]  [BUGGY]  Node  scope  =  n.removeLastChild();  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  n.removeLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  n.removeLastChild();	  Node    scope    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	201	None	replace
179	[BUG]  [BUGGY]  Node  scope  =  parent.replaceChild(n,  scope);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  parent.replaceChild(n,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  parent.replaceChild(n,  scope);	  Node    scope    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	201	None	replace
180	[BUG]  [BUGGY]  Node  scope  =  node.removeFirstChild();  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  node.removeFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  node.removeFirstChild();	  Node    scope    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	201	None	replace
181	[BUG]  [BUGGY]  Node  scope  =  getFunctionScope().getLastChild();  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  getFunctionScope().getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getFunctionScope().getLastChild();	  Node    scope    =    getFunctionScope().getFirstChild();    	non-compiled	[CE]  orphaned  case	216	None	replace
182	[BUG]  [BUGGY]  Node  scope  =  getFunctionScope().getParent();  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  getFunctionScope().getParent();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getFunctionScope().getParent();	  Node    scope    =    getFunctionScope().getFirstChild();    	non-compiled	[CE]  orphaned  case	216	None	replace
183	[BUG]  [BUGGY]  Node  scope  =  getFunctionScope().getOwnScope();  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  getFunctionScope().getOwnScope();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getFunctionScope().getOwnScope();	  Node    scope    =    getFunctionScope().getFirstChild();    	non-compiled	[CE]  orphaned  case	216	None	replace
184	[BUG]  [BUGGY]  Node  scope  =  getFunctionScope().getString();  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  getFunctionScope().getString();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getFunctionScope().getString();	  Node    scope    =    getFunctionScope().getFirstChild();    	non-compiled	[CE]  orphaned  case	216	None	replace
185	[BUG]  [BUGGY]  Node  scope  =  getFunctionScope().getNext();  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  getFunctionScope().getNext();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getFunctionScope().getNext();	  Node    scope    =    getFunctionScope().getFirstChild();    	non-compiled	[CE]  orphaned  case	216	None	replace
186	[BUG]  [BUGGY]  Node  scope  =  getFunctionScope().getRootNode();  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  getFunctionScope().getRootNode();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getFunctionScope().getRootNode();	  Node    scope    =    getFunctionScope().getFirstChild();    	non-compiled	[CE]  orphaned  case	216	None	replace
187	[BUG]  [BUGGY]  Node  scope  =  getFunctionScope().getCurrentNode();  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  getFunctionScope().getCurrentNode();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getFunctionScope().getCurrentNode();	  Node    scope    =    getFunctionScope().getFirstChild();    	non-compiled	[CE]  orphaned  case	216	None	replace
188	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isExpressionNode(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	75	None	replace
189	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.CALL);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.CALL);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.CALL);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.CALL);    	non-compiled	[CE]  orphaned  case	205	None	replace
190	[BUG]  [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.CALL);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.CALL);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.CALL);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.CALL);    	non-compiled	[CE]  orphaned  case	205	None	replace
191	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.CALL);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.CALL);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.CALL);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.CALL);    	non-compiled	[CE]  orphaned  case	205	None	replace
192	[BUG]  [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.CALL);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.CALL);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.CALL);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.CALL);    	non-compiled	[CE]  orphaned  case	205	None	replace
193	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.CALL);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.CALL);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.CALL);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.CALL);    	non-compiled	[CE]  orphaned  case	205	None	replace
194	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.GETPROP);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.GETPROP);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.GETPROP);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.CALL);    	non-compiled	[CE]  orphaned  case	205	None	replace
195	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	275	None	replace
196	[BUG]  [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	275	None	replace
197	[BUG]  [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	275	None	replace
198	[BUG]  [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	275	None	replace
199	[BUG]  [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	275	None	replace
200	[BUG]  [BUGGY]  if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	275	None	replace
201	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION,  scope);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION,  scope);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	110	None	replace
202	[BUG]  [BUGGY]  Preconditions.checkState(type!=  Token.FUNCTION  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type!=  Token.FUNCTION  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type!=  Token.FUNCTION  ||  type  ==  Token.FUNCTION);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	110	None	replace
203	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  &&  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  &&  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  &&  type  ==  Token.FUNCTION);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	110	None	replace
204	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type!=  Token.FUNCTION);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type!=  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type!=  Token.FUNCTION);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	110	None	replace
205	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION;  [CE]  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION;	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.FUNCTION);    	non-compiled	[CE]  	110	None	replace
206	[BUG]  [BUGGY]  Node  scope  =  getFunctionScope(parent.getLastChild());  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  getFunctionScope(parent.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getFunctionScope(parent.getLastChild());	  Node    scope    =    getFunctionScope(n.getLastChild());    	non-compiled	[CE]  orphaned  case	136	None	replace
207	[BUG]  [BUGGY]  Node  scope  =  getFunctionScope(n,  parent.getLastChild());  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  getFunctionScope(n,  parent.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getFunctionScope(n,  parent.getLastChild());	  Node    scope    =    getFunctionScope(n.getLastChild());    	non-compiled	[CE]  orphaned  case	136	None	replace
208	[BUG]  [BUGGY]  Node  scope  =  getFunctionScope(n.getLastChild(),  parent);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  getFunctionScope(n.getLastChild(),  parent);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getFunctionScope(n.getLastChild(),  parent);	  Node    scope    =    getFunctionScope(n.getLastChild());    	non-compiled	[CE]  orphaned  case	136	None	replace
209	[BUG]  [BUGGY]  Node  scope  =  getFunctionScope(n.getLastChild(),  type);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  getFunctionScope(n.getLastChild(),  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getFunctionScope(n.getLastChild(),  type);	  Node    scope    =    getFunctionScope(n.getLastChild());    	non-compiled	[CE]  orphaned  case	136	None	replace
210	[BUG]  [BUGGY]  Node  scope  =  findFunctionScope(n.getFirstChild());  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  findFunctionScope(n.getFirstChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  findFunctionScope(n.getFirstChild());	  Node    scope    =    getFunctionScope(n.getLastChild());    	non-compiled	[CE]  orphaned  case	136	None	replace
211	[BUG]  [BUGGY]  Node  scope  =  getScope(n.getLastChild());  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  getScope(n.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getScope(n.getLastChild());	  Node    scope    =    getFunctionScope(n.getLastChild());    	non-compiled	[CE]  orphaned  case	136	None	replace
212	[BUG]  [BUGGY]  Node  scope  =  getFunctionScope(n.getLastChild(),  n);  [CE]  orphaned  case  [FE]                                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  getFunctionScope(n.getLastChild(),  n);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getFunctionScope(n.getLastChild(),  n);	  Node    scope    =    getFunctionScope(n.getLastChild());    	non-compiled	[CE]  orphaned  case	136	None	replace
213	[BUG]  [BUGGY]  Node  n  =  n.getfirstChild();  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  n.getfirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  n.getfirstChild();	  Node    n    =    parent.getfirstChild();    	non-compiled	[CE]  orphaned  case	267	None	replace
214	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  modifiedVar.equals(var))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  modifiedVar.equals(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  modifiedVar.equals(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    modifiedVar.equals(var))    {    	non-compiled	[CE]  	247	None	replace
215	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  var.equals(type))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  var.equals(type))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  var.equals(type))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    modifiedVar.equals(var))    {    	non-compiled	[CE]  	247	None	replace
216	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  modifiedVar.equals(var))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  modifiedVar.equals(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  modifiedVar.equals(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    modifiedVar.equals(var))    {    	non-compiled	[CE]  	247	None	replace
217	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  type.equals(var))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  type.equals(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  type.equals(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    modifiedVar.equals(var))    {    	non-compiled	[CE]  	247	None	replace
218	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  modifiedVar.equals(var))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  modifiedVar.equals(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  modifiedVar.equals(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    modifiedVar.equals(var))    {    	non-compiled	[CE]  	247	None	replace
219	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  modifiedVar.equals(scope.getVar(n.getLastChild  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  modifiedVar.equals(scope.getVar(n.getLastChild  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  modifiedVar.equals(scope.getVar(n.getLastChild	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    modifiedVar.equals(var))    {    	non-compiled	[CE]  	247	None	replace
220	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  modifiedVar.equals(type))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  modifiedVar.equals(type))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  modifiedVar.equals(type))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    modifiedVar.equals(var))    {    	non-compiled	[CE]  	247	None	replace
221	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	115	None	replace
222	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	115	None	replace
223	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	115	None	replace
224	[BUG]  [BUGGY]  if(scope.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	115	None	replace
225	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	115	None	replace
226	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	115	None	replace
227	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isDefinedVar(var))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isDefinedVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isDefinedVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isDefinedVar(var))    {    	non-compiled	[CE]  	248	None	replace
228	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isDefinedVar(var))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isDefinedVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isDefinedVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isDefinedVar(var))    {    	non-compiled	[CE]  	248	None	replace
229	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isDefinedVar(var))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isDefinedVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isDefinedVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isDefinedVar(var))    {    	non-compiled	[CE]  	248	None	replace
230	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isDefinedVar(var))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isDefinedVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isDefinedVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isDefinedVar(var))    {    	non-compiled	[CE]  	248	None	replace
231	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isDefinedVar(var,  type))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isDefinedVar(var,  type))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isDefinedVar(var,  type))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isDefinedVar(var))    {    	non-compiled	[CE]  	248	None	replace
232	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  isDefinedVar(var))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  isDefinedVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  isDefinedVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isDefinedVar(var))    {    	non-compiled	[CE]  	248	None	replace
233	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isDefinedVar(var))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isDefinedVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isDefinedVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isDefinedVar(var))    {    	non-compiled	[CE]  	248	None	replace
234	[BUG]  [BUGGY]  Node  var  =  node.getLastChild();  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  node.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  node.getLastChild();	  Node    var    =    node.getFirstChild();    	non-compiled	[CE]  orphaned  case	228	None	replace
235	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  n.getLastChild();  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  n.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  n.getLastChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	255	None	replace
236	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  n.getLastChild()  :  n.getLastChild();  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  n.getLastChild()  :  n.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()!=  null)?  n.getLastChild()  :  n.getLastChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	255	None	replace
237	[BUG]  [BUGGY]  Node  scope  =(n.getLastChild()  ==  null)?  n.getLastChild()  :  n.getLastChild();  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getLastChild()  ==  null)?  n.getLastChild()  :  n.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getLastChild()  ==  null)?  n.getLastChild()  :  n.getLastChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	255	None	replace
238	[BUG]  [BUGGY]  Node  scope  =(n.getLastChild()  ==  null)?  n.getLastChild()  :  n.getFirstChild();  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getLastChild()  ==  null)?  n.getLastChild()  :  n.getFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getLastChild()  ==  null)?  n.getLastChild()  :  n.getFirstChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	255	None	replace
239	[BUG]  [BUGGY]  Node  scope  =(n.getLastChild()  ==  null)?  n.getFirstChild()  :  n.getFirstChild();  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getLastChild()  ==  null)?  n.getFirstChild()  :  n.getFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getLastChild()  ==  null)?  n.getFirstChild()  :  n.getFirstChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	255	None	replace
240	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  n.getNext();  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  n.getNext();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  n.getNext();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	255	None	replace
241	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  parent.getFirstChild();  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  parent.getFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  parent.getFirstChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	255	None	replace
242	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null)  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getVar(n.getFirstChild().getString())!=    null)    {    	non-compiled	[CE]  	281	None	replace
243	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getLastChild().getString())!=  null)  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getLastChild().getString())!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getLastChild().getString())!=  null)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getVar(n.getFirstChild().getString())!=    null)    {    	non-compiled	[CE]  	281	None	replace
244	[BUG]  [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getVar(n.getFirstChild().getString())!=    null)    {    	non-compiled	[CE]  	281	None	replace
245	[BUG]  [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getVar(n.getFirstChild().getString())!=    null)    {    	non-compiled	[CE]  	281	None	replace
246	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  scope.getVar(n.getFirstChild().getString())!=  null)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  scope.getVar(n.getFirstChild().getString())!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  scope.getVar(n.getFirstChild().getString())!=  null)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getVar(n.getFirstChild().getString())!=    null)    {    	non-compiled	[CE]  	281	None	replace
247	[BUG]  [BUGGY]  if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getVar(n.getFirstChild().getString())!=    null)    {    	non-compiled	[CE]  	281	None	replace
248	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())  ==  null)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())  ==  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())  ==  null)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getVar(n.getFirstChild().getString())!=    null)    {    	non-compiled	[CE]  	281	None	replace
249	[BUG]  [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getLastChild().getString())!=  null)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getLastChild().getString())!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getLastChild().getString())!=  null)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getVar(n.getFirstChild().getString())!=    null)    {    	non-compiled	[CE]  	281	None	replace
250	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild().getType()  ==  Token.VAR)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild().getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild().getType()  ==  Token.VAR)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    n.getFirstChild().getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	285	None	replace
251	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild().getType()  ==  Token.VAR)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild().getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild().getType()  ==  Token.VAR)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    n.getFirstChild().getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	285	None	replace
252	[BUG]  [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getType()  ==  Token.VAR)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getType()  ==  Token.VAR)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    n.getFirstChild().getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	285	None	replace
253	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild().getType()  ==  Token.VAR)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild().getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild().getType()  ==  Token.VAR)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    n.getFirstChild().getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	285	None	replace
254	[BUG]  [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getType()  ==  Token.VAR)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getType()  ==  Token.VAR)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    n.getFirstChild().getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	285	None	replace
255	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getLastChild().getType()  ==  Token.VAR)  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getLastChild().getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getLastChild().getType()  ==  Token.VAR)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    n.getFirstChild().getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	285	None	replace
256	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  n.getFirstChild().getType()  ==  Token.VAR)  {  [CE]  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  n.getFirstChild().getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  n.getFirstChild().getType()  ==  Token.VAR)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    n.getFirstChild().getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	285	None	replace
257	[BUG]  [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild().getType()  ==  Token.VAR)  {  [CE]  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild().getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild().getType()  ==  Token.VAR)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    n.getFirstChild().getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	285	None	replace
258	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  &&  n.getFirstChild().getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  &&  n.getFirstChild().getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  &&  n.getFirstChild().getType()  ==  Token.VAR);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	206	None	replace
259	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()!=  Token.VAR);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()!=  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()!=  Token.VAR);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	206	None	replace
260	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getType()  ==  Token.VAR);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	206	None	replace
261	[BUG]  [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()!=  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.VAR);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	206	None	replace
262	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getLastChild().getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getLastChild().getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getLastChild().getType()  ==  Token.VAR);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	206	None	replace
263	[BUG]  [BUGGY]  Context.checkState(scope.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(scope.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(scope.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.VAR);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	206	None	replace
264	[BUG]  [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.VAR);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	206	None	replace
265	[BUG]  [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  &&  n.getFirstChild().getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  &&  n.getFirstChild().getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()!=  Token.FUNCTION  &&  n.getFirstChild().getType()  ==  Token.VAR);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	206	None	replace
266	[BUG]  [BUGGY]  var  =  scope.getVar(n.getFirstChild(),  n.getLastChild());  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getFirstChild(),  n.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getFirstChild(),  n.getLastChild());	  var    =    scope.getVar(n.getLastChild(),    n.getLastChild());    	non-compiled	[CE]  orphaned  case	182	None	replace
267	[BUG]  [BUGGY]  var  =  scope.getVar(parent.getLastChild(),  n.getLastChild());  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(parent.getLastChild(),  n.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(parent.getLastChild(),  n.getLastChild());	  var    =    scope.getVar(n.getLastChild(),    n.getLastChild());    	non-compiled	[CE]  orphaned  case	182	None	replace
268	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  parent.getLastChild());  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild(),  parent.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  parent.getLastChild());	  var    =    scope.getVar(n.getLastChild(),    n.getLastChild());    	non-compiled	[CE]  orphaned  case	182	None	replace
269	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n.getNext());  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n.getNext());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  n.getNext());	  var    =    scope.getVar(n.getLastChild(),    n.getLastChild());    	non-compiled	[CE]  orphaned  case	182	None	replace
270	[BUG]  [BUGGY]  var  =  scope.getVar(n.getfirstChild(),  n.getLastChild());  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getfirstChild(),  n.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getfirstChild(),  n.getLastChild());	  var    =    scope.getVar(n.getLastChild(),    n.getLastChild());    	non-compiled	[CE]  orphaned  case	182	None	replace
271	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	93	None	replace
272	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	93	None	replace
273	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	93	None	replace
274	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(parent)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	93	None	replace
275	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n,  scope))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n,  scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n,  scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	93	None	replace
276	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	85	None	replace
277	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	85	None	replace
278	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)&&  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	85	None	replace
279	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()!=  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()!=  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()!=  null  ||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	85	None	replace
280	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	85	None	replace
281	[BUG]  [BUGGY]  if(NodeUtil.isLiteralValue(n)&&  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isLiteralValue(n)&&  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isLiteralValue(n)&&  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isLiteralValue(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	277	None	replace
282	[BUG]  [BUGGY]  if(NodeUtil.isLiteralValue(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isLiteralValue(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isLiteralValue(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isLiteralValue(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	277	None	replace
283	[BUG]  [BUGGY]  if(NodeUtil.isLiteralValue(n)&&  scope.getType()  ==  Token.VAR)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isLiteralValue(n)&&  scope.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isLiteralValue(n)&&  scope.getType()  ==  Token.VAR)  {	  if(NodeUtil.isLiteralValue(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	277	None	replace
284	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isExpressionNode(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	37	None	replace
285	[BUG]  [BUGGY]  if(NodeUtil.isFunctionAssign(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionAssign(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionAssign(n)&&  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isExpressionNode(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	37	None	replace
286	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getType()  ==  Token.VAR)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  scope.getType()  ==  Token.VAR)  {	  if(NodeUtil.isExpressionNode(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	37	None	replace
287	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n,  parent,  scope))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n,  parent,  scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n,  parent,  scope))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n,    parent))    {    	non-compiled	[CE]  	271	None	replace
288	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  NodeUtil.isFunctionDeclaration(n,  parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  NodeUtil.isFunctionDeclaration(n,  parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  NodeUtil.isFunctionDeclaration(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n,    parent))    {    	non-compiled	[CE]  	271	None	replace
289	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(n,  parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(n,  parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n,    parent))    {    	non-compiled	[CE]  	271	None	replace
290	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isFunctionDeclaration(n,  parent))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isFunctionDeclaration(n,  parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isFunctionDeclaration(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n,    parent))    {    	non-compiled	[CE]  	271	None	replace
291	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  NodeUtil.isFunctionDeclaration(n,  parent))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  NodeUtil.isFunctionDeclaration(n,  parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)&&  NodeUtil.isFunctionDeclaration(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n,    parent))    {    	non-compiled	[CE]  	271	None	replace
292	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)&&  NodeUtil.isFunctionDeclaration(n,  parent))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)&&  NodeUtil.isFunctionDeclaration(n,  parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)&&  NodeUtil.isFunctionDeclaration(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n,    parent))    {    	non-compiled	[CE]  	271	None	replace
293	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent,  scope))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent,  scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent,  scope))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n,    parent))    {    	non-compiled	[CE]  	271	None	replace
294	[BUG]  [BUGGY]  if(NodeUtil.isName(n)&&  NodeUtil.isFunctionDeclaration(n,  parent))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)&&  NodeUtil.isFunctionDeclaration(n,  parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)&&  NodeUtil.isFunctionDeclaration(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n,    parent))    {    	non-compiled	[CE]  	271	None	replace
295	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getType()!=  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getType()!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getType()!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()!=    Token.FUNCTION)    {    	non-compiled	[CE]  	157	None	replace
296	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getType()!=  Token.FUNCTION)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getType()!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  scope.getType()!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()!=    Token.FUNCTION)    {    	non-compiled	[CE]  	157	None	replace
297	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  parent.getType()!=  Token.FUNCTION)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  parent.getType()!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  parent.getType()!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()!=    Token.FUNCTION)    {    	non-compiled	[CE]  	157	None	replace
298	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  parent.getType()!=  Token.FUNCTION)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  parent.getType()!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  parent.getType()!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()!=    Token.FUNCTION)    {    	non-compiled	[CE]  	157	None	replace
299	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  parent.getType()!=  Token.FUNCTION)  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  parent.getType()!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  parent.getType()!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()!=    Token.FUNCTION)    {    	non-compiled	[CE]  	157	None	replace
300	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(n)||  parent.getType()!=  Token.FUNCTION)  {  [CE]  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(n)||  parent.getType()!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(n)||  parent.getType()!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()!=    Token.FUNCTION)    {    	non-compiled	[CE]  	157	None	replace
301	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  parent.getType()!=  Token.FUNCTION)  {  [CE]  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  parent.getType()!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  parent.getType()!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()!=    Token.FUNCTION)    {    	non-compiled	[CE]  	157	None	replace
302	[BUG]  [BUGGY]  if(NodeUtil.isName(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(parent)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	32	None	replace
303	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.VAR)  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	186	None	replace
304	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  parent.getType()  ==  Token.VAR)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  parent.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  parent.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	186	None	replace
305	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()!=  Token.VAR)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()!=  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()!=  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	186	None	replace
306	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.VAR)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	186	None	replace
307	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	186	None	replace
308	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	186	None	replace
309	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	186	None	replace
310	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(n)&&  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(n)&&  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(n)&&  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isGetProp(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	39	None	replace
311	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isGetProp(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	39	None	replace
312	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(parent)&&  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(parent)&&  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(parent)&&  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isGetProp(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	39	None	replace
313	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(n)&&  scope.getType()  ==  Token.VAR)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(n)&&  scope.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(n)&&  scope.getType()  ==  Token.VAR)  {	  if(NodeUtil.isGetProp(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	39	None	replace
314	[BUG]  [BUGGY]  var  =  scope.getVar(parent.getFirstChild());  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(parent.getFirstChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(parent.getFirstChild());	  var    =    scope.getVar(parent.getLastChild());    	non-compiled	[CE]  orphaned  case	103	None	replace
315	[BUG]  [BUGGY]  Var  var  =  scope.getVar(n.getLastChild());  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Var  var  =  scope.getVar(n.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Var  var  =  scope.getVar(n.getLastChild());	  var    =    scope.getVar(parent.getLastChild());    	non-compiled	[CE]  orphaned  case	103	None	replace
316	[BUG]  [BUGGY]  var  var  =  scope.getVar(n.getLastChild());  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  var  =  scope.getVar(n.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  var  =  scope.getVar(n.getLastChild());	  var    =    scope.getVar(parent.getLastChild());    	non-compiled	[CE]  orphaned  case	103	None	replace
317	[BUG]  [BUGGY]  var  =  scope.getVar(parent.getLastChild(),  n);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(parent.getLastChild(),  n);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(parent.getLastChild(),  n);	  var    =    scope.getVar(parent.getLastChild());    	non-compiled	[CE]  orphaned  case	103	None	replace
318	[BUG]  [BUGGY]  var  =  scope.getVar(parent.getLastChild(),  type);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(parent.getLastChild(),  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(parent.getLastChild(),  type);	  var    =    scope.getVar(parent.getLastChild());    	non-compiled	[CE]  orphaned  case	103	None	replace
319	[BUG]  [BUGGY]  n  =  parent.removeFirstChild();  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  parent.removeFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  parent.removeFirstChild();	  n    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	261	None	replace
320	[BUG]  [BUGGY]  n  =  n.removeLastChild();  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.removeLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.removeLastChild();	  n    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	261	None	replace
321	[BUG]  [BUGGY]  n  =  parent.replaceChild(n,  new  Node(Token.FUNCTION));  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  parent.replaceChild(n,  new  Node(Token.FUNCTION));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  parent.replaceChild(n,  new  Node(Token.FUNCTION));	  n    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	261	None	replace
322	[BUG]  [BUGGY]  n  =  n.removeFirstChild()  ||  parent.getType()  ==  Token.FUNCTION;  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.removeFirstChild()  ||  parent.getType()  ==  Token.FUNCTION;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.removeFirstChild()  ||  parent.getType()  ==  Token.FUNCTION;	  n    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	261	None	replace
323	[BUG]  [BUGGY]  Node  c  =  scope.getLastChild();  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  scope.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  scope.getLastChild();	  Node    c    =    scope.getFirstChild();    	non-compiled	[CE]  orphaned  case	64	None	replace
324	[BUG]  [BUGGY]  Node  c  =  scope.getCurrentNode();  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  scope.getCurrentNode();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  scope.getCurrentNode();	  Node    c    =    scope.getFirstChild();    	non-compiled	[CE]  orphaned  case	64	None	replace
325	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getFirstChild()  :  n.getLastChild();  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getFirstChild()  :  n.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()  ==  null)?  n.getFirstChild()  :  n.getLastChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    parent.getFirstChild()    :    n.getLastChild();    	non-compiled	[CE]  orphaned  case	257	None	replace
326	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  parent.getLastChild()  :  n.getLastChild();  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  parent.getLastChild()  :  n.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()  ==  null)?  parent.getLastChild()  :  n.getLastChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    parent.getFirstChild()    :    n.getLastChild();    	non-compiled	[CE]  orphaned  case	257	None	replace
327	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  n.getFirstChild()  :  n.getLastChild();  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  n.getFirstChild()  :  n.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()!=  null)?  n.getFirstChild()  :  n.getLastChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    parent.getFirstChild()    :    n.getLastChild();    	non-compiled	[CE]  orphaned  case	257	None	replace
328	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  parent.getFirstChild()  :  n.getLastChild();  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  parent.getFirstChild()  :  n.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()!=  null)?  parent.getFirstChild()  :  n.getLastChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    parent.getFirstChild()    :    n.getLastChild();    	non-compiled	[CE]  orphaned  case	257	None	replace
329	[BUG]  [BUGGY]  Node  scope  =(n.getLastChild()  ==  null)?  parent.getFirstChild()  :  n.getLastChild();  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getLastChild()  ==  null)?  parent.getFirstChild()  :  n.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getLastChild()  ==  null)?  parent.getFirstChild()  :  n.getLastChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    parent.getFirstChild()    :    n.getLastChild();    	non-compiled	[CE]  orphaned  case	257	None	replace
330	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  parent.getLastChild()  :  n.getLastChild();  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  parent.getLastChild()  :  n.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()!=  null)?  parent.getLastChild()  :  n.getLastChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    parent.getFirstChild()    :    n.getLastChild();    	non-compiled	[CE]  orphaned  case	257	None	replace
331	[BUG]  [BUGGY]  var  =  n.getFirstChild().getVar(parent.getFirstChild().getString());  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  n.getFirstChild().getVar(parent.getFirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  n.getFirstChild().getVar(parent.getFirstChild().getString());	  var    =    parent.getFirstChild().getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	243	None	replace
332	[BUG]  [BUGGY]  var  =  node.getFirstChild().getVar(n.getFirstChild().getString());  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  node.getFirstChild().getVar(n.getFirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  node.getFirstChild().getVar(n.getFirstChild().getString());	  var    =    parent.getFirstChild().getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	243	None	replace
333	[BUG]  [BUGGY]  var  =  parent.getLastChild().getVar(n.getFirstChild().getString());  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  parent.getLastChild().getVar(n.getFirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  parent.getLastChild().getVar(n.getFirstChild().getString());	  var    =    parent.getFirstChild().getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	243	None	replace
334	[BUG]  [BUGGY]  var  =  n.getFirstChild().getVar(n.getFirstChild().getString());  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  n.getFirstChild().getVar(n.getFirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  n.getFirstChild().getVar(n.getFirstChild().getString());	  var    =    parent.getFirstChild().getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	243	None	replace
335	[BUG]  [BUGGY]  var  =  n.getLastChild().getVar(n.getFirstChild().getString());  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  n.getLastChild().getVar(n.getFirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  n.getLastChild().getVar(n.getFirstChild().getString());	  var    =    parent.getFirstChild().getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	243	None	replace
336	[BUG]  [BUGGY]  if(NodeUtil.isName(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isName(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	191	None	replace
337	[BUG]  [BUGGY]  if(NodeUtil.isFunction(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunction(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunction(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isName(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	191	None	replace
338	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isName(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	191	None	replace
339	[BUG]  [BUGGY]  if(NodeUtil.isFunctionAnonymous(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionAnonymous(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionAnonymous(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isName(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	191	None	replace
340	[BUG]  [BUGGY]  if(NodeUtil.isName(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isName(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	191	None	replace
341	[BUG]  [BUGGY]  if(NodeUtil.isName(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isName(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	191	None	replace
342	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	89	None	replace
343	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()!=  null  ||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()!=  null  ||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()!=  null  ||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	89	None	replace
344	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	89	None	replace
345	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	89	None	replace
346	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	89	None	replace
347	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	89	None	replace
348	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(parent)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isAssignmentOp(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	8	None	replace
349	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isAssignmentOp(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	8	None	replace
350	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(n))  {	  if(NodeUtil.isAssignmentOp(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	8	None	replace
351	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(parent))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(parent))  {	  if(NodeUtil.isAssignmentOp(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	8	None	replace
352	[BUG]  [BUGGY]  Node  parent  =  n.getNext();  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  parent  =  n.getNext();  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  parent  =  n.getNext();	  Node    parent    =    n.getParent();    	non-compiled	[CE]  orphaned  case	142	None	replace
353	[BUG]  [BUGGY]  Node  parent  =  n.getLastChild();  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  parent  =  n.getLastChild();  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  parent  =  n.getLastChild();	  Node    parent    =    n.getParent();    	non-compiled	[CE]  orphaned  case	142	None	replace
354	[BUG]  [BUGGY]  Node  parent  =  n.getFirstChild();  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  parent  =  n.getFirstChild();  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  parent  =  n.getFirstChild();	  Node    parent    =    n.getParent();    	non-compiled	[CE]  orphaned  case	142	None	replace
355	[BUG]  [BUGGY]  Node  parent  =  n.getPreviousParent();  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  parent  =  n.getPreviousParent();  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  parent  =  n.getPreviousParent();	  Node    parent    =    n.getParent();    	non-compiled	[CE]  orphaned  case	142	None	replace
356	[BUG]  [BUGGY]  Node  parent  =  n.getPreviousChild();  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  parent  =  n.getPreviousChild();  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  parent  =  n.getPreviousChild();	  Node    parent    =    n.getParent();    	non-compiled	[CE]  orphaned  case	142	None	replace
357	[BUG]  [BUGGY]  Node  parent  =  n.getParentNode();  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  parent  =  n.getParentNode();  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  parent  =  n.getParentNode();	  Node    parent    =    n.getParent();    	non-compiled	[CE]  orphaned  case	142	None	replace
358	[BUG]  [BUGGY]  Node  parent  =  scope.getParent();  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  parent  =  scope.getParent();  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  parent  =  scope.getParent();	  Node    parent    =    n.getParent();    	non-compiled	[CE]  orphaned  case	142	None	replace
359	[BUG]  [BUGGY]  Node  parent  =  node.getParent();  [CE]  orphaned  case  [FE]                                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  parent  =  node.getParent();  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  parent  =  node.getParent();	  Node    parent    =    n.getParent();    	non-compiled	[CE]  orphaned  case	142	None	replace
360	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	246	None	replace
361	[BUG]  [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	246	None	replace
362	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	246	None	replace
363	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	246	None	replace
364	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	246	None	replace
365	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(var))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(var))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	246	None	replace
366	[BUG]  [BUGGY]  if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	246	None	replace
367	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  isRemovableVar(var))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  isRemovableVar(var))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	246	None	replace
368	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	249	None	replace
369	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	249	None	replace
370	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  type!=  Token.VAR)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  type!=  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  type!=  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	249	None	replace
371	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	249	None	replace
372	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	249	None	replace
373	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  &&  type  ==  Token.VAR)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  &&  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  &&  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	249	None	replace
374	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	249	None	replace
375	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    n.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	226	None	replace
376	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getLastChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getLastChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  n.getLastChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    n.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	226	None	replace
377	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  n.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  n.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)&&  n.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    n.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	226	None	replace
378	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    n.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	226	None	replace
379	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  n.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  n.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  n.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    n.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	226	None	replace
380	[BUG]  [BUGGY]  Node  var  =  n.getLastChild().getNext();  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  n.getLastChild().getNext();  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  n.getLastChild().getNext();	  Node    var    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	208	None	replace
381	[BUG]  [BUGGY]  Node  var  =  n.getFirstChild().getString();  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  n.getFirstChild().getString();  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  n.getFirstChild().getString();	  Node    var    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	208	None	replace
382	[BUG]  [BUGGY]  Node  var  =  parent.getFirstChild().getNext();  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  parent.getFirstChild().getNext();  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  parent.getFirstChild().getNext();	  Node    var    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	208	None	replace
383	[BUG]  [BUGGY]  Node  var  =  n.getFirstChild().getLastChild();  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  n.getFirstChild().getLastChild();  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  n.getFirstChild().getLastChild();	  Node    var    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	208	None	replace
384	[BUG]  [BUGGY]  Node  var  =  n.getFirstChild().getNext()  ||  type  ==  Token.FUNCTION;  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  n.getFirstChild().getNext()  ||  type  ==  Token.FUNCTION;  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  n.getFirstChild().getNext()  ||  type  ==  Token.FUNCTION;	  Node    var    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	208	None	replace
385	[BUG]  [BUGGY]  Node  var  =  n.getFirstChild().getNext()  ||  parent.getType()  ==  Token.FUNCTION;  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  n.getFirstChild().getNext()  ||  parent.getType()  ==  Token.FUNCTION;  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  n.getFirstChild().getNext()  ||  parent.getType()  ==  Token.FUNCTION;	  Node    var    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	208	None	replace
386	[BUG]  [BUGGY]  Node  var  =  n.getFirstChild().getParent();  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  n.getFirstChild().getParent();  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  n.getFirstChild().getParent();	  Node    var    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	208	None	replace
387	[BUG]  [BUGGY]  if(scope!=  null  &&  node.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  node.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  node.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(fnScope!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	237	None	replace
388	[BUG]  [BUGGY]  if(fnScope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(fnScope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(fnScope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {	  if(fnScope!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	237	None	replace
389	[BUG]  [BUGGY]  if(fnScope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(fnScope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(fnScope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {	  if(fnScope!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	237	None	replace
390	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION)  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	274	None	replace
391	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	274	None	replace
392	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	274	None	replace
393	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	274	None	replace
394	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	274	None	replace
395	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	274	None	replace
396	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	274	None	replace
397	[BUG]  [BUGGY]  Node  var  =  parent.getLastChild();  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  parent.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  parent.getLastChild();	  Node    var    =    parent.getFirstChild();    	non-compiled	[CE]  orphaned  case	12	None	replace
398	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getLastChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	114	None	replace
399	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getLastChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	114	None	replace
400	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getLastChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	114	None	replace
401	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getLastChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	114	None	replace
402	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getLastChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	114	None	replace
403	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	241	None	replace
404	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	241	None	replace
405	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	241	None	replace
406	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(n,  scope))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(n,  scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(n,  scope))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	241	None	replace
407	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	241	None	replace
408	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  node.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  node.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  node.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	241	None	replace
409	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()  ==  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()  ==  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()  ==  null  &&  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	241	None	replace
410	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	241	None	replace
411	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION,  parent);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION,  parent);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION,  parent);	  Context.checkState(n.getType()    ==    Token.FUNCTION,    scope);    	non-compiled	[CE]  orphaned  case	152	None	replace
412	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  scope.isFunctionDeclaration());  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  scope.isFunctionDeclaration());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  scope.isFunctionDeclaration());	  Context.checkState(n.getType()    ==    Token.FUNCTION,    scope);    	non-compiled	[CE]  orphaned  case	152	None	replace
413	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION,  type);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION,  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION,  type);	  Context.checkState(n.getType()    ==    Token.FUNCTION,    scope);    	non-compiled	[CE]  orphaned  case	152	None	replace
414	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION,  parent,  scope);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION,  parent,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION,  parent,  scope);	  Context.checkState(n.getType()    ==    Token.FUNCTION,    scope);    	non-compiled	[CE]  orphaned  case	152	None	replace
415	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION,  scope,  type);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION,  scope,  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION,  scope,  type);	  Context.checkState(n.getType()    ==    Token.FUNCTION,    scope);    	non-compiled	[CE]  orphaned  case	152	None	replace
416	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  scope.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  scope.getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  scope.getType()  ==  Token.FUNCTION);	  Context.checkState(n.getType()    ==    Token.FUNCTION,    scope);    	non-compiled	[CE]  orphaned  case	152	None	replace
417	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION,  var);  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION,  var);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION,  var);	  Context.checkState(n.getType()    ==    Token.FUNCTION,    scope);    	non-compiled	[CE]  orphaned  case	152	None	replace
418	[BUG]  [BUGGY]  if(NodeUtil.isFunction(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunction(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunction(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isName(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	188	None	replace
419	[BUG]  [BUGGY]  if(NodeUtil.isName(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(parent)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isName(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	188	None	replace
420	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(parent)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(parent)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(parent)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isAssignmentOp(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	166	None	replace
421	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)&&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isAssignmentOp(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	166	None	replace
422	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isAssignmentOp(n))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isAssignmentOp(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isAssignmentOp(n))  {	  if(NodeUtil.isAssignmentOp(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	166	None	replace
423	[BUG]  [BUGGY]  if(NodeUtil.isFunction(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunction(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunction(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isVar(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	272	None	replace
424	[BUG]  [BUGGY]  if(NodeUtil.isFunction(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunction(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunction(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isName(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	172	None	replace
425	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isName(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	172	None	replace
426	[BUG]  [BUGGY]  if(NodeUtil.isFunctionAnonymous(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionAnonymous(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionAnonymous(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isName(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	172	None	replace
427	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isName(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	172	None	replace
428	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	94	None	replace
429	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(scope))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	94	None	replace
430	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	94	None	replace
431	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	94	None	replace
432	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	94	None	replace
433	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	94	None	replace
434	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent,  scope))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent,  scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent,  scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	94	None	replace
435	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  parent.getFirstChild()  :  n.getFirstChild();  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  parent.getFirstChild()  :  n.getFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()  ==  null)?  parent.getFirstChild()  :  n.getFirstChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    parent.getLastChild()    :    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	260	None	replace
436	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  parent.getFirstChild()  :  n.getFirstChild();  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  parent.getFirstChild()  :  n.getFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()!=  null)?  parent.getFirstChild()  :  n.getFirstChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    parent.getLastChild()    :    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	260	None	replace
437	[BUG]  [BUGGY]  Node  scope  =(n.getLastChild()  ==  null)?  parent.getFirstChild()  :  n.getFirstChild();  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getLastChild()  ==  null)?  parent.getFirstChild()  :  n.getFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getLastChild()  ==  null)?  parent.getFirstChild()  :  n.getFirstChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    parent.getLastChild()    :    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	260	None	replace
438	[BUG]  [BUGGY]  Node  var  =  scope.getVar(n.getFirstChild(),  type);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  scope.getVar(n.getFirstChild(),  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getVar(n.getFirstChild(),  type);	  Node    var    =    scope.getVar(n.getFirstChild());    	non-compiled	[CE]  orphaned  case	14	None	replace
439	[BUG]  [BUGGY]  Node  var  =  scope.getVar(n.getString());  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  scope.getVar(n.getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getVar(n.getString());	  Node    var    =    scope.getVar(n.getFirstChild());    	non-compiled	[CE]  orphaned  case	14	None	replace
440	[BUG]  [BUGGY]  Node  var  =  scope.getVar(n.getFirstChild(),  n.getLastChild());  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  scope.getVar(n.getFirstChild(),  n.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getVar(n.getFirstChild(),  n.getLastChild());	  Node    var    =    scope.getVar(n.getFirstChild());    	non-compiled	[CE]  orphaned  case	14	None	replace
441	[BUG]  [BUGGY]  Node  var  =  scope.getVar(n.getFirstChild(),  n.getString());  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  scope.getVar(n.getFirstChild(),  n.getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getVar(n.getFirstChild(),  n.getString());	  Node    var    =    scope.getVar(n.getFirstChild());    	non-compiled	[CE]  orphaned  case	14	None	replace
442	[BUG]  [BUGGY]  Node  var  =  scope.getVar(n.getFirstChild(),  parent);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  scope.getVar(n.getFirstChild(),  parent);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getVar(n.getFirstChild(),  parent);	  Node    var    =    scope.getVar(n.getFirstChild());    	non-compiled	[CE]  orphaned  case	14	None	replace
443	[BUG]  [BUGGY]  Node  n  =  scope.getFirstChild().getNext();  [CE]  orphaned  case  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  scope.getFirstChild().getNext();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  scope.getFirstChild().getNext();	  Node    n    =    n.getNext();    	non-compiled	[CE]  orphaned  case	18	None	replace
444	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  node.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  node.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  node.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    node.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	90	None	replace
445	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  node.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  node.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  node.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    node.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	90	None	replace
446	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  node.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  node.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)&&  node.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    node.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	90	None	replace
447	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  node.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  node.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  node.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    node.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	90	None	replace
448	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  node.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  node.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  node.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    node.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	90	None	replace
449	[BUG]  [BUGGY]  Node  n  =  nameNode.getLastChild();  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  nameNode.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  nameNode.getLastChild();	  Node    n    =    nameNode.getFirstChild();    	non-compiled	[CE]  orphaned  case	222	None	replace
450	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	98	None	replace
451	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	98	None	replace
452	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	98	None	replace
453	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	98	None	replace
454	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent)  [CE]  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent)  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent)	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	98	None	replace
455	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	98	None	replace
456	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	98	None	replace
457	[BUG]  [BUGGY]  var  var  =  scope.getVar(n.getLastChild().getString());  [CE]  orphaned  case  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  var  =  scope.getVar(n.getLastChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  var  =  scope.getVar(n.getLastChild().getString());	  var    =    scope.getVar(parent.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	143	None	replace
458	[BUG]  [BUGGY]  var  =  parent.getLastChild().getString();  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  parent.getLastChild().getString();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  parent.getLastChild().getString();	  var    =    scope.getVar(parent.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	143	None	replace
459	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getLastChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	28	None	replace
460	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getLastChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	28	None	replace
461	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getLastChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	28	None	replace
462	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getLastChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	28	None	replace
463	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getLastChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	28	None	replace
464	[BUG]  [BUGGY]  if(NodeUtil.isName(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getLastChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	28	None	replace
465	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()!=  Token.FUNCTION);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()!=  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()!=  Token.FUNCTION);	  Preconditions.checkState(n.getType()!=    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	44	None	replace
466	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()!=  Token.FUNCTION);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()!=  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()!=  Token.FUNCTION);	  Preconditions.checkState(n.getType()!=    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	44	None	replace
467	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  >=  Token.FUNCTION);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  >=  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  >=  Token.FUNCTION);	  Preconditions.checkState(n.getType()!=    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	44	None	replace
468	[BUG]  [BUGGY]  Preconditions.checkArgument(n.getType()!=  Token.FUNCTION);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(n.getType()!=  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(n.getType()!=  Token.FUNCTION);	  Preconditions.checkState(n.getType()!=    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	44	None	replace
469	[BUG]  [BUGGY]  Node  scope  =  n.getlastChild();  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  n.getlastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  n.getlastChild();	  Node    scope    =    parent.getLastChild();    	non-compiled	[CE]  orphaned  case	134	None	replace
470	[BUG]  [BUGGY]  Node  scope  =  n.getfirstChild();  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  n.getfirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  n.getfirstChild();	  Node    scope    =    parent.getLastChild();    	non-compiled	[CE]  orphaned  case	134	None	replace
471	[BUG]  [BUGGY]  Node  scope  =  n.getPreviousChild();  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  n.getPreviousChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  n.getPreviousChild();	  Node    scope    =    parent.getLastChild();    	non-compiled	[CE]  orphaned  case	134	None	replace
472	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n,  scope))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n,  scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n,  scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	185	None	replace
473	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n,  parent))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n,  parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	185	None	replace
474	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	185	None	replace
475	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	185	None	replace
476	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	185	None	replace
477	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	185	None	replace
478	[BUG]  [BUGGY]  Node  scope  =  nameNode.getFirstChild();  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  nameNode.getFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  nameNode.getFirstChild();	  Node    scope    =    node.getFirstChild();    	non-compiled	[CE]  orphaned  case	138	None	replace
479	[BUG]  [BUGGY]  Node  scope  =  getFunctionScope(n,  parent.getFirstChild());  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  getFunctionScope(n,  parent.getFirstChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getFunctionScope(n,  parent.getFirstChild());	  Node    scope    =    parent.getFirstChild();    	non-compiled	[CE]  orphaned  case	135	None	replace
480	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION  ||  scope.getType()  ==  Token.VAR)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION  ||  scope.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION  ||  scope.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    scope.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	58	None	replace
481	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  &&  scope.getType()  ==  Token.VAR)  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  &&  scope.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  &&  scope.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    scope.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	58	None	replace
482	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  scope.getType()!=  Token.VAR)  {  [CE]  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  scope.getType()!=  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  scope.getType()!=  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    scope.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	58	None	replace
483	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION  ||  scope.getType()  ==  Token.VAR)  {  [CE]  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION  ||  scope.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION  ||  scope.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    scope.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	58	None	replace
484	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION  ||  scope.getType()  ==  Token.VAR)  {  [CE]  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION  ||  scope.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION  ||  scope.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    scope.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	58	None	replace
485	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION  ||  scope.getType()  ==  Token.VAR)  {  [CE]  [FE]                                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION  ||  scope.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION  ||  scope.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    scope.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	58	None	replace
486	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  type  ==  Token.FUNCTION  ||  scope.getType()  ==  Token.VAR)  {  [CE]  [FE]                                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  type  ==  Token.FUNCTION  ||  scope.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  type  ==  Token.FUNCTION  ||  scope.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    scope.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	58	None	replace
487	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    n.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	227	None	replace
488	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  n.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  n.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  n.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    n.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	227	None	replace
489	[BUG]  [BUGGY]  var  =  scope.getVar(n.getFirstChild(),  n);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getFirstChild(),  n);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getFirstChild(),  n);	  var    =    scope.getVar(n.getLastChild(),    n);    	non-compiled	[CE]  orphaned  case	179	None	replace
490	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  parent);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild(),  parent);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  parent);	  var    =    scope.getVar(n.getLastChild(),    n);    	non-compiled	[CE]  orphaned  case	179	None	replace
491	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n,  parent);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n,  parent);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  n,  parent);	  var    =    scope.getVar(n.getLastChild(),    n);    	non-compiled	[CE]  orphaned  case	179	None	replace
492	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n,  type);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n,  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  n,  type);	  var    =    scope.getVar(n.getLastChild(),    n);    	non-compiled	[CE]  orphaned  case	179	None	replace
493	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION  ||  type  ==  Token.NAME)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION  ||  type  ==  Token.NAME)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION  ||  type  ==  Token.NAME)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    type    ==    Token.NAME)    {    	non-compiled	[CE]  	250	None	replace
494	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION  ||  type  ==  Token.NAME)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION  ||  type  ==  Token.NAME)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION  ||  type  ==  Token.NAME)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    type    ==    Token.NAME)    {    	non-compiled	[CE]  	250	None	replace
495	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION  ||  type  ==  Token.NAME)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION  ||  type  ==  Token.NAME)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION  ||  type  ==  Token.NAME)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    type    ==    Token.NAME)    {    	non-compiled	[CE]  	250	None	replace
496	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION  ||  type  ==  Token.NAME)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION  ||  type  ==  Token.NAME)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION  ||  type  ==  Token.NAME)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    type    ==    Token.NAME)    {    	non-compiled	[CE]  	250	None	replace
497	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  type!=  Token.NAME)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  type!=  Token.NAME)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  type!=  Token.NAME)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    type    ==    Token.NAME)    {    	non-compiled	[CE]  	250	None	replace
498	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.NAME  ||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.NAME  ||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.NAME  ||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    type    ==    Token.NAME)    {    	non-compiled	[CE]  	250	None	replace
499	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  &&  type  ==  Token.NAME)  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  &&  type  ==  Token.NAME)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  &&  type  ==  Token.NAME)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    type    ==    Token.NAME)    {    	non-compiled	[CE]  	250	None	replace
500	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  type  ==  Token.FUNCTION  ||  type  ==  Token.NAME)  {  [CE]  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  type  ==  Token.FUNCTION  ||  type  ==  Token.NAME)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  type  ==  Token.FUNCTION  ||  type  ==  Token.NAME)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    type    ==    Token.NAME)    {    	non-compiled	[CE]  	250	None	replace
501	[BUG]  [BUGGY]  Node  scope  =  parent.getNext();  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  parent.getNext();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  parent.getNext();	  Node    scope    =    n.getNext();    	non-compiled	[CE]  orphaned  case	168	None	replace
502	[BUG]  [BUGGY]  Node  scope  =  n.getParent();  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  n.getParent();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  n.getParent();	  Node    scope    =    n.getNext();    	non-compiled	[CE]  orphaned  case	168	None	replace
503	[BUG]  [BUGGY]  Node  scope  =  n.getScope();  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  n.getScope();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  n.getScope();	  Node    scope    =    n.getNext();    	non-compiled	[CE]  orphaned  case	168	None	replace
504	[BUG]  [BUGGY]  Node  scope  =  n.getType();  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  n.getType();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  n.getType();	  Node    scope    =    n.getNext();    	non-compiled	[CE]  orphaned  case	168	None	replace
505	[BUG]  [BUGGY]  Node  scope  =  n.getFunctionScope();  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  n.getFunctionScope();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  n.getFunctionScope();	  Node    scope    =    n.getNext();    	non-compiled	[CE]  orphaned  case	168	None	replace
506	[BUG]  [BUGGY]  Node  scope  =  n.getString();  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  n.getString();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  n.getString();	  Node    scope    =    n.getNext();    	non-compiled	[CE]  orphaned  case	168	None	replace
507	[BUG]  [BUGGY]  var  var  =  scope.getVar(n.getFirstChild().getString());  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  var  =  scope.getVar(n.getFirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  var  =  scope.getVar(n.getFirstChild().getString());	  var    =    scope.getVar(parent.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	80	None	replace
508	[BUG]  [BUGGY]  Node  var  =  scope.getVar(n.getLastChild(),  type);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  scope.getVar(n.getLastChild(),  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getVar(n.getLastChild(),  type);	  Node    var    =    scope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	17	None	replace
509	[BUG]  [BUGGY]  Node  var  =  scope.getVar(n.getLastChild(),  n.getString());  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  scope.getVar(n.getLastChild(),  n.getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getVar(n.getLastChild(),  n.getString());	  Node    var    =    scope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	17	None	replace
510	[BUG]  [BUGGY]  Node  var  =  scope.getVar(n.getLastChild(),  n.getFirstChild());  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  scope.getVar(n.getLastChild(),  n.getFirstChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getVar(n.getLastChild(),  n.getFirstChild());	  Node    var    =    scope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	17	None	replace
511	[BUG]  [BUGGY]  Node  var  =  scope.getVar(parent.getLastChild());  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  scope.getVar(parent.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getVar(parent.getLastChild());	  Node    var    =    scope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	17	None	replace
512	[BUG]  [BUGGY]  Node  var  =  scope.getVar(n.getLastChild(),  n.getLastChild());  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  scope.getVar(n.getLastChild(),  n.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getVar(n.getLastChild(),  n.getLastChild());	  Node    var    =    scope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	17	None	replace
513	[BUG]  [BUGGY]  Node  var  =  scope.getVar(n.getLastChild(),  n);  [CE]  orphaned  case  [FE]                                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  scope.getVar(n.getLastChild(),  n);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getVar(n.getLastChild(),  n);	  Node    var    =    scope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	17	None	replace
514	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(parent))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	73	None	replace
515	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(parent))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	73	None	replace
516	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isVar(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	269	None	replace
517	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(scope))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(parent))    {    	non-compiled	[CE]  	77	None	replace
518	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.mayHaveSideEffects(parent))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.mayHaveSideEffects(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  NodeUtil.mayHaveSideEffects(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(parent))    {    	non-compiled	[CE]  	77	None	replace
519	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(parent,  scope))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(parent,  scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(parent,  scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(parent))    {    	non-compiled	[CE]  	77	None	replace
520	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.mayHaveSideEffects(parent))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.mayHaveSideEffects(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  NodeUtil.mayHaveSideEffects(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(parent))    {    	non-compiled	[CE]  	77	None	replace
521	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(parent))    {    	non-compiled	[CE]  	214	None	replace
522	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(parent))    {    	non-compiled	[CE]  	214	None	replace
523	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(n,  parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(n,  parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(parent))    {    	non-compiled	[CE]  	214	None	replace
524	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(parent))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(parent))    {    	non-compiled	[CE]  	214	None	replace
525	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(parent))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(parent))    {    	non-compiled	[CE]  	214	None	replace
526	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(n,  parent))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(n,  parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(parent))    {    	non-compiled	[CE]  	214	None	replace
527	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	35	None	replace
528	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	35	None	replace
529	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	35	None	replace
530	[BUG]  [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isConstructorDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	35	None	replace
531	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSecondarySideEffects(parent))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSecondarySideEffects(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSecondarySideEffects(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSecondarySideEffects(parent))    {    	non-compiled	[CE]  	175	None	replace
532	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(n,  parent))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(n,  parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSecondarySideEffects(parent))    {    	non-compiled	[CE]  	175	None	replace
533	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(scope))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSecondarySideEffects(parent))    {    	non-compiled	[CE]  	175	None	replace
534	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSecondarySideEffects(parent))    {    	non-compiled	[CE]  	175	None	replace
535	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(n,  scope))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(n,  scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(n,  scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSecondarySideEffects(parent))    {    	non-compiled	[CE]  	175	None	replace
536	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.mayHaveSecondarySideEffects(parent))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.mayHaveSecondarySideEffects(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  NodeUtil.mayHaveSecondarySideEffects(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSecondarySideEffects(parent))    {    	non-compiled	[CE]  	175	None	replace
537	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(parent,  scope))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(parent,  scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(parent,  scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSecondarySideEffects(parent))    {    	non-compiled	[CE]  	175	None	replace
538	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.mayHaveSecondarySideEffects(parent))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.mayHaveSecondarySideEffects(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  NodeUtil.mayHaveSecondarySideEffects(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSecondarySideEffects(parent))    {    	non-compiled	[CE]  	175	None	replace
539	[BUG]  [BUGGY]  if(NodeUtil.mayHaveSecondarySideEffects(n)||  NodeUtil.mayHaveSecondarySideEffects(scope))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.mayHaveSecondarySideEffects(n)||  NodeUtil.mayHaveSecondarySideEffects(scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.mayHaveSecondarySideEffects(n)||  NodeUtil.mayHaveSecondarySideEffects(scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSecondarySideEffects(parent))    {    	non-compiled	[CE]  	175	None	replace
540	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isAssignmentOp(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	160	None	replace
541	[BUG]  [BUGGY]  if(NodeUtil.isFunctionAnswer(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionAnswer(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionAnswer(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isAssignmentOp(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	160	None	replace
542	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isAssignmentOp(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	160	None	replace
543	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(parent)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isAssignmentOp(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	160	None	replace
544	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  parent.getFirstChild());  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild(),  parent.getFirstChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  parent.getFirstChild());	  var    =    scope.getVar(n.getLastChild(),    n.getFirstChild());    	non-compiled	[CE]  orphaned  case	178	None	replace
545	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n.getFirstChild(),  type);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n.getFirstChild(),  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  n.getFirstChild(),  type);	  var    =    scope.getVar(n.getLastChild(),    n.getFirstChild());    	non-compiled	[CE]  orphaned  case	178	None	replace
546	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR,  scope);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR,  scope);	  Preconditions.checkState(n.getType()    ==    Token.VAR,    type);    	non-compiled	[CE]  orphaned  case	71	None	replace
547	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR,  type,  scope);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR,  type,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR,  type,  scope);	  Preconditions.checkState(n.getType()    ==    Token.VAR,    type);    	non-compiled	[CE]  orphaned  case	71	None	replace
548	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR,  parent.getType());  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR,  parent.getType());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR,  parent.getType());	  Preconditions.checkState(n.getType()    ==    Token.VAR,    type);    	non-compiled	[CE]  orphaned  case	71	None	replace
549	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR,  var);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR,  var);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR,  var);	  Preconditions.checkState(n.getType()    ==    Token.VAR,    type);    	non-compiled	[CE]  orphaned  case	71	None	replace
550	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR,  var.getType());  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR,  var.getType());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR,  var.getType());	  Preconditions.checkState(n.getType()    ==    Token.VAR,    type);    	non-compiled	[CE]  orphaned  case	71	None	replace
551	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR,  parent);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR,  parent);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR,  parent);	  Preconditions.checkState(n.getType()    ==    Token.VAR,    type);    	non-compiled	[CE]  orphaned  case	71	None	replace
552	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.VAR,  type);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.VAR,  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.VAR,  type);	  Preconditions.checkState(n.getType()    ==    Token.VAR,    type);    	non-compiled	[CE]  orphaned  case	71	None	replace
553	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.FUNCTION);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	148	None	replace
554	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION,  scope);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION,  scope);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	148	None	replace
555	[BUG]  [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	148	None	replace
556	[BUG]  [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.FUNCTION);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	148	None	replace
557	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.FUNCTION);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	148	None	replace
558	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.FUNCTION);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.FUNCTION);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	148	None	replace
559	[BUG]  [BUGGY]  Context.checkState(scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	148	None	replace
560	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	96	None	replace
561	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	96	None	replace
562	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	96	None	replace
563	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	96	None	replace
564	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  &&  n.getFirstChild().getString().equals( "function   "));  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  &&  n.getFirstChild().getString().equals( "function   "));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  &&  n.getFirstChild().getString().equals( "function   "));	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString().equals(   "function   "));    	non-compiled	[CE]  orphaned  case	153	None	replace
565	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getLastChild().getString().equals( "function "));  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getLastChild().getString().equals( "function "));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getLastChild().getString().equals( "function "));	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString().equals(   "function   "));    	non-compiled	[CE]  orphaned  case	153	None	replace
566	[BUG]  [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  ||  n.getFirstChild().getString().equals( "function "));  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  ||  n.getFirstChild().getString().equals( "function "));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()!=  Token.FUNCTION  ||  n.getFirstChild().getString().equals( "function "));	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString().equals(   "function   "));    	non-compiled	[CE]  orphaned  case	153	None	replace
567	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getString().equals( "function "));  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getString().equals( "function "));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getString().equals( "function "));	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString().equals(   "function   "));    	non-compiled	[CE]  orphaned  case	153	None	replace
568	[BUG]  [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  &&  n.getFirstChild().getString().equals( "function   "));  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  &&  n.getFirstChild().getString().equals( "function   "));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()!=  Token.FUNCTION  &&  n.getFirstChild().getString().equals( "function   "));	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString().equals(   "function   "));    	non-compiled	[CE]  orphaned  case	153	None	replace
569	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().equals( ".function "));  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().equals( ".function "));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().equals( ".function "));	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString().equals(   "function   "));    	non-compiled	[CE]  orphaned  case	153	None	replace
570	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent)&&  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent)&&  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent)&&  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	211	None	replace
571	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	211	None	replace
572	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	211	None	replace
573	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()!=  Token.FUNCTION)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	211	None	replace
574	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	211	None	replace
575	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	211	None	replace
576	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  &&!NodeUtil.isFunctionObjectCall(n));  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  &&!NodeUtil.isFunctionObjectCall(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  &&!NodeUtil.isFunctionObjectCall(n));	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||!NodeUtil.isFunctionObjectCall(n));    	non-compiled	[CE]  orphaned  case	245	None	replace
577	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionObjectCall(parent));  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionObjectCall(parent));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionObjectCall(parent));	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||!NodeUtil.isFunctionObjectCall(n));    	non-compiled	[CE]  orphaned  case	245	None	replace
578	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionObjectCall(n));  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionObjectCall(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionObjectCall(n));	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||!NodeUtil.isFunctionObjectCall(n));    	non-compiled	[CE]  orphaned  case	245	None	replace
579	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionObjectDeclaration(n));  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionObjectDeclaration(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionObjectDeclaration(n));	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||!NodeUtil.isFunctionObjectCall(n));    	non-compiled	[CE]  orphaned  case	245	None	replace
580	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionConstructor(n));  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionConstructor(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionConstructor(n));	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||!NodeUtil.isFunctionObjectCall(n));    	non-compiled	[CE]  orphaned  case	245	None	replace
581	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    parent.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	218	None	replace
582	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  parent.getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  parent.getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  parent.getType()  ==  Token.VAR);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    parent.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	218	None	replace
583	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()!=  Token.VAR);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()!=  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()!=  Token.VAR);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    parent.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	218	None	replace
584	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    parent.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	218	None	replace
585	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  scope.getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  scope.getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  scope.getType()  ==  Token.VAR);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    parent.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	218	None	replace
586	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    parent.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	218	None	replace
587	[BUG]  [BUGGY]  Context.checkState(parent.getType()!=  Token.FUNCTION);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(parent.getType()!=  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(parent.getType()!=  Token.FUNCTION);	  Context.checkState(n.getType()!=    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	150	None	replace
588	[BUG]  [BUGGY]  Context.checkState(n.getType()  >=  Token.FUNCTION);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  >=  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  >=  Token.FUNCTION);	  Context.checkState(n.getType()!=    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	150	None	replace
589	[BUG]  [BUGGY]  Context.checkState(scope.getType()!=  Token.FUNCTION);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(scope.getType()!=  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(scope.getType()!=  Token.FUNCTION);	  Context.checkState(n.getType()!=    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	150	None	replace
590	[BUG]  [BUGGY]  Context.checkState(n.getType()  [Delete]  Token.FUNCTION);  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  [Delete]  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  [Delete]  Token.FUNCTION);	  Context.checkState(n.getType()!=    Token.FUNCTION);    	non-compiled	[CE]  	150	None	replace
591	[BUG]  [BUGGY]  Context.checkState(n.getType()  >>  Token.FUNCTION);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  >>  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  >>  Token.FUNCTION);	  Context.checkState(n.getType()!=    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	150	None	replace
592	[BUG]  [BUGGY]  Context.checkState(child.getType()!=  Token.FUNCTION);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(child.getType()!=  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(child.getType()!=  Token.FUNCTION);	  Context.checkState(n.getType()!=    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	150	None	replace
593	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isAssignmentOp(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	33	None	replace
594	[BUG]  [BUGGY]  if(NodeUtil.isFunctionAnonymous(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionAnonymous(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionAnonymous(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isAssignmentOp(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	33	None	replace
595	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isAssignmentOp(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	33	None	replace
596	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(var))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(var))  {	  if(NodeUtil.isAssignmentOp(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	33	None	replace
597	[BUG]  [BUGGY]  if(NodeUtil.isFunctionAnswer(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionAnswer(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionAnswer(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isAssignmentOp(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	33	None	replace
598	[BUG]  [BUGGY]  Node  c  =  node.getLastChild();  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  node.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  node.getLastChild();	  Node    c    =    node.getFirstChild();    	non-compiled	[CE]  orphaned  case	65	None	replace
599	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isAssignmentOp(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	118	None	replace
600	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isAssignmentOp(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	118	None	replace
601	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isAssignmentOp(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	118	None	replace
602	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)&&  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isExpressionNode(parent)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	184	None	replace
603	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isExpressionNode(parent)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	184	None	replace
604	[BUG]  [BUGGY]  Node  c  =  n.getNext()  ||  parent.getType()  ==  Token.FUNCTION;  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.getNext()  ||  parent.getType()  ==  Token.FUNCTION;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getNext()  ||  parent.getType()  ==  Token.FUNCTION;	  Node    c    =    n.getNext();    	non-compiled	[CE]  orphaned  case	63	None	replace
605	[BUG]  [BUGGY]  Node  c  =  n.getNext()  ||  parent.getType()!=  Token.FUNCTION;  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.getNext()  ||  parent.getType()!=  Token.FUNCTION;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getNext()  ||  parent.getType()!=  Token.FUNCTION;	  Node    c    =    n.getNext();    	non-compiled	[CE]  orphaned  case	63	None	replace
606	[BUG]  [BUGGY]  Node  c  =  n.getNext()  ||  type  ==  Token.FUNCTION;  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.getNext()  ||  type  ==  Token.FUNCTION;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getNext()  ||  type  ==  Token.FUNCTION;	  Node    c    =    n.getNext();    	non-compiled	[CE]  orphaned  case	63	None	replace
607	[BUG]  [BUGGY]  Node  n  =  child.getLastChild();  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  child.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  child.getLastChild();	  Node    n    =    scope.getLastChild();    	non-compiled	[CE]  orphaned  case	1	None	replace
608	[BUG]  [BUGGY]  Context.reportError( "Unused  scope: "  +  n.getFirstChild().getString());  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.reportError( "Unused  scope: "  +  n.getFirstChild().getString());  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.reportError( "Unused  scope: "  +  n.getFirstChild().getString());	  Context.reportCodeChange();    	non-compiled	[CE]  orphaned  case	141	None	replace
609	[BUG]  [BUGGY]  Context.report(JSError.make(n,  parent,  type));  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.report(JSError.make(n,  parent,  type));  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.report(JSError.make(n,  parent,  type));	  Context.reportCodeChange();    	non-compiled	[CE]  orphaned  case	141	None	replace
610	[BUG]  [BUGGY]  Context.reportError( "Unused  scope: "  +  n.getType());  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.reportError( "Unused  scope: "  +  n.getType());  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.reportError( "Unused  scope: "  +  n.getType());	  Context.reportCodeChange();    	non-compiled	[CE]  orphaned  case	141	None	replace
611	[BUG]  [BUGGY]  Context.report(JSError.make(n,  parent,  FUNCTION_EXPR_RESULT));  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.report(JSError.make(n,  parent,  FUNCTION_EXPR_RESULT));  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.report(JSError.make(n,  parent,  FUNCTION_EXPR_RESULT));	  Context.reportCodeChange();    	non-compiled	[CE]  orphaned  case	141	None	replace
612	[BUG]  [BUGGY]  Context.report(JSError.make(n,  parent,  scope));  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.report(JSError.make(n,  parent,  scope));  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.report(JSError.make(n,  parent,  scope));	  Context.reportCodeChange();    	non-compiled	[CE]  orphaned  case	141	None	replace
613	[BUG]  [BUGGY]  Context.report(n.getType());  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.report(n.getType());  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.report(n.getType());	  Context.reportCodeChange();    	non-compiled	[CE]  orphaned  case	141	None	replace
614	[BUG]  [BUGGY]  Context.reportError( "Unused  scope: "  +  n.getString());  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.reportError( "Unused  scope: "  +  n.getString());  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.reportError( "Unused  scope: "  +  n.getString());	  Context.reportCodeChange();    	non-compiled	[CE]  orphaned  case	141	None	replace
615	[BUG]  [BUGGY]  Context.report(n.getFirstChild().getString(),  type);  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.report(n.getFirstChild().getString(),  type);  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.report(n.getFirstChild().getString(),  type);	  Context.reportCodeChange();    	non-compiled	[CE]  orphaned  case	141	None	replace
616	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	189	None	replace
617	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n)  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n)  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n)	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	189	None	replace
618	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	189	None	replace
619	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	189	None	replace
620	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	189	None	replace
621	[BUG]  [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	189	None	replace
622	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n)  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n)  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n)	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	189	None	replace
623	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	189	None	replace
624	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	86	None	replace
625	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	86	None	replace
626	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	86	None	replace
627	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild()!=  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild()!=  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild()!=  null  ||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	86	None	replace
628	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	86	None	replace
629	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isAssignmentOp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	97	None	replace
630	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isAssignmentOp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	97	None	replace
631	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isAssignmentOp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	97	None	replace
632	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)	  if(NodeUtil.isAssignmentOp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	97	None	replace
633	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION,  scope);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION,  scope);	  Preconditions.checkState(type    ==    Token.FUNCTION,    scope);    	non-compiled	[CE]  orphaned  case	111	None	replace
634	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION,  n);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION,  n);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION,  n);	  Preconditions.checkState(type    ==    Token.FUNCTION,    scope);    	non-compiled	[CE]  orphaned  case	111	None	replace
635	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION,  parent);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION,  parent);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION,  parent);	  Preconditions.checkState(type    ==    Token.FUNCTION,    scope);    	non-compiled	[CE]  orphaned  case	111	None	replace
636	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION,  scope,  continuations);  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION,  scope,  continuations);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION,  scope,  continuations);	  Preconditions.checkState(type    ==    Token.FUNCTION,    scope);    	non-compiled	[CE]  orphaned  case	111	None	replace
637	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isPropertyAssign(var))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isPropertyAssign(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isPropertyAssign(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isPropertyAssign(var))    {    	non-compiled	[CE]  	30	None	replace
638	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(var))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isPropertyAssign(var))    {    	non-compiled	[CE]  	30	None	replace
639	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(var))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isPropertyAssign(var))    {    	non-compiled	[CE]  	30	None	replace
640	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(var,  type))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(var,  type))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(var,  type))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isPropertyAssign(var))    {    	non-compiled	[CE]  	30	None	replace
641	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(var))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isPropertyAssign(var))    {    	non-compiled	[CE]  	30	None	replace
642	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	87	None	replace
643	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	87	None	replace
644	[BUG]  [BUGGY]  Node  c  =  parent.getCurrentNode();  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  parent.getCurrentNode();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  parent.getCurrentNode();	  Node    c    =    n.getCurrentNode();    	non-compiled	[CE]  orphaned  case	223	None	replace
645	[BUG]  [BUGGY]  Node  c  =  n.getCurrentChild();  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.getCurrentChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getCurrentChild();	  Node    c    =    n.getCurrentNode();    	non-compiled	[CE]  orphaned  case	223	None	replace
646	[BUG]  [BUGGY]  Node  c  =  n.getFunctionNode();  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.getFunctionNode();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getFunctionNode();	  Node    c    =    n.getCurrentNode();    	non-compiled	[CE]  orphaned  case	223	None	replace
647	[BUG]  [BUGGY]  Node  c  =  node.getCurrentNode();  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  node.getCurrentNode();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  node.getCurrentNode();	  Node    c    =    n.getCurrentNode();    	non-compiled	[CE]  orphaned  case	223	None	replace
648	[BUG]  [BUGGY]  if(NodeUtil.isFunctionAnonymous(n)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionAnonymous(n)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionAnonymous(n)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isExpressionNode(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	55	None	replace
649	[BUG]  [BUGGY]  if(NodeUtil.isFunction(n)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunction(n)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunction(n)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isExpressionNode(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	55	None	replace
650	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  type  ==  Token.VAR)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  type  ==  Token.VAR)  {	  if(NodeUtil.isExpressionNode(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	55	None	replace
651	[BUG]  [BUGGY]  if(NodeUtil.isFunction(n)&&  type  ==  Token.FUNCTION)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunction(n)&&  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunction(n)&&  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isExpressionNode(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	55	None	replace
652	[BUG]  [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION);	  Preconditions.checkArgument(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	251	None	replace
653	[BUG]  [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR);	  Preconditions.checkArgument(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	251	None	replace
654	[BUG]  [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);	  Preconditions.checkArgument(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	251	None	replace
655	[BUG]  [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME);	  Preconditions.checkArgument(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	251	None	replace
656	[BUG]  [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION,  type);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION,  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION,  type);	  Preconditions.checkArgument(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	251	None	replace
657	[BUG]  [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().equals( "function "));  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().equals( "function "));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().equals( "function "));	  Preconditions.checkArgument(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	251	None	replace
658	[BUG]  [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION,  scope);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION,  scope);	  Preconditions.checkArgument(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	251	None	replace
659	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	113	None	replace
660	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	113	None	replace
661	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	113	None	replace
662	[BUG]  [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isConstructorDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	113	None	replace
663	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isExpressionNode(parent))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isExpressionNode(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isExpressionNode(parent))  {	  if(NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	176	None	replace
664	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isExpressionNode(parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isExpressionNode(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isExpressionNode(parent))  {	  if(NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	176	None	replace
665	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isExpressionNode(parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isExpressionNode(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  NodeUtil.isExpressionNode(parent))  {	  if(NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	176	None	replace
666	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  n.getFirstChild().getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  n.getFirstChild().getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  n.getFirstChild().getType()  ==  Token.VAR);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	252	None	replace
667	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()!=  Token.VAR);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()!=  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()!=  Token.VAR);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	252	None	replace
668	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getType()  ==  Token.VAR);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	252	None	replace
669	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.VAR);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	252	None	replace
670	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getLastChild().getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getLastChild().getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getLastChild().getType()  ==  Token.VAR);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	252	None	replace
671	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.VAR);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	252	None	replace
672	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.VAR);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	252	None	replace
673	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  &&  n.getFirstChild().getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  &&  n.getFirstChild().getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()!=  Token.FUNCTION  &&  n.getFirstChild().getType()  ==  Token.VAR);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	252	None	replace
674	[BUG]  [BUGGY]  var  =  scope.getVar(n.getfirstChild().getString());  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getfirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getfirstChild().getString());	  var    =    scope.getVar(n.getFirstChild().getString()    +    1);    	non-compiled	[CE]  orphaned  case	83	None	replace
675	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)||    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	29	None	replace
676	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)||    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	29	None	replace
677	[BUG]  [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isConstructorDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)||    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	29	None	replace
678	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	21	None	replace
679	[BUG]  [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	21	None	replace
680	[BUG]  [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	21	None	replace
681	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	21	None	replace
682	[BUG]  [BUGGY]  if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	21	None	replace
683	[BUG]  [BUGGY]  if(scope  ==  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope  ==  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope  ==  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	21	None	replace
684	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)&&  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)&&  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)&&  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isVar(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	42	None	replace
685	[BUG]  [BUGGY]  if(NodeUtil.isName(n)&&  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)&&  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)&&  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isVar(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	42	None	replace
686	[BUG]  [BUGGY]  if(NodeUtil.isFunction(n)&&  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunction(n)&&  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunction(n)&&  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isVar(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	42	None	replace
687	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isExpressionNode(parent))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isExpressionNode(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isExpressionNode(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	244	None	replace
688	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(scope))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	244	None	replace
689	[BUG]  [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	244	None	replace
690	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	244	None	replace
691	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(parent))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	244	None	replace
692	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	244	None	replace
693	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(scope))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	244	None	replace
694	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(n,  scope))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(n,  scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(n,  scope))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	197	None	replace
695	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	197	None	replace
696	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	197	None	replace
697	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(n)&&  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	197	None	replace
698	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)&&  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	197	None	replace
699	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)&&  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	197	None	replace
700	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  scope.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  scope.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  scope.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	53	None	replace
701	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.VAR)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	53	None	replace
702	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type!=  Token.VAR)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type!=  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  type!=  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	53	None	replace
703	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	36	None	replace
704	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	36	None	replace
705	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getType()!=  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getType()!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getType()!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	36	None	replace
706	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getParent().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getParent().getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getParent().getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	36	None	replace
707	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  &&  n.getFirstChild().getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  &&  n.getFirstChild().getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  &&  n.getFirstChild().getType()  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    n.getFirstChild().getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	69	None	replace
708	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  n.getFirstChild().getType()!=  Token.FUNCTION);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  n.getFirstChild().getType()!=  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  ||  n.getFirstChild().getType()!=  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    n.getFirstChild().getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	69	None	replace
709	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    n.getFirstChild().getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	69	None	replace
710	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  parent.getFirstChild().getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  parent.getFirstChild().getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  ||  parent.getFirstChild().getType()  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    n.getFirstChild().getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	69	None	replace
711	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.VAR  ||  n.getFirstChild().getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()!=  Token.VAR  ||  n.getFirstChild().getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()!=  Token.VAR  ||  n.getFirstChild().getType()  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    n.getFirstChild().getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	69	None	replace
712	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.VAR  &&  n.getFirstChild().getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()!=  Token.VAR  &&  n.getFirstChild().getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()!=  Token.VAR  &&  n.getFirstChild().getType()  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    n.getFirstChild().getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	69	None	replace
713	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  n.getLastChild().getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  n.getLastChild().getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  ||  n.getLastChild().getType()  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    n.getFirstChild().getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	69	None	replace
714	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.VAR  ||  n.getFirstChild().getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.VAR  ||  n.getFirstChild().getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.VAR  ||  n.getFirstChild().getType()  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    n.getFirstChild().getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	69	None	replace
715	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  n.getFirstChild().getString().equals( "function   "));  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  n.getFirstChild().getString().equals( "function   "));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  n.getFirstChild().getString().equals( "function   "));	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString().equals(   "function   "));    	non-compiled	[CE]  orphaned  case	50	None	replace
716	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getLastChild().getString().equals( "function "));  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getLastChild().getString().equals( "function "));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getLastChild().getString().equals( "function "));	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString().equals(   "function   "));    	non-compiled	[CE]  orphaned  case	50	None	replace
717	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  n.getFirstChild().getString().equals( "function "));  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  n.getFirstChild().getString().equals( "function "));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  n.getFirstChild().getString().equals( "function "));	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString().equals(   "function   "));    	non-compiled	[CE]  orphaned  case	50	None	replace
718	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getString().equals( "function "));  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getString().equals( "function "));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getString().equals( "function "));	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString().equals(   "function   "));    	non-compiled	[CE]  orphaned  case	50	None	replace
719	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  &&  n.getFirstChild().getString().equals( "function   "));  [CE]  orphaned  case  [FE]                                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  &&  n.getFirstChild().getString().equals( "function   "));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()!=  Token.FUNCTION  &&  n.getFirstChild().getString().equals( "function   "));	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString().equals(   "function   "));    	non-compiled	[CE]  orphaned  case	50	None	replace
720	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().equals( "function "));  [CE]  orphaned  case  [FE]                                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().equals( "function "));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().equals( "function "));	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString().equals(   "function   "));    	non-compiled	[CE]  orphaned  case	50	None	replace
721	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n,  scope))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n,  scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n,  scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n,    scope))    {    	non-compiled	[CE]  	133	None	replace
722	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent,  scope))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent,  scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent,  scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n,    scope))    {    	non-compiled	[CE]  	133	None	replace
723	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n,  scope))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n,  scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n,  scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n,    scope))    {    	non-compiled	[CE]  	133	None	replace
724	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n,  scope))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n,  scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n,  scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n,    scope))    {    	non-compiled	[CE]  	133	None	replace
725	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n,  scope))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n,  scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n,  scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n,    scope))    {    	non-compiled	[CE]  	133	None	replace
726	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  NodeUtil.isFunctionDeclaration(n,  scope))  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  NodeUtil.isFunctionDeclaration(n,  scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)||  NodeUtil.isFunctionDeclaration(n,  scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n,    scope))    {    	non-compiled	[CE]  	133	None	replace
727	[BUG]  [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  scope))  {  [CE]  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n,    scope))    {    	non-compiled	[CE]  	133	None	replace
728	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n,  parent))  {  [CE]  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n,  parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n,    scope))    {    	non-compiled	[CE]  	133	None	replace
729	[BUG]  [BUGGY]  if(NodeUtil.isFunctionObjectCall(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionObjectCall(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionObjectCall(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isExpressionNode(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	31	None	replace
730	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isExpressionNode(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	31	None	replace
731	[BUG]  [BUGGY]  var  =  node.getVar(n.getFirstChild().getString());  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  node.getVar(n.getFirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  node.getVar(n.getFirstChild().getString());	  var    =    parent.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	221	None	replace
732	[BUG]  [BUGGY]  var  =  n.getFirstChild().getVar(parent.getString());  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  n.getFirstChild().getVar(parent.getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  n.getFirstChild().getVar(parent.getString());	  var    =    parent.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	221	None	replace
733	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  parent.getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	23	None	replace
734	[BUG]  [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	23	None	replace
735	[BUG]  [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	23	None	replace
736	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	23	None	replace
737	[BUG]  [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	23	None	replace
738	[BUG]  [BUGGY]  if(scope  ==  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope  ==  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope  ==  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	23	None	replace
739	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION  ||  parent!=  null)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION  ||  parent!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION  ||  parent!=  null)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    parent!=    null)    {    	non-compiled	[CE]  	235	None	replace
740	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  parent.getFirstChild()!=  null)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  parent.getFirstChild()!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  parent.getFirstChild()!=  null)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    parent!=    null)    {    	non-compiled	[CE]  	235	None	replace
741	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  &&  parent!=  null)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  &&  parent!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  &&  parent!=  null)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    parent!=    null)    {    	non-compiled	[CE]  	235	None	replace
742	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION  ||  parent!=  null)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION  ||  parent!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION  ||  parent!=  null)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    parent!=    null)    {    	non-compiled	[CE]  	235	None	replace
743	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION  ||  parent!=  null)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION  ||  parent!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION  ||  parent!=  null)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    parent!=    null)    {    	non-compiled	[CE]  	235	None	replace
744	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  NodeUtil.isFunctionDeclaration(n,  scope))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  NodeUtil.isFunctionDeclaration(n,  scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)&&  NodeUtil.isFunctionDeclaration(n,  scope))  {	  if(NodeUtil.isExpressionNode(parent)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	198	None	replace
745	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||!NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||!NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||!NodeUtil.isFunctionDeclaration(parent))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||!NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	238	None	replace
746	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||!NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||!NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||!NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||!NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	238	None	replace
747	[BUG]  [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||!NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||!NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||!NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||!NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	238	None	replace
748	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&!NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&!NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&!NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||!NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	238	None	replace
749	[BUG]  [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||!NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||!NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||!NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||!NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	238	None	replace
750	[BUG]  [BUGGY]  if(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(n.getType()    ==    Token.FUNCTION    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	163	None	replace
751	[BUG]  [BUGGY]  if(n.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(n.getType()    ==    Token.FUNCTION    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	163	None	replace
752	[BUG]  [BUGGY]  if(n.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(n.getType()    ==    Token.FUNCTION    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	163	None	replace
753	[BUG]  [BUGGY]  if(scope.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(n.getType()    ==    Token.FUNCTION    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	163	None	replace
754	[BUG]  [BUGGY]  if(parent.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(parent.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(parent.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(n.getType()    ==    Token.FUNCTION    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	163	None	replace
755	[BUG]  [BUGGY]  if(scope.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(n.getType()    ==    Token.FUNCTION    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	163	None	replace
756	[BUG]  [BUGGY]  if(n.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(n.getType()    ==    Token.FUNCTION    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	163	None	replace
757	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.EXPR_RESULT);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.EXPR_RESULT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.EXPR_RESULT);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  orphaned  case	151	None	replace
758	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.EXPR_RESULT);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.EXPR_RESULT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.EXPR_RESULT);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  orphaned  case	151	None	replace
759	[BUG]  [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  orphaned  case	151	None	replace
760	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT,  scope);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT,  scope);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  orphaned  case	151	None	replace
761	[BUG]  [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  orphaned  case	151	None	replace
762	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.EXPR_RESULT);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.EXPR_RESULT);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  orphaned  case	151	None	replace
763	[BUG]  [BUGGY]  Context.checkState(scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  orphaned  case	151	None	replace
764	[BUG]  [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  &&  type  ==  Token.EXPR_RESULT);  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  &&  type  ==  Token.EXPR_RESULT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()!=  Token.FUNCTION  &&  type  ==  Token.EXPR_RESULT);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  orphaned  case	151	None	replace
765	[BUG]  [BUGGY]  Preconditions.checkState(type  >=  Token.FUNCTION);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  >=  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  >=  Token.FUNCTION);	  Preconditions.checkState(type!=    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	106	None	replace
766	[BUG]  [BUGGY]  Preconditions.checkState(type!=  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type!=  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type!=  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);	  Preconditions.checkState(type!=    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	106	None	replace
767	[BUG]  [BUGGY]  var  =  node.getVar(n.getLastChild().getString());  [CE]  orphaned  case  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  node.getVar(n.getLastChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  node.getVar(n.getLastChild().getString());	  var    =    parent.getVar(n.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	215	None	replace
768	[BUG]  [BUGGY]  var  =  module.getVar(n.getLastChild().getString());  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  module.getVar(n.getLastChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  module.getVar(n.getLastChild().getString());	  var    =    parent.getVar(n.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	215	None	replace
769	[BUG]  [BUGGY]  var  =  n.getLastChild().getString();  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  n.getLastChild().getString();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  n.getLastChild().getString();	  var    =    parent.getVar(n.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	215	None	replace
770	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	187	None	replace
771	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()!=  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	187	None	replace
772	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	187	None	replace
773	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	187	None	replace
774	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	187	None	replace
775	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	187	None	replace
776	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	187	None	replace
777	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	210	None	replace
778	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(parent))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	210	None	replace
779	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	210	None	replace
780	[BUG]  [BUGGY]  if(scope  ==  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope  ==  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope  ==  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	210	None	replace
781	[BUG]  [BUGGY]  n  =  node.getLastChild();  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  node.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  node.getLastChild();	  n    =    n.getLastChild();    	non-compiled	[CE]  orphaned  case	121	None	replace
782	[BUG]  [BUGGY]  n  =  n.getLastChild().getString();  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.getLastChild().getString();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getLastChild().getString();	  n    =    n.getLastChild();    	non-compiled	[CE]  orphaned  case	121	None	replace
783	[BUG]  [BUGGY]  n  =  n.getLastChild().getNext();  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.getLastChild().getNext();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getLastChild().getNext();	  n    =    n.getLastChild();    	non-compiled	[CE]  orphaned  case	121	None	replace
784	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	6	None	replace
785	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()!=  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	6	None	replace
786	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	6	None	replace
787	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	6	None	replace
788	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	6	None	replace
789	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	6	None	replace
790	[BUG]  [BUGGY]  Node  c  =  n.getLastChild().getNext();  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.getLastChild().getNext();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getLastChild().getNext();	  Node    c    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	224	None	replace
791	[BUG]  [BUGGY]  Node  c  =  parent.getFirstChild().getNext();  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  parent.getFirstChild().getNext();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  parent.getFirstChild().getNext();	  Node    c    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	224	None	replace
792	[BUG]  [BUGGY]  Node  c  =  n.getFirstChild().getString();  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.getFirstChild().getString();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getFirstChild().getString();	  Node    c    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	224	None	replace
793	[BUG]  [BUGGY]  Node  c  =  n.getFirstChild().getLastChild();  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.getFirstChild().getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getFirstChild().getLastChild();	  Node    c    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	224	None	replace
794	[BUG]  [BUGGY]  Node  c  =  n.getFirstChild().getNext()  ||  parent.getType()  ==  Token.FUNCTION;  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.getFirstChild().getNext()  ||  parent.getType()  ==  Token.FUNCTION;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getFirstChild().getNext()  ||  parent.getType()  ==  Token.FUNCTION;	  Node    c    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	224	None	replace
795	[BUG]  [BUGGY]  Node  c  =  n.getFirstChild().getNext()  ||  type  ==  Token.FUNCTION;  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.getFirstChild().getNext()  ||  type  ==  Token.FUNCTION;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getFirstChild().getNext()  ||  type  ==  Token.FUNCTION;	  Node    c    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	224	None	replace
796	[BUG]  [BUGGY]  Node  c  =  n.getFirstChild().getParent();  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.getFirstChild().getParent();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getFirstChild().getParent();	  Node    c    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	224	None	replace
797	[BUG]  [BUGGY]  Node  n  =  parent.removeFirstChild();  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  parent.removeFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  parent.removeFirstChild();	  Node    n    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	266	None	replace
798	[BUG]  [BUGGY]  Node  n  =  parent.replaceChild(n,  new  Node(Token.FUNCTION));  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  parent.replaceChild(n,  new  Node(Token.FUNCTION));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  parent.replaceChild(n,  new  Node(Token.FUNCTION));	  Node    n    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	266	None	replace
799	[BUG]  [BUGGY]  Node  n  =  scope.removeFirstChild();  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  scope.removeFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  scope.removeFirstChild();	  Node    n    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	266	None	replace
800	[BUG]  [BUGGY]  Node  n  =  parent.replaceChild(n,  var);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  parent.replaceChild(n,  var);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  parent.replaceChild(n,  var);	  Node    n    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	266	None	replace
801	[BUG]  [BUGGY]  var  =  scope.getVar(n.getFirstChild(),  n.getString());  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getFirstChild(),  n.getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getFirstChild(),  n.getString());	  var    =    scope.getVar(n.getLastChild(),    n.getString());    	non-compiled	[CE]  orphaned  case	181	None	replace
802	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n.getFirstChild().getString());  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n.getFirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  n.getFirstChild().getString());	  var    =    scope.getVar(n.getLastChild(),    n.getString());    	non-compiled	[CE]  orphaned  case	181	None	replace
803	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n.getString(),  type);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n.getString(),  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  n.getString(),  type);	  var    =    scope.getVar(n.getLastChild(),    n.getString());    	non-compiled	[CE]  orphaned  case	181	None	replace
804	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  parent.getString());  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild(),  parent.getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  parent.getString());	  var    =    scope.getVar(n.getLastChild(),    n.getString());    	non-compiled	[CE]  orphaned  case	181	None	replace
805	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n.getString()  +  1);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n.getString()  +  1);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  n.getString()  +  1);	  var    =    scope.getVar(n.getLastChild(),    n.getString());    	non-compiled	[CE]  orphaned  case	181	None	replace
806	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isConstructorOp(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	99	None	replace
807	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructorOp(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructorOp(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructorOp(parent)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isConstructorOp(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	99	None	replace
808	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isConstructorOp(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isConstructorOp(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isConstructorOp(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isConstructorOp(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	99	None	replace
809	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isConstructorOp(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	99	None	replace
810	[BUG]  [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isConstructorOp(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	99	None	replace
811	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isConstructorOp(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isConstructorOp(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isConstructorOp(n)&&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isConstructorOp(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	99	None	replace
812	[BUG]  [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isConstructorOp(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	99	None	replace
813	[BUG]  [BUGGY]  if(NodeUtil.isFunction(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunction(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunction(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isVar(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	120	None	replace
814	[BUG]  [BUGGY]  if(NodeUtil.isVar(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isVar(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	120	None	replace
815	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isVar(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	120	None	replace
816	[BUG]  [BUGGY]  var  =  scope.getVar(n.getFirstChild(),  fnScope);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getFirstChild(),  fnScope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getFirstChild(),  fnScope);	  var    =    scope.getVar(n.getLastChild(),    fnScope);    	non-compiled	[CE]  orphaned  case	180	None	replace
817	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  fnScope,  type);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild(),  fnScope,  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  fnScope,  type);	  var    =    scope.getVar(n.getLastChild(),    fnScope);    	non-compiled	[CE]  orphaned  case	180	None	replace
818	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  fnScope,  parent);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild(),  fnScope,  parent);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  fnScope,  parent);	  var    =    scope.getVar(n.getLastChild(),    fnScope);    	non-compiled	[CE]  orphaned  case	180	None	replace
819	[BUG]  [BUGGY]  var  =  scope.getVar(n.getString(),  fnScope);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getString(),  fnScope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getString(),  fnScope);	  var    =    scope.getVar(n.getLastChild(),    fnScope);    	non-compiled	[CE]  orphaned  case	180	None	replace
820	[BUG]  [BUGGY]  var  =  scope.getVar(parent.getLastChild(),  fnScope);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(parent.getLastChild(),  fnScope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(parent.getLastChild(),  fnScope);	  var    =    scope.getVar(n.getLastChild(),    fnScope);    	non-compiled	[CE]  orphaned  case	180	None	replace
821	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  fnScope,  nameNode);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild(),  fnScope,  nameNode);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  fnScope,  nameNode);	  var    =    scope.getVar(n.getLastChild(),    fnScope);    	non-compiled	[CE]  orphaned  case	180	None	replace
822	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionPrototype(parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionPrototype(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionPrototype(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionPrototype(parent))    {    	non-compiled	[CE]  	177	None	replace
823	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(scope))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionPrototype(parent))    {    	non-compiled	[CE]  	177	None	replace
824	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionPrototype(parent))    {    	non-compiled	[CE]  	177	None	replace
825	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(n,  parent))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(n,  parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionPrototype(parent))    {    	non-compiled	[CE]  	177	None	replace
826	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionPrototype(parent))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionPrototype(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionPrototype(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionPrototype(parent))    {    	non-compiled	[CE]  	177	None	replace
827	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionPrototype(parent))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionPrototype(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionPrototype(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionPrototype(parent))    {    	non-compiled	[CE]  	177	None	replace
828	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionPrototype(parent))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionPrototype(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  NodeUtil.isFunctionPrototype(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionPrototype(parent))    {    	non-compiled	[CE]  	177	None	replace
829	[BUG]  [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionPrototype(parent))  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionPrototype(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionPrototype(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionPrototype(parent))    {    	non-compiled	[CE]  	177	None	replace
830	[BUG]  [BUGGY]  Node  c  =  parent.getLastChild();  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  parent.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  parent.getLastChild();	  Node    c    =    parent.getFirstChild();    	non-compiled	[CE]  orphaned  case	62	None	replace
831	[BUG]  [BUGGY]  Node  scope  =  getFunctionScope(n.getFirstChild(),  parent);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  getFunctionScope(n.getFirstChild(),  parent);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getFunctionScope(n.getFirstChild(),  parent);	  Node    scope    =    getFunctionScope(n.getFirstChild());    	non-compiled	[CE]  orphaned  case	139	None	replace
832	[BUG]  [BUGGY]  Node  scope  =  getFunctionScope(n.getFirstChild(),  scope);  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  getFunctionScope(n.getFirstChild(),  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getFunctionScope(n.getFirstChild(),  scope);	  Node    scope    =    getFunctionScope(n.getFirstChild());    	non-compiled	[CE]  orphaned  case	139	None	replace
833	[BUG]  [BUGGY]  Node  scope  =  getFunctionScope(parent.getFirstChild());  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  getFunctionScope(parent.getFirstChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getFunctionScope(parent.getFirstChild());	  Node    scope    =    getFunctionScope(n.getFirstChild());    	non-compiled	[CE]  orphaned  case	139	None	replace
834	[BUG]  [BUGGY]  Node  scope  =  getFunctionScope(n.getFirstChild(),  type);  [CE]  orphaned  case  [FE]                                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  getFunctionScope(n.getFirstChild(),  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getFunctionScope(n.getFirstChild(),  type);	  Node    scope    =    getFunctionScope(n.getFirstChild());    	non-compiled	[CE]  orphaned  case	139	None	replace
835	[BUG]  [BUGGY]  Node  scope  =  getFunctionScope(n.getNext());  [CE]  orphaned  case  [FE]                                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  getFunctionScope(n.getNext());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getFunctionScope(n.getNext());	  Node    scope    =    getFunctionScope(n.getFirstChild());    	non-compiled	[CE]  orphaned  case	139	None	replace
836	[BUG]  [BUGGY]  Node  scope  =  getFunctionScope(n.getString());  [CE]  orphaned  case  [FE]                                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  getFunctionScope(n.getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getFunctionScope(n.getString());	  Node    scope    =    getFunctionScope(n.getFirstChild());    	non-compiled	[CE]  orphaned  case	139	None	replace
837	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())    ==    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	192	None	replace
838	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())    ==    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	192	None	replace
839	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()    ==    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	225	None	replace
840	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()  ==  null  ||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()  ==  null  ||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()  ==  null  ||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()    ==    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	225	None	replace
841	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.EXPR_RESULT);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.EXPR_RESULT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.EXPR_RESULT);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  orphaned  case	47	None	replace
842	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  orphaned  case	47	None	replace
843	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  orphaned  case	47	None	replace
844	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.EXPR_RESULT);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.EXPR_RESULT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.EXPR_RESULT);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  orphaned  case	47	None	replace
845	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT,  scope);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT,  scope);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  orphaned  case	47	None	replace
846	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.EXPR_RESULT);  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  orphaned  case	47	None	replace
847	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  orphaned  case	47	None	replace
848	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  &&  type  ==  Token.EXPR_RESULT);  [CE]  orphaned  case  [FE]                                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  &&  type  ==  Token.EXPR_RESULT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()!=  Token.FUNCTION  &&  type  ==  Token.EXPR_RESULT);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  orphaned  case	47	None	replace
849	[BUG]  [BUGGY]  Var  var  =  scope.getVar(n.getFirstChild().getString()  +  1);  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Var  var  =  scope.getVar(n.getFirstChild().getString()  +  1);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Var  var  =  scope.getVar(n.getFirstChild().getString()  +  1);	  Var    var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	145	None	replace
850	[BUG]  [BUGGY]  Var  var  =  scope.getVar(parent.getFirstChild().getString());  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Var  var  =  scope.getVar(parent.getFirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Var  var  =  scope.getVar(parent.getFirstChild().getString());	  Var    var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	145	None	replace
851	[BUG]  [BUGGY]  Var  var  =  scope.getVar(n.getFirstChild().getString(),  type);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Var  var  =  scope.getVar(n.getFirstChild().getString(),  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Var  var  =  scope.getVar(n.getFirstChild().getString(),  type);	  Var    var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	145	None	replace
852	[BUG]  [BUGGY]  Var  var  =  scope.getVar(n.getFirstChild().getType());  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Var  var  =  scope.getVar(n.getFirstChild().getType());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Var  var  =  scope.getVar(n.getFirstChild().getType());	  Var    var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	145	None	replace
853	[BUG]  [BUGGY]  Var  var  =  parent.getVar(n.getFirstChild().getString());  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Var  var  =  parent.getVar(n.getFirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Var  var  =  parent.getVar(n.getFirstChild().getString());	  Var    var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	145	None	replace
854	[BUG]  [BUGGY]  Var  var  =  scope.getVar(n.getFirstChild().getString())+  1;  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Var  var  =  scope.getVar(n.getFirstChild().getString())+  1;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Var  var  =  scope.getVar(n.getFirstChild().getString())+  1;	  Var    var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	145	None	replace
855	[BUG]  [BUGGY]  Var  var  =  scope.getVar(n.getNext().getString());  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Var  var  =  scope.getVar(n.getNext().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Var  var  =  scope.getVar(n.getNext().getString());	  Var    var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	145	None	replace
856	[BUG]  [BUGGY]  Context.checkState(scope.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(scope.getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(scope.getType()  ==  Token.FUNCTION);	  Context.checkState(parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	203	None	replace
857	[BUG]  [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getType()  ==  Token.FUNCTION);	  Context.checkState(parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	203	None	replace
858	[BUG]  [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getString().equals( "function "));  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getString().equals( "function "));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getString().equals( "function "));	  Context.checkState(parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	203	None	replace
859	[BUG]  [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getType()  ==  Token.VAR);	  Context.checkState(parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	203	None	replace
860	[BUG]  [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().equals( "function "));  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().equals( "function "));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().equals( "function "));	  Context.checkState(parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	203	None	replace
861	[BUG]  [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.FUNCTION);	  Context.checkState(parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	203	None	replace
862	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.VAR  ||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.VAR  ||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.VAR  ||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	41	None	replace
863	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getType()!=  Token.VAR)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getType()!=  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getType()!=  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	41	None	replace
864	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getParent().getType()  ==  Token.VAR)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getParent().getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getParent().getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	41	None	replace
865	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild().getType()  ==  Token.VAR)  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild().getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild().getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	41	None	replace
866	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  scope.getType()  ==  Token.VAR)  {  [CE]  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  scope.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)&&  scope.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	41	None	replace
867	[BUG]  [BUGGY]  n  =  parent.getParent();  [CE]  orphaned  case  [FE]                                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  parent.getParent();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  parent.getParent();	  n    =    n.getParent();    	non-compiled	[CE]  orphaned  case	126	None	replace
868	[BUG]  [BUGGY]  n  =  n.getPrevious();  [CE]  orphaned  case  [FE]                                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.getPrevious();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getPrevious();	  n    =    n.getParent();    	non-compiled	[CE]  orphaned  case	126	None	replace
869	[BUG]  [BUGGY]  n  =  n.getString();  [CE]  orphaned  case  [FE]                                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.getString();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getString();	  n    =    n.getParent();    	non-compiled	[CE]  orphaned  case	126	None	replace
870	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	233	None	replace
871	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	233	None	replace
872	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	233	None	replace
873	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	233	None	replace
874	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	233	None	replace
875	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	233	None	replace
876	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)||  type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	233	None	replace
877	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	233	None	replace
878	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent)&&  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent)&&  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent)&&  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	209	None	replace
879	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	209	None	replace
880	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()!=  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	209	None	replace
881	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	209	None	replace
882	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	209	None	replace
883	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	209	None	replace
884	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	155	None	replace
885	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	155	None	replace
886	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	155	None	replace
887	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	155	None	replace
888	[BUG]  [BUGGY]  Preconditions.checkState(type!=  Token.FUNCTION  ||  type  ==  Token.CATCH);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type!=  Token.FUNCTION  ||  type  ==  Token.CATCH);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type!=  Token.FUNCTION  ||  type  ==  Token.CATCH);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.CATCH);    	non-compiled	[CE]  orphaned  case	265	None	replace
889	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  &&  type  ==  Token.CATCH);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  &&  type  ==  Token.CATCH);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  &&  type  ==  Token.CATCH);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.CATCH);    	non-compiled	[CE]  orphaned  case	265	None	replace
890	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type!=  Token.CATCH);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type!=  Token.CATCH);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type!=  Token.CATCH);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.CATCH);    	non-compiled	[CE]  orphaned  case	265	None	replace
891	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.CATCH,  scope);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.CATCH,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.CATCH,  scope);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.CATCH);    	non-compiled	[CE]  orphaned  case	265	None	replace
892	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent)&&  type  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent)&&  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent)&&  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	212	None	replace
893	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  type!=  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  type!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  type!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	212	None	replace
894	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	212	None	replace
895	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	212	None	replace
896	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	212	None	replace
897	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	212	None	replace
898	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.NAME);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.NAME);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.NAME);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	49	None	replace
899	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  scope);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  scope);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	49	None	replace
900	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	49	None	replace
901	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.NAME);  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.NAME);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.NAME);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	49	None	replace
902	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.NAME);  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.NAME);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.NAME);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	49	None	replace
903	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.NAME);  [CE]  orphaned  case  [FE]                                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.NAME);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.NAME);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	49	None	replace
904	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.NAME  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.NAME  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.NAME  ||  type  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	49	None	replace
905	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  parent);  [CE]  orphaned  case  [FE]                                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  parent);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  parent);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	49	None	replace
906	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getLastChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	119	None	replace
907	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getLastChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	119	None	replace
908	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getLastChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	119	None	replace
909	[BUG]  [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isConstructorDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getLastChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	119	None	replace
910	[BUG]  [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isGetProp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	194	None	replace
911	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isGetProp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	194	None	replace
912	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isGetProp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	194	None	replace
913	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isGetProp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	194	None	replace
914	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isVarDeclaration(parent))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isVarDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isVarDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isGetProp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	194	None	replace
915	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isGetProp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	194	None	replace
916	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isGetProp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	194	None	replace
917	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isGetProp(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent)  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isGetProp(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent)  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isGetProp(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent)	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isGetProp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	194	None	replace
918	[BUG]  [BUGGY]  Node  n  =  getFunctionNode(n.getLastChild());  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  getFunctionNode(n.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  getFunctionNode(n.getLastChild());	  Node    n    =    getFunctionNode(n.getFirstChild());    	non-compiled	[CE]  orphaned  case	174	None	replace
919	[BUG]  [BUGGY]  Node  n  =  getFunctionNode(parent.getFirstChild());  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  getFunctionNode(parent.getFirstChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  getFunctionNode(parent.getFirstChild());	  Node    n    =    getFunctionNode(n.getFirstChild());    	non-compiled	[CE]  orphaned  case	174	None	replace
920	[BUG]  [BUGGY]  Node  n  =  getFunctionNode(n.getFirstChild(),  scope);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  getFunctionNode(n.getFirstChild(),  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  getFunctionNode(n.getFirstChild(),  scope);	  Node    n    =    getFunctionNode(n.getFirstChild());    	non-compiled	[CE]  orphaned  case	174	None	replace
921	[BUG]  [BUGGY]  Node  n  =  getFunctionNode(n.getFirstChild(),  parent);  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  getFunctionNode(n.getFirstChild(),  parent);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  getFunctionNode(n.getFirstChild(),  parent);	  Node    n    =    getFunctionNode(n.getFirstChild());    	non-compiled	[CE]  orphaned  case	174	None	replace
922	[BUG]  [BUGGY]  Node  n  =  getFunctionNode(n.getNext());  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  getFunctionNode(n.getNext());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  getFunctionNode(n.getNext());	  Node    n    =    getFunctionNode(n.getFirstChild());    	non-compiled	[CE]  orphaned  case	174	None	replace
923	[BUG]  [BUGGY]  Node  n  =  getFunctionNode(n,  parent.getFirstChild());  [CE]  orphaned  case  [FE]                                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  getFunctionNode(n,  parent.getFirstChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  getFunctionNode(n,  parent.getFirstChild());	  Node    n    =    getFunctionNode(n.getFirstChild());    	non-compiled	[CE]  orphaned  case	174	None	replace
924	[BUG]  [BUGGY]  Node  n  =  getFunctionNode(n.getFirstChild(),  type);  [CE]  orphaned  case  [FE]                                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  getFunctionNode(n.getFirstChild(),  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  getFunctionNode(n.getFirstChild(),  type);	  Node    n    =    getFunctionNode(n.getFirstChild());    	non-compiled	[CE]  orphaned  case	174	None	replace
925	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()!=    Token.FUNCTION    ||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	161	None	replace
926	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  scope.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()!=    Token.FUNCTION    ||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	161	None	replace
927	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  parent.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  parent.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  parent.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()!=    Token.FUNCTION    ||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	161	None	replace
928	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION  ||  type!=  Token.VAR)  {  [CE]  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION  ||  type!=  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION  ||  type!=  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()!=    Token.FUNCTION    ||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	161	None	replace
929	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  parent.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  parent.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  parent.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()!=    Token.FUNCTION    ||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	161	None	replace
930	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  parent.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  parent.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  parent.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()!=    Token.FUNCTION    ||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	161	None	replace
931	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&!NodeUtil.isFunctionDeclaration(n));  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&!NodeUtil.isFunctionDeclaration(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&!NodeUtil.isFunctionDeclaration(n));	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||!NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	217	None	replace
932	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(parent));  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(parent));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(parent));	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||!NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	217	None	replace
933	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(n));  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(n));	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||!NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	217	None	replace
934	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(n));  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(n));	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||!NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	217	None	replace
935	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  &&  n.getFirstChild().getString()!=  null);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  &&  n.getFirstChild().getString()!=  null);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  &&  n.getFirstChild().getString()!=  null);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString()!=    null);    	non-compiled	[CE]  orphaned  case	154	None	replace
936	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getString()!=  null);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getString()!=  null);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getString()!=  null);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString()!=    null);    	non-compiled	[CE]  orphaned  case	154	None	replace
937	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getLastChild().getString()!=  null);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getLastChild().getString()!=  null);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getLastChild().getString()!=  null);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString()!=    null);    	non-compiled	[CE]  orphaned  case	154	None	replace
938	[BUG]  [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  ||  n.getFirstChild().getString()!=  null);  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  ||  n.getFirstChild().getString()!=  null);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()!=  Token.FUNCTION  ||  n.getFirstChild().getString()!=  null);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString()!=    null);    	non-compiled	[CE]  orphaned  case	154	None	replace
939	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString()  ==  null);  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString()  ==  null);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString()  ==  null);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString()!=    null);    	non-compiled	[CE]  orphaned  case	154	None	replace
940	[BUG]  [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  &&  n.getFirstChild().getString()!=  null);  [CE]  orphaned  case  [FE]                                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  &&  n.getFirstChild().getString()!=  null);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()!=  Token.FUNCTION  &&  n.getFirstChild().getString()!=  null);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString()!=    null);    	non-compiled	[CE]  orphaned  case	154	None	replace
941	[BUG]  [BUGGY]  Context.checkState(scope.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString()!=  null);  [CE]  orphaned  case  [FE]                                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(scope.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString()!=  null);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(scope.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString()!=  null);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString()!=    null);    	non-compiled	[CE]  orphaned  case	154	None	replace
942	[BUG]  [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString()!=  null);  [CE]  orphaned  case  [FE]                                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString()!=  null);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString()!=  null);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString()!=    null);    	non-compiled	[CE]  orphaned  case	154	None	replace
943	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION  ||  isRemovableVar(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION  ||  isRemovableVar(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION  ||  isRemovableVar(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    isRemovableVar(n))    {    	non-compiled	[CE]  	236	None	replace
944	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  &&  isRemovableVar(n))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  &&  isRemovableVar(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  &&  isRemovableVar(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    isRemovableVar(n))    {    	non-compiled	[CE]  	236	None	replace
945	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  isPropertyAssign(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  isPropertyAssign(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  isPropertyAssign(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    isRemovableVar(n))    {    	non-compiled	[CE]  	236	None	replace
946	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  isRemovableVar(parent))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  isRemovableVar(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  isRemovableVar(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    isRemovableVar(n))    {    	non-compiled	[CE]  	236	None	replace
947	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION  ||  isRemovableVar(n))  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION  ||  isRemovableVar(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION  ||  isRemovableVar(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    isRemovableVar(n))    {    	non-compiled	[CE]  	236	None	replace
948	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION  ||  isRemovableVar(n))  {  [CE]  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION  ||  isRemovableVar(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION  ||  isRemovableVar(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    isRemovableVar(n))    {    	non-compiled	[CE]  	236	None	replace
949	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  isPropertyAssign(var))  {  [CE]  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  isPropertyAssign(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  isPropertyAssign(var))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    isRemovableVar(n))    {    	non-compiled	[CE]  	236	None	replace
950	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  isDefinedVar(n))  {  [CE]  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  isDefinedVar(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  isDefinedVar(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    isRemovableVar(n))    {    	non-compiled	[CE]  	236	None	replace
951	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.CALL);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.CALL);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.CALL);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.CALL);    	non-compiled	[CE]  orphaned  case	220	None	replace
952	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.CALL);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.CALL);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.CALL);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.CALL);    	non-compiled	[CE]  orphaned  case	220	None	replace
953	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.CALL);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.CALL);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.CALL);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.CALL);    	non-compiled	[CE]  orphaned  case	220	None	replace
954	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.CALL);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.CALL);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.CALL);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.CALL);    	non-compiled	[CE]  orphaned  case	220	None	replace
955	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.CALL);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.CALL);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.CALL);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.CALL);    	non-compiled	[CE]  orphaned  case	220	None	replace
956	[BUG]  [BUGGY]  var  =  scope.getVar(n.getFirstChild()  +  1);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getFirstChild()  +  1);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getFirstChild()  +  1);	  var    =    scope.getVar(n.getLastChild()    +    1);    	non-compiled	[CE]  orphaned  case	104	None	replace
957	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild()).getString();  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild()).getString();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild()).getString();	  var    =    scope.getVar(n.getLastChild()    +    1);    	non-compiled	[CE]  orphaned  case	104	None	replace
958	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild();  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild();	  var    =    scope.getVar(n.getLastChild()    +    1);    	non-compiled	[CE]  	104	None	replace
959	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	48	None	replace
960	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getType()  ==  Token.FUNCTION);	  Preconditions.checkState(parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	48	None	replace
961	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild().getType()  ==  Token.VAR);	  Preconditions.checkState(parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	48	None	replace
962	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	48	None	replace
963	[BUG]  [BUGGY]  if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	25	None	replace
964	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	193	None	replace
965	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	193	None	replace
966	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n,  scope))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n,  scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n,  scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	193	None	replace
967	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	193	None	replace
968	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	193	None	replace
969	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  NodeUtil.mayHaveSideEffects  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  NodeUtil.mayHaveSideEffects  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  NodeUtil.mayHaveSideEffects	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	193	None	replace
970	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	193	None	replace
971	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  n.getFirstChild()!=  null);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  n.getFirstChild()!=  null);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  n.getFirstChild()!=  null);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild()!=    null);    	non-compiled	[CE]  orphaned  case	253	None	replace
972	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild()  ==  null);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild()  ==  null);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild()  ==  null);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild()!=    null);    	non-compiled	[CE]  orphaned  case	253	None	replace
973	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild()!=  null);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild()!=  null);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild()!=  null);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild()!=    null);    	non-compiled	[CE]  orphaned  case	253	None	replace
974	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getLastChild()!=  null);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getLastChild()!=  null);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getLastChild()!=  null);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild()!=    null);    	non-compiled	[CE]  orphaned  case	253	None	replace
975	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  n.getFirstChild()!=  null);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  n.getFirstChild()!=  null);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  n.getFirstChild()!=  null);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild()!=    null);    	non-compiled	[CE]  orphaned  case	253	None	replace
976	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  n.getFirstChild()  ==  null);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  n.getFirstChild()  ==  null);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  n.getFirstChild()  ==  null);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild()!=    null);    	non-compiled	[CE]  orphaned  case	253	None	replace
977	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  n.getFirstChild()!=  null);  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  n.getFirstChild()!=  null);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  n.getFirstChild()!=  null);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild()!=    null);    	non-compiled	[CE]  orphaned  case	253	None	replace
978	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild()!=  parent);  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild()!=  parent);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild()!=  parent);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild()!=    null);    	non-compiled	[CE]  orphaned  case	253	None	replace
979	[BUG]  [BUGGY]  Node  var  =  parent.getParent();  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  parent.getParent();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  parent.getParent();	  Node    var    =    n.getParent();    	non-compiled	[CE]  orphaned  case	229	None	replace
980	[BUG]  [BUGGY]  Node  var  =  parent.getNext();  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  parent.getNext();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  parent.getNext();	  Node    var    =    n.getParent();    	non-compiled	[CE]  orphaned  case	229	None	replace
981	[BUG]  [BUGGY]  Node  var  =  scope.getParent();  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  scope.getParent();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getParent();	  Node    var    =    n.getParent();    	non-compiled	[CE]  orphaned  case	229	None	replace
982	[BUG]  [BUGGY]  Node  var  =  n.getString();  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  n.getString();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  n.getString();	  Node    var    =    n.getParent();    	non-compiled	[CE]  orphaned  case	229	None	replace
983	[BUG]  [BUGGY]  Node  var  =  n.getPreviousSibling();  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  n.getPreviousSibling();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  n.getPreviousSibling();	  Node    var    =    n.getParent();    	non-compiled	[CE]  orphaned  case	229	None	replace
984	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  scope);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  scope);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	149	None	replace
985	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.NAME);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.NAME);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.NAME);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	149	None	replace
986	[BUG]  [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.NAME);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.NAME);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.NAME);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	149	None	replace
987	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.NAME);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.NAME);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.NAME);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	149	None	replace
988	[BUG]  [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	149	None	replace
989	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.NAME);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.NAME);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.NAME);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	149	None	replace
990	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  parent);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  parent);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  parent);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	149	None	replace
991	[BUG]  [BUGGY]  Context.checkState(scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	149	None	replace
992	[BUG]  [BUGGY]  Node  var  =  scope.getVar(n.getLastChild().getString());  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  scope.getVar(n.getLastChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getVar(n.getLastChild().getString());	  Node    var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	15	None	replace
993	[BUG]  [BUGGY]  Node  var  =  parent.getFirstChild().getVar(n.getFirstChild().getString());  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  parent.getFirstChild().getVar(n.getFirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  parent.getFirstChild().getVar(n.getFirstChild().getString());	  Node    var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	15	None	replace
994	[BUG]  [BUGGY]  Node  var  =  scope.getVar(parent.getFirstChild().getString());  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  scope.getVar(parent.getFirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getVar(parent.getFirstChild().getString());	  Node    var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	15	None	replace
995	[BUG]  [BUGGY]  Node  var  =  scope.getVar(n.getFirstChild().getString()  +  1);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  scope.getVar(n.getFirstChild().getString()  +  1);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getVar(n.getFirstChild().getString()  +  1);	  Node    var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	15	None	replace
996	[BUG]  [BUGGY]  Node  var  =  scope.getVar(n.getFirstChild().getString(),  type);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  scope.getVar(n.getFirstChild().getString(),  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getVar(n.getFirstChild().getString(),  type);	  Node    var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	15	None	replace
997	[BUG]  [BUGGY]  Node  var  =  scope.getVar(n.getNext().getString());  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  scope.getVar(n.getNext().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getVar(n.getNext().getString());	  Node    var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	15	None	replace
998	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)    	non-compiled	[CE]  	278	None	replace
999	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)    	non-compiled	[CE]  	278	None	replace
1000	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)    	non-compiled	[CE]  	278	None	replace
1001	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)    	non-compiled	[CE]  	278	None	replace
1002	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)    	non-compiled	[CE]  	278	None	replace
1003	[BUG]  [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)    	non-compiled	[CE]  	278	None	replace
1004	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)    	non-compiled	[CE]  	278	None	replace
1005	[BUG]  [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.VAR)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.VAR)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	283	None	replace
1006	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.VAR)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.VAR)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	283	None	replace
1007	[BUG]  [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.VAR)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.VAR)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	283	None	replace
1008	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.VAR)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.VAR)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	283	None	replace
1009	[BUG]  [BUGGY]  if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.VAR)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.VAR)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	283	None	replace
1010	[BUG]  [BUGGY]  if(scope  ==  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.VAR)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope  ==  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope  ==  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.VAR)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	283	None	replace
1011	[BUG]  [BUGGY]  if(scope!=  null  &&  nodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.VAR)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  nodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  nodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.VAR)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	283	None	replace
1012	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  &&  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  &&  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  &&  type  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	67	None	replace
1013	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  type  ==  Token.FUNCTION,  scope);  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  type  ==  Token.FUNCTION,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  ||  type  ==  Token.FUNCTION,  scope);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	67	None	replace
1014	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.VAR  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.VAR  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.VAR  ||  type  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	67	None	replace
1015	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.VAR  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()!=  Token.VAR  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()!=  Token.VAR  ||  type  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	67	None	replace
1016	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  type!=  Token.FUNCTION);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  type!=  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  ||  type!=  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	67	None	replace
1017	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()  ==  Token.VAR  ||  type  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	67	None	replace
1018	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION    ||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	156	None	replace
1019	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION  &&  type  ==  Token.VAR)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION  &&  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION  &&  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION    ||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	156	None	replace
1020	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION    ||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	156	None	replace
1021	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isFunctionDeclaration(n,  scope))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isFunctionDeclaration(n,  scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isFunctionDeclaration(n,  scope))  {	  if(NodeUtil.isFunctionDeclaration(parent)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	162	None	replace
1022	[BUG]  [BUGGY]  if(NodeUtil.isName(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)&&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(parent)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	162	None	replace
1023	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  parent.getString()  :  n.getLastChild();  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  parent.getString()  :  n.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()  ==  null)?  parent.getString()  :  n.getLastChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getString()    :    n.getLastChild();    	non-compiled	[CE]  orphaned  case	259	None	replace
1024	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  n.getString()  :  n.getLastChild();  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  n.getString()  :  n.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()!=  null)?  n.getString()  :  n.getLastChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getString()    :    n.getLastChild();    	non-compiled	[CE]  orphaned  case	259	None	replace
1025	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  parent.getString()  :  n.getLastChild();  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  parent.getString()  :  n.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()!=  null)?  parent.getString()  :  n.getLastChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getString()    :    n.getLastChild();    	non-compiled	[CE]  orphaned  case	259	None	replace
1026	[BUG]  [BUGGY]  Node  scope  =(n.getLastChild()  ==  null)?  n.getString()  :  n.getLastChild();  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getLastChild()  ==  null)?  n.getString()  :  n.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getLastChild()  ==  null)?  n.getString()  :  n.getLastChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getString()    :    n.getLastChild();    	non-compiled	[CE]  orphaned  case	259	None	replace
1027	[BUG]  [BUGGY]  Node  scope  =  n.getFirstChild()  ==  null?  n.getString()  :  n.getLastChild();  [CE]  orphaned  case  [FE]                                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  n.getFirstChild()  ==  null?  n.getString()  :  n.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  n.getFirstChild()  ==  null?  n.getString()  :  n.getLastChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getString()    :    n.getLastChild();    	non-compiled	[CE]  orphaned  case	259	None	replace
1028	[BUG]  [BUGGY]  Node  scope  =  n.getFirstChild()!=  null?  n.getString()  :  n.getLastChild();  [CE]  orphaned  case  [FE]                                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  n.getFirstChild()!=  null?  n.getString()  :  n.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  n.getFirstChild()!=  null?  n.getString()  :  n.getLastChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getString()    :    n.getLastChild();    	non-compiled	[CE]  orphaned  case	259	None	replace
1029	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getString()  :  parent.getLastChild();  [CE]  orphaned  case  [FE]                                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getString()  :  parent.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()  ==  null)?  n.getString()  :  parent.getLastChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getString()    :    n.getLastChild();    	non-compiled	[CE]  orphaned  case	259	None	replace
1030	[BUG]  [BUGGY]  var  =  scope.getVar(n.getParent().getString());  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getParent().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getParent().getString());	  var    =    scope.getVar(n.getNext().getString());    	non-compiled	[CE]  orphaned  case	84	None	replace
1031	[BUG]  [BUGGY]  var  =  scope.getVar(n.getPreviousChild().getString());  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getPreviousChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getPreviousChild().getString());	  var    =    scope.getVar(n.getNext().getString());    	non-compiled	[CE]  orphaned  case	84	None	replace
1032	[BUG]  [BUGGY]  var  =  scope.getVar(n.getNext().getString(),  type);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getNext().getString(),  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getNext().getString(),  type);	  var    =    scope.getVar(n.getNext().getString());    	non-compiled	[CE]  orphaned  case	84	None	replace
1033	[BUG]  [BUGGY]  if(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {	  if(n.getType()    ==    Token.FUNCTION    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	167	None	replace
1034	[BUG]  [BUGGY]  if(n.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(n.getType()    ==    Token.FUNCTION    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	167	None	replace
1035	[BUG]  [BUGGY]  if(scope.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {	  if(n.getType()    ==    Token.FUNCTION    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	167	None	replace
1036	[BUG]  [BUGGY]  if(scope.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {	  if(n.getType()    ==    Token.FUNCTION    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	167	None	replace
1037	[BUG]  [BUGGY]  if(n.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(scope))  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(scope))  {	  if(n.getType()    ==    Token.FUNCTION    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	167	None	replace
1038	[BUG]  [BUGGY]  if(n.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {	  if(n.getType()    ==    Token.FUNCTION    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	167	None	replace
1039	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.VAR);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.VAR);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	45	None	replace
1040	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	45	None	replace
1041	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	45	None	replace
1042	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.VAR);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.VAR);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	45	None	replace
1043	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR,  scope);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR,  scope);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	45	None	replace
1044	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	45	None	replace
1045	[BUG]  [BUGGY]  var  =  this.fnScope.getVar(n.getFirstChild());  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  this.fnScope.getVar(n.getFirstChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  this.fnScope.getVar(n.getFirstChild());	  var    =    this.fnScope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	268	None	replace
1046	[BUG]  [BUGGY]  var  =  this.fnScope.getVar(n.getLastChild(),  type);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  this.fnScope.getVar(n.getLastChild(),  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  this.fnScope.getVar(n.getLastChild(),  type);	  var    =    this.fnScope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	268	None	replace
1047	[BUG]  [BUGGY]  var  =  getFunctionScope().getVar(n.getLastChild());  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  getFunctionScope().getVar(n.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  getFunctionScope().getVar(n.getLastChild());	  var    =    this.fnScope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	268	None	replace
1048	[BUG]  [BUGGY]  var  =  scope.getScope().getVar(n.getLastChild());  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getScope().getVar(n.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getScope().getVar(n.getLastChild());	  var    =    this.fnScope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	268	None	replace
1049	[BUG]  [BUGGY]  var  =  this.fnScope.getVar(n.getString());  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  this.fnScope.getVar(n.getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  this.fnScope.getVar(n.getString());	  var    =    this.fnScope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	268	None	replace
1050	[BUG]  [BUGGY]  Node  var  =  n.getNext()  ||  parent.getType()  ==  Token.FUNCTION;  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  n.getNext()  ||  parent.getType()  ==  Token.FUNCTION;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  n.getNext()  ||  parent.getType()  ==  Token.FUNCTION;	  Node    var    =    n.getNext();    	non-compiled	[CE]  orphaned  case	16	None	replace
1051	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isExpressionNode(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	91	None	replace
1052	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isExpressionNode(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	91	None	replace
1053	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects    	non-compiled	[CE]  	279	None	replace
1054	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects    	non-compiled	[CE]  	279	None	replace
1055	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.mayHaveSideEffects  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.mayHaveSideEffects  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.mayHaveSideEffects	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects    	non-compiled	[CE]  	279	None	replace
1056	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects    	non-compiled	[CE]  	279	None	replace
1057	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects    	non-compiled	[CE]  	279	None	replace
1058	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects  ||  NodeUtil.mayHaveSideEffects  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects  ||  NodeUtil.mayHaveSideEffects  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects  ||  NodeUtil.mayHaveSideEffects	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects    	non-compiled	[CE]  	279	None	replace
1059	[BUG]  [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects    	non-compiled	[CE]  	279	None	replace
1060	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.mayHaveSideEffects  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.mayHaveSideEffects  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.mayHaveSideEffects	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects    	non-compiled	[CE]  	279	None	replace
1061	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  &&  parent.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  &&  parent.getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  &&  parent.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	264	None	replace
1062	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  parent.getType()!=  Token.FUNCTION);  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  parent.getType()!=  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  ||  parent.getType()!=  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	264	None	replace
1063	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.VAR  ||  parent.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()!=  Token.VAR  ||  parent.getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()!=  Token.VAR  ||  parent.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	264	None	replace
1064	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	270	None	replace
1065	[BUG]  [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	270	None	replace
1066	[BUG]  [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	270	None	replace
1067	[BUG]  [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	270	None	replace
1068	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isName(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isName(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isName(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	270	None	replace
1069	[BUG]  [BUGGY]  var  =  scope.getVar(n.getFirstChild(),  type);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getFirstChild(),  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getFirstChild(),  type);	  var    =    scope.getVar(n.getLastChild(),    type);    	non-compiled	[CE]  orphaned  case	102	None	replace
1070	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  type,  parent);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild(),  type,  parent);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  type,  parent);	  var    =    scope.getVar(n.getLastChild(),    type);    	non-compiled	[CE]  orphaned  case	102	None	replace
1071	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n));  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n));	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	219	None	replace
1072	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(parent));  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(parent));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(parent));	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	219	None	replace
1073	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n));  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n));	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	219	None	replace
1074	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n));  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n));	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	219	None	replace
1075	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isAssignmentOp(n));  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isAssignmentOp(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isAssignmentOp(n));	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	219	None	replace
1076	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n));  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n));	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	219	None	replace
1077	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isExpressionNode(n));  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isExpressionNode(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isExpressionNode(n));	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	219	None	replace
1078	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isExpressionNode(parent));  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isExpressionNode(parent));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isExpressionNode(parent));	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	219	None	replace
1079	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild().getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getFirstChild().getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	171	None	replace
1080	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getFirstChild().getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	171	None	replace
1081	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getFirstChild().getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	171	None	replace
1082	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild().getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild().getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild().getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getFirstChild().getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	171	None	replace
1083	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  parent.getFirstChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  parent.getFirstChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  parent.getFirstChild().getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getFirstChild().getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	171	None	replace
1084	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild().getType()!=  Token.FUNCTION)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild().getType()!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild().getType()!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getFirstChild().getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	171	None	replace
1085	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  parent.getFirstChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  parent.getFirstChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  parent.getFirstChild().getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getFirstChild().getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	171	None	replace
1086	[BUG]  [BUGGY]  var  =  type.getVar(n.getLastChild().getString());  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  type.getVar(n.getLastChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  type.getVar(n.getLastChild().getString());	  var    =    scope.getVar(n.getLastChild().getString()    +    1);    	non-compiled	[CE]  orphaned  case	144	None	replace
1087	[BUG]  [BUGGY]  var  =  scope.getVar(N.getLastChild().getString());  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(N.getLastChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(N.getLastChild().getString());	  var    =    scope.getVar(n.getLastChild().getString()    +    1);    	non-compiled	[CE]  orphaned  case	144	None	replace
1088	[BUG]  [BUGGY]  n  =  parent.getFirstChild().getNext();  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  parent.getFirstChild().getNext();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  parent.getFirstChild().getNext();	  n    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	195	None	replace
1089	[BUG]  [BUGGY]  n  =  n.getFirstChild().getString();  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.getFirstChild().getString();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getFirstChild().getString();	  n    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	195	None	replace
1090	[BUG]  [BUGGY]  n  =  n.getFirstChild().getLastChild();  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.getFirstChild().getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getFirstChild().getLastChild();	  n    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	195	None	replace
1091	[BUG]  [BUGGY]  n  =  n.getFirstChild().getNext()  ||  type  ==  Token.FUNCTION;  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.getFirstChild().getNext()  ||  type  ==  Token.FUNCTION;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getFirstChild().getNext()  ||  type  ==  Token.FUNCTION;	  n    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	195	None	replace
1092	[BUG]  [BUGGY]  n  =  n.getFirstChild().getNext()  ||  parent.getType()  ==  Token.FUNCTION;  [CE]  orphaned  case  [FE]                                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.getFirstChild().getNext()  ||  parent.getType()  ==  Token.FUNCTION;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getFirstChild().getNext()  ||  parent.getType()  ==  Token.FUNCTION;	  n    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	195	None	replace
1093	[BUG]  [BUGGY]  n  =  scope.getFirstChild().getNext();  [CE]  orphaned  case  [FE]                                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  scope.getFirstChild().getNext();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  scope.getFirstChild().getNext();	  n    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	195	None	replace
1094	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	95	None	replace
1095	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	95	None	replace
1096	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	95	None	replace
1097	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	95	None	replace
1098	[BUG]  [BUGGY]  if(NodeUtil.isVar(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	95	None	replace
1099	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isConstructorOp(n))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isConstructorOp(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isConstructorOp(n))  {	  if(NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	95	None	replace
1100	[BUG]  [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  scope,  type);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  scope,  type);  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	NodeTraversal.traverse(compiler,  n,  parent,  scope,  type);	  NodeTraversal.traverse(compiler,    n,    parent,    scope);    	non-compiled	[CE]  orphaned  case	207	None	replace
1101	[BUG]  [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  scope,  subclassRelationship);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  scope,  subclassRelationship);  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	NodeTraversal.traverse(compiler,  n,  parent,  scope,  subclassRelationship);	  NodeTraversal.traverse(compiler,    n,    parent,    scope);    	non-compiled	[CE]  orphaned  case	207	None	replace
1102	[BUG]  [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  scope,  continuations);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  scope,  continuations);  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	NodeTraversal.traverse(compiler,  n,  parent,  scope,  continuations);	  NodeTraversal.traverse(compiler,    n,    parent,    scope);    	non-compiled	[CE]  orphaned  case	207	None	replace
1103	[BUG]  [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  scope,  null);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  scope,  null);  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	NodeTraversal.traverse(compiler,  n,  parent,  scope,  null);	  NodeTraversal.traverse(compiler,    n,    parent,    scope);    	non-compiled	[CE]  orphaned  case	207	None	replace
1104	[BUG]  [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  scope,  nameNode);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  scope,  nameNode);  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	NodeTraversal.traverse(compiler,  n,  parent,  scope,  nameNode);	  NodeTraversal.traverse(compiler,    n,    parent,    scope);    	non-compiled	[CE]  orphaned  case	207	None	replace
1105	[BUG]  [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  scope,  true);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  scope,  true);  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	NodeTraversal.traverse(compiler,  n,  parent,  scope,  true);	  NodeTraversal.traverse(compiler,    n,    parent,    scope);    	non-compiled	[CE]  orphaned  case	207	None	replace
1106	[BUG]  [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  scope,  operationScope);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  scope,  operationScope);  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	NodeTraversal.traverse(compiler,  n,  parent,  scope,  operationScope);	  NodeTraversal.traverse(compiler,    n,    parent,    scope);    	non-compiled	[CE]  orphaned  case	207	None	replace
1107	[BUG]  [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  type);  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  type);  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	NodeTraversal.traverse(compiler,  n,  parent,  type);	  NodeTraversal.traverse(compiler,    n,    parent,    scope);    	non-compiled	[CE]  orphaned  case	207	None	replace
1108	[BUG]  [BUGGY]  var  =  n.getFirstChild().getVar(n.getLastChild().getString());  [CE]  orphaned  case  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  n.getFirstChild().getVar(n.getLastChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  n.getFirstChild().getVar(n.getLastChild().getString());	  var    =    parent.getFirstChild().getVar(n.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	276	None	replace
1109	[BUG]  [BUGGY]  var  =  n.getFirstChild().getVar(parent.getLastChild().getString());  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  n.getFirstChild().getVar(parent.getLastChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  n.getFirstChild().getVar(parent.getLastChild().getString());	  var    =    parent.getFirstChild().getVar(n.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	276	None	replace
1110	[BUG]  [BUGGY]  var  =  node.getFirstChild().getVar(n.getLastChild().getString());  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  node.getFirstChild().getVar(n.getLastChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  node.getFirstChild().getVar(n.getLastChild().getString());	  var    =    parent.getFirstChild().getVar(n.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	276	None	replace
1111	[BUG]  [BUGGY]  var  =  scope.getFirstChild().getVar(n.getLastChild().getString());  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getFirstChild().getVar(n.getLastChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getFirstChild().getVar(n.getLastChild().getString());	  var    =    parent.getFirstChild().getVar(n.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	276	None	replace
1112	[BUG]  [BUGGY]  var  =  n.getLastChild().getVar(parent.getString());  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  n.getLastChild().getVar(parent.getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  n.getLastChild().getVar(parent.getString());	  var    =    parent.getFirstChild().getVar(n.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	276	None	replace
1113	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  className);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  className);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild().getString(),  className);	  var    =    scope.getVar(n.getLastChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	146	None	replace
1114	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  n.getFirstChild().getString(),  type);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  n.getFirstChild().getString(),  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild().getString(),  n.getFirstChild().getString(),  type);	  var    =    scope.getVar(n.getLastChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	146	None	replace
1115	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  type,  parent);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  type,  parent);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild().getString(),  type,  parent);	  var    =    scope.getVar(n.getLastChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	146	None	replace
1116	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  n.getFirstChild().getString());  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  n.getFirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild().getString(),  n.getFirstChild().getString());	  var    =    scope.getVar(n.getLastChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	146	None	replace
1117	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  n.getType());  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  n.getType());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild().getString(),  n.getType());	  var    =    scope.getVar(n.getLastChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	146	None	replace
1118	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  parent);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  parent);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild().getString(),  parent);	  var    =    scope.getVar(n.getLastChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	146	None	replace
1119	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isName(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	100	None	replace
1120	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(parent)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isName(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	100	None	replace
1121	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isName(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isName(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isName(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isName(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	100	None	replace
1122	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isName(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	100	None	replace
1123	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isName(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	100	None	replace
1124	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isName(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	100	None	replace
1125	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isImmutableValue(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isImmutableValue(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isImmutableValue(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isName(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	100	None	replace
1126	[BUG]  [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isName(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	100	None	replace
1127	[BUG]  [BUGGY]  Node  n  =  parent.getFirstChild().getNext();  [CE]  orphaned  case  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  parent.getFirstChild().getNext();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  parent.getFirstChild().getNext();	  Node    n    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	183	None	replace
1128	[BUG]  [BUGGY]  Node  n  =  n.getLastChild().getNext();  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  n.getLastChild().getNext();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  n.getLastChild().getNext();	  Node    n    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	183	None	replace
1129	[BUG]  [BUGGY]  Node  n  =  n.getFirstChild().getLastChild();  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  n.getFirstChild().getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  n.getFirstChild().getLastChild();	  Node    n    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	183	None	replace
1130	[BUG]  [BUGGY]  Node  n  =  n.getFirstChild().getNext()  ||  parent.getType()  ==  Token.FUNCTION;  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  n.getFirstChild().getNext()  ||  parent.getType()  ==  Token.FUNCTION;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  n.getFirstChild().getNext()  ||  parent.getType()  ==  Token.FUNCTION;	  Node    n    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	183	None	replace
1131	[BUG]  [BUGGY]  Node  n  =  n.getFirstChild().getString();  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  n.getFirstChild().getString();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  n.getFirstChild().getString();	  Node    n    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	183	None	replace
1132	[BUG]  [BUGGY]  Node  n  =  n.getFirstChild().getNext()  ||  type  ==  Token.FUNCTION;  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  n.getFirstChild().getNext()  ||  type  ==  Token.FUNCTION;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  n.getFirstChild().getNext()  ||  type  ==  Token.FUNCTION;	  Node    n    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	183	None	replace
1133	[BUG]  [BUGGY]  Node  n  =  node.getFirstChild().getNext();  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  node.getFirstChild().getNext();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  node.getFirstChild().getNext();	  Node    n    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	183	None	replace
1134	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  parent;  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  parent;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  parent;	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n;    	non-compiled	[CE]  orphaned  case	256	None	replace
1135	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  parent.getLastChild()  :  n;  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  parent.getLastChild()  :  n;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()  ==  null)?  parent.getLastChild()  :  n;	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n;    	non-compiled	[CE]  orphaned  case	256	None	replace
1136	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  n.getLastChild()  :  n;  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  n.getLastChild()  :  n;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()!=  null)?  n.getLastChild()  :  n;	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n;    	non-compiled	[CE]  orphaned  case	256	None	replace
1137	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  n.getLastChild()  :  parent;  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  n.getLastChild()  :  parent;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()!=  null)?  n.getLastChild()  :  parent;	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n;    	non-compiled	[CE]  orphaned  case	256	None	replace
1138	[BUG]  [BUGGY]  Node  scope  =(n.getLastChild()  ==  null)?  n.getLastChild()  :  n;  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getLastChild()  ==  null)?  n.getLastChild()  :  n;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getLastChild()  ==  null)?  n.getLastChild()  :  n;	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n;    	non-compiled	[CE]  orphaned  case	256	None	replace
1139	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  parent.getLastChild()  :  n;  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  parent.getLastChild()  :  n;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()!=  null)?  parent.getLastChild()  :  n;	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n;    	non-compiled	[CE]  orphaned  case	256	None	replace
1140	[BUG]  [BUGGY]  n  =  parent.getPreviousSibling();  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  parent.getPreviousSibling();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  parent.getPreviousSibling();	  n    =    n.getPreviousSibling();    	non-compiled	[CE]  orphaned  case	262	None	replace
1141	[BUG]  [BUGGY]  n  =  n.getNextSibling();  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.getNextSibling();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getNextSibling();	  n    =    n.getPreviousSibling();    	non-compiled	[CE]  orphaned  case	262	None	replace
1142	[BUG]  [BUGGY]  n  =  n.getPreviousSibling()  ||  parent.getType()  ==  Token.FUNCTION;  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.getPreviousSibling()  ||  parent.getType()  ==  Token.FUNCTION;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getPreviousSibling()  ||  parent.getType()  ==  Token.FUNCTION;	  n    =    n.getPreviousSibling();    	non-compiled	[CE]  orphaned  case	262	None	replace
1143	[BUG]  [BUGGY]  n  =  scope.getPreviousSibling();  [CE]  orphaned  case  [FE]                                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  scope.getPreviousSibling();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  scope.getPreviousSibling();	  n    =    n.getPreviousSibling();    	non-compiled	[CE]  orphaned  case	262	None	replace
1144	[BUG]  [BUGGY]  n  =  n.getPreviousSibling()  ||  type  ==  Token.FUNCTION;  [CE]  orphaned  case  [FE]                                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.getPreviousSibling()  ||  type  ==  Token.FUNCTION;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getPreviousSibling()  ||  type  ==  Token.FUNCTION;	  n    =    n.getPreviousSibling();    	non-compiled	[CE]  orphaned  case	262	None	replace
1145	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()!=  Token.VAR);  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()!=  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()!=  Token.VAR);	  Preconditions.checkState(n.getType()!=    Token.VAR);    	non-compiled	[CE]  orphaned  case	68	None	replace
1146	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()!=  Token.VAR);  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()!=  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()!=  Token.VAR);	  Preconditions.checkState(n.getType()!=    Token.VAR);    	non-compiled	[CE]  orphaned  case	68	None	replace
1147	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  >=  Token.VAR);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  >=  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  >=  Token.VAR);	  Preconditions.checkState(n.getType()!=    Token.VAR);    	non-compiled	[CE]  orphaned  case	68	None	replace
1148	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isExpressionNode(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	117	None	replace
1149	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.VAR);  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  &&  type  ==  Token.VAR);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	147	None	replace
1150	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR,  scope);  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR,  scope);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	147	None	replace
1151	[BUG]  [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	147	None	replace
1152	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.VAR);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type!=  Token.VAR);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	147	None	replace
1153	[BUG]  [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	147	None	replace
1154	[BUG]  [BUGGY]  Context.checkState(scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	147	None	replace
1155	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()  ==  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()  ==  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()  ==  null  ||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()    ==    null    ||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	240	None	replace
1156	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild()  ==  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild()  ==  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild()  ==  null  ||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()    ==    null    ||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	240	None	replace
1157	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()!=  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()!=  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()!=  null  ||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()    ==    null    ||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	240	None	replace
1158	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  node.getFirstChild()  ==  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  node.getFirstChild()  ==  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  node.getFirstChild()  ==  null  ||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()    ==    null    ||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	240	None	replace
1159	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()  ==  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()  ==  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()  ==  null  ||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()    ==    null    ||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	240	None	replace
1160	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(scope))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(scope))    {    	non-compiled	[CE]  	131	None	replace
1161	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(scope))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(scope))    {    	non-compiled	[CE]  	131	None	replace
1162	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(scope))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(scope))    {    	non-compiled	[CE]  	131	None	replace
1163	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(fnScope))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(fnScope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(fnScope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(scope))    {    	non-compiled	[CE]  	131	None	replace
1164	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(scope))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(scope))    {    	non-compiled	[CE]  	131	None	replace
1165	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(scope))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(scope))    {    	non-compiled	[CE]  	131	None	replace
1166	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(type))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(type))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(type))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(scope))    {    	non-compiled	[CE]  	131	None	replace
1167	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  &&  type  ==  Token.EXPR_RESULT);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  &&  type  ==  Token.EXPR_RESULT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  &&  type  ==  Token.EXPR_RESULT);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  orphaned  case	108	None	replace
1168	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type!=  Token.EXPR_RESULT);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type!=  Token.EXPR_RESULT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type!=  Token.EXPR_RESULT);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  orphaned  case	108	None	replace
1169	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT,  scope);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT,  scope);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  orphaned  case	108	None	replace
1170	[BUG]  [BUGGY]  Preconditions.checkArgument(type  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(type  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(type  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  orphaned  case	108	None	replace
1171	[BUG]  [BUGGY]  Preconditions.checkState(type  >=  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  >=  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  >=  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  orphaned  case	108	None	replace
1172	[BUG]  [BUGGY]  Preconditions.checkState(type!=  Token.FUNCTION  &&  type  ==  Token.EXPR_RESULT);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type!=  Token.FUNCTION  &&  type  ==  Token.EXPR_RESULT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type!=  Token.FUNCTION  &&  type  ==  Token.EXPR_RESULT);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  orphaned  case	108	None	replace
1173	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION,  type,  scope);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION,  type,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION,  type,  scope);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION,    type);    	non-compiled	[CE]  orphaned  case	51	None	replace
1174	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION,  parent);  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION,  parent);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION,  parent);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION,    type);    	non-compiled	[CE]  orphaned  case	51	None	replace
1175	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION,  parent.getType());  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION,  parent.getType());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION,  parent.getType());	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION,    type);    	non-compiled	[CE]  orphaned  case	51	None	replace
1176	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION,  type);  [CE]  orphaned  case  [FE]                                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION,  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.FUNCTION,  type);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION,    type);    	non-compiled	[CE]  orphaned  case	51	None	replace
1177	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION,  var);  [CE]  orphaned  case  [FE]                                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION,  var);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION,  var);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION,    type);    	non-compiled	[CE]  orphaned  case	51	None	replace
1178	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION,  var.getString());  [CE]  orphaned  case  [FE]                                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION,  var.getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION,  var.getString());	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION,    type);    	non-compiled	[CE]  orphaned  case	51	None	replace
1179	[BUG]  [BUGGY]  if(n!=  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n!=  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n!=  null  ||  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    ||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	26	None	replace
1180	[BUG]  [BUGGY]  if(parent!=  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(parent!=  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(parent!=  null  ||  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    ||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	26	None	replace
1181	[BUG]  [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)&&  parent.getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    ||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	26	None	replace
1182	[BUG]  [BUGGY]  if(n  ==  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n  ==  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n  ==  null  ||  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    ||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	26	None	replace
1183	[BUG]  [BUGGY]  Node  var  =  scope.getLastChild();  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  scope.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getLastChild();	  Node    var    =    scope.getFirstChild();    	non-compiled	[CE]  orphaned  case	13	None	replace
1184	[BUG]  [BUGGY]  Node  var  =  scope.getNext();  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  scope.getNext();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getNext();	  Node    var    =    scope.getFirstChild();    	non-compiled	[CE]  orphaned  case	13	None	replace
1185	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild().getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    n.getFirstChild().getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	282	None	replace
1186	[BUG]  [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    n.getFirstChild().getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	282	None	replace
1187	[BUG]  [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    n.getFirstChild().getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	282	None	replace
1188	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getLastChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getLastChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getLastChild().getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    n.getFirstChild().getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	282	None	replace
1189	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  n.getFirstChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  n.getFirstChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  n.getFirstChild().getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    n.getFirstChild().getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	282	None	replace
1190	[BUG]  [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  className);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  className);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getFirstChild().getString(),  className);	  var    =    scope.getVar(n.getFirstChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	82	None	replace
1191	[BUG]  [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  type,  parent);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  type,  parent);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getFirstChild().getString(),  type,  parent);	  var    =    scope.getVar(n.getFirstChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	82	None	replace
1192	[BUG]  [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  n.getType());  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  n.getType());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getFirstChild().getString(),  n.getType());	  var    =    scope.getVar(n.getFirstChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	82	None	replace
1193	[BUG]  [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  parent);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  parent);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getFirstChild().getString(),  parent);	  var    =    scope.getVar(n.getFirstChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	82	None	replace
1194	[BUG]  [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  nameNode);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  nameNode);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getFirstChild().getString(),  nameNode);	  var    =    scope.getVar(n.getFirstChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	82	None	replace
1195	[BUG]  [BUGGY]  Node  c  =  n.getfirstChild();  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.getfirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getfirstChild();	  Node    c    =    n.getLastChild();    	non-compiled	[CE]  orphaned  case	61	None	replace
1196	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  type!=  Token.FUNCTION)  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  type!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)&&  type!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    type!=    Token.FUNCTION)    {    	non-compiled	[CE]  	59	None	replace
1197	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  type!=  Token.FUNCTION)  {  [CE]  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  type!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)&&  type!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    type!=    Token.FUNCTION)    {    	non-compiled	[CE]  	59	None	replace
1198	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent,  scope))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent,  scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent,  scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n,    parent))    {    	non-compiled	[CE]  	76	None	replace
1199	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent),  scope)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent),  scope)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent),  scope)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n,    parent))    {    	non-compiled	[CE]  	76	None	replace
1200	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n,  parent))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n,  parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n,    parent))    {    	non-compiled	[CE]  	76	None	replace
1201	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n,  parent))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n,  parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n,    parent))    {    	non-compiled	[CE]  	76	None	replace
1202	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n,  parent))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n,  parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n,    parent))    {    	non-compiled	[CE]  	76	None	replace
1203	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n,  parent))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n,  parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n,    parent))    {    	non-compiled	[CE]  	76	None	replace
1204	[BUG]  [BUGGY]  if(NodeUtil.isFunction(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunction(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunction(n)&&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isVar(parent)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	200	None	replace
1205	[BUG]  [BUGGY]  if(NodeUtil.isVar(parent)&&  NodeUtil.isFunctionDeclaration(n,  scope))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(parent)&&  NodeUtil.isFunctionDeclaration(n,  scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(parent)&&  NodeUtil.isFunctionDeclaration(n,  scope))  {	  if(NodeUtil.isVar(parent)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	200	None	replace
1206	[BUG]  [BUGGY]  Var  var  =  scope.getVar(n.getLastChild().getString(),  type);  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Var  var  =  scope.getVar(n.getLastChild().getString(),  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Var  var  =  scope.getVar(n.getLastChild().getString(),  type);	  Var    var    =    scope.getVar(n.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	81	None	replace
1207	[BUG]  [BUGGY]  Var  var  =  scope.getVar(n.getLastChild().getString()  +  1);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Var  var  =  scope.getVar(n.getLastChild().getString()  +  1);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Var  var  =  scope.getVar(n.getLastChild().getString()  +  1);	  Var    var    =    scope.getVar(n.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	81	None	replace
1208	[BUG]  [BUGGY]  Var  var  =  scope.getVar(parent.getLastChild().getString());  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Var  var  =  scope.getVar(parent.getLastChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Var  var  =  scope.getVar(parent.getLastChild().getString());	  Var    var    =    scope.getVar(n.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	81	None	replace
1209	[BUG]  [BUGGY]  Var  var  =  parent.getVar(n.getLastChild().getString());  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Var  var  =  parent.getVar(n.getLastChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Var  var  =  parent.getVar(n.getLastChild().getString());	  Var    var    =    scope.getVar(n.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	81	None	replace
1210	[BUG]  [BUGGY]  Var  var  =  scope.getVar(n.getLastChild().getString())+  1;  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Var  var  =  scope.getVar(n.getLastChild().getString())+  1;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Var  var  =  scope.getVar(n.getLastChild().getString())+  1;	  Var    var    =    scope.getVar(n.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	81	None	replace
1211	[BUG]  [BUGGY]  Var  var  =  type.getVar(n.getLastChild().getString());  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Var  var  =  type.getVar(n.getLastChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Var  var  =  type.getVar(n.getLastChild().getString());	  Var    var    =    scope.getVar(n.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	81	None	replace
1212	[BUG]  [BUGGY]  Var  var  =  scope.getVar(n.getLastChild().getString(),  n);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Var  var  =  scope.getVar(n.getLastChild().getString(),  n);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Var  var  =  scope.getVar(n.getLastChild().getString(),  n);	  Var    var    =    scope.getVar(n.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	81	None	replace
1213	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isGetProp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	280	None	replace
1214	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isGetProp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	280	None	replace
1215	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isGetProp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	280	None	replace
1216	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isGetProp(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isGetProp(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isGetProp(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isGetProp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	280	None	replace
1217	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isGetProp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	280	None	replace
1218	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isVarDeclaration(n))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isVarDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isVarDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isGetProp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	280	None	replace
1219	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isGetProp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	280	None	replace
1220	[BUG]  [BUGGY]  Node  c  =  parent.removeFirstChild();  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  parent.removeFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  parent.removeFirstChild();	  Node    c    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	242	None	replace
1221	[BUG]  [BUGGY]  Node  c  =  n.removeLastChild();  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.removeLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.removeLastChild();	  Node    c    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	242	None	replace
1222	[BUG]  [BUGGY]  Node  c  =  node.removeFirstChild();  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  node.removeFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  node.removeFirstChild();	  Node    c    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	242	None	replace
1223	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR,  type);  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR,  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()  ==  Token.VAR,  type);	  Preconditions.checkState(scope.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	231	None	replace
1224	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR,  scope.getFirstChild().getString());  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR,  scope.getFirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()  ==  Token.VAR,  scope.getFirstChild().getString());	  Preconditions.checkState(scope.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	231	None	replace
1225	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR  ||  scope.getType()!=  Token.FUNCTION);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR  ||  scope.getType()!=  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()  ==  Token.VAR  ||  scope.getType()!=  Token.FUNCTION);	  Preconditions.checkState(scope.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	231	None	replace
1226	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isExpressionNode(scope))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isExpressionNode(scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isExpressionNode(scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(scope))    {    	non-compiled	[CE]  	79	None	replace
1227	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isExpressionNode(scope))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isExpressionNode(scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isExpressionNode(scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(scope))    {    	non-compiled	[CE]  	79	None	replace
1228	[BUG]  [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isExpressionNode(scope))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isExpressionNode(scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isExpressionNode(scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(scope))    {    	non-compiled	[CE]  	79	None	replace
1229	[BUG]  [BUGGY]  Node  n  =  type.getLastChild();  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  type.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  type.getLastChild();	  Node    n    =    type.getFirstChild();    	non-compiled	[CE]  orphaned  case	173	None	replace
1230	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  scope);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  scope);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	109	None	replace
1231	[BUG]  [BUGGY]  Preconditions.checkState(type!=  Token.FUNCTION  ||  type  ==  Token.NAME);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type!=  Token.FUNCTION  ||  type  ==  Token.NAME);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type!=  Token.FUNCTION  ||  type  ==  Token.NAME);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	109	None	replace
1232	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  &&  type  ==  Token.NAME);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  &&  type  ==  Token.NAME);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  &&  type  ==  Token.NAME);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	109	None	replace
1233	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type!=  Token.NAME);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type!=  Token.NAME);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type!=  Token.NAME);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	109	None	replace
1234	[BUG]  [BUGGY]  Preconditions.checkArgument(type  ==  Token.FUNCTION  ||  type  ==  Token.NAME);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(type  ==  Token.FUNCTION  ||  type  ==  Token.NAME);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(type  ==  Token.FUNCTION  ||  type  ==  Token.NAME);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	109	None	replace
1235	[BUG]  [BUGGY]  Preconditions.checkState(type!=  Token.FUNCTION  ||  type  ==  Token.NAME,  scope);  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type!=  Token.FUNCTION  ||  type  ==  Token.NAME,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type!=  Token.FUNCTION  ||  type  ==  Token.NAME,  scope);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	109	None	replace
1236	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  n.getFirstChild());  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  n.getFirstChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  n.getFirstChild());	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	109	None	replace
1237	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  &&!NodeUtil.isFunctionDeclaration(n));  [CE]  orphaned  case  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  &&!NodeUtil.isFunctionDeclaration(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  &&!NodeUtil.isFunctionDeclaration(n));	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||!NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	230	None	replace
1238	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||!NodeUtil.isFunctionDeclaration(parent));  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||!NodeUtil.isFunctionDeclaration(parent));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  ||!NodeUtil.isFunctionDeclaration(parent));	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||!NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	230	None	replace
1239	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  NodeUtil.isFunctionDeclaration(n));  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  NodeUtil.isFunctionDeclaration(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  ||  NodeUtil.isFunctionDeclaration(n));	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||!NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	230	None	replace
1240	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.VAR  ||!NodeUtil.isFunctionDeclaration(n));  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.VAR  ||!NodeUtil.isFunctionDeclaration(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.VAR  ||!NodeUtil.isFunctionDeclaration(n));	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||!NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	230	None	replace
1241	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isExpressionNode(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isExpressionNode(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isExpressionNode(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(n))    {    	non-compiled	[CE]  	74	None	replace
1242	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isExpressionNode(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isExpressionNode(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isExpressionNode(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(n))    {    	non-compiled	[CE]  	74	None	replace
1243	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructorOp(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructorOp(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructorOp(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(n))    {    	non-compiled	[CE]  	74	None	replace
1244	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION  ||  scope!=  null)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION  ||  scope!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION  ||  scope!=  null)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    scope!=    null)    {    	non-compiled	[CE]  	234	None	replace
1245	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  &&  scope!=  null)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  &&  scope!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  &&  scope!=  null)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    scope!=    null)    {    	non-compiled	[CE]  	234	None	replace
1246	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION  ||  scope!=  null)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION  ||  scope!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION  ||  scope!=  null)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    scope!=    null)    {    	non-compiled	[CE]  	234	None	replace
1247	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION  ||  scope!=  null)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION  ||  scope!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION  ||  scope!=  null)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    scope!=    null)    {    	non-compiled	[CE]  	234	None	replace
1248	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  type  ==  Token.FUNCTION  ||  scope!=  null)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  type  ==  Token.FUNCTION  ||  scope!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  type  ==  Token.FUNCTION  ||  scope!=  null)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    scope!=    null)    {    	non-compiled	[CE]  	234	None	replace
1249	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  type  ==  Token.FUNCTION  ||  scope!=  null)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  type  ==  Token.FUNCTION  ||  scope!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)||  type  ==  Token.FUNCTION  ||  scope!=  null)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    scope!=    null)    {    	non-compiled	[CE]  	234	None	replace
1250	[BUG]  [BUGGY]  Preconditions.checkState(type!=  Token.FUNCTION  ||  type  ==  Token.CALL);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type!=  Token.FUNCTION  ||  type  ==  Token.CALL);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type!=  Token.FUNCTION  ||  type  ==  Token.CALL);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.CALL);    	non-compiled	[CE]  orphaned  case	112	None	replace
1251	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  &&  type  ==  Token.CALL);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  &&  type  ==  Token.CALL);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  &&  type  ==  Token.CALL);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.CALL);    	non-compiled	[CE]  orphaned  case	112	None	replace
1252	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type!=  Token.CALL);  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type!=  Token.CALL);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type!=  Token.CALL);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.CALL);    	non-compiled	[CE]  orphaned  case	112	None	replace
1253	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.CALL,  scope);  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.CALL,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.CALL,  scope);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.CALL);    	non-compiled	[CE]  orphaned  case	112	None	replace
1254	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isExpressionNode(parent)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	213	None	replace
1255	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.VAR  ||  parent.getFirstChild().getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.VAR  ||  parent.getFirstChild().getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.VAR  ||  parent.getFirstChild().getType()  ==  Token.FUNCTION);	  Preconditions.checkState(parent.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	70	None	replace
1256	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	190	None	replace
1257	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	190	None	replace
1258	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(parent))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	190	None	replace
1259	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	190	None	replace
1260	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n,  parent))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n,  parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	190	None	replace
1261	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	190	None	replace
1262	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	190	None	replace
1263	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n)  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n)  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n)	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	190	None	replace
1264	[BUG]  [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.VAR  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.VAR  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(n.getType()  ==  Token.VAR  ||  type  ==  Token.FUNCTION);	  Preconditions.checkArgument(n.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	263	None	replace
1265	[BUG]  [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.VAR,  type);  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.VAR,  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(n.getType()  ==  Token.VAR,  type);	  Preconditions.checkArgument(n.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	263	None	replace
1266	[BUG]  [BUGGY]  Preconditions.checkArgument(n.getType()!=  Token.VAR);  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(n.getType()!=  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(n.getType()!=  Token.VAR);	  Preconditions.checkArgument(n.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	263	None	replace
1267	[BUG]  [BUGGY]  Preconditions.checkArgument(n.getType()!=  Token.VAR  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(n.getType()!=  Token.VAR  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(n.getType()!=  Token.VAR  ||  type  ==  Token.FUNCTION);	  Preconditions.checkArgument(n.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	263	None	replace
1268	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())  ==  null  &&  isRemovableVar(var))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())  ==  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())  ==  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())    ==    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	34	None	replace
1269	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())  ==  null  &&  isRemovableVar(var))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())  ==  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())  ==  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())    ==    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	34	None	replace
1270	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getType()  ==  Token.VAR);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    parent.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	204	None	replace
1271	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  &&  parent.getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  &&  parent.getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  &&  parent.getType()  ==  Token.VAR);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    parent.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	204	None	replace
1272	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()!=  Token.VAR);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()!=  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()!=  Token.VAR);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    parent.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	204	None	replace
1273	[BUG]  [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    parent.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	204	None	replace
1274	[BUG]  [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()!=  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    parent.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	204	None	replace
1275	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString()  ==  Token.VAR);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    parent.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	204	None	replace
1276	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  scope.getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  scope.getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  scope.getType()  ==  Token.VAR);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    parent.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	204	None	replace
1277	[BUG]  [BUGGY]  Node  n  =  n.getlastChild();  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  n.getlastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  n.getlastChild();	  Node    n    =    parent.getLastChild();    	non-compiled	[CE]  orphaned  case	2	None	replace
1278	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSecondarySideEffects(n))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSecondarySideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSecondarySideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	197	None	replace
1279	[BUG]  [BUGGY]  var  =  scope.getVar(parent.getLastChild(),  n.getString());  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(parent.getLastChild(),  n.getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(parent.getLastChild(),  n.getString());	  var    =    scope.getVar(n.getLastChild(),    n.getString());    	non-compiled	[CE]  orphaned  case	181	None	replace
1280	[BUG]  [BUGGY]  if(NodeUtil.isFunctionObjectCall(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionObjectCall(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionObjectCall(n)&&  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isExpressionNode(parent)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	184	None	replace
1281	[BUG]  [BUGGY]  if(NodeUtil.isFunction(parent)&&  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunction(parent)&&  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunction(parent)&&  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isExpressionNode(parent)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	184	None	replace
1282	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	211	None	replace
1283	[BUG]  [BUGGY]  if(NodeUtil.isFunction(parent)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunction(parent)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunction(parent)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isVar(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	272	None	replace
1284	[BUG]  [BUGGY]  n  =  type.getFirstChild();  [CE]  orphaned  case  [FE]                                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  type.getFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  type.getFirstChild();	  n    =    scope.getFirstChild();    	non-compiled	[CE]  orphaned  case	124	None	replace
1285	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())  ==  null  &&  isRemovableVar(var))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())  ==  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())  ==  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())    ==    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	34	None	replace
1286	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  isRemovableVar(var))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())    ==    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	34	None	replace
1287	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  isRemovableVar(var))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())    ==    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	34	None	replace
1288	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isGetProp(n));  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isGetProp(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isGetProp(n));	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	219	None	replace
1289	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n));  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n));	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	219	None	replace
1290	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(parent)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	5	None	replace
1291	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	5	None	replace
1292	[BUG]  [BUGGY]  if(type  ==  Token.FUNCTION  ||  parent!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(type  ==  Token.FUNCTION  ||  parent!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(type  ==  Token.FUNCTION  ||  parent!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(parent!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	27	None	replace
1293	[BUG]  [BUGGY]  if(parent  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(parent  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(parent  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(parent!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	27	None	replace
1294	[BUG]  [BUGGY]  Node  n  =  scope.getFunctionNode(n.getFirstChild());  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  scope.getFunctionNode(n.getFirstChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  scope.getFunctionNode(n.getFirstChild());	  Node    n    =    getFunctionNode(n.getFirstChild());    	non-compiled	[CE]  orphaned  case	174	None	replace
1295	[BUG]  [BUGGY]  var  =  scope.getVar(n.getlastChild().getString());  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getlastChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getlastChild().getString());	  var    =    scope.getVar(n.getLastChild().getString()    +    1);    	non-compiled	[CE]  orphaned  case	144	None	replace
1296	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLestChild().getString());  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLestChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLestChild().getString());	  var    =    scope.getVar(n.getLastChild().getString()    +    1);    	non-compiled	[CE]  orphaned  case	144	None	replace
1297	[BUG]  [BUGGY]  if(scope  ==  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope  ==  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope  ==  null  ||  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    ||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	26	None	replace
1298	[BUG]  [BUGGY]  if(fnScope!=  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(fnScope!=  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(fnScope!=  null  ||  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    ||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	26	None	replace
1299	[BUG]  [BUGGY]  Node  n  =  nameNode.getNext();  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  nameNode.getNext();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  nameNode.getNext();	  Node    n    =    node.getNext();    	non-compiled	[CE]  orphaned  case	129	None	replace
1300	[BUG]  [BUGGY]  if(NodeUtil.isFunctionPrototype(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionPrototype(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionPrototype(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isExpressionNode(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	75	None	replace
1301	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	89	None	replace
1302	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()  ==  null  ||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()  ==  null  ||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()  ==  null  ||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	89	None	replace
1303	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getLastChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getLastChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getLastChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	89	None	replace
1304	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(n)&&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	130	None	replace
1305	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getNext().getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getNext().getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getNext().getType()  ==  Token.VAR);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	206	None	replace
1306	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  type  ==  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)&&  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	52	None	replace
1307	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent  ==  null)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent  ==  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent  ==  null)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	52	None	replace
1308	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR  ||!NodeUtil.isFunctionDeclaration(n));  [CE]  orphaned  case  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR  ||!NodeUtil.isFunctionDeclaration(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()  ==  Token.VAR  ||!NodeUtil.isFunctionDeclaration(n));	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||!NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	230	None	replace
1309	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	233	None	replace
1310	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	155	None	replace
1311	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  type!=  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  type!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  type!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type!=    Token.FUNCTION)    {    	non-compiled	[CE]  	54	None	replace
1312	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  type!=  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  type!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)||  type!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type!=    Token.FUNCTION)    {    	non-compiled	[CE]  	54	None	replace
1313	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent!=  null)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent!=  null)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type!=    Token.FUNCTION)    {    	non-compiled	[CE]  	54	None	replace
1314	[BUG]  [BUGGY]  if(NodeUtil.isName(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getLastChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	119	None	replace
1315	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getLastChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	119	None	replace
1316	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION  ||  scope!=  null)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION  ||  scope!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION  ||  scope!=  null)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    scope!=    null)    {    	non-compiled	[CE]  	234	None	replace
1317	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  scope!=  null)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  scope!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  scope!=  null)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    scope!=    null)    {    	non-compiled	[CE]  	234	None	replace
1318	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  type  ==  Token.FUNCTION  ||  scope!=  null)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  type  ==  Token.FUNCTION  ||  scope!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  type  ==  Token.FUNCTION  ||  scope!=  null)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    scope!=    null)    {    	non-compiled	[CE]  	234	None	replace
1319	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(parent)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(parent)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(parent)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isName(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	199	None	replace
1320	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.EXPR_RESULT  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.EXPR_RESULT  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.EXPR_RESULT  ||  type  ==  Token.FUNCTION);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  orphaned  case	151	None	replace
1321	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()!=  null  &&  NodeUtil.mayHaveSecondarySideEffects(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()!=  null  &&  NodeUtil.mayHaveSecondarySideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()!=  null  &&  NodeUtil.mayHaveSecondarySideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	241	None	replace
1322	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()  ==  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()  ==  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()  ==  null  &&  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	241	None	replace
1323	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	241	None	replace
1324	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.mayHaveSecondarySideEffects(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.mayHaveSecondarySideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.mayHaveSecondarySideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	241	None	replace
1325	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isExpressionNode(n)||  scope.getType()  ==  Token.VAR)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isExpressionNode(n)||  scope.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isExpressionNode(n)||  scope.getType()  ==  Token.VAR)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	283	None	replace
1326	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.CALL  &&  NodeUtil.isFunctionDeclaration(n));  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.CALL  &&  NodeUtil.isFunctionDeclaration(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.CALL  &&  NodeUtil.isFunctionDeclaration(n));	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.CALL);    	non-compiled	[CE]  orphaned  case	112	None	replace
1327	[BUG]  [BUGGY]  Node  scope  =(n.getLastChild()  ==  null)?  n.getString()  :  n.getFirstChild();  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getLastChild()  ==  null)?  n.getString()  :  n.getFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getLastChild()  ==  null)?  n.getString()  :  n.getFirstChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getString()    :    n.getLastChild();    	non-compiled	[CE]  orphaned  case	259	None	replace
1328	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	49	None	replace
1329	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  parent  ==  null)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  parent  ==  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  parent  ==  null)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    parent!=    null)    {    	non-compiled	[CE]  	235	None	replace
1330	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  nameNode!=  null)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  nameNode!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  nameNode!=  null)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    parent!=    null)    {    	non-compiled	[CE]  	235	None	replace
1331	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  nameNode  ==  null)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  nameNode  ==  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  nameNode  ==  null)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    parent!=    null)    {    	non-compiled	[CE]  	235	None	replace
1332	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  parent  >=  null)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  parent  >=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  parent  >=  null)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    parent!=    null)    {    	non-compiled	[CE]  	235	None	replace
1333	[BUG]  [BUGGY]  if(NodeUtil.isFunctionObjectCall(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionObjectCall(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionObjectCall(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isAssignmentOp(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	118	None	replace
1334	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	25	None	replace
1335	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.mayHaveSideEffects(parent))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.mayHaveSideEffects(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.mayHaveSideEffects(parent))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	25	None	replace
1336	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	95	None	replace
1337	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isGetProp(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isGetProp(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isGetProp(n))  {	  if(NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	95	None	replace
1338	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	95	None	replace
1339	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())    ==    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	192	None	replace
1340	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  parent.getFirstChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  parent.getFirstChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  parent.getFirstChild().getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getFirstChild().getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	171	None	replace
1341	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  parent.getFirstChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  parent.getFirstChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)||  parent.getFirstChild().getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getFirstChild().getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	171	None	replace
1342	[BUG]  [BUGGY]  Context.checkState(type!=  Token.FUNCTION);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(type!=  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(type!=  Token.FUNCTION);	  Context.checkState(n.getType()!=    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	150	None	replace
1343	[BUG]  [BUGGY]  Context.checkState(type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(type  ==  Token.FUNCTION);	  Context.checkState(n.getType()!=    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	150	None	replace
1344	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(scope))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(scope))    {    	non-compiled	[CE]  	79	None	replace
1345	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(scope))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(scope))    {    	non-compiled	[CE]  	79	None	replace
1346	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isExpressionNode(scope))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isExpressionNode(scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isExpressionNode(scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(scope))    {    	non-compiled	[CE]  	79	None	replace
1347	[BUG]  [BUGGY]  Node  var  =  n.getFirstChild().getNext()  +  1;  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  n.getFirstChild().getNext()  +  1;  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  n.getFirstChild().getNext()  +  1;	  Node    var    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	208	None	replace
1348	[BUG]  [BUGGY]  Node  var  =  n.getFirstChild().getFunctionNode();  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  n.getFirstChild().getFunctionNode();  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  n.getFirstChild().getFunctionNode();	  Node    var    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	208	None	replace
1349	[BUG]  [BUGGY]  Node  var  =  node.getFirstChild().getNext();  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  node.getFirstChild().getNext();  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  node.getFirstChild().getNext();	  Node    var    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	208	None	replace
1350	[BUG]  [BUGGY]  if(NodeUtil.isLiteralValue(parent)&&  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isLiteralValue(parent)&&  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isLiteralValue(parent)&&  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isLiteralValue(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	277	None	replace
1351	[BUG]  [BUGGY]  if(NodeUtil.isLiteralValue(parent)&&  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isLiteralValue(parent)&&  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isLiteralValue(parent)&&  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isLiteralValue(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	277	None	replace
1352	[BUG]  [BUGGY]  if(NodeUtil.isLiteralValue(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isLiteralValue(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isLiteralValue(parent)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isLiteralValue(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	277	None	replace
1353	[BUG]  [BUGGY]  if(NodeUtil.isFunction(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunction(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunction(parent)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isVar(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	269	None	replace
1354	[BUG]  [BUGGY]  if(NodeUtil.isVar(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(parent)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isVar(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	269	None	replace
1355	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isAssignmentOp(parent))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isAssignmentOp(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isAssignmentOp(parent))  {	  if(NodeUtil.isAssignmentOp(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	166	None	replace
1356	[BUG]  [BUGGY]  n  =  NodeUtil.getFunctionDeclaration(n.getFirstChild());  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  NodeUtil.getFunctionDeclaration(n.getFirstChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  NodeUtil.getFunctionDeclaration(n.getFirstChild());	  n    =    parent.getFirstChild();    	non-compiled	[CE]  orphaned  case	122	None	replace
1357	[BUG]  [BUGGY]  n  =  NodeUtil.getFunctionDeclaration(n).getFirstChild();  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  NodeUtil.getFunctionDeclaration(n).getFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  NodeUtil.getFunctionDeclaration(n).getFirstChild();	  n    =    parent.getFirstChild();    	non-compiled	[CE]  orphaned  case	122	None	replace
1358	[BUG]  [BUGGY]  n  =  n.getFirstChild().getParent();  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.getFirstChild().getParent();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getFirstChild().getParent();	  n    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	195	None	replace
1359	[BUG]  [BUGGY]  n  =  n.getFirstChild().getNext()  +  1;  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.getFirstChild().getNext()  +  1;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getFirstChild().getNext()  +  1;	  n    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	195	None	replace
1360	[BUG]  [BUGGY]  if(NodeUtil.isFunctionAnonymous(n)||  NodeUtil.isExpressionNode(parent))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionAnonymous(n)||  NodeUtil.isExpressionNode(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionAnonymous(n)||  NodeUtil.isExpressionNode(parent))  {	  if(NodeUtil.isConstructorDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	78	None	replace
1361	[BUG]  [BUGGY]  if(NodeUtil.isFunctionObjectCall(n)||  NodeUtil.isExpressionNode(parent))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionObjectCall(n)||  NodeUtil.isExpressionNode(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionObjectCall(n)||  NodeUtil.isExpressionNode(parent))  {	  if(NodeUtil.isConstructorDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	78	None	replace
1362	[BUG]  [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionAnonymous(parent))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionAnonymous(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isFunctionAnonymous(parent))  {	  if(NodeUtil.isConstructorDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	78	None	replace
1363	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isExpressionNode(n)||  n.getFirstChild().getType()  ==  Token.VAR)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isExpressionNode(n)||  n.getFirstChild().getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isExpressionNode(n)||  n.getFirstChild().getType()  ==  Token.VAR)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    n.getFirstChild().getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	285	None	replace
1364	[BUG]  [BUGGY]  Node  n  =  childNode.getFirstChild();  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  childNode.getFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  childNode.getFirstChild();	  Node    n    =    nameNode.getFirstChild();    	non-compiled	[CE]  orphaned  case	222	None	replace
1365	[BUG]  [BUGGY]  Node  scope  =  n.getFirstChild()!=  null?  n.getLastChild()  :  n.getString();  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  n.getFirstChild()!=  null?  n.getLastChild()  :  n.getString();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  n.getFirstChild()!=  null?  n.getLastChild()  :  n.getString();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n.getString();    	non-compiled	[CE]  orphaned  case	258	None	replace
1366	[BUG]  [BUGGY]  if(NodeUtil.isFunctionPrototype(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionPrototype(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionPrototype(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isVar(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	120	None	replace
1367	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(parent)&&  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isAssignmentOp(parent)&&  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(parent)&&  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isAssignmentOp(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	38	None	replace
1368	[BUG]  [BUGGY]  if(NodeUtil.isFunction(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunction(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunction(parent)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isVar(parent)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	200	None	replace
1369	[BUG]  [BUGGY]  Node  var  =  n.getPreviousChild();  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  n.getPreviousChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  n.getPreviousChild();	  Node    var    =    n.getParent();    	non-compiled	[CE]  orphaned  case	229	None	replace
1370	[BUG]  [BUGGY]  Node  var  =  n.getPrevious();  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  n.getPrevious();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  n.getPrevious();	  Node    var    =    n.getParent();    	non-compiled	[CE]  orphaned  case	229	None	replace
1371	[BUG]  [BUGGY]  Node  var  =  node.getParent();  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  node.getParent();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  node.getParent();	  Node    var    =    n.getParent();    	non-compiled	[CE]  orphaned  case	229	None	replace
1372	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(n)&&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(n)&&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(n)&&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	164	None	replace
1373	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isExpressionNode(n)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isExpressionNode(n)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isExpressionNode(n)||  scope.getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	21	None	replace
1374	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isGetProp(n)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isGetProp(n)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isGetProp(n)||  scope.getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	21	None	replace
1375	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isName(n)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isName(n)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isName(n)||  scope.getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	21	None	replace
1376	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.mayHaveSecondarySideEffects(n));  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.mayHaveSecondarySideEffects(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.mayHaveSecondarySideEffects(n));	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||!NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	202	None	replace
1377	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getLastChild().getString().equals( "function "));  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getLastChild().getString().equals( "function "));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getLastChild().getString().equals( "function "));	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString().equals(   "function   "));    	non-compiled	[CE]  orphaned  case	153	None	replace
1378	[BUG]  [BUGGY]  Context.checkState(scope.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().equals( "function "));  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(scope.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().equals( "function "));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(scope.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().equals( "function "));	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString().equals(   "function   "));    	non-compiled	[CE]  orphaned  case	153	None	replace
1379	[BUG]  [BUGGY]  Context.checkState(scope.getType()  ==  Token.FUNCTION  ||  scope.getFirstChild().getString().equals( "function "));  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(scope.getType()  ==  Token.FUNCTION  ||  scope.getFirstChild().getString().equals( "function "));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(scope.getType()  ==  Token.FUNCTION  ||  scope.getFirstChild().getString().equals( "function "));	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString().equals(   "function   "));    	non-compiled	[CE]  orphaned  case	153	None	replace
1380	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.NAME  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.NAME  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.NAME  ||  type  ==  Token.FUNCTION);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	109	None	replace
1381	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  varType);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  varType);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  varType);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	109	None	replace
1382	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  parent);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  parent);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  parent);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	109	None	replace
1383	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  n);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  n);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  n);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	109	None	replace
1384	[BUG]  [BUGGY]  Context.checkState(parent!=  null  ||  parent.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(parent!=  null  ||  parent.getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(parent!=  null  ||  parent.getType()  ==  Token.FUNCTION);	  Context.checkState(parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	203	None	replace
1385	[BUG]  [BUGGY]  Context.checkState(parent!=  null  &&  parent.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(parent!=  null  &&  parent.getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(parent!=  null  &&  parent.getType()  ==  Token.FUNCTION);	  Context.checkState(parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	203	None	replace
1386	[BUG]  [BUGGY]  Context.checkState(parent  ==  null  ||  parent.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(parent  ==  null  ||  parent.getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(parent  ==  null  ||  parent.getType()  ==  Token.FUNCTION);	  Context.checkState(parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	203	None	replace
1387	[BUG]  [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild()!=  n);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild()!=  n);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild()!=  n);	  Context.checkState(parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	203	None	replace
1388	[BUG]  [BUGGY]  Context.checkState(fnScope.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(fnScope.getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(fnScope.getType()  ==  Token.FUNCTION);	  Context.checkState(parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	203	None	replace
1389	[BUG]  [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()!=  Token.VAR);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()!=  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()!=  Token.VAR);	  Context.checkState(parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	203	None	replace
1390	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.VAR  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.VAR  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.VAR  ||  type  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	67	None	replace
1391	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  isDefinedVar(var))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  isDefinedVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  isDefinedVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isDefinedVar(var))    {    	non-compiled	[CE]  	248	None	replace
1392	[BUG]  [BUGGY]  if(NodeUtil.isName(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isDefinedVar(var))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isDefinedVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isDefinedVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isDefinedVar(var))    {    	non-compiled	[CE]  	248	None	replace
1393	[BUG]  [BUGGY]  Node  scope  =  n.cloneTree();  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  n.cloneTree();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  n.cloneTree();	  Node    scope    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	201	None	replace
1394	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild()  ==  parent);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild()  ==  parent);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild()  ==  parent);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild()!=    null);    	non-compiled	[CE]  orphaned  case	253	None	replace
1395	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  modifiedVar.equals(var))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  modifiedVar.equals(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  modifiedVar.equals(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    modifiedVar.equals(var))    {    	non-compiled	[CE]  	247	None	replace
1396	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  modifiedVar.equals(var))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  modifiedVar.equals(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  modifiedVar.equals(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    modifiedVar.equals(var))    {    	non-compiled	[CE]  	247	None	replace
1397	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  nameNode.equals(n.getLastChild().getString())  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  nameNode.equals(n.getLastChild().getString())  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  nameNode.equals(n.getLastChild().getString())	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    modifiedVar.equals(var))    {    	non-compiled	[CE]  	247	None	replace
1398	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  modifiedVar.equals(scope.getVar(n.getFirstChild().getString())  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  modifiedVar.equals(scope.getVar(n.getFirstChild().getString())  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  modifiedVar.equals(scope.getVar(n.getFirstChild().getString())	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    modifiedVar.equals(var))    {    	non-compiled	[CE]  	247	None	replace
1399	[BUG]  [BUGGY]  Node  var  =  scope.getVar(n.getFirstChild(),  n);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  scope.getVar(n.getFirstChild(),  n);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getVar(n.getFirstChild(),  n);	  Node    var    =    scope.getVar(n.getFirstChild());    	non-compiled	[CE]  orphaned  case	14	None	replace
1400	[BUG]  [BUGGY]  Node  var  =  scope.getVar(n.getNext());  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  scope.getVar(n.getNext());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getVar(n.getNext());	  Node    var    =    scope.getVar(n.getFirstChild());    	non-compiled	[CE]  orphaned  case	14	None	replace
1401	[BUG]  [BUGGY]  Node  var  =  scope.getVar(n.getFirstChild()  +  1);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  scope.getVar(n.getFirstChild()  +  1);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getVar(n.getFirstChild()  +  1);	  Node    var    =    scope.getVar(n.getFirstChild());    	non-compiled	[CE]  orphaned  case	14	None	replace
1402	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR  ||  n.getFirstChild().getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR  ||  n.getFirstChild().getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()  ==  Token.VAR  ||  n.getFirstChild().getType()  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    n.getFirstChild().getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	69	None	replace
1403	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isExpressionNode(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isExpressionNode(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isExpressionNode(n))  {	  if(NodeUtil.isExpressionNode(parent)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	198	None	replace
1404	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getLastChild().getString().equals( "function "));  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getLastChild().getString().equals( "function "));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getLastChild().getString().equals( "function "));	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString().equals(   "function   "));    	non-compiled	[CE]  orphaned  case	50	None	replace
1405	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().equals( "function "));  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().equals( "function "));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().equals( "function "));	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString().equals(   "function   "));    	non-compiled	[CE]  orphaned  case	50	None	replace
1406	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  scope.getFirstChild().getString().equals( "function "));  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  scope.getFirstChild().getString().equals( "function "));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  scope.getFirstChild().getString().equals( "function "));	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString().equals(   "function   "));    	non-compiled	[CE]  orphaned  case	50	None	replace
1407	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isExpressionNode(n)||  n.getFirstChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isExpressionNode(n)||  n.getFirstChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isExpressionNode(n)||  n.getFirstChild().getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    n.getFirstChild().getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	282	None	replace
1408	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent)||  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n,    parent))    {    	non-compiled	[CE]  	76	None	replace
1409	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n,    parent))    {    	non-compiled	[CE]  	76	None	replace
1410	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent)||  scope.getType()  ==  Token.VAR)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent)||  scope.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent)||  scope.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n,    parent))    {    	non-compiled	[CE]  	76	None	replace
1411	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n,    parent))    {    	non-compiled	[CE]  	76	None	replace
1412	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent)||  type  ==  Token.VAR)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent)||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent)||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n,    parent))    {    	non-compiled	[CE]  	76	None	replace
1413	[BUG]  [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  null);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  null);  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	NodeTraversal.traverse(compiler,  n,  parent,  null);	  NodeTraversal.traverse(compiler,    n,    parent,    scope);    	non-compiled	[CE]  orphaned  case	207	None	replace
1414	[BUG]  [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  this);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  this);  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	NodeTraversal.traverse(compiler,  n,  parent,  this);	  NodeTraversal.traverse(compiler,    n,    parent,    scope);    	non-compiled	[CE]  orphaned  case	207	None	replace
1415	[BUG]  [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  subclassRelationship);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  subclassRelationship);  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	NodeTraversal.traverse(compiler,  n,  parent,  subclassRelationship);	  NodeTraversal.traverse(compiler,    n,    parent,    scope);    	non-compiled	[CE]  orphaned  case	207	None	replace
1416	[BUG]  [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  subclassRelationships);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  subclassRelationships);  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	NodeTraversal.traverse(compiler,  n,  parent,  subclassRelationships);	  NodeTraversal.traverse(compiler,    n,    parent,    scope);    	non-compiled	[CE]  orphaned  case	207	None	replace
1417	[BUG]  [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  scope,  modifiedVars);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  scope,  modifiedVars);  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	NodeTraversal.traverse(compiler,  n,  parent,  scope,  modifiedVars);	  NodeTraversal.traverse(compiler,    n,    parent,    scope);    	non-compiled	[CE]  orphaned  case	207	None	replace
1418	[BUG]  [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  scope,  replications);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  scope,  replications);  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	NodeTraversal.traverse(compiler,  n,  parent,  scope,  replications);	  NodeTraversal.traverse(compiler,    n,    parent,    scope);    	non-compiled	[CE]  orphaned  case	207	None	replace
1419	[BUG]  [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  scope,  referenced);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  scope,  referenced);  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	NodeTraversal.traverse(compiler,  n,  parent,  scope,  referenced);	  NodeTraversal.traverse(compiler,    n,    parent,    scope);    	non-compiled	[CE]  orphaned  case	207	None	replace
1420	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR,  nameNode);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR,  nameNode);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR,  nameNode);	  Preconditions.checkState(n.getType()    ==    Token.VAR,    type);    	non-compiled	[CE]  orphaned  case	71	None	replace
1421	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(parent)&&  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(parent)&&  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(parent)&&  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isGetProp(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	39	None	replace
1422	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(parent)&&  n.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(parent)&&  n.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(parent)&&  n.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isGetProp(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	39	None	replace
1423	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	53	None	replace
1424	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  scope.isConstructor())  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  scope.isConstructor())  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  scope.isConstructor())  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	53	None	replace
1425	[BUG]  [BUGGY]  Node  c  =  scope.getParent();  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  scope.getParent();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  scope.getParent();	  Node    c    =    scope.getFirstChild();    	non-compiled	[CE]  orphaned  case	64	None	replace
1426	[BUG]  [BUGGY]  Node  var  =  nameNode.getFirstChild();  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  nameNode.getFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  nameNode.getFirstChild();	  Node    var    =    scope.getFirstChild();    	non-compiled	[CE]  orphaned  case	13	None	replace
1427	[BUG]  [BUGGY]  Node  var  =  type.getFirstChild();  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  type.getFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  type.getFirstChild();	  Node    var    =    scope.getFirstChild();    	non-compiled	[CE]  orphaned  case	13	None	replace
1428	[BUG]  [BUGGY]  Node  scope  =  n.getChildCount();  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  n.getChildCount();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  n.getChildCount();	  Node    scope    =    n.getNext();    	non-compiled	[CE]  orphaned  case	168	None	replace
1429	[BUG]  [BUGGY]  Node  scope  =  n.getOwnerChild();  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  n.getOwnerChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  n.getOwnerChild();	  Node    scope    =    n.getNext();    	non-compiled	[CE]  orphaned  case	168	None	replace
1430	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionNode(parent))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionNode(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionNode(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	244	None	replace
1431	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(parent))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	244	None	replace
1432	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isExpressionNode(parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isExpressionNode(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isExpressionNode(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	244	None	replace
1433	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	244	None	replace
1434	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionExpressionNode(parent))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionExpressionNode(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionExpressionNode(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	244	None	replace
1435	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(parent))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	244	None	replace
1436	[BUG]  [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  var);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  var);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getFirstChild().getString(),  var);	  var    =    scope.getVar(n.getFirstChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	82	None	replace
1437	[BUG]  [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  varType);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  varType);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getFirstChild().getString(),  varType);	  var    =    scope.getVar(n.getFirstChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	82	None	replace
1438	[BUG]  [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  varName);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  varName);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getFirstChild().getString(),  varName);	  var    =    scope.getVar(n.getFirstChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	82	None	replace
1439	[BUG]  [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  varNode);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  varNode);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getFirstChild().getString(),  varNode);	  var    =    scope.getVar(n.getFirstChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	82	None	replace
1440	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.mayHaveSecondarySideEffects(n));  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.mayHaveSecondarySideEffects(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.mayHaveSecondarySideEffects(n));	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||!NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	217	None	replace
1441	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(n));  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(n));	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||!NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	217	None	replace
1442	[BUG]  [BUGGY]  Preconditions.checkState(parent!=  null  ||  parent.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent!=  null  ||  parent.getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent!=  null  ||  parent.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	48	None	replace
1443	[BUG]  [BUGGY]  Preconditions.checkState(parent!=  null  &&  parent.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent!=  null  &&  parent.getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent!=  null  &&  parent.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	48	None	replace
1444	[BUG]  [BUGGY]  Preconditions.checkState(parent  ==  null  ||  parent.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent  ==  null  ||  parent.getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent  ==  null  ||  parent.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	48	None	replace
1445	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild()!=  n);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild()!=  n);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getFirstChild()!=  n);	  Preconditions.checkState(parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	48	None	replace
1446	[BUG]  [BUGGY]  Node  scope  =(n.getLastChild()  ==  null)?  n.getFirstChild()  :  n;  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getLastChild()  ==  null)?  n.getFirstChild()  :  n;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getLastChild()  ==  null)?  n.getFirstChild()  :  n;	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n;    	non-compiled	[CE]  orphaned  case	256	None	replace
1447	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getFirstChild()  :  n;  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getFirstChild()  :  n;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()  ==  null)?  n.getFirstChild()  :  n;	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n;    	non-compiled	[CE]  orphaned  case	256	None	replace
1448	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.VAR);  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.VAR);	  Preconditions.checkState(n.getType()!=    Token.VAR);    	non-compiled	[CE]  orphaned  case	68	None	replace
1449	[BUG]  [BUGGY]  var  =  scope.getVar(fnScope.getLastChild());  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(fnScope.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(fnScope.getLastChild());	  var    =    scope.getVar(parent.getLastChild());    	non-compiled	[CE]  orphaned  case	103	None	replace
1450	[BUG]  [BUGGY]  var  =  type.getVar(n.getLastChild());  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  type.getVar(n.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  type.getVar(n.getLastChild());	  var    =    scope.getVar(parent.getLastChild());    	non-compiled	[CE]  orphaned  case	103	None	replace
1451	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	22	None	replace
1452	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    scope.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	58	None	replace
1453	[BUG]  [BUGGY]  Var  var  =  scope.getVar(n.getFirstChild().getString(),  n);  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Var  var  =  scope.getVar(n.getFirstChild().getString(),  n);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Var  var  =  scope.getVar(n.getFirstChild().getString(),  n);	  Var    var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	145	None	replace
1454	[BUG]  [BUGGY]  Var  var  =  scope.getVar(n.getFirstChild().getQualifiedName());  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Var  var  =  scope.getVar(n.getFirstChild().getQualifiedName());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Var  var  =  scope.getVar(n.getFirstChild().getQualifiedName());	  Var    var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	145	None	replace
1455	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getFirstChild()  :  n.getFirstChild();  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getFirstChild()  :  n.getFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()  ==  null)?  n.getFirstChild()  :  n.getFirstChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    parent.getLastChild()    :    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	260	None	replace
1456	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(scope))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(scope))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(scope))    {    	non-compiled	[CE]  	131	None	replace
1457	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.CALL,  scope);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.CALL,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.CALL,  scope);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.CALL);    	non-compiled	[CE]  orphaned  case	205	None	replace
1458	[BUG]  [BUGGY]  if(NodeUtil.isFunctionObjectCall(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionObjectCall(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionObjectCall(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isExpressionNode(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	7	None	replace
1459	[BUG]  [BUGGY]  Context.report(JSError.make(n,  parent,  FUNCTION_DEFINE_INIT_ERROR,  type));  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.report(JSError.make(n,  parent,  FUNCTION_DEFINE_INIT_ERROR,  type));  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.report(JSError.make(n,  parent,  FUNCTION_DEFINE_INIT_ERROR,  type));	  Context.reportCodeChange();    	non-compiled	[CE]  orphaned  case	141	None	replace
1460	[BUG]  [BUGGY]  Context.report(JSError.make(sourceName,  n,  type));  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.report(JSError.make(sourceName,  n,  type));  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.report(JSError.make(sourceName,  n,  type));	  Context.reportCodeChange();    	non-compiled	[CE]  orphaned  case	141	None	replace
1461	[BUG]  [BUGGY]  Context.report(JSError.make(n,  FUNCTION_DEFINE_INIT_ERROR,  type));  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.report(JSError.make(n,  FUNCTION_DEFINE_INIT_ERROR,  type));  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.report(JSError.make(n,  FUNCTION_DEFINE_INIT_ERROR,  type));	  Context.reportCodeChange();    	non-compiled	[CE]  orphaned  case	141	None	replace
1462	[BUG]  [BUGGY]  Context.report(JSError.make(n,  scope));  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.report(JSError.make(n,  scope));  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.report(JSError.make(n,  scope));	  Context.reportCodeChange();    	non-compiled	[CE]  orphaned  case	141	None	replace
1463	[BUG]  [BUGGY]  Context.report(JSError.make(n,  parent,  FUNCTION_EXPR_TYPE));  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.report(JSError.make(n,  parent,  FUNCTION_EXPR_TYPE));  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.report(JSError.make(n,  parent,  FUNCTION_EXPR_TYPE));	  Context.reportCodeChange();    	non-compiled	[CE]  orphaned  case	141	None	replace
1464	[BUG]  [BUGGY]  Context.checkState(scope.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(scope.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(scope.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    parent.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	204	None	replace
1465	[BUG]  [BUGGY]  Preconditions.checkState(type!=  Token.FUNCTION  &&  type  ==  Token.VAR);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type!=  Token.FUNCTION  &&  type  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type!=  Token.FUNCTION  &&  type  ==  Token.VAR);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	107	None	replace
1466	[BUG]  [BUGGY]  n  =  scope.removeFirstChild();  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  scope.removeFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  scope.removeFirstChild();	  n    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	261	None	replace
1467	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION,  var);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION,  var);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION,  var);	  Preconditions.checkState(type    ==    Token.FUNCTION,    scope);    	non-compiled	[CE]  orphaned  case	111	None	replace
1468	[BUG]  [BUGGY]  Node  node  =  n.getFirstChild().getNext();  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  node  =  n.getFirstChild().getNext();  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  node  =  n.getFirstChild().getNext();	  Node    node    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	140	None	replace
1469	[BUG]  [BUGGY]  Node  node  =  n.removeFirstChild();  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  node  =  n.removeFirstChild();  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  node  =  n.removeFirstChild();	  Node    node    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	140	None	replace
1470	[BUG]  [BUGGY]  if(NodeUtil.isFunction(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunction(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunction(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isName(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	188	None	replace
1471	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isName(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	188	None	replace
1472	[BUG]  [BUGGY]  var  =  type.getVar(n.getLastChild(),  n.getLastChild());  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  type.getVar(n.getLastChild(),  n.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  type.getVar(n.getLastChild(),  n.getLastChild());	  var    =    scope.getVar(n.getLastChild(),    n.getLastChild());    	non-compiled	[CE]  orphaned  case	182	None	replace
1473	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(parent)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(parent)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(parent)||  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionPrototype(parent))    {    	non-compiled	[CE]  	177	None	replace
1474	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionPrototype(parent))    {    	non-compiled	[CE]  	177	None	replace
1475	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(parent)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(parent)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(parent)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionPrototype(parent))    {    	non-compiled	[CE]  	177	None	replace
1476	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(parent)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionPrototype(parent))    {    	non-compiled	[CE]  	177	None	replace
1477	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION,  nameNode);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION,  nameNode);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION,  nameNode);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION,    type);    	non-compiled	[CE]  orphaned  case	51	None	replace
1478	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n,  parent))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n,  parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n,    parent))    {    	non-compiled	[CE]  	271	None	replace
1479	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n,  parent)&&  NodeUtil.isFunctionDeclaration(n,  parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n,  parent)&&  NodeUtil.isFunctionDeclaration(n,  parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n,  parent)&&  NodeUtil.isFunctionDeclaration(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n,    parent))    {    	non-compiled	[CE]  	271	None	replace
1480	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(n)&&  NodeUtil.isFunctionDeclaration(n,  parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(n)&&  NodeUtil.isFunctionDeclaration(n,  parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(n)&&  NodeUtil.isFunctionDeclaration(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n,    parent))    {    	non-compiled	[CE]  	271	None	replace
1481	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.GETELEM);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.GETELEM);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.GETELEM);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.GETPROP);    	non-compiled	[CE]  orphaned  case	170	None	replace
1482	[BUG]  [BUGGY]  Preconditions.checkState(type  >=  Token.FUNCTION  ||  type  ==  Token.GETPROP);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  >=  Token.FUNCTION  ||  type  ==  Token.GETPROP);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  >=  Token.FUNCTION  ||  type  ==  Token.GETPROP);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.GETPROP);    	non-compiled	[CE]  orphaned  case	170	None	replace
1483	[BUG]  [BUGGY]  var  =  n.getLastChild().getVar(parent.getFirstChild().getString());  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  n.getLastChild().getVar(parent.getFirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  n.getLastChild().getVar(parent.getFirstChild().getString());	  var    =    parent.getFirstChild().getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	243	None	replace
1484	[BUG]  [BUGGY]  var  =  node.getLastChild().getVar(n.getFirstChild().getString());  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  node.getLastChild().getVar(n.getFirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  node.getLastChild().getVar(n.getFirstChild().getString());	  var    =    parent.getFirstChild().getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	243	None	replace
1485	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	98	None	replace
1486	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructor(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructor(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructor(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	98	None	replace
1487	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	98	None	replace
1488	[BUG]  [BUGGY]  var  =  scope.getVar(fnScope.getLastChild(),  n);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(fnScope.getLastChild(),  n);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(fnScope.getLastChild(),  n);	  var    =    scope.getVar(n.getLastChild(),    fnScope);    	non-compiled	[CE]  orphaned  case	180	None	replace
1489	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	212	None	replace
1490	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)||  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	212	None	replace
1491	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	185	None	replace
1492	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isGetProp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	280	None	replace
1493	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isGetProp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	280	None	replace
1494	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isConstructor(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isConstructor(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isConstructor(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isGetProp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	280	None	replace
1495	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(n)||  NodeUtil.mayHaveSideEffects(parent))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(n)||  NodeUtil.mayHaveSideEffects(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(n)||  NodeUtil.mayHaveSideEffects(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(parent))    {    	non-compiled	[CE]  	286	None	replace
1496	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(parent))    {    	non-compiled	[CE]  	286	None	replace
1497	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(parent))    {    	non-compiled	[CE]  	286	None	replace
1498	[BUG]  [BUGGY]  Node  scope  =  getFunctionScope(n.getLastChild(),  scope);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  getFunctionScope(n.getLastChild(),  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getFunctionScope(n.getLastChild(),  scope);	  Node    scope    =    getFunctionScope(n.getLastChild());    	non-compiled	[CE]  orphaned  case	136	None	replace
1499	[BUG]  [BUGGY]  Node  scope  =  findFunctionScope(n.getLastChild());  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  findFunctionScope(n.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  findFunctionScope(n.getLastChild());	  Node    scope    =    getFunctionScope(n.getLastChild());    	non-compiled	[CE]  orphaned  case	136	None	replace
1500	[BUG]  [BUGGY]  Node  c  =  n.getContainingNode();  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.getContainingNode();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getContainingNode();	  Node    c    =    n.getCurrentNode();    	non-compiled	[CE]  orphaned  case	223	None	replace
1501	[BUG]  [BUGGY]  Node  c  =  n.getPreviousNode();  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.getPreviousNode();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getPreviousNode();	  Node    c    =    n.getCurrentNode();    	non-compiled	[CE]  orphaned  case	223	None	replace
1502	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isConstructor(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isConstructor(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isConstructor(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isGetProp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	194	None	replace
1503	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isGetProp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	194	None	replace
1504	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isForIn(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isForIn(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isForIn(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isGetProp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	194	None	replace
1505	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR  ||  parent.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR  ||  parent.getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()  ==  Token.VAR  ||  parent.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	264	None	replace
1506	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(parent))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(parent))    {    	non-compiled	[CE]  	214	None	replace
1507	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  isRemovableVar(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  isRemovableVar(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  isRemovableVar(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(parent))    {    	non-compiled	[CE]  	214	None	replace
1508	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  isRemovableVar(parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  isRemovableVar(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  isRemovableVar(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(parent))    {    	non-compiled	[CE]  	214	None	replace
1509	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	209	None	replace
1510	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(parent)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(parent)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(parent)||  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	209	None	replace
1511	[BUG]  [BUGGY]  if(type  ==  Token.FUNCTION  ||  n!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(type  ==  Token.FUNCTION  ||  n!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(type  ==  Token.FUNCTION  ||  n!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(n!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	20	None	replace
1512	[BUG]  [BUGGY]  Node  n  =  n.getFirstChild().getParent();  [CE]  orphaned  case  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  n.getFirstChild().getParent();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  n.getFirstChild().getParent();	  Node    n    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	183	None	replace
1513	[BUG]  [BUGGY]  Node  n  =  n.getFirstChild().getNext()  +  1;  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  n.getFirstChild().getNext()  +  1;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  n.getFirstChild().getNext()  +  1;	  Node    n    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	183	None	replace
1514	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	41	None	replace
1515	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)    	non-compiled	[CE]  	278	None	replace
1516	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)    	non-compiled	[CE]  	278	None	replace
1517	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)    	non-compiled	[CE]  	278	None	replace
1518	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)    	non-compiled	[CE]  	278	None	replace
1519	[BUG]  [BUGGY]  var  =  this.fnScope.getVar(n.getLastChild(),  n);  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  this.fnScope.getVar(n.getLastChild(),  n);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  this.fnScope.getVar(n.getLastChild(),  n);	  var    =    this.fnScope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	268	None	replace
1520	[BUG]  [BUGGY]  var  =  parent.getFirstChild().getVar(n.getLastChild());  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  parent.getFirstChild().getVar(n.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  parent.getFirstChild().getVar(n.getLastChild());	  var    =    this.fnScope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	268	None	replace
1521	[BUG]  [BUGGY]  var  =  nameNode.getVar(n.getLastChild().getString());  [CE]  orphaned  case  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  nameNode.getVar(n.getLastChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  nameNode.getVar(n.getLastChild().getString());	  var    =    parent.getVar(n.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	215	None	replace
1522	[BUG]  [BUGGY]  var  =  node.getVar(parent.getLastChild().getString());  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  node.getVar(parent.getLastChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  node.getVar(parent.getLastChild().getString());	  var    =    parent.getVar(n.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	215	None	replace
1523	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)||    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	29	None	replace
1524	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)||    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	29	None	replace
1525	[BUG]  [BUGGY]  if(NodeUtil.mayHaveSecondarySideEffects(n)||  NodeUtil.mayHaveSecondarySideEffects(parent))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.mayHaveSecondarySideEffects(n)||  NodeUtil.mayHaveSecondarySideEffects(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.mayHaveSecondarySideEffects(n)||  NodeUtil.mayHaveSecondarySideEffects(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSecondarySideEffects(parent))    {    	non-compiled	[CE]  	175	None	replace
1526	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(n)||  NodeUtil.mayHaveSecondarySideEffects(parent)  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(n)||  NodeUtil.mayHaveSecondarySideEffects(parent)  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(n)||  NodeUtil.mayHaveSecondarySideEffects(parent)	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSecondarySideEffects(parent))    {    	non-compiled	[CE]  	175	None	replace
1527	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.VAR  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.VAR  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.VAR  ||  type  ==  Token.FUNCTION);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	147	None	replace
1528	[BUG]  [BUGGY]  var  =  scope.getVar(fnScope.getLastChild().getString());  [CE]  orphaned  case  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(fnScope.getLastChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(fnScope.getLastChild().getString());	  var    =    scope.getVar(parent.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	143	None	replace
1529	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||!NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||!NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||!NodeUtil.mayHaveSideEffects(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||!NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	238	None	replace
1530	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||!NodeUtil.mayHaveSecondarySideEffects(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||!NodeUtil.mayHaveSecondarySideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||!NodeUtil.mayHaveSecondarySideEffects(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||!NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	238	None	replace
1531	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	86	None	replace
1532	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	86	None	replace
1533	[BUG]  [BUGGY]  Node  scope  =(n.getType()  ==  Token.FUNCTION)?  parent.getFirstChild()  :  n.getLastChild();  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getType()  ==  Token.FUNCTION)?  parent.getFirstChild()  :  n.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getType()  ==  Token.FUNCTION)?  parent.getFirstChild()  :  n.getLastChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    parent.getFirstChild()    :    n.getLastChild();    	non-compiled	[CE]  orphaned  case	257	None	replace
1534	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION  ||  isRemovableVar(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION  ||  isRemovableVar(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION  ||  isRemovableVar(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    isRemovableVar(n))    {    	non-compiled	[CE]  	236	None	replace
1535	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  type  ==  Token.FUNCTION  ||  isRemovableVar(n))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  type  ==  Token.FUNCTION  ||  isRemovableVar(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  type  ==  Token.FUNCTION  ||  isRemovableVar(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    isRemovableVar(n))    {    	non-compiled	[CE]  	236	None	replace
1536	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  type  ==  Token.FUNCTION  ||  isRemovableVar(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  type  ==  Token.FUNCTION  ||  isRemovableVar(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)||  type  ==  Token.FUNCTION  ||  isRemovableVar(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    isRemovableVar(n))    {    	non-compiled	[CE]  	236	None	replace
1537	[BUG]  [BUGGY]  Node  var  =  n.getfirstChild();  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  n.getfirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  n.getfirstChild();	  Node    var    =    parent.getFirstChild();    	non-compiled	[CE]  orphaned  case	12	None	replace
1538	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects    	non-compiled	[CE]  	279	None	replace
1539	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects    	non-compiled	[CE]  	279	None	replace
1540	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  NodeUtil.mayHaveSideEffects  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  NodeUtil.mayHaveSideEffects  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  NodeUtil.mayHaveSideEffects	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects    	non-compiled	[CE]  	279	None	replace
1541	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects    	non-compiled	[CE]  	279	None	replace
1542	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(n)||  NodeUtil.mayHaveSideEffects  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(n)||  NodeUtil.mayHaveSideEffects  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(n)||  NodeUtil.mayHaveSideEffects	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects    	non-compiled	[CE]  	279	None	replace
1543	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  parent.getFirstChild().getType()  ==  Token.VAR)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  parent.getFirstChild().getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  parent.getFirstChild().getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	56	None	replace
1544	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  type  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  type  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)||  type  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	56	None	replace
1545	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	56	None	replace
1546	[BUG]  [BUGGY]  Node  c  =  n.getPrevious();  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.getPrevious();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getPrevious();	  Node    c    =    n.getParent();    	non-compiled	[CE]  orphaned  case	66	None	replace
1547	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  n.getFirstChild().getString().equals( "function "))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  n.getFirstChild().getString().equals( "function "))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent)||  n.getFirstChild().getString().equals( "function "))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    n.getFirstChild().getString().equals(   "function   "))    {    	non-compiled	[CE]  	284	None	replace
1548	[BUG]  [BUGGY]  if(NodeUtil.isFunctionPrototype(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionPrototype(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionPrototype(n)&&  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isExpressionNode(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	37	None	replace
1549	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isConstructorOp(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	99	None	replace
1550	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isConstructorOp(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	99	None	replace
1551	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isConstructorOp(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	99	None	replace
1552	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isConstructorOp(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	99	None	replace
1553	[BUG]  [BUGGY]  Node  var  =  n.removeFirstChild().getNext();  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  n.removeFirstChild().getNext();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  n.removeFirstChild().getNext();	  Node    var    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	254	None	replace
1554	[BUG]  [BUGGY]  Node  var  =  n.removeLastChild();  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  n.removeLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  n.removeLastChild();	  Node    var    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	254	None	replace
1555	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	6	None	replace
1556	[BUG]  [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(n));  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(n));	  Preconditions.checkArgument(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	251	None	replace
1557	[BUG]  [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n));  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n));	  Preconditions.checkArgument(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	251	None	replace
1558	[BUG]  [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n));  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n));	  Preconditions.checkArgument(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	251	None	replace
1559	[BUG]  [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.CALL);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.CALL);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.CALL);	  Preconditions.checkArgument(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	251	None	replace
1560	[BUG]  [BUGGY]  n  =  n.getPreviousChild();  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.getPreviousChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getPreviousChild();	  n    =    n.getPreviousSibling();    	non-compiled	[CE]  orphaned  case	262	None	replace
1561	[BUG]  [BUGGY]  n  =  n.getFunctionSibling();  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.getFunctionSibling();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getFunctionSibling();	  n    =    n.getPreviousSibling();    	non-compiled	[CE]  orphaned  case	262	None	replace
1562	[BUG]  [BUGGY]  if(NodeUtil.isName(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(parent)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isName(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	172	None	replace
1563	[BUG]  [BUGGY]  var  =  scope.getVar(n.getNextChild().getString());  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getNextChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getNextChild().getString());	  var    =    scope.getVar(n.getNext().getString());    	non-compiled	[CE]  orphaned  case	84	None	replace
1564	[BUG]  [BUGGY]  var  =  scope.getVar(n.getNext().getString()  +  1);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getNext().getString()  +  1);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getNext().getString()  +  1);	  var    =    scope.getVar(n.getNext().getString());    	non-compiled	[CE]  orphaned  case	84	None	replace
1565	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  parent.getType()!=  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  parent.getType()!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)||  parent.getType()!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()!=    Token.FUNCTION)    {    	non-compiled	[CE]  	157	None	replace
1566	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  parent.getType()!=  Token.FUNCTION)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  parent.getType()!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  parent.getType()!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()!=    Token.FUNCTION)    {    	non-compiled	[CE]  	157	None	replace
1567	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.CALL);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.CALL);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()  ==  Token.FUNCTION  ||  type  ==  Token.CALL);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.CALL);    	non-compiled	[CE]  orphaned  case	220	None	replace
1568	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(parent))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	210	None	replace
1569	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	210	None	replace
1570	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	270	None	replace
1571	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isConstructor(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isConstructor(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isConstructor(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	270	None	replace
1572	[BUG]  [BUGGY]  var  =  scope.getVar(n.getNext());  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getNext());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getNext());	  var    =    scope.getVar(n.getFirstChild());    	non-compiled	[CE]  orphaned  case	101	None	replace
1573	[BUG]  [BUGGY]  Node  scope  =  getFunctionScope().getOwnScope(n);  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  getFunctionScope().getOwnScope(n);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getFunctionScope().getOwnScope(n);	  Node    scope    =    getFunctionScope().getFirstChild();    	non-compiled	[CE]  orphaned  case	216	None	replace
1574	[BUG]  [BUGGY]  Node  scope  =  getFunctionScope().removeFirstChild();  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  getFunctionScope().removeFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getFunctionScope().removeFirstChild();	  Node    scope    =    getFunctionScope().getFirstChild();    	non-compiled	[CE]  orphaned  case	216	None	replace
1575	[BUG]  [BUGGY]  Node  scope  =  getFunctionScope().getVar(n.getFirstChild());  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  getFunctionScope().getVar(n.getFirstChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getFunctionScope().getVar(n.getFirstChild());	  Node    scope    =    getFunctionScope().getFirstChild();    	non-compiled	[CE]  orphaned  case	216	None	replace
1576	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    n.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	227	None	replace
1577	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    n.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	227	None	replace
1578	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()  ==  parent  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()  ==  parent  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()  ==  parent  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    n.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	227	None	replace
1579	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()  ==  parent  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()  ==  parent  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()  ==  parent  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    n.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	227	None	replace
1580	[BUG]  [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.VAR  ||  type  ==  Token.NAME);  [CE]  orphaned  case  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.VAR  ||  type  ==  Token.NAME);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(n.getType()  ==  Token.VAR  ||  type  ==  Token.NAME);	  Preconditions.checkArgument(n.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	263	None	replace
1581	[BUG]  [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.VAR  ||  type  ==  Token.CALL);  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.VAR  ||  type  ==  Token.CALL);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(n.getType()  ==  Token.VAR  ||  type  ==  Token.CALL);	  Preconditions.checkArgument(n.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	263	None	replace
1582	[BUG]  [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.NAME);  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.NAME);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(n.getType()  ==  Token.NAME);	  Preconditions.checkArgument(n.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	263	None	replace
1583	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	193	None	replace
1584	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	193	None	replace
1585	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	193	None	replace
1586	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()  ==  null  ||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()  ==  null  ||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()  ==  null  ||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()    ==    null    ||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	240	None	replace
1587	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(var))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isPropertyAssign(var))    {    	non-compiled	[CE]  	30	None	replace
1588	[BUG]  [BUGGY]  if(NodeUtil.isName(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(var))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isPropertyAssign(var))    {    	non-compiled	[CE]  	30	None	replace
1589	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(parent))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isPropertyAssign(var))    {    	non-compiled	[CE]  	30	None	replace
1590	[BUG]  [BUGGY]  var  =  scope.getVar(fnScope.getFirstChild().getString());  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(fnScope.getFirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(fnScope.getFirstChild().getString());	  var    =    scope.getVar(parent.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	80	None	replace
1591	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLestChild()  +  1);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLestChild()  +  1);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLestChild()  +  1);	  var    =    scope.getVar(n.getLastChild()    +    1);    	non-compiled	[CE]  orphaned  case	104	None	replace
1592	[BUG]  [BUGGY]  var  =  scope.getVar(N.getLastChild());  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(N.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(N.getLastChild());	  var    =    scope.getVar(n.getLastChild()    +    1);    	non-compiled	[CE]  orphaned  case	104	None	replace
1593	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	94	None	replace
1594	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	94	None	replace
1595	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(parent))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	94	None	replace
1596	[BUG]  [BUGGY]  if(parent.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(parent.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(parent.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {	  if(n.getType()    ==    Token.FUNCTION    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	167	None	replace
1597	[BUG]  [BUGGY]  if(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(n.getType()    ==    Token.FUNCTION    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	167	None	replace
1598	[BUG]  [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionObjectCall(n));  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionObjectCall(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(parent.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionObjectCall(n));	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||!NodeUtil.isFunctionObjectCall(n));    	non-compiled	[CE]  orphaned  case	245	None	replace
1599	[BUG]  [BUGGY]  Preconditions.checkState(type!=  Token.FUNCTION  &&  type  ==  Token.SCRIPT);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type!=  Token.FUNCTION  &&  type  ==  Token.SCRIPT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type!=  Token.FUNCTION  &&  type  ==  Token.SCRIPT);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.SCRIPT);    	non-compiled	[CE]  orphaned  case	169	None	replace
1600	[BUG]  [BUGGY]  var  =  scope.getVar(n.getString(),  n.getFirstChild());  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getString(),  n.getFirstChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getString(),  n.getFirstChild());	  var    =    scope.getVar(n.getString());    	non-compiled	[CE]  orphaned  case	105	None	replace
1601	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  node.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  node.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  node.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()    ==    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	225	None	replace
1602	[BUG]  [BUGGY]  Node  var  =  n.getChildCount();  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  n.getChildCount();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  n.getChildCount();	  Node    var    =    n.getNext();    	non-compiled	[CE]  orphaned  case	16	None	replace
1603	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent  ==  null  ||  type  ==  Token.FUNCTION  ||  type  ==  Token.NAME)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent  ==  null  ||  type  ==  Token.FUNCTION  ||  type  ==  Token.NAME)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent  ==  null  ||  type  ==  Token.FUNCTION  ||  type  ==  Token.NAME)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    type    ==    Token.NAME)    {    	non-compiled	[CE]  	250	None	replace
1604	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  type  ==  Token.NAME)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  type  ==  Token.NAME)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  type  ==  Token.NAME)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    type    ==    Token.NAME)    {    	non-compiled	[CE]  	250	None	replace
1605	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  type  ==  Token.FUNCTION  ||  type  ==  Token.NAME)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  type  ==  Token.FUNCTION  ||  type  ==  Token.NAME)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  type  ==  Token.FUNCTION  ||  type  ==  Token.NAME)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    type    ==    Token.NAME)    {    	non-compiled	[CE]  	250	None	replace
1606	[BUG]  [BUGGY]  if(NodeUtil.isFunctionObjectCall(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionObjectCall(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionObjectCall(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isExpressionNode(parent)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	213	None	replace
1607	[BUG]  [BUGGY]  if(NodeUtil.isFunctionPrototype(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionPrototype(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionPrototype(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isExpressionNode(parent)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	213	None	replace
1608	[BUG]  [BUGGY]  Node  c  =  n.getFirstChild().getCurrentNode();  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.getFirstChild().getCurrentNode();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getFirstChild().getCurrentNode();	  Node    c    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	224	None	replace
1609	[BUG]  [BUGGY]  Node  c  =  n.getFirstChild().getNext()  +  1;  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.getFirstChild().getNext()  +  1;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getFirstChild().getNext()  +  1;	  Node    c    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	224	None	replace
1610	[BUG]  [BUGGY]  Node  c  =  n.getFirstChild().getFunctionDeclaration();  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.getFirstChild().getFunctionDeclaration();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getFirstChild().getFunctionDeclaration();	  Node    c    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	224	None	replace
1611	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent  ==  null  ||  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent  ==  null  ||  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent  ==  null  ||  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	249	None	replace
1612	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	249	None	replace
1613	[BUG]  [BUGGY]  Node  n  =  node.removeFirstChild();  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  node.removeFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  node.removeFirstChild();	  Node    n    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	266	None	replace
1614	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent!=  null)  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent!=  null)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    type!=    Token.FUNCTION)    {    	non-compiled	[CE]  	59	None	replace
1615	[BUG]  [BUGGY]  if(NodeUtil.isName(n)&&  type!=  Token.FUNCTION)  {  [CE]  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)&&  type!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)&&  type!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    type!=    Token.FUNCTION)    {    	non-compiled	[CE]  	59	None	replace
1616	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  type!=  Token.FUNCTION)  {  [CE]  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  type!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)&&  type!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    type!=    Token.FUNCTION)    {    	non-compiled	[CE]  	59	None	replace
1617	[BUG]  [BUGGY]  if(fnScope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(fnScope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(fnScope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(fnScope!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	237	None	replace
1618	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  scope.isFunctionPrototype());  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  scope.isFunctionPrototype());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  scope.isFunctionPrototype());	  Context.checkState(n.getType()    ==    Token.FUNCTION,    scope);    	non-compiled	[CE]  orphaned  case	152	None	replace
1619	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION,  nameNode);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION,  nameNode);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION,  nameNode);	  Context.checkState(n.getType()    ==    Token.FUNCTION,    scope);    	non-compiled	[CE]  orphaned  case	152	None	replace
1620	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  scope.isConstructor());  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  scope.isConstructor());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  scope.isConstructor());	  Context.checkState(n.getType()    ==    Token.FUNCTION,    scope);    	non-compiled	[CE]  orphaned  case	152	None	replace
1621	[BUG]  [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION,  scope);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(parent.getType()  ==  Token.FUNCTION,  scope);	  Context.checkState(n.getType()    ==    Token.FUNCTION,    scope);    	non-compiled	[CE]  orphaned  case	152	None	replace
1622	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  scope.isExtern());  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  scope.isExtern());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  scope.isExtern());	  Context.checkState(n.getType()    ==    Token.FUNCTION,    scope);    	non-compiled	[CE]  orphaned  case	152	None	replace
1623	[BUG]  [BUGGY]  if(NodeUtil.isFunctionPrototype(n)||  NodeUtil.isExpressionNode(parent))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionPrototype(n)||  NodeUtil.isExpressionNode(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionPrototype(n)||  NodeUtil.isExpressionNode(parent))  {	  if(NodeUtil.isExpressionNode(parent)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	10	None	replace
1624	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().getType()  ==  Token.VAR);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	252	None	replace
1625	[BUG]  [BUGGY]  var  =  module.getVar(n.getFirstChild().getString());  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  module.getVar(n.getFirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  module.getVar(n.getFirstChild().getString());	  var    =    parent.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	221	None	replace
1626	[BUG]  [BUGGY]  var  =  node.getVar(parent.getFirstChild().getString());  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  node.getVar(parent.getFirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  node.getVar(parent.getFirstChild().getString());	  var    =    parent.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	221	None	replace
1627	[BUG]  [BUGGY]  var  =  type.getVar(n.getFirstChild().getString());  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  type.getVar(n.getFirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  type.getVar(n.getFirstChild().getString());	  var    =    parent.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	221	None	replace
1628	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	275	None	replace
1629	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	275	None	replace
1630	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.FUNCTION);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString()!=    null);    	non-compiled	[CE]  orphaned  case	154	None	replace
1631	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getLastChild().getString()!=  null);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getLastChild().getString()!=  null);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getLastChild().getString()!=  null);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString()!=    null);    	non-compiled	[CE]  orphaned  case	154	None	replace
1632	[BUG]  [BUGGY]  if(NodeUtil.isFunctionObjectCall(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionObjectCall(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionObjectCall(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isExpressionNode(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	165	None	replace
1633	[BUG]  [BUGGY]  if(NodeUtil.isFunctionAnonymous(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionAnonymous(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionAnonymous(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isExpressionNode(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	165	None	replace
1634	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    n.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	226	None	replace
1635	[BUG]  [BUGGY]  Var  var  =  scope.getVar(n.getLastChild().getString(),  n.getFirstChild());  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Var  var  =  scope.getVar(n.getLastChild().getString(),  n.getFirstChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Var  var  =  scope.getVar(n.getLastChild().getString(),  n.getFirstChild());	  Var    var    =    scope.getVar(n.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	81	None	replace
1636	[BUG]  [BUGGY]  Node  var  =  parent.getVar(n.getLastChild());  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  parent.getVar(n.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  parent.getVar(n.getLastChild());	  Node    var    =    scope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	17	None	replace
1637	[BUG]  [BUGGY]  Node  var  =  scope.getVar(n.getLastChild(),  n.getJSDocInfo());  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  scope.getVar(n.getLastChild(),  n.getJSDocInfo());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getVar(n.getLastChild(),  n.getJSDocInfo());	  Node    var    =    scope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	17	None	replace
1638	[BUG]  [BUGGY]  Node  n  =  node.getfirstChild();  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  node.getfirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  node.getfirstChild();	  Node    n    =    parent.getfirstChild();    	non-compiled	[CE]  orphaned  case	267	None	replace
1639	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.CATCH  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.CATCH  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.CATCH  ||  type  ==  Token.FUNCTION);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.CATCH);    	non-compiled	[CE]  orphaned  case	265	None	replace
1640	[BUG]  [BUGGY]  if(NodeUtil.isFunction(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunction(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunction(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isAssignmentOp(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	33	None	replace
1641	[BUG]  [BUGGY]  if(NodeUtil.isFunction(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunction(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunction(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isAssignmentOp(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	33	None	replace
1642	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(parent)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	32	None	replace
1643	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.NAME  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.NAME  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.NAME  ||  type  ==  Token.FUNCTION);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	149	None	replace
1644	[BUG]  [BUGGY]  if(NodeUtil.isFunctionObjectCall(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionObjectCall(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionObjectCall(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isExpressionNode(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	158	None	replace
1645	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  parent.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  parent.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  parent.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()!=    Token.FUNCTION    ||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	161	None	replace
1646	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  parent.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  parent.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)||  parent.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()!=    Token.FUNCTION    ||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	161	None	replace
1647	[BUG]  [BUGGY]  Node  var  =  node.getNext();  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  node.getNext();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  node.getNext();	  Node    var    =    node.getFirstChild();    	non-compiled	[CE]  orphaned  case	228	None	replace
1648	[BUG]  [BUGGY]  var  =  scope.getVar(parent.getLastChild(),  n.getFirstChild());  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(parent.getLastChild(),  n.getFirstChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(parent.getLastChild(),  n.getFirstChild());	  var    =    scope.getVar(n.getLastChild(),    n.getFirstChild());    	non-compiled	[CE]  orphaned  case	178	None	replace
1649	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isGetProp(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isGetProp(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isGetProp(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	23	None	replace
1650	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isName(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	100	None	replace
1651	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isName(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	100	None	replace
1652	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isGetProp(n))  {  [CE]  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isGetProp(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isGetProp(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isName(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	100	None	replace
1653	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  parent.getType()  ==  Token.VAR)  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  parent.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  parent.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	186	None	replace
1654	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	186	None	replace
1655	[BUG]  [BUGGY]  if(NodeUtil.isName(parent)&&  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(parent)&&  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(parent)&&  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isName(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	40	None	replace
1656	[BUG]  [BUGGY]  if(var!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(var!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(var!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	246	None	replace
1657	[BUG]  [BUGGY]  if(NodeUtil.isFunctionObjectCall(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionObjectCall(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionObjectCall(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isExpressionNode(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	91	None	replace
1658	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isExpressionNode(parent))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isExpressionNode(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isExpressionNode(parent))  {	  if(NodeUtil.isExpressionNode(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	91	None	replace
1659	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	85	None	replace
1660	[BUG]  [BUGGY]  Node  parent  =  n.getPrevious();  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  parent  =  n.getPrevious();  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  parent  =  n.getPrevious();	  Node    parent    =    n.getParent();    	non-compiled	[CE]  orphaned  case	142	None	replace
1661	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent  ==  null)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent  ==  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent  ==  null)  {	  if(NodeUtil.isFunctionDeclaration(parent)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	57	None	replace
1662	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(parent)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(parent)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(parent)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(parent)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	57	None	replace
1663	[BUG]  [BUGGY]  if(NodeUtil.isVar(parent)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(parent)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(parent)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(parent)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	57	None	replace
1664	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT,  n);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT,  n);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT,  n);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  orphaned  case	108	None	replace
1665	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.EXPR_RESULT  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.EXPR_RESULT  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.EXPR_RESULT  ||  type  ==  Token.FUNCTION);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  orphaned  case	108	None	replace
1666	[BUG]  [BUGGY]  Node  n  =  n.getNext()  ||  parent.getType()  ==  Token.FUNCTION;  [CE]  orphaned  case  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  n.getNext()  ||  parent.getType()  ==  Token.FUNCTION;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  n.getNext()  ||  parent.getType()  ==  Token.FUNCTION;	  Node    n    =    n.getNext();    	non-compiled	[CE]  orphaned  case	18	None	replace
1667	[BUG]  [BUGGY]  Node  n  =  n.getNext()  ||  parent.getType()!=  Token.FUNCTION;  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  n.getNext()  ||  parent.getType()!=  Token.FUNCTION;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  n.getNext()  ||  parent.getType()!=  Token.FUNCTION;	  Node    n    =    n.getNext();    	non-compiled	[CE]  orphaned  case	18	None	replace
1668	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isExpressionNode(n)||  scope.getVar(n.getFirstChild().getString())!=  null)  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isExpressionNode(n)||  scope.getVar(n.getFirstChild().getString())!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isExpressionNode(n)||  scope.getVar(n.getFirstChild().getString())!=  null)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getVar(n.getFirstChild().getString())!=    null)    {    	non-compiled	[CE]  	281	None	replace
1669	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	93	None	replace
1670	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(parent)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	93	None	replace
1671	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructor(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructor(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructor(parent)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	93	None	replace
1672	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isVar(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isVar(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isVar(parent)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	93	None	replace
1673	[BUG]  [BUGGY]  Node  var  =  parent.getVar(n.getFirstChild().getString());  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  parent.getVar(n.getFirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  parent.getVar(n.getFirstChild().getString());	  Node    var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	15	None	replace
1674	[BUG]  [BUGGY]  Node  var  =  scope.getVar(n.getFirstChild().getString(),  n);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  scope.getVar(n.getFirstChild().getString(),  n);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getVar(n.getFirstChild().getString(),  n);	  Node    var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	15	None	replace
1675	[BUG]  [BUGGY]  Node  var  =  scope.getVar(n.getFirstChild().getString())+  1;  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  scope.getVar(n.getFirstChild().getString())+  1;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getVar(n.getFirstChild().getString())+  1;	  Node    var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	15	None	replace
1676	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  var);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild(),  var);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  var);	  var    =    scope.getVar(n.getLastChild(),    type);    	non-compiled	[CE]  orphaned  case	102	None	replace
1677	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  varType);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild(),  varType);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  varType);	  var    =    scope.getVar(n.getLastChild(),    type);    	non-compiled	[CE]  orphaned  case	102	None	replace
1678	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  var.getString());  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild(),  var.getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  var.getString());	  var    =    scope.getVar(n.getLastChild(),    type);    	non-compiled	[CE]  orphaned  case	102	None	replace
1679	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	87	None	replace
1680	[BUG]  [BUGGY]  if(NodeUtil.isFunctionObjectCall(n)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionObjectCall(n)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionObjectCall(n)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isExpressionNode(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	55	None	replace
1681	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	176	None	replace
1682	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isExpressionNode(parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isExpressionNode(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isExpressionNode(parent))  {	  if(NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	176	None	replace
1683	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isForIn(parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isForIn(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isForIn(parent))  {	  if(NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	176	None	replace
1684	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	35	None	replace
1685	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  node.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  node.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  node.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	35	None	replace
1686	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  modifiedVar.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  modifiedVar.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  modifiedVar.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	35	None	replace
1687	[BUG]  [BUGGY]  if(NodeUtil.isName(n)&&  parent.getLastChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)&&  parent.getLastChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)&&  parent.getLastChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getLastChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	92	None	replace
1688	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	187	None	replace
1689	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	187	None	replace
1690	[BUG]  [BUGGY]  n  =  NodeUtil.getLastChild();  [CE]  orphaned  case  [FE]                                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  NodeUtil.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  NodeUtil.getLastChild();	  n    =    parent.getLastChild();    	non-compiled	[CE]  orphaned  case	125	None	replace
1691	[BUG]  [BUGGY]  n  =  n.getfirstChild();  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.getfirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getfirstChild();	  n    =    n.getLastChild();    	non-compiled	[CE]  orphaned  case	121	None	replace
1692	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR  ||  scope.isFunctionDeclaration());  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR  ||  scope.isFunctionDeclaration());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()  ==  Token.VAR  ||  scope.isFunctionDeclaration());	  Preconditions.checkState(scope.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	231	None	replace
1693	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR,  n);  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR,  n);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()  ==  Token.VAR,  n);	  Preconditions.checkState(scope.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	231	None	replace
1694	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR  ||  scope.isFunctionPrototype());  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR  ||  scope.isFunctionPrototype());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()  ==  Token.VAR  ||  scope.isFunctionPrototype());	  Preconditions.checkState(scope.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	231	None	replace
1695	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isGetProp(n)||  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isGetProp(n)||  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isGetProp(n)||  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getFirstChild().getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	24	None	replace
1696	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isName(n)||  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isName(n)||  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isName(n)||  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getFirstChild().getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	24	None	replace
1697	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getLastChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	114	None	replace
1698	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isGetProp(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getLastChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	114	None	replace
1699	[BUG]  [BUGGY]  Node  c  =  n.getChildCount();  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.getChildCount();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getChildCount();	  Node    c    =    n.getNext();    	non-compiled	[CE]  orphaned  case	63	None	replace
1700	[BUG]  [BUGGY]  Node  n  =  getFunctionScope().getVar(n.getLastChild());  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  getFunctionScope().getVar(n.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  getFunctionScope().getVar(n.getLastChild());	  Node    n    =    getFunctionScope().getFirstChild();    	non-compiled	[CE]  orphaned  case	273	None	replace
1701	[BUG]  [BUGGY]  Node  n  =  getFunctionScope().getRootNode();  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  getFunctionScope().getRootNode();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  getFunctionScope().getRootNode();	  Node    n    =    getFunctionScope().getFirstChild();    	non-compiled	[CE]  orphaned  case	273	None	replace
1702	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.EXPR_RESULT  ||  type  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  orphaned  case	47	None	replace
1703	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(	  if(NodeUtil.isAssignmentOp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	97	None	replace
1704	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n	  if(NodeUtil.isAssignmentOp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	97	None	replace
1705	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isAssignmentOp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	97	None	replace
1706	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  n.getFirstChild()  :  n.getFirstChild();  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  n.getFirstChild()  :  n.getFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()!=  null)?  n.getFirstChild()  :  n.getFirstChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	255	None	replace
1707	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.hasChildren())  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.hasChildren())  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.hasChildren())  {	  if(scope    ==    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	239	None	replace
1708	[BUG]  [BUGGY]  Preconditions.checkState(n.type!=  Token.FUNCTION);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.type!=  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.type!=  Token.FUNCTION);	  Preconditions.checkState(type!=    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	106	None	replace
1709	[BUG]  [BUGGY]  Preconditions.checkState(n.type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.type  ==  Token.FUNCTION);	  Preconditions.checkState(type!=    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	106	None	replace
1710	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR  ||  type  ==  Token.NAME);  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR  ||  type  ==  Token.NAME);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()  ==  Token.VAR  ||  type  ==  Token.NAME);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	232	None	replace
1711	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  n.getType()  ==  Token.NAME);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  n.getType()  ==  Token.NAME);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  ||  n.getType()  ==  Token.NAME);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	232	None	replace
1712	[BUG]  [BUGGY]  Node  c  =  n.removeFirstChild().getNext();  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.removeFirstChild().getNext();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.removeFirstChild().getNext();	  Node    c    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	242	None	replace
1713	[BUG]  [BUGGY]  Node  c  =  n.cloneTree();  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.cloneTree();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.cloneTree();	  Node    c    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	242	None	replace
1714	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	190	None	replace
1715	[BUG]  [BUGGY]  if(NodeUtil.isName(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	190	None	replace
1716	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	190	None	replace
1717	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	190	None	replace
1718	[BUG]  [BUGGY]  Preconditions.checkState(parent!=  null  &&  parent.getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent!=  null  &&  parent.getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent!=  null  &&  parent.getType()  ==  Token.VAR);	  Preconditions.checkState(parent.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	70	None	replace
1719	[BUG]  [BUGGY]  Preconditions.checkState(parent!=  null  ||  parent.getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent!=  null  ||  parent.getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent!=  null  ||  parent.getType()  ==  Token.VAR);	  Preconditions.checkState(parent.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	70	None	replace
1720	[BUG]  [BUGGY]  var  =  scope.getVar(N.getFirstChild().getString());  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(N.getFirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(N.getFirstChild().getString());	  var    =    scope.getVar(n.getFirstChild().getString()    +    1);    	non-compiled	[CE]  orphaned  case	83	None	replace
1721	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild().getType()  ==  Token.VAR)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild().getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild().getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	159	None	replace
1722	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n  +  1);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n  +  1);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  n  +  1);	  var    =    scope.getVar(n.getLastChild(),    n);    	non-compiled	[CE]  orphaned  case	179	None	replace
1723	[BUG]  [BUGGY]  var  =  scope.getVar(n.getString(),  n);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getString(),  n);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getString(),  n);	  var    =    scope.getVar(n.getLastChild(),    n);    	non-compiled	[CE]  orphaned  case	179	None	replace
1724	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  var);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  var);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild().getString(),  var);	  var    =    scope.getVar(n.getLastChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	146	None	replace
1725	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  varName);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  varName);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild().getString(),  varName);	  var    =    scope.getVar(n.getLastChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	146	None	replace
1726	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  varType);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  varType);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild().getString(),  varType);	  var    =    scope.getVar(n.getLastChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	146	None	replace
1727	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  varNode);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  varNode);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild().getString(),  varNode);	  var    =    scope.getVar(n.getLastChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	146	None	replace
1728	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  fnScope);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  fnScope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild().getString(),  fnScope);	  var    =    scope.getVar(n.getLastChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	146	None	replace
1729	[BUG]  [BUGGY]  var  =  scope.getVar(parent.getLastChild().getString(),  type);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(parent.getLastChild().getString(),  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(parent.getLastChild().getString(),  type);	  var    =    scope.getVar(n.getLastChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	146	None	replace
1730	[BUG]  [BUGGY]  Node  scope  =  n.removeChild(parent);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  n.removeChild(parent);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  n.removeChild(parent);	  Node    scope    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	201	None	replace
1731	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)&&  type!=  Token.FUNCTION)  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)&&  type!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)&&  type!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    type!=    Token.FUNCTION)    {    	non-compiled	[CE]  	59	None	replace
1732	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSecondaryVar(n))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSecondaryVar(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSecondaryVar(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	73	None	replace
1733	[BUG]  [BUGGY]  Node  n  =  parent.getParentNode();  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  parent.getParentNode();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  parent.getParentNode();	  Node    n    =    parent.getNext();    	non-compiled	[CE]  orphaned  case	43	None	replace
1734	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(parent))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(parent))    {    	non-compiled	[CE]  	214	None	replace
1735	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION    ||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	156	None	replace
1736	[BUG]  [BUGGY]  if(NodeUtil.isLiteralValue(n)||  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isLiteralValue(n)||  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isLiteralValue(n)||  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    scope.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	209	None	replace
1737	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  parent!=  null)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  parent!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  parent!=  null)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    parent!=    null)    {    	non-compiled	[CE]  	235	None	replace
1738	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	130	None	replace
1739	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	130	None	replace
1740	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getString()  :  n.getFirstChild();  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getString()  :  n.getFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()  ==  null)?  n.getString()  :  n.getFirstChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getString()    :    n.getLastChild();    	non-compiled	[CE]  orphaned  case	259	None	replace
1741	[BUG]  [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  ||  n.getFirstChild().getString()  ==  null);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  ||  n.getFirstChild().getString()  ==  null);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()!=  Token.FUNCTION  ||  n.getFirstChild().getString()  ==  null);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString()!=    null);    	non-compiled	[CE]  orphaned  case	154	None	replace
1742	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	274	None	replace
1743	[BUG]  [BUGGY]  Preconditions.checkArgument(type  ==  Token.FUNCTION  ||  type  ==  Token.CALL);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(type  ==  Token.FUNCTION  ||  type  ==  Token.CALL);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(type  ==  Token.FUNCTION  ||  type  ==  Token.CALL);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.CALL);    	non-compiled	[CE]  orphaned  case	112	None	replace
1744	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.CALL  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.CALL  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.CALL  ||  type  ==  Token.FUNCTION);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.CALL);    	non-compiled	[CE]  orphaned  case	112	None	replace
1745	[BUG]  [BUGGY]  if(NodeUtil.isLiteralValue(n)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isLiteralValue(n)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isLiteralValue(n)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(parent)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	57	None	replace
1746	[BUG]  [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.VAR  ||  n.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.VAR  ||  n.getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(n.getType()  ==  Token.VAR  ||  n.getType()  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	72	None	replace
1747	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  parent.getFirstChild().getString())  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  parent.getFirstChild().getString())  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  parent.getFirstChild().getString())  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	56	None	replace
1748	[BUG]  [BUGGY]  Node  c  =  node.getNext();  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  node.getNext();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  node.getNext();	  Node    c    =    node.getFirstChild();    	non-compiled	[CE]  orphaned  case	65	None	replace
1749	[BUG]  [BUGGY]  Node  scope  =  n.getOwnerFunction();  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  n.getOwnerFunction();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  n.getOwnerFunction();	  Node    scope    =    n.getNext();    	non-compiled	[CE]  orphaned  case	168	None	replace
1750	[BUG]  [BUGGY]  Node  scope  =  n.getFirstChild().getNext();  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  n.getFirstChild().getNext();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  n.getFirstChild().getNext();	  Node    scope    =    n.getNext();    	non-compiled	[CE]  orphaned  case	168	None	replace
1751	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(n.getFirstChild()))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(n.getFirstChild()))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(n.getFirstChild()))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionPrototype(parent))    {    	non-compiled	[CE]  	177	None	replace
1752	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionPrototype(parent))    {    	non-compiled	[CE]  	177	None	replace
1753	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(parent)||  type  ==  Token.VAR)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(parent)||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(parent)||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionPrototype(parent))    {    	non-compiled	[CE]  	177	None	replace
1754	[BUG]  [BUGGY]  Node  n  =  type.getNext();  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  type.getNext();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  type.getNext();	  Node    n    =    scope.getParent();    	non-compiled	[CE]  orphaned  case	4	None	replace
1755	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	95	None	replace
1756	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	95	None	replace
1757	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	95	None	replace
1758	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	95	None	replace
1759	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT,  n.getFirstChild());  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT,  n.getFirstChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT,  n.getFirstChild());	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.EXPR_RESULT);    	non-compiled	[CE]  orphaned  case	151	None	replace
1760	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  type!=  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  type!=  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  type!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type!=    Token.FUNCTION)    {    	non-compiled	[CE]  	54	None	replace
1761	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n,  parent),  scope)  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n,  parent),  scope)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n,  parent),  scope)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n,    parent))    {    	non-compiled	[CE]  	271	None	replace
1762	[BUG]  [BUGGY]  if(scope.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {	  if(n.getType()    ==    Token.FUNCTION    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	167	None	replace
1763	[BUG]  [BUGGY]  if(n.getType()  ==  Token.VAR  ||  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n.getType()  ==  Token.VAR  ||  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n.getType()  ==  Token.VAR  ||  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {	  if(n.getType()    ==    Token.FUNCTION    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	167	None	replace
1764	[BUG]  [BUGGY]  if(n.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(n.getType()    ==    Token.FUNCTION    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	167	None	replace
1765	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  n.getFirstChild());  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  n.getFirstChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild().getString(),  n.getFirstChild());	  var    =    scope.getVar(n.getLastChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	146	None	replace
1766	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  n.getNext());  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  n.getNext());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild().getString(),  n.getNext());	  var    =    scope.getVar(n.getLastChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	146	None	replace
1767	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  c);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  c);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild().getString(),  c);	  var    =    scope.getVar(n.getLastChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	146	None	replace
1768	[BUG]  [BUGGY]  Node  c  =  n.firstChild();  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.firstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.firstChild();	  Node    c    =    n.getLastChild();    	non-compiled	[CE]  orphaned  case	61	None	replace
1769	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	283	None	replace
1770	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isVar(n)||  scope.getType()  ==  Token.VAR)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isVar(n)||  scope.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isVar(n)||  scope.getType()  ==  Token.VAR)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	283	None	replace
1771	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  module.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  module.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  module.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	35	None	replace
1772	[BUG]  [BUGGY]  Node  scope  =(parent.getFirstChild()  ==  null)?  parent.getFirstChild()  :  n.getLastChild();  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(parent.getFirstChild()  ==  null)?  parent.getFirstChild()  :  n.getLastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(parent.getFirstChild()  ==  null)?  parent.getFirstChild()  :  n.getLastChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    parent.getFirstChild()    :    n.getLastChild();    	non-compiled	[CE]  orphaned  case	257	None	replace
1773	[BUG]  [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  scope).traverse(fnScope);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  scope).traverse(fnScope);  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	NodeTraversal.traverse(compiler,  n,  parent,  scope).traverse(fnScope);	  NodeTraversal.traverse(compiler,    n,    parent,    scope);    	non-compiled	[CE]  orphaned  case	207	None	replace
1774	[BUG]  [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  scope).traverse(scope);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  scope).traverse(scope);  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	NodeTraversal.traverse(compiler,  n,  parent,  scope).traverse(scope);	  NodeTraversal.traverse(compiler,    n,    parent,    scope);    	non-compiled	[CE]  orphaned  case	207	None	replace
1775	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getLastChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getLastChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  n.getLastChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getLastChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	92	None	replace
1776	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isVar(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isVar(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isVar(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isConstructorOp(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	99	None	replace
1777	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isConstructorOp(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	99	None	replace
1778	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.VAR  ||!NodeUtil.isFunctionDeclaration(n));  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()!=  Token.VAR  ||!NodeUtil.isFunctionDeclaration(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()!=  Token.VAR  ||!NodeUtil.isFunctionDeclaration(n));	  Preconditions.checkState(n.getType()!=    Token.VAR);    	non-compiled	[CE]  orphaned  case	68	None	replace
1779	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  isExpressionNode(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  isExpressionNode(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  isExpressionNode(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    isRemovableVar(n))    {    	non-compiled	[CE]  	236	None	replace
1780	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  isRemovableVar(n,  parent))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  isRemovableVar(n,  parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  isRemovableVar(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    isRemovableVar(n))    {    	non-compiled	[CE]  	236	None	replace
1781	[BUG]  [BUGGY]  if(NodeUtil.isVarDeclaration(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVarDeclaration(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVarDeclaration(n)&&  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isLiteralValue(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	277	None	replace
1782	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(parent))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	241	None	replace
1783	[BUG]  [BUGGY]  Node  c  =  n.getOwnerChild();  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.getOwnerChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getOwnerChild();	  Node    c    =    n.getNext();    	non-compiled	[CE]  orphaned  case	63	None	replace
1784	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  type  ==  Token.FUNCTION  ||  scope.getType()  ==  Token.VAR)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  type  ==  Token.FUNCTION  ||  scope.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  type  ==  Token.FUNCTION  ||  scope.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    scope.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	58	None	replace
1785	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.hasVar(n.getFirstChild().getString()))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.hasVar(n.getFirstChild().getString()))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.hasVar(n.getFirstChild().getString()))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	25	None	replace
1786	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionAssign(n))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionAssign(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionAssign(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	25	None	replace
1787	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.EXPR_RESULT);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.EXPR_RESULT);	  Preconditions.checkState(parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	48	None	replace
1788	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.CALL);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.CALL);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.CALL);	  Preconditions.checkState(parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	48	None	replace
1789	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.NAME);  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.NAME);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.NAME);	  Preconditions.checkState(parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	48	None	replace
1790	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.SCRIPT);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.SCRIPT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.SCRIPT);	  Preconditions.checkState(parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	48	None	replace
1791	[BUG]  [BUGGY]  if(NodeUtil.isFunctionObjectCall(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionObjectCall(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionObjectCall(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isExpressionNode(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	75	None	replace
1792	[BUG]  [BUGGY]  if(NodeUtil.isFunctionAnonymous(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionAnonymous(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionAnonymous(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isExpressionNode(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	75	None	replace
1793	[BUG]  [BUGGY]  if(NodeUtil.isFunctionAssign(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionAssign(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionAssign(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isExpressionNode(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	75	None	replace
1794	[BUG]  [BUGGY]  Node  scope  =  getFunctionScope().getChildCount();  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  getFunctionScope().getChildCount();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getFunctionScope().getChildCount();	  Node    scope    =    getFunctionScope().getFirstChild();    	non-compiled	[CE]  orphaned  case	216	None	replace
1795	[BUG]  [BUGGY]  Node  scope  =  n.getFirstChild().getFirstChild();  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  n.getFirstChild().getFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  n.getFirstChild().getFirstChild();	  Node    scope    =    getFunctionScope().getFirstChild();    	non-compiled	[CE]  orphaned  case	216	None	replace
1796	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.VAR  ||  parent.getFirstChild()!=  n);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.VAR  ||  parent.getFirstChild()!=  n);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.VAR  ||  parent.getFirstChild()!=  n);	  Preconditions.checkState(parent.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	70	None	replace
1797	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.VAR  ||  parent.getType()  ==  Token.BLOCK);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.VAR  ||  parent.getType()  ==  Token.BLOCK);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.VAR  ||  parent.getType()  ==  Token.BLOCK);	  Preconditions.checkState(parent.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	70	None	replace
1798	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.VAR  ||  parent.getType()  ==  Token.CALL);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.VAR  ||  parent.getType()  ==  Token.CALL);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.VAR  ||  parent.getType()  ==  Token.CALL);	  Preconditions.checkState(parent.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	70	None	replace
1799	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.VAR  ||  parent.getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.VAR  ||  parent.getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.VAR  ||  parent.getType()  ==  Token.VAR);	  Preconditions.checkState(parent.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	70	None	replace
1800	[BUG]  [BUGGY]  var  =  scope.getVar(n,  parent.getFirstChild().getString());  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n,  parent.getFirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n,  parent.getFirstChild().getString());	  var    =    scope.getVar(parent.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	80	None	replace
1801	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()  ==  n  ||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()  ==  n  ||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()  ==  n  ||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()    ==    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	88	None	replace
1802	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isExpressionNode(parent))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isExpressionNode(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isExpressionNode(parent))  {	  if(NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	176	None	replace
1803	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExprAssign(parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExprAssign(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExprAssign(parent))  {	  if(NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	176	None	replace
1804	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR  ||  scope.hasOneChild());  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR  ||  scope.hasOneChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()  ==  Token.VAR  ||  scope.hasOneChild());	  Preconditions.checkState(scope.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	231	None	replace
1805	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  n.getLocalName();  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  n.getLocalName();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  n.getLocalName();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n.getString();    	non-compiled	[CE]  orphaned  case	258	None	replace
1806	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getFirstChild()  :  n.getString();  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getFirstChild()  :  n.getString();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()  ==  null)?  n.getFirstChild()  :  n.getString();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n.getString();    	non-compiled	[CE]  orphaned  case	258	None	replace
1807	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  n.getParent();  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  n.getParent();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  n.getParent();	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n.getString();    	non-compiled	[CE]  orphaned  case	258	None	replace
1808	[BUG]  [BUGGY]  Node  parent  =  n.getParent()  +  1;  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  parent  =  n.getParent()  +  1;  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  parent  =  n.getParent()  +  1;	  Node    parent    =    n.getParent();    	non-compiled	[CE]  orphaned  case	142	None	replace
1809	[BUG]  [BUGGY]  Node  parent  =  n.getParentOfThis();  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  parent  =  n.getParentOfThis();  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  parent  =  n.getParentOfThis();	  Node    parent    =    n.getParent();    	non-compiled	[CE]  orphaned  case	142	None	replace
1810	[BUG]  [BUGGY]  if(NodeUtil.isFunctionObjectCall(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionObjectCall(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionObjectCall(n)&&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isExpressionNode(parent)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	198	None	replace
1811	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()!=  null)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()!=  null)  {	  if(NodeUtil.isExpressionNode(parent)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	198	None	replace
1812	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isExpressionNode(parent)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	198	None	replace
1813	[BUG]  [BUGGY]  Var  var  =  this.fnScope.getVar(n.getLastChild().getString());  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Var  var  =  this.fnScope.getVar(n.getLastChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Var  var  =  this.fnScope.getVar(n.getLastChild().getString());	  Var    var    =    scope.getVar(n.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	81	None	replace
1814	[BUG]  [BUGGY]  Var  var  =  scope.getVar(n.getfirstChild().getString());  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Var  var  =  scope.getVar(n.getfirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Var  var  =  scope.getVar(n.getfirstChild().getString());	  Var    var    =    scope.getVar(n.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	81	None	replace
1815	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  isPropertyAssign(var))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  isPropertyAssign(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  isPropertyAssign(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isPropertyAssign(var))    {    	non-compiled	[CE]  	30	None	replace
1816	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isConstructorAssign(n,  parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isConstructorAssign(n,  parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isConstructorAssign(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isPropertyAssign(var))    {    	non-compiled	[CE]  	30	None	replace
1817	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  parent.getLastChild()  :  n.getFirstChild();  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  parent.getLastChild()  :  n.getFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()!=  null)?  parent.getLastChild()  :  n.getFirstChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    parent.getLastChild()    :    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	260	None	replace
1818	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  n.getLastChild()  :  n.getFirstChild();  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()!=  null)?  n.getLastChild()  :  n.getFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()!=  null)?  n.getLastChild()  :  n.getFirstChild();	  Node    scope    =(n.getFirstChild()    ==    null)?    parent.getLastChild()    :    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	260	None	replace
1819	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isGetProp(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isGetProp(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isGetProp(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	270	None	replace
1820	[BUG]  [BUGGY]  if(NodeUtil.isVar(parent)&&  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(parent)&&  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(parent)&&  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isVar(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	269	None	replace
1821	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  n.getFirstChild());  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  n.getFirstChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  n.getFirstChild());	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	49	None	replace
1822	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(parent)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	162	None	replace
1823	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().contains( "function "));  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().contains( "function "));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().contains( "function "));	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString().equals(   "function   "));    	non-compiled	[CE]  orphaned  case	50	None	replace
1824	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionAnonymous(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionAnonymous(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionAnonymous(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(n))    {    	non-compiled	[CE]  	74	None	replace
1825	[BUG]  [BUGGY]  var  =  scope.getVar(n.getChildCount().getString());  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getChildCount().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getChildCount().getString());	  var    =    scope.getVar(n.getNext().getString());    	non-compiled	[CE]  orphaned  case	84	None	replace
1826	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.CALL  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.CALL  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.CALL  ||  type  ==  Token.FUNCTION);	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.CALL);    	non-compiled	[CE]  orphaned  case	205	None	replace
1827	[BUG]  [BUGGY]  Node  c  =  n.getParentNode();  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.getParentNode();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getParentNode();	  Node    c    =    n.getCurrentNode();    	non-compiled	[CE]  orphaned  case	223	None	replace
1828	[BUG]  [BUGGY]  n  =  n.getNext()  ||  parent.getType()  ==  Token.VAR;  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.getNext()  ||  parent.getType()  ==  Token.VAR;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getNext()  ||  parent.getType()  ==  Token.VAR;	  n    =    n.getNext();    	non-compiled	[CE]  orphaned  case	123	None	replace
1829	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(parent))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	89	None	replace
1830	[BUG]  [BUGGY]  Node  n  =  n.getFirstChild().getQualifiedName();  [CE]  orphaned  case  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  n.getFirstChild().getQualifiedName();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  n.getFirstChild().getQualifiedName();	  Node    n    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	183	None	replace
1831	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getLastChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	119	None	replace
1832	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n,  parent))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n,  parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	193	None	replace
1833	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  NodeUtil.mayHaveSideE  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  NodeUtil.mayHaveSideE  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  NodeUtil.mayHaveSideE	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	193	None	replace
1834	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	193	None	replace
1835	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()!=  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()!=  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()!=  null  ||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()    ==    null    ||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	240	None	replace
1836	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  type  ==  Token.CATCH)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  type  ==  Token.CATCH)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  type  ==  Token.CATCH)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	53	None	replace
1837	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  type  ==  Token.VAR)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	53	None	replace
1838	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  type  ==  Token.GETPROP)  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  type  ==  Token.GETPROP)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR  ||  type  ==  Token.GETPROP)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	53	None	replace
1839	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isFunctionExpressionVar(var))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isFunctionExpressionVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isFunctionExpressionVar(var))  {	  if(NodeUtil.isExpressionNode(parent)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	213	None	replace
1840	[BUG]  [BUGGY]  Preconditions.checkArgument(type  ==  Token.FUNCTION  ||  type  ==  Token.SCRIPT);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(type  ==  Token.FUNCTION  ||  type  ==  Token.SCRIPT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(type  ==  Token.FUNCTION  ||  type  ==  Token.SCRIPT);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.SCRIPT);    	non-compiled	[CE]  orphaned  case	169	None	replace
1841	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.SCRIPT  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.SCRIPT  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.SCRIPT  ||  type  ==  Token.FUNCTION);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.SCRIPT);    	non-compiled	[CE]  orphaned  case	169	None	replace
1842	[BUG]  [BUGGY]  n  =  n.getFirstChild()  ||  parent.getType()  ==  Token.FUNCTION;  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.getFirstChild()  ||  parent.getType()  ==  Token.FUNCTION;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getFirstChild()  ||  parent.getType()  ==  Token.FUNCTION;	  n    =    parent.getFirstChild();    	non-compiled	[CE]  orphaned  case	122	None	replace
1843	[BUG]  [BUGGY]  n  =  n.getFirstChild()  ||  parent.getType()!=  Token.FUNCTION;  [CE]  orphaned  case  [FE]                                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.getFirstChild()  ||  parent.getType()!=  Token.FUNCTION;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getFirstChild()  ||  parent.getType()!=  Token.FUNCTION;	  n    =    parent.getFirstChild();    	non-compiled	[CE]  orphaned  case	122	None	replace
1844	[BUG]  [BUGGY]  Node  var  =  n.cloneTree();  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  n.cloneTree();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  n.cloneTree();	  Node    var    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	254	None	replace
1845	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)||    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	29	None	replace
1846	[BUG]  [BUGGY]  if(NodeUtil.isLiteralValue(n)||  type  ==  Token.FUNCTION  ||  scope!=  null)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isLiteralValue(n)||  type  ==  Token.FUNCTION  ||  scope!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isLiteralValue(n)||  type  ==  Token.FUNCTION  ||  scope!=  null)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    scope!=    null)    {    	non-compiled	[CE]  	234	None	replace
1847	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  type  ==  Token.FUNCTION  ||  scope!=  null)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  type  ==  Token.FUNCTION  ||  scope!=  null)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  type  ==  Token.FUNCTION  ||  scope!=  null)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    scope!=    null)    {    	non-compiled	[CE]  	234	None	replace
1848	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild().getString()!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild().getString()!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild().getString()!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	190	None	replace
1849	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects    	non-compiled	[CE]  	279	None	replace
1850	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isStatementBlock(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isStatementBlock(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isStatementBlock(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects    	non-compiled	[CE]  	279	None	replace
1851	[BUG]  [BUGGY]  Node  var  =  node.getFirstChild().getVar(n.getFirstChild().getString());  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  node.getFirstChild().getVar(n.getFirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  node.getFirstChild().getVar(n.getFirstChild().getString());	  Node    var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	15	None	replace
1852	[BUG]  [BUGGY]  Node  var  =  scope.getVar(n.getFirstChild().getQualifiedName());  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  scope.getVar(n.getFirstChild().getQualifiedName());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getVar(n.getFirstChild().getQualifiedName());	  Node    var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	15	None	replace
1853	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	210	None	replace
1854	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	233	None	replace
1855	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	233	None	replace
1856	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION,  type);  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION,  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()!=  Token.FUNCTION,  type);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION,    type);    	non-compiled	[CE]  orphaned  case	51	None	replace
1857	[BUG]  [BUGGY]  Node  n  =  parent.replaceChild(n,  Node.newString(Token.NAME,  getFunctionName()));  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  parent.replaceChild(n,  Node.newString(Token.NAME,  getFunctionName()));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  parent.replaceChild(n,  Node.newString(Token.NAME,  getFunctionName()));	  Node    n    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	266	None	replace
1858	[BUG]  [BUGGY]  Node  n  =  parent.replaceChild(n,  Node.newString(Token.NAME,  getNameNode()));  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  parent.replaceChild(n,  Node.newString(Token.NAME,  getNameNode()));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  parent.replaceChild(n,  Node.newString(Token.NAME,  getNameNode()));	  Node    n    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	266	None	replace
1859	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	189	None	replace
1860	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  node.getFirstChild()  ==  parent  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  node.getFirstChild()  ==  parent  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  node.getFirstChild()  ==  parent  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    node.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	90	None	replace
1861	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  fnScope,  null);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild(),  fnScope,  null);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  fnScope,  null);	  var    =    scope.getVar(n.getLastChild(),    fnScope);    	non-compiled	[CE]  orphaned  case	180	None	replace
1862	[BUG]  [BUGGY]  Node  n  =  findFunctionNode(n.getFirstChild());  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  findFunctionNode(n.getFirstChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  findFunctionNode(n.getFirstChild());	  Node    n    =    getFunctionNode(n.getFirstChild());    	non-compiled	[CE]  orphaned  case	174	None	replace
1863	[BUG]  [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  n.getLastChild());  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  n.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getFirstChild().getString(),  n.getLastChild());	  var    =    scope.getVar(n.getFirstChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	82	None	replace
1864	[BUG]  [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  fnScope);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  fnScope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getFirstChild().getString(),  fnScope);	  var    =    scope.getVar(n.getFirstChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	82	None	replace
1865	[BUG]  [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  n.getLocalPart());  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  n.getLocalPart());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getFirstChild().getString(),  n.getLocalPart());	  var    =    scope.getVar(n.getFirstChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	82	None	replace
1866	[BUG]  [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  n);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  n);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getFirstChild().getString(),  n);	  var    =    scope.getVar(n.getFirstChild().getString(),    type);    	non-compiled	[CE]  orphaned  case	82	None	replace
1867	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	212	None	replace
1868	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  n,  parent;  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  n,  parent;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  n,  parent;	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n;    	non-compiled	[CE]  orphaned  case	256	None	replace
1869	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  n,  parent);  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  n,  parent);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  n,  parent);	  Node    scope    =(n.getFirstChild()    ==    null)?    n.getLastChild()    :    n;    	non-compiled	[CE]  	256	None	replace
1870	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	22	None	replace
1871	[BUG]  [BUGGY]  Preconditions.checkArgument(type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(type  ==  Token.FUNCTION);	  Preconditions.checkState(type!=    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	106	None	replace
1872	[BUG]  [BUGGY]  var  =  nameNode.getFirstChild().getVar(n.getLastChild().getString());  [CE]  orphaned  case  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  nameNode.getFirstChild().getVar(n.getLastChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  nameNode.getFirstChild().getVar(n.getLastChild().getString());	  var    =    parent.getFirstChild().getVar(n.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	276	None	replace
1873	[BUG]  [BUGGY]  Var  var  =  module.getVar(n.getFirstChild().getString());  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Var  var  =  module.getVar(n.getFirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Var  var  =  module.getVar(n.getFirstChild().getString());	  Var    var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	145	None	replace
1874	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(parent)  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(parent)  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(parent)	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	98	None	replace
1875	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  NodeUtil.isFunctionDeclaration(  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  NodeUtil.isFunctionDeclaration(  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  NodeUtil.isFunctionDeclaration(	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	98	None	replace
1876	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	98	None	replace
1877	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	113	None	replace
1878	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    type    ==    Token.NAME)    {    	non-compiled	[CE]  	250	None	replace
1879	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  type  ==  Token.FUNCTION  ||  type  ==  Token.NAME)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  type  ==  Token.FUNCTION  ||  type  ==  Token.NAME)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)||  type  ==  Token.FUNCTION  ||  type  ==  Token.NAME)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    type    ==    Token.NAME)    {    	non-compiled	[CE]  	250	None	replace
1880	[BUG]  [BUGGY]  if(scope.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(parent)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	116	None	replace
1881	[BUG]  [BUGGY]  if(NodeUtil.mayHaveSecondarySideEffects(n)&&  NodeUtil.mayHaveSecondarySideEffects(parent))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.mayHaveSecondarySideEffects(n)&&  NodeUtil.mayHaveSecondarySideEffects(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.mayHaveSecondarySideEffects(n)&&  NodeUtil.mayHaveSecondarySideEffects(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSecondarySideEffects(parent))    {    	non-compiled	[CE]  	175	None	replace
1882	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.mayHaveSecondarySideEffects(parent))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.mayHaveSecondarySideEffects(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  NodeUtil.mayHaveSecondarySideEffects(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSecondarySideEffects(parent))    {    	non-compiled	[CE]  	175	None	replace
1883	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild()  ==  null  ||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild()  ==  null  ||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild()  ==  null  ||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()    ==    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	225	None	replace
1884	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()    ==    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	225	None	replace
1885	[BUG]  [BUGGY]  n  =  n.getlastChild();  [CE]  orphaned  case  [FE]                                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.getlastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getlastChild();	  n    =    parent.getLastChild();    	non-compiled	[CE]  orphaned  case	125	None	replace
1886	[BUG]  [BUGGY]  Node  var  =  n.getParentNode();  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  n.getParentNode();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  n.getParentNode();	  Node    var    =    n.getNext();    	non-compiled	[CE]  orphaned  case	16	None	replace
1887	[BUG]  [BUGGY]  Node  var  =  n.getOwnerFunction();  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  n.getOwnerFunction();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  n.getOwnerFunction();	  Node    var    =    n.getNext();    	non-compiled	[CE]  orphaned  case	16	None	replace
1888	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.BLOCK);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.BLOCK);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.BLOCK);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	107	None	replace
1889	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.VAR  ||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.VAR  ||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.VAR  ||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	52	None	replace
1890	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isExpressionNode(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isExpressionNode(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isExpressionNode(n))  {	  if(scope    ==    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	239	None	replace
1891	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getString()  ==  Token.FUNCTION)  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getString()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getString()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    n.getFirstChild().getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	282	None	replace
1892	[BUG]  [BUGGY]  if(scope!=  null  &&  nodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  nodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  nodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    ||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	26	None	replace
1893	[BUG]  [BUGGY]  if(scope  >=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope  >=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope  >=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    ||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	26	None	replace
1894	[BUG]  [BUGGY]  Node  c  =  n,  parent.getFirstChild();  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n,  parent.getFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n,  parent.getFirstChild();	  Node    c    =    parent.getFirstChild();    	non-compiled	[CE]  	62	None	replace
1895	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	94	None	replace
1896	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  parent.getType()  ==  Token.VAR)  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  parent.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n)||  parent.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	185	None	replace
1897	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent)||  scope.hasVar(n.getFirstChild().getString()))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent)||  scope.hasVar(n.getFirstChild().getString()))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent)||  scope.hasVar(n.getFirstChild().getString()))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n,    parent))    {    	non-compiled	[CE]  	76	None	replace
1898	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)    	non-compiled	[CE]  	278	None	replace
1899	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)    	non-compiled	[CE]  	278	None	replace
1900	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)    	non-compiled	[CE]  	278	None	replace
1901	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)    	non-compiled	[CE]  	278	None	replace
1902	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)    	non-compiled	[CE]  	278	None	replace
1903	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)||  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	249	None	replace
1904	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION    ||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	249	None	replace
1905	[BUG]  [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.EXPR_RESULT);  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.EXPR_RESULT);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.EXPR_RESULT);	  Context.checkState(parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	203	None	replace
1906	[BUG]  [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.CALL);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.CALL);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.CALL);	  Context.checkState(parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	203	None	replace
1907	[BUG]  [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.NAME);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.NAME);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(parent.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.NAME);	  Context.checkState(parent.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	203	None	replace
1908	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(parent!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	27	None	replace
1909	[BUG]  [BUGGY]  if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getType()  ==  Token.FUNCTION)  {	  if(parent!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	27	None	replace
1910	[BUG]  [BUGGY]  if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getType()  ==  Token.VAR)  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getType()  ==  Token.VAR)  {	  if(parent!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	27	None	replace
1911	[BUG]  [BUGGY]  var  =  scope.getVar(n,  parent.getLastChild().getString());  [CE]  orphaned  case  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n,  parent.getLastChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n,  parent.getLastChild().getString());	  var    =    scope.getVar(parent.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	143	None	replace
1912	[BUG]  [BUGGY]  if(NodeUtil.isFunctionAnonymous(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionAnonymous(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionAnonymous(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isExpressionNode(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	91	None	replace
1913	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  parent.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  parent.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  parent.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isExpressionNode(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	91	None	replace
1914	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  module.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  module.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  module.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	246	None	replace
1915	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	246	None	replace
1916	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isDefinedVar(var))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isDefinedVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isDefinedVar(var))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	246	None	replace
1917	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isLocalVar(var))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isLocalVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isLocalVar(var))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	246	None	replace
1918	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	93	None	replace
1919	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isAssignmentOp(parent)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	93	None	replace
1920	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	93	None	replace
1921	[BUG]  [BUGGY]  var  =  scope.getVar(n,  parent.getLastChild());  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n,  parent.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n,  parent.getLastChild());	  var    =    scope.getVar(parent.getLastChild());    	non-compiled	[CE]  orphaned  case	103	None	replace
1922	[BUG]  [BUGGY]  var  =  parent.getVar(n.getLastChild());  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  parent.getVar(n.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  parent.getVar(n.getLastChild());	  var    =    scope.getVar(parent.getLastChild());    	non-compiled	[CE]  orphaned  case	103	None	replace
1923	[BUG]  [BUGGY]  var  =  module.getVar(n.getLastChild());  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  module.getVar(n.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  module.getVar(n.getLastChild());	  var    =    scope.getVar(parent.getLastChild());    	non-compiled	[CE]  orphaned  case	103	None	replace
1924	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	87	None	replace
1925	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  var.getFirstChild());  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  var.getFirstChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  var.getFirstChild());	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	109	None	replace
1926	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  var.getString());  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  var.getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  var.getString());	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	109	None	replace
1927	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(parent))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(parent))    {    	non-compiled	[CE]  	286	None	replace
1928	[BUG]  [BUGGY]  if(NodeUtil.isFunctionAnonymous(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionAnonymous(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionAnonymous(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isExpressionNode(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	7	None	replace
1929	[BUG]  [BUGGY]  Node  n  =  n.getNext()  ||  parent.getType()  ==  Token.VAR;  [CE]  orphaned  case  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  n.getNext()  ||  parent.getType()  ==  Token.VAR;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  n.getNext()  ||  parent.getType()  ==  Token.VAR;	  Node    n    =    n.getNext();    	non-compiled	[CE]  orphaned  case	18	None	replace
1930	[BUG]  [BUGGY]  Node  var  =  n.getFirstChild().getNext()  ||  parent.getType()  ==  Token.VAR;  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  n.getFirstChild().getNext()  ||  parent.getType()  ==  Token.VAR;  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  n.getFirstChild().getNext()  ||  parent.getType()  ==  Token.VAR;	  Node    var    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	208	None	replace
1931	[BUG]  [BUGGY]  Node  var  =  n.getFirstChild().getNext()  ||  var.getType()  ==  Token.FUNCTION;  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  n.getFirstChild().getNext()  ||  var.getType()  ==  Token.FUNCTION;  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  n.getFirstChild().getNext()  ||  var.getType()  ==  Token.FUNCTION;	  Node    var    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	208	None	replace
1932	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().contains( "function "));  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().contains( "function "));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().contains( "function "));	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString().equals(   "function   "));    	non-compiled	[CE]  orphaned  case	153	None	replace
1933	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().isEmpty());  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().isEmpty());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().isEmpty());	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getString().equals(   "function   "));    	non-compiled	[CE]  orphaned  case	153	None	replace
1934	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()!=  null  ||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()!=  null  ||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()!=  null  ||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    n.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	227	None	replace
1935	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getType()  ==  Token.FUNCTION);	  Context.checkState(n.getType()    ==    Token.FUNCTION,    scope);    	non-compiled	[CE]  orphaned  case	152	None	replace
1936	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION,  n.getFirstChild());  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION,  n.getFirstChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION,  n.getFirstChild());	  Context.checkState(n.getType()    ==    Token.FUNCTION,    scope);    	non-compiled	[CE]  orphaned  case	152	None	replace
1937	[BUG]  [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION,  scope);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION,  scope);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()!=  Token.FUNCTION,  scope);	  Context.checkState(n.getType()    ==    Token.FUNCTION,    scope);    	non-compiled	[CE]  orphaned  case	152	None	replace
1938	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isExpressionNode(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isExpressionNode(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isExpressionNode(parent)||  parent.getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	23	None	replace
1939	[BUG]  [BUGGY]  if(NodeUtil.mayHaveSideEffects(n)&&  NodeUtil.mayHaveSideEffects(parent))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.mayHaveSideEffects(n)&&  NodeUtil.mayHaveSideEffects(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.mayHaveSideEffects(n)&&  NodeUtil.mayHaveSideEffects(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.mayHaveSideEffects(parent))    {    	non-compiled	[CE]  	77	None	replace
1940	[BUG]  [BUGGY]  Node  n  =  type.removeFirstChild();  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  type.removeFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  type.removeFirstChild();	  Node    n    =    type.getFirstChild();    	non-compiled	[CE]  orphaned  case	173	None	replace
1941	[BUG]  [BUGGY]  if(n.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(n.getType()    ==    Token.FUNCTION    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	163	None	replace
1942	[BUG]  [BUGGY]  if(scope.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(n.getType()    ==    Token.FUNCTION    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	163	None	replace
1943	[BUG]  [BUGGY]  if(n.getType()  ==  Token.VAR  ||  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n.getType()  ==  Token.VAR  ||  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n.getType()  ==  Token.VAR  ||  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(n.getType()    ==    Token.FUNCTION    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	163	None	replace
1944	[BUG]  [BUGGY]  if(n.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(n.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n.getType()  ==  Token.VAR  &&  NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(n.getType()    ==    Token.FUNCTION    &&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	163	None	replace
1945	[BUG]  [BUGGY]  var  =  scope.getVar(n.getFirstChild().getLastChild());  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getFirstChild().getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getFirstChild().getLastChild());	  var    =    scope.getVar(n.getLastChild()    +    1);    	non-compiled	[CE]  orphaned  case	104	None	replace
1946	[BUG]  [BUGGY]  Preconditions.checkArgument(type  ==  Token.FUNCTION  ||  type  ==  Token.CATCH);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(type  ==  Token.FUNCTION  ||  type  ==  Token.CATCH);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(type  ==  Token.FUNCTION  ||  type  ==  Token.CATCH);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.CATCH);    	non-compiled	[CE]  orphaned  case	265	None	replace
1947	[BUG]  [BUGGY]  Node  c  =  n,  scope.getFirstChild();  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n,  scope.getFirstChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n,  scope.getFirstChild();	  Node    c    =    scope.getFirstChild();    	non-compiled	[CE]  	64	None	replace
1948	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR  ||  type  ==  Token.VAR)  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	159	None	replace
1949	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  type  ==  Token.NAME,  n.getFirstChild());  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  type  ==  Token.NAME,  n.getFirstChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  ||  type  ==  Token.NAME,  n.getFirstChild());	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	232	None	replace
1950	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR,  var.getString());  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR,  var.getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR,  var.getString());	  Preconditions.checkState(n.getType()    ==    Token.VAR,    type);    	non-compiled	[CE]  orphaned  case	71	None	replace
1951	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.VAR,  type);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()!=  Token.VAR,  type);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()!=  Token.VAR,  type);	  Preconditions.checkState(n.getType()    ==    Token.VAR,    type);    	non-compiled	[CE]  orphaned  case	71	None	replace
1952	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  type  ==  Token.CALL);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  type  ==  Token.CALL);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  ||  type  ==  Token.CALL);	  Preconditions.checkState(n.getType()    ==    Token.VAR,    type);    	non-compiled	[CE]  orphaned  case	71	None	replace
1953	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString());  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString());	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild().getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	206	None	replace
1954	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(n,  parent));  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(n,  parent));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(n,  parent));	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||!NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	202	None	replace
1955	[BUG]  [BUGGY]  var  =  this.fnScope.getVar(n.getLastChild(),  n.getLastChild());  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  this.fnScope.getVar(n.getLastChild(),  n.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  this.fnScope.getVar(n.getLastChild(),  n.getLastChild());	  var    =    scope.getVar(n.getLastChild(),    n.getLastChild());    	non-compiled	[CE]  orphaned  case	182	None	replace
1956	[BUG]  [BUGGY]  var  =  parent.getVar(n.getLastChild(),  n.getLastChild());  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  parent.getVar(n.getLastChild(),  n.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  parent.getVar(n.getLastChild(),  n.getLastChild());	  var    =    scope.getVar(n.getLastChild(),    n.getLastChild());    	non-compiled	[CE]  orphaned  case	182	None	replace
1957	[BUG]  [BUGGY]  var  =  module.getVar(n.getFirstChild(),  n.getLastChild());  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  module.getVar(n.getFirstChild(),  n.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  module.getVar(n.getFirstChild(),  n.getLastChild());	  var    =    scope.getVar(n.getLastChild(),    n.getLastChild());    	non-compiled	[CE]  orphaned  case	182	None	replace
1958	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	275	None	replace
1959	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	275	None	replace
1960	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.VAR  ||  type  ==  Token.VAR)  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.VAR  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.VAR  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	41	None	replace
1961	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.VAR  &&!NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.VAR  &&!NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.VAR  &&!NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	41	None	replace
1962	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isGetProp(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isGetProp(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isGetProp(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isGetProp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	194	None	replace
1963	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isStatementBlock(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isStatementBlock(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isStatementBlock(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isGetProp(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	194	None	replace
1964	[BUG]  [BUGGY]  Node  scope  =  mergeFunctionScope(n.getLastChild());  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  scope  =  mergeFunctionScope(n.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  mergeFunctionScope(n.getLastChild());	  Node    scope    =    getFunctionScope(n.getLastChild());    	non-compiled	[CE]  orphaned  case	136	None	replace
1965	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild().getString()  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild().getString()  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild().getString()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    scope.getFirstChild().getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	24	None	replace
1966	[BUG]  [BUGGY]  Node  var  =  this.fnScope.getVar(n.getLastChild());  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  this.fnScope.getVar(n.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  this.fnScope.getVar(n.getLastChild());	  Node    var    =    scope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	17	None	replace
1967	[BUG]  [BUGGY]  Node  var  =  parent.getFirstChild().getVar(n.getLastChild());  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  var  =  parent.getFirstChild().getVar(n.getLastChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  parent.getFirstChild().getVar(n.getLastChild());	  Node    var    =    scope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	17	None	replace
1968	[BUG]  [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  ||!NodeUtil.isFunctionObjectCall(n));  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION  ||!NodeUtil.isFunctionObjectCall(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()!=  Token.FUNCTION  ||!NodeUtil.isFunctionObjectCall(n));	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||!NodeUtil.isFunctionObjectCall(n));    	non-compiled	[CE]  orphaned  case	245	None	replace
1969	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionObjectApply(n));  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionObjectApply(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionObjectApply(n));	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||!NodeUtil.isFunctionObjectCall(n));    	non-compiled	[CE]  orphaned  case	245	None	replace
1970	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionObjectConcept(n));  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionObjectConcept(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionObjectConcept(n));	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||!NodeUtil.isFunctionObjectCall(n));    	non-compiled	[CE]  orphaned  case	245	None	replace
1971	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||!NodeUtil.mayHaveSecondaryVar(n))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||!NodeUtil.mayHaveSecondaryVar(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||!NodeUtil.mayHaveSecondaryVar(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||!NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	238	None	replace
1972	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n.getJSDocInfo());  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n.getJSDocInfo());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  n.getJSDocInfo());	  var    =    scope.getVar(n.getLastChild(),    type);    	non-compiled	[CE]  orphaned  case	102	None	replace
1973	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n.getSimpleName());  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n.getSimpleName());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  n.getSimpleName());	  var    =    scope.getVar(n.getLastChild(),    n.getFirstChild());    	non-compiled	[CE]  orphaned  case	178	None	replace
1974	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	96	None	replace
1975	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	96	None	replace
1976	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	96	None	replace
1977	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  n.getFirstChild());  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  n.getFirstChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME,  n.getFirstChild());	  Context.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.NAME);    	non-compiled	[CE]  orphaned  case	149	None	replace
1978	[BUG]  [BUGGY]  Preconditions.checkArgument(type  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(type  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(type  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	110	None	replace
1979	[BUG]  [BUGGY]  n  =  n.getFirstChild().getQualifiedName();  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.getFirstChild().getQualifiedName();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getFirstChild().getQualifiedName();	  n    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	195	None	replace
1980	[BUG]  [BUGGY]  n  =  n.getFirstChild().getNext()  ||  parent.getType()!=  Token.FUNCTION;  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.getFirstChild().getNext()  ||  parent.getType()!=  Token.FUNCTION;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getFirstChild().getNext()  ||  parent.getType()!=  Token.FUNCTION;	  n    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	195	None	replace
1981	[BUG]  [BUGGY]  var  =  parent.getType()  ==  Token.FUNCTION?  this.fnScope.getVar(n.getLastChild()):  null;  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  parent.getType()  ==  Token.FUNCTION?  this.fnScope.getVar(n.getLastChild()):  null;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  parent.getType()  ==  Token.FUNCTION?  this.fnScope.getVar(n.getLastChild()):  null;	  var    =    this.fnScope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	268	None	replace
1982	[BUG]  [BUGGY]  var  =  parent.getType()  ==  Token.FUNCTION?  this.fnScope.getVar(n.getLastChild()):  n;  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  parent.getType()  ==  Token.FUNCTION?  this.fnScope.getVar(n.getLastChild()):  n;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  parent.getType()  ==  Token.FUNCTION?  this.fnScope.getVar(n.getLastChild()):  n;	  var    =    this.fnScope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	268	None	replace
1983	[BUG]  [BUGGY]  var  =  this.fnScope.getVar(n.getLastChild(),  n.getFirstChild());  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  var  =  this.fnScope.getVar(n.getLastChild(),  n.getFirstChild());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  this.fnScope.getVar(n.getLastChild(),  n.getFirstChild());	  var    =    this.fnScope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	268	None	replace
1984	[BUG]  [BUGGY]  Node  c  =  n.getFirstChild().getQualifiedName();  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  c  =  n.getFirstChild().getQualifiedName();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getFirstChild().getQualifiedName();	  Node    c    =    n.getFirstChild().getNext();    	non-compiled	[CE]  orphaned  case	224	None	replace
1985	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||!NodeUtil.mayHaveSecondarySideEffects(n));  [CE]  orphaned  case  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||!NodeUtil.mayHaveSecondarySideEffects(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  ||!NodeUtil.mayHaveSecondarySideEffects(n));	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||!NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	230	None	replace
1986	[BUG]  [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.VAR  ||!NodeUtil.isFunctionDeclaration(n));  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.VAR  ||!NodeUtil.isFunctionDeclaration(n));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(n.getType()  ==  Token.VAR  ||!NodeUtil.isFunctionDeclaration(n));	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||!NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	230	None	replace
1987	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  fnScope.isFunctionDeclaration(n))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  fnScope.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  fnScope.isFunctionDeclaration(n))  {	  if(fnScope!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	237	None	replace
1988	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  modifiedVar.equals(n.getFirstChild().getString()))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  modifiedVar.equals(n.getFirstChild().getString()))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  modifiedVar.equals(n.getFirstChild().getString()))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    modifiedVar.equals(var))    {    	non-compiled	[CE]  	247	None	replace
1989	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  type  ==  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    modifiedVar.equals(var))    {    	non-compiled	[CE]  	247	None	replace
1990	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  parent.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)||  parent.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  parent.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()!=    Token.FUNCTION    ||    type    ==    Token.VAR)    {    	non-compiled	[CE]  	161	None	replace
1991	[BUG]  [BUGGY]  Node  n  =  parent.getlastChild();  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  parent.getlastChild();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  parent.getlastChild();	  Node    n    =    node.getLastChild();    	non-compiled	[CE]  orphaned  case	60	None	replace
1992	[BUG]  [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR);	  Preconditions.checkArgument(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	251	None	replace
1993	[BUG]  [BUGGY]  Preconditions.checkArgument(type  ==  Token.FUNCTION  ||  type  ==  Token.GETPROP);  [CE]  orphaned  case  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(type  ==  Token.FUNCTION  ||  type  ==  Token.GETPROP);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(type  ==  Token.FUNCTION  ||  type  ==  Token.GETPROP);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.GETPROP);    	non-compiled	[CE]  orphaned  case	170	None	replace
1994	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FOR  ||  type  ==  Token.GETPROP);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(type  ==  Token.FOR  ||  type  ==  Token.GETPROP);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FOR  ||  type  ==  Token.GETPROP);	  Preconditions.checkState(type    ==    Token.FUNCTION    ||    type    ==    Token.GETPROP);    	non-compiled	[CE]  orphaned  case	170	None	replace
1995	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isName(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	100	None	replace
1996	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n,  parent))  {  [CE]  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n,  parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isName(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	100	None	replace
1997	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  n.getFirstChild().getString().getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  n.getFirstChild().getString().getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  ||  n.getFirstChild().getString().getType()  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    n.getFirstChild().getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	69	None	replace
1998	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  n.getFirstChild().getString());  [CE]  orphaned  case  [FE]                  AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  n.getFirstChild().getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  ||  n.getFirstChild().getString());	  Preconditions.checkState(n.getType()    ==    Token.VAR    ||    n.getFirstChild().getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	69	None	replace
1999	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionReturnValue(parent))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionReturnValue(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionReturnValue(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	244	None	replace
2000	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(parent))  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(parent))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	244	None	replace
2001	[BUG]  [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.VAR  ||  n.getFirstChild().getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.VAR  ||  n.getFirstChild().getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(n.getType()  ==  Token.VAR  ||  n.getFirstChild().getType()  ==  Token.FUNCTION);	  Preconditions.checkArgument(n.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	263	None	replace
2002	[BUG]  [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.VAR  ||  parent.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.VAR  ||  parent.getType()  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(n.getType()  ==  Token.VAR  ||  parent.getType()  ==  Token.FUNCTION);	  Preconditions.checkArgument(n.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	263	None	replace
2003	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getString()  ==  Token.VAR)  {  [CE]  [FE]                    AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getString()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getString()  ==  Token.VAR)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n)||    n.getFirstChild().getType()    ==    Token.VAR)    {    	non-compiled	[CE]  	285	None	replace
2004	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(n)&&  parent.getType()  ==  Token.VAR)  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(n)&&  parent.getType()  ==  Token.VAR)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(n)&&  parent.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	197	None	replace
2005	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(n)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(n)||  type  ==  Token.FUNCTION)  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(n)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.mayHaveSideEffects(n))    {    	non-compiled	[CE]  	197	None	replace
2006	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isVar(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getLastChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	28	None	replace
2007	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  n.getFirstChild()!=  null);  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  n.getFirstChild()!=  null);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()!=  Token.FUNCTION  ||  n.getFirstChild()!=  null);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    n.getFirstChild()!=    null);    	non-compiled	[CE]  orphaned  case	253	None	replace
2008	[BUG]  [BUGGY]  n  =  n.replaceChild(parent,  new  Node(Token.FUNCTION));  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.replaceChild(parent,  new  Node(Token.FUNCTION));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.replaceChild(parent,  new  Node(Token.FUNCTION));	  n    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	261	None	replace
2009	[BUG]  [BUGGY]  n  =  n.removeFirstChild()  ||  parent.getType()!=  Token.FUNCTION;  [CE]  orphaned  case  [FE]                                AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  n  =  n.removeFirstChild()  ||  parent.getType()!=  Token.FUNCTION;  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.removeFirstChild()  ||  parent.getType()!=  Token.FUNCTION;	  n    =    n.removeFirstChild();    	non-compiled	[CE]  orphaned  case	261	None	replace
2010	[BUG]  [BUGGY]  if(NodeUtil.isFunctionAssign(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  if(NodeUtil.isFunctionAssign(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionAssign(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isExpressionNode(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	117	None	replace
2011	[BUG]  [BUGGY]  Context.report(JSError.make(n,  parent,  NON_GLOBAL_DEFINE_INIT_ERROR,  type));  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.report(JSError.make(n,  parent,  NON_GLOBAL_DEFINE_INIT_ERROR,  type));  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.report(JSError.make(n,  parent,  NON_GLOBAL_DEFINE_INIT_ERROR,  type));	  Context.reportCodeChange();    	non-compiled	[CE]  orphaned  case	141	None	replace
2012	[BUG]  [BUGGY]  Context.report(JSError.make(n,  parent,  NON_GLOBAL_DEFINE_INIT_ERROR, " "));  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.report(JSError.make(n,  parent,  NON_GLOBAL_DEFINE_INIT_ERROR, " "));  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.report(JSError.make(n,  parent,  NON_GLOBAL_DEFINE_INIT_ERROR, " "));	  Context.reportCodeChange();    	non-compiled	[CE]  orphaned  case	141	None	replace
2013	[BUG]  [BUGGY]  Context.report(JSError.make(n,  parent,  FUNCTION_EXPECTED_ERROR,  type));  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.report(JSError.make(n,  parent,  FUNCTION_EXPECTED_ERROR,  type));  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.report(JSError.make(n,  parent,  FUNCTION_EXPECTED_ERROR,  type));	  Context.reportCodeChange();    	non-compiled	[CE]  orphaned  case	141	None	replace
2014	[BUG]  [BUGGY]  Context.report(JSError.make(n,  parent,  FUNCTION_DEFINE_INIT_ERROR, " "));  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.report(JSError.make(n,  parent,  FUNCTION_DEFINE_INIT_ERROR, " "));  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.report(JSError.make(n,  parent,  FUNCTION_DEFINE_INIT_ERROR, " "));	  Context.reportCodeChange();    	non-compiled	[CE]  orphaned  case	141	None	replace
2015	[BUG]  [BUGGY]  Context.report(JSError.make(n,  parent,  NON_GLOBAL_DEFINE_INIT_ERROR));  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Context.report(JSError.make(n,  parent,  NON_GLOBAL_DEFINE_INIT_ERROR));  [BUGGY]      var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.report(JSError.make(n,  parent,  NON_GLOBAL_DEFINE_INIT_ERROR));	  Context.reportCodeChange();    	non-compiled	[CE]  orphaned  case	141	None	replace
2016	[BUG]  [BUGGY]  Node  n  =  getFunctionScope().getChildCount();  [CE]  orphaned  case  [FE]                          AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  getFunctionScope().getChildCount();  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  getFunctionScope().getChildCount();	  Node    n    =    getFunctionScope().getFirstChild();    	non-compiled	[CE]  orphaned  case	273	None	replace
2017	[BUG]  [BUGGY]  Node  n  =  getFunctionScope().getOwnScope(n);  [CE]  orphaned  case  [FE]                            AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  getFunctionScope().getOwnScope(n);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  getFunctionScope().getOwnScope(n);	  Node    n    =    getFunctionScope().getFirstChild();    	non-compiled	[CE]  orphaned  case	273	None	replace
2018	[BUG]  [BUGGY]  Node  n  =  getFunctionScope().getVar(n.getString());  [CE]  orphaned  case  [FE]                              AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Node  n  =  getFunctionScope().getVar(n.getString());  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  getFunctionScope().getVar(n.getString());	  Node    n    =    getFunctionScope().getFirstChild();    	non-compiled	[CE]  orphaned  case	273	None	replace
2019	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CALL  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                        AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.CALL  ||  type  ==  Token.FUNCTION);  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.CALL  ||  type  ==  Token.FUNCTION);	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    type    ==    Token.CALL);    	non-compiled	[CE]  orphaned  case	220	None	replace
2020	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n,  parent));  [CE]  orphaned  case  [FE]                      AssertionFailedError      [CONTEXT]      private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:        [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n,  parent));  [BUGGY]      if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n,  parent));	  Preconditions.checkState(n.getType()    ==    Token.FUNCTION    ||    NodeUtil.isFunctionDeclaration(n));    	non-compiled	[CE]  orphaned  case	219	None	replace
