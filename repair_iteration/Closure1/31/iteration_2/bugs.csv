bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  Node  n  =  scope.getLastChild();  [CE]  orphaned  case  [FE]                      AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  n  =  scope.getLastChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  scope.getLastChild();	      Node    n    =    scope.getFirstChild();    	non-compiled	[CE]  orphaned  case	16	None	replace
2	[BUG]  [BUGGY]  Node  n  =  parent.getLastChild();  [CE]  orphaned  case  [FE]                        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  n  =  parent.getLastChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  parent.getLastChild();	      Node    n    =    scope.getFirstChild();    	non-compiled	[CE]  orphaned  case	16	None	replace
3	[BUG]  [BUGGY]  Node  n  =  node.getFirstChild();  [CE]  orphaned  case  [FE]                          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  n  =  node.getFirstChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  node.getFirstChild();	      Node    n    =    scope.getFirstChild();    	non-compiled	[CE]  orphaned  case	16	None	replace
4	[BUG]  [BUGGY]  Node  n  =  scope.getParent();  [CE]  orphaned  case  [FE]                            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  n  =  scope.getParent();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  scope.getParent();	      Node    n    =    scope.getFirstChild();    	non-compiled	[CE]  orphaned  case	16	None	replace
5	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	1	None	replace
6	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	1	None	replace
7	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	1	None	replace
8	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	1	None	replace
9	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	1	None	replace
10	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isExpressionNode(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	1	None	replace
11	[BUG]  [BUGGY]  Node  var  =  n.getLastChild();  [CE]  orphaned  case  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  var  =  n.getLastChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  n.getLastChild();	      Node    var    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	23	None	replace
12	[BUG]  [BUGGY]  Node  var  =  parent.getFirstChild();  [CE]  orphaned  case  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  var  =  parent.getFirstChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  parent.getFirstChild();	      Node    var    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	23	None	replace
13	[BUG]  [BUGGY]  Node  var  =  scope.getFirstChild();  [CE]  orphaned  case  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  var  =  scope.getFirstChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getFirstChild();	      Node    var    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	23	None	replace
14	[BUG]  [BUGGY]  Node  var  =  scope.getVar(n.getFirstChild());  [CE]  orphaned  case  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  var  =  scope.getVar(n.getFirstChild());  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getVar(n.getFirstChild());	      Node    var    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	23	None	replace
15	[BUG]  [BUGGY]  Node  var  =  scope.getVar(n.getFirstChild().getString());  [CE]  orphaned  case  [FE]                    AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  var  =  scope.getVar(n.getFirstChild().getString());  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getVar(n.getFirstChild().getString());	      Node    var    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	23	None	replace
16	[BUG]  [BUGGY]  Node  var  =  n.getNext();  [CE]  orphaned  case  [FE]                      AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  var  =  n.getNext();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  n.getNext();	      Node    var    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	23	None	replace
17	[BUG]  [BUGGY]  Node  var  =  scope.getVar(n.getLastChild());  [CE]  orphaned  case  [FE]                        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  var  =  scope.getVar(n.getLastChild());  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  scope.getVar(n.getLastChild());	      Node    var    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	23	None	replace
18	[BUG]  [BUGGY]  Node  n  =  n.getNext();  [CE]  orphaned  case  [FE]        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  n  =  n.getNext();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  n.getNext();	      Node    n    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	9	None	replace
19	[BUG]  [BUGGY]  Node  n  =  child.getFirstChild();  [CE]  orphaned  case  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  n  =  child.getFirstChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  child.getFirstChild();	      Node    n    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	9	None	replace
20	[BUG]  [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	25	None	replace
21	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	25	None	replace
22	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	25	None	replace
23	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	25	None	replace
24	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getFirstChild().getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	25	None	replace
25	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	25	None	replace
26	[BUG]  [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  ||  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	25	None	replace
27	[BUG]  [BUGGY]  if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                      AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(parent!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	25	None	replace
28	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	19	None	replace
29	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	19	None	replace
30	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(var))  {  [CE]  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(var))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isPropertyAssign(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	19	None	replace
31	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	19	None	replace
32	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	19	None	replace
33	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	19	None	replace
34	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  isRemovableVar(var))  {  [CE]  [FE]                    AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  isRemovableVar(var))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	19	None	replace
35	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]                      AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	19	None	replace
36	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	8	None	replace
37	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	8	None	replace
38	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)&&  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	8	None	replace
39	[BUG]  [BUGGY]  if(NodeUtil.isGetProp(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isGetProp(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isGetProp(n)&&  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	8	None	replace
40	[BUG]  [BUGGY]  if(NodeUtil.isName(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isName(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)&&  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	8	None	replace
41	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.VAR)  {  [CE]  [FE]                    AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.VAR)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	8	None	replace
42	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isVar(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)&&  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	8	None	replace
43	[BUG]  [BUGGY]  Node  n  =  parent.getNext();  [CE]  orphaned  case  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  n  =  parent.getNext();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  parent.getNext();	      Node    n    =    parent.getFirstChild();    	non-compiled	[CE]  orphaned  case	10	None	replace
44	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION);  [CE]  orphaned  case  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(n.getType()!=  Token.FUNCTION);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()!=  Token.FUNCTION);	      Preconditions.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	12	None	replace
45	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR);  [CE]  orphaned  case  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR);	      Preconditions.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	12	None	replace
46	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION);	      Preconditions.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	12	None	replace
47	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);  [CE]  orphaned  case  [FE]                    AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);	      Preconditions.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	12	None	replace
48	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                      AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.FUNCTION);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.FUNCTION);	      Preconditions.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	12	None	replace
49	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME);  [CE]  orphaned  case  [FE]                        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME);	      Preconditions.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	12	None	replace
50	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().equals( "function "));  [CE]  orphaned  case  [FE]                          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().equals( "function "));  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().equals( "function "));	      Preconditions.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	12	None	replace
51	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION,  type);  [CE]  orphaned  case  [FE]                            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION,  type);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION,  type);	      Preconditions.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	12	None	replace
52	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION)  {  [CE]  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	3	None	replace
53	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR)  {  [CE]  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	3	None	replace
54	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	3	None	replace
55	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	3	None	replace
56	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR)  {  [CE]  [FE]                    AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	3	None	replace
57	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                      AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	3	None	replace
58	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  scope.getType()  ==  Token.VAR)  {  [CE]  [FE]                        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  scope.getType()  ==  Token.VAR)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  scope.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	3	None	replace
59	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type!=  Token.FUNCTION)  {  [CE]  [FE]                          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  type!=  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  type!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	3	None	replace
60	[BUG]  [BUGGY]  Node  n  =  node.getLastChild();  [CE]  orphaned  case  [FE]                    AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  n  =  node.getLastChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  node.getLastChild();	      Node    n    =    n.getLastChild();    	non-compiled	[CE]  orphaned  case	15	None	replace
61	[BUG]  [BUGGY]  Node  c  =  n.getLastChild();  [CE]  orphaned  case  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  c  =  n.getLastChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getLastChild();	      Node    c    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	13	None	replace
62	[BUG]  [BUGGY]  Node  c  =  parent.getFirstChild();  [CE]  orphaned  case  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  c  =  parent.getFirstChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  parent.getFirstChild();	      Node    c    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	13	None	replace
63	[BUG]  [BUGGY]  Node  c  =  n.getNext();  [CE]  orphaned  case  [FE]                    AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  c  =  n.getNext();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getNext();	      Node    c    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	13	None	replace
64	[BUG]  [BUGGY]  Node  c  =  scope.getFirstChild();  [CE]  orphaned  case  [FE]                      AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  c  =  scope.getFirstChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  scope.getFirstChild();	      Node    c    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	13	None	replace
65	[BUG]  [BUGGY]  Node  c  =  node.getFirstChild();  [CE]  orphaned  case  [FE]                        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  c  =  node.getFirstChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  node.getFirstChild();	      Node    c    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	13	None	replace
66	[BUG]  [BUGGY]  Node  c  =  n.getParent();  [CE]  orphaned  case  [FE]                          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  c  =  n.getParent();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getParent();	      Node    c    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	13	None	replace
67	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  type  ==  Token.FUNCTION);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  ||  type  ==  Token.FUNCTION);	      Preconditions.checkState(n.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	28	None	replace
68	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()!=  Token.VAR);  [CE]  orphaned  case  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(n.getType()!=  Token.VAR);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()!=  Token.VAR);	      Preconditions.checkState(n.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	28	None	replace
69	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  n.getFirstChild().getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  n.getFirstChild().getType()  ==  Token.FUNCTION);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  ||  n.getFirstChild().getType()  ==  Token.FUNCTION);	      Preconditions.checkState(n.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	28	None	replace
70	[BUG]  [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(parent.getType()  ==  Token.VAR);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(parent.getType()  ==  Token.VAR);	      Preconditions.checkState(n.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	28	None	replace
71	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR,  type);  [CE]  orphaned  case  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR,  type);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR,  type);	      Preconditions.checkState(n.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	28	None	replace
72	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  n.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  n.getType()  ==  Token.FUNCTION);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  ||  n.getType()  ==  Token.FUNCTION);	      Preconditions.checkState(n.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	28	None	replace
73	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isExpressionNode(parent))  {  [CE]  [FE]        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isExpressionNode(parent))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isExpressionNode(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	6	None	replace
74	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(n))  {  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	6	None	replace
75	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	6	None	replace
76	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent))  {  [CE]  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	6	None	replace
77	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(parent))  {  [CE]  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(parent))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	6	None	replace
78	[BUG]  [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isExpressionNode(parent))  {  [CE]  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isExpressionNode(parent))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isConstructorDeclaration(n)||  NodeUtil.isExpressionNode(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	6	None	replace
79	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(scope))  {  [CE]  [FE]                    AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(scope))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	6	None	replace
80	[BUG]  [BUGGY]  var  =  scope.getVar(parent.getFirstChild().getString());  [CE]  orphaned  case  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  var  =  scope.getVar(parent.getFirstChild().getString());  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(parent.getFirstChild().getString());	      var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	22	None	replace
81	[BUG]  [BUGGY]  Var  var  =  scope.getVar(n.getLastChild().getString());  [CE]  orphaned  case  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Var  var  =  scope.getVar(n.getLastChild().getString());  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Var  var  =  scope.getVar(n.getLastChild().getString());	      var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	22	None	replace
82	[BUG]  [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  type);  [CE]  orphaned  case  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString(),  type);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getFirstChild().getString(),  type);	      var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	22	None	replace
83	[BUG]  [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString()  +  1);  [CE]  orphaned  case  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  var  =  scope.getVar(n.getFirstChild().getString()  +  1);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getFirstChild().getString()  +  1);	      var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	22	None	replace
84	[BUG]  [BUGGY]  var  =  scope.getVar(n.getNext().getString());  [CE]  orphaned  case  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  var  =  scope.getVar(n.getNext().getString());  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getNext().getString());	      var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	22	None	replace
85	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	26	None	replace
86	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	26	None	replace
87	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	26	None	replace
88	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	26	None	replace
89	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	26	None	replace
90	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  node.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  node.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  node.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	26	None	replace
91	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	26	None	replace
92	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getLastChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                      AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getLastChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getLastChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	26	None	replace
93	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	27	None	replace
94	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	27	None	replace
95	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	27	None	replace
96	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	27	None	replace
97	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	27	None	replace
98	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                    AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	27	None	replace
99	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                      AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isConstructorOp(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	27	None	replace
100	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	27	None	replace
101	[BUG]  [BUGGY]  var  =  scope.getVar(n.getFirstChild());  [CE]  orphaned  case  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  var  =  scope.getVar(n.getFirstChild());  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getFirstChild());	      var    =    scope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	30	None	replace
102	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  type);  [CE]  orphaned  case  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  var  =  scope.getVar(n.getLastChild(),  type);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  type);	      var    =    scope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	30	None	replace
103	[BUG]  [BUGGY]  var  =  scope.getVar(parent.getLastChild());  [CE]  orphaned  case  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  var  =  scope.getVar(parent.getLastChild());  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(parent.getLastChild());	      var    =    scope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	30	None	replace
104	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild()  +  1);  [CE]  orphaned  case  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  var  =  scope.getVar(n.getLastChild()  +  1);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild()  +  1);	      var    =    scope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	30	None	replace
105	[BUG]  [BUGGY]  var  =  scope.getVar(n.getString());  [CE]  orphaned  case  [FE]                    AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  var  =  scope.getVar(n.getString());  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getString());	      var    =    scope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	30	None	replace
106	[BUG]  [BUGGY]  Preconditions.checkState(type!=  Token.FUNCTION);  [CE]  orphaned  case  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(type!=  Token.FUNCTION);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type!=  Token.FUNCTION);	      Preconditions.checkState(type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	24	None	replace
107	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.VAR);  [CE]  orphaned  case  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.VAR);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.VAR);	      Preconditions.checkState(type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	24	None	replace
108	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);  [CE]  orphaned  case  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);	      Preconditions.checkState(type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	24	None	replace
109	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.NAME);  [CE]  orphaned  case  [FE]                    AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.NAME);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.NAME);	      Preconditions.checkState(type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	24	None	replace
110	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]                      AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION);	      Preconditions.checkState(type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	24	None	replace
111	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION,  scope);  [CE]  orphaned  case  [FE]                        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION,  scope);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION,  scope);	      Preconditions.checkState(type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	24	None	replace
112	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.CALL);  [CE]  orphaned  case  [FE]                          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.CALL);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.CALL);	      Preconditions.checkState(type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	24	None	replace
113	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	20	None	replace
114	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	20	None	replace
115	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	20	None	replace
116	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	20	None	replace
117	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	20	None	replace
118	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                    AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	20	None	replace
119	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                      AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getLastChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	20	None	replace
120	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isVar(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	20	None	replace
121	[BUG]  [BUGGY]  n  =  n.getLastChild();  [CE]  orphaned  case  [FE]                          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  n  =  n.getLastChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getLastChild();	      n    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	18	None	replace
122	[BUG]  [BUGGY]  n  =  parent.getFirstChild();  [CE]  orphaned  case  [FE]                            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  n  =  parent.getFirstChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  parent.getFirstChild();	      n    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	18	None	replace
123	[BUG]  [BUGGY]  n  =  n.getNext();  [CE]  orphaned  case  [FE]                              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  n  =  n.getNext();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getNext();	      n    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	18	None	replace
124	[BUG]  [BUGGY]  n  =  scope.getFirstChild();  [CE]  orphaned  case  [FE]                                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  n  =  scope.getFirstChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  scope.getFirstChild();	      n    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	18	None	replace
125	[BUG]  [BUGGY]  n  =  parent.getLastChild();  [CE]  orphaned  case  [FE]                                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  n  =  parent.getLastChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  parent.getLastChild();	      n    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	18	None	replace
126	[BUG]  [BUGGY]  n  =  n.getParent();  [CE]  orphaned  case  [FE]                                    AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  n  =  n.getParent();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getParent();	      n    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	18	None	replace
127	[BUG]  [BUGGY]  Node  n  =  n.getParent();  [CE]  orphaned  case  [FE]                        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  n  =  n.getParent();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  n.getParent();	      Node    n    =    parent.getParent();    	non-compiled	[CE]  orphaned  case	17	None	replace
128	[BUG]  [BUGGY]  Node  n  =  node.getParent();  [CE]  orphaned  case  [FE]                          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  n  =  node.getParent();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  node.getParent();	      Node    n    =    parent.getParent();    	non-compiled	[CE]  orphaned  case	17	None	replace
129	[BUG]  [BUGGY]  Node  n  =  node.getNext();  [CE]  orphaned  case  [FE]                            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  n  =  node.getNext();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  node.getNext();	      Node    n    =    parent.getParent();    	non-compiled	[CE]  orphaned  case	17	None	replace
130	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	2	None	replace
131	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(scope))  {  [CE]  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(scope))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	2	None	replace
132	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	2	None	replace
133	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  scope))  {  [CE]  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  scope))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n,  scope))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	2	None	replace
134	[BUG]  [BUGGY]  Node  scope  =  parent.getLastChild();  [CE]  orphaned  case  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  scope  =  parent.getLastChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  parent.getLastChild();	      Node    scope    =    n.getLastChild();    	non-compiled	[CE]  orphaned  case	14	None	replace
135	[BUG]  [BUGGY]  Node  scope  =  parent.getFirstChild();  [CE]  orphaned  case  [FE]                    AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  scope  =  parent.getFirstChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  parent.getFirstChild();	      Node    scope    =    n.getLastChild();    	non-compiled	[CE]  orphaned  case	14	None	replace
136	[BUG]  [BUGGY]  Node  scope  =  getFunctionScope(n.getLastChild());  [CE]  orphaned  case  [FE]                      AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  scope  =  getFunctionScope(n.getLastChild());  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getFunctionScope(n.getLastChild());	      Node    scope    =    n.getLastChild();    	non-compiled	[CE]  orphaned  case	14	None	replace
137	[BUG]  [BUGGY]  Node  scope  =  node.getLastChild();  [CE]  orphaned  case  [FE]                        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  scope  =  node.getLastChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  node.getLastChild();	      Node    scope    =    n.getLastChild();    	non-compiled	[CE]  orphaned  case	14	None	replace
138	[BUG]  [BUGGY]  Node  scope  =  node.getFirstChild();  [CE]  orphaned  case  [FE]                          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  scope  =  node.getFirstChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  node.getFirstChild();	      Node    scope    =    n.getLastChild();    	non-compiled	[CE]  orphaned  case	14	None	replace
139	[BUG]  [BUGGY]  Node  scope  =  getFunctionScope(n.getFirstChild());  [CE]  orphaned  case  [FE]                            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  scope  =  getFunctionScope(n.getFirstChild());  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getFunctionScope(n.getFirstChild());	      Node    scope    =    n.getLastChild();    	non-compiled	[CE]  orphaned  case	14	None	replace
140	[BUG]  [BUGGY]  Node  node  =  n.getFirstChild();  [CE]  orphaned  case  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  node  =  n.getFirstChild();  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  node  =  n.getFirstChild();	      	non-compiled	[CE]  orphaned  case	5	None	replace
141	[BUG]  [BUGGY]  Context.reportCodeChange();  [CE]  orphaned  case  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Context.reportCodeChange();  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.reportCodeChange();	      	non-compiled	[CE]  orphaned  case	5	None	replace
142	[BUG]  [BUGGY]  Node  parent  =  n.getParent();  [CE]  orphaned  case  [FE]                    AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  parent  =  n.getParent();  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  parent  =  n.getParent();	      	non-compiled	[CE]  orphaned  case	5	None	replace
143	[BUG]  [BUGGY]  var  =  scope.getVar(parent.getLastChild().getString());  [CE]  orphaned  case  [FE]        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  var  =  scope.getVar(parent.getLastChild().getString());  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(parent.getLastChild().getString());	      var    =    scope.getVar(n.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	21	None	replace
144	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild().getString()  +  1);  [CE]  orphaned  case  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  var  =  scope.getVar(n.getLastChild().getString()  +  1);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild().getString()  +  1);	      var    =    scope.getVar(n.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	21	None	replace
145	[BUG]  [BUGGY]  Var  var  =  scope.getVar(n.getFirstChild().getString());  [CE]  orphaned  case  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Var  var  =  scope.getVar(n.getFirstChild().getString());  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Var  var  =  scope.getVar(n.getFirstChild().getString());	      var    =    scope.getVar(n.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	21	None	replace
146	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  type);  [CE]  orphaned  case  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  var  =  scope.getVar(n.getLastChild().getString(),  type);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild().getString(),  type);	      var    =    scope.getVar(n.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	21	None	replace
147	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR);  [CE]  orphaned  case  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR);	      Context.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	29	None	replace
148	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.FUNCTION);	      Context.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	29	None	replace
149	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME);  [CE]  orphaned  case  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.NAME);	      Context.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	29	None	replace
150	[BUG]  [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION);  [CE]  orphaned  case  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Context.checkState(n.getType()!=  Token.FUNCTION);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()!=  Token.FUNCTION);	      Context.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	29	None	replace
151	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);  [CE]  orphaned  case  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.EXPR_RESULT);	      Context.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	29	None	replace
152	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION,  scope);  [CE]  orphaned  case  [FE]                    AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION,  scope);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION,  scope);	      Context.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	29	None	replace
153	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().equals( "function "));  [CE]  orphaned  case  [FE]                      AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().equals( "function "));  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString().equals( "function "));	      Context.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	29	None	replace
154	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString()!=  null);  [CE]  orphaned  case  [FE]                        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString()!=  null);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getString()!=  null);	      Context.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	29	None	replace
155	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	4	None	replace
156	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	4	None	replace
157	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()!=  Token.FUNCTION)  {  [CE]  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()!=  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()!=  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	4	None	replace
158	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                    AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isExpressionNode(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	4	None	replace
159	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR)  {  [CE]  [FE]                      AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	4	None	replace
160	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isAssignmentOp(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	4	None	replace
161	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]                          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent.getType()!=  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	4	None	replace
162	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	7	None	replace
163	[BUG]  [BUGGY]  if(n.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(n.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	7	None	replace
164	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	7	None	replace
165	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isExpressionNode(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	7	None	replace
166	[BUG]  [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isAssignmentOp(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isAssignmentOp(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	7	None	replace
167	[BUG]  [BUGGY]  if(n.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(n.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(n.getType()  ==  Token.FUNCTION  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	7	None	replace
168	[BUG]  [BUGGY]  Node  scope  =  n.getNext();  [CE]  orphaned  case  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  scope  =  n.getNext();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  n.getNext();	      Node    scope    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	11	None	replace
169	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.SCRIPT);  [CE]  orphaned  case  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.SCRIPT);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.SCRIPT);	      Preconditions.checkState(type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	24	None	replace
170	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.GETPROP);  [CE]  orphaned  case  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.GETPROP);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.GETPROP);	      Preconditions.checkState(type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	24	None	replace
171	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  parent.getFirstChild().getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	4	None	replace
172	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isName(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	4	None	replace
173	[BUG]  [BUGGY]  Node  n  =  type.getFirstChild();  [CE]  orphaned  case  [FE]                      AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  n  =  type.getFirstChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  type.getFirstChild();	      Node    n    =    scope.getFirstChild();    	non-compiled	[CE]  orphaned  case	16	None	replace
174	[BUG]  [BUGGY]  Node  n  =  getFunctionNode(n.getFirstChild());  [CE]  orphaned  case  [FE]                        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  n  =  getFunctionNode(n.getFirstChild());  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  getFunctionNode(n.getFirstChild());	      Node    n    =    scope.getFirstChild();    	non-compiled	[CE]  orphaned  case	16	None	replace
175	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(parent))  {  [CE]  [FE]        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(parent))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSecondarySideEffects(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	6	None	replace
176	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isExpressionNode(parent))  {  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isExpressionNode(parent))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(parent)||  NodeUtil.isExpressionNode(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	6	None	replace
177	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(parent))  {  [CE]  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(parent))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionPrototype(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	6	None	replace
178	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n.getFirstChild());  [CE]  orphaned  case  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n.getFirstChild());  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  n.getFirstChild());	      var    =    scope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	30	None	replace
179	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n);  [CE]  orphaned  case  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  n);	      var    =    scope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	30	None	replace
180	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  fnScope);  [CE]  orphaned  case  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  var  =  scope.getVar(n.getLastChild(),  fnScope);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  fnScope);	      var    =    scope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	30	None	replace
181	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n.getString());  [CE]  orphaned  case  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n.getString());  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  n.getString());	      var    =    scope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	30	None	replace
182	[BUG]  [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n.getLastChild());  [CE]  orphaned  case  [FE]                    AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  var  =  scope.getVar(n.getLastChild(),  n.getLastChild());  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  scope.getVar(n.getLastChild(),  n.getLastChild());	      var    =    scope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	30	None	replace
183	[BUG]  [BUGGY]  Node  n  =  n.getFirstChild().getNext();  [CE]  orphaned  case  [FE]        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  n  =  n.getFirstChild().getNext();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  n.getFirstChild().getNext();	      Node    n    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	9	None	replace
184	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)&&  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	8	None	replace
185	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	1	None	replace
186	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR)  {  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  parent.getType()  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	1	None	replace
187	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	1	None	replace
188	[BUG]  [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	1	None	replace
189	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	20	None	replace
190	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	20	None	replace
191	[BUG]  [BUGGY]  if(NodeUtil.isName(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isName(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	20	None	replace
192	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	20	None	replace
193	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	27	None	replace
194	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	27	None	replace
195	[BUG]  [BUGGY]  n  =  n.getFirstChild().getNext();  [CE]  orphaned  case  [FE]                          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  n  =  n.getFirstChild().getNext();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getFirstChild().getNext();	      n    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	18	None	replace
196	[BUG]  [BUGGY]  n  =  node.getFirstChild();  [CE]  orphaned  case  [FE]                            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  n  =  node.getFirstChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  node.getFirstChild();	      n    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	18	None	replace
197	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	7	None	replace
198	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	7	None	replace
199	[BUG]  [BUGGY]  if(NodeUtil.isName(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isName(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isName(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	7	None	replace
200	[BUG]  [BUGGY]  if(NodeUtil.isVar(parent)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isVar(parent)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(parent)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	7	None	replace
201	[BUG]  [BUGGY]  Node  scope  =  n.removeFirstChild();  [CE]  orphaned  case  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  scope  =  n.removeFirstChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  n.removeFirstChild();	      Node    scope    =    n.getLastChild();    	non-compiled	[CE]  orphaned  case	14	None	replace
202	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(n));  [CE]  orphaned  case  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(n));  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(n));	      Context.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	29	None	replace
203	[BUG]  [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Context.checkState(parent.getType()  ==  Token.FUNCTION);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(parent.getType()  ==  Token.FUNCTION);	      Context.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	29	None	replace
204	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR);	      Context.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	29	None	replace
205	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.CALL);  [CE]  orphaned  case  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.CALL);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.CALL);	      Context.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	29	None	replace
206	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.VAR);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.VAR);	      Context.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	29	None	replace
207	[BUG]  [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  scope);  [CE]  orphaned  case  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  NodeTraversal.traverse(compiler,  n,  parent,  scope);  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	NodeTraversal.traverse(compiler,  n,  parent,  scope);	      	non-compiled	[CE]  orphaned  case	5	None	replace
208	[BUG]  [BUGGY]  Node  var  =  n.getFirstChild().getNext();  [CE]  orphaned  case  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  var  =  n.getFirstChild().getNext();  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  n.getFirstChild().getNext();	      	non-compiled	[CE]  orphaned  case	5	None	replace
209	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  scope.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	2	None	replace
210	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	2	None	replace
211	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	2	None	replace
212	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(parent)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	2	None	replace
213	[BUG]  [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isExpressionNode(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isExpressionNode(parent)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	19	None	replace
214	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(parent))  {  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(parent))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	19	None	replace
215	[BUG]  [BUGGY]  var  =  parent.getVar(n.getLastChild().getString());  [CE]  orphaned  case  [FE]        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  var  =  parent.getVar(n.getLastChild().getString());  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  parent.getVar(n.getLastChild().getString());	      var    =    scope.getVar(n.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	21	None	replace
216	[BUG]  [BUGGY]  Node  scope  =  getFunctionScope().getFirstChild();  [CE]  orphaned  case  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  scope  =  getFunctionScope().getFirstChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =  getFunctionScope().getFirstChild();	      Node    scope    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	11	None	replace
217	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(n));  [CE]  orphaned  case  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(n));  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionDeclaration(n));	      Preconditions.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	12	None	replace
218	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  parent.getType()  ==  Token.VAR);	      Preconditions.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	12	None	replace
219	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n));  [CE]  orphaned  case  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n));  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n));	      Preconditions.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	12	None	replace
220	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.CALL);  [CE]  orphaned  case  [FE]                    AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.CALL);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  type  ==  Token.CALL);	      Preconditions.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	12	None	replace
221	[BUG]  [BUGGY]  var  =  parent.getVar(n.getFirstChild().getString());  [CE]  orphaned  case  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  var  =  parent.getVar(n.getFirstChild().getString());  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  parent.getVar(n.getFirstChild().getString());	      var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	22	None	replace
222	[BUG]  [BUGGY]  Node  n  =  nameNode.getFirstChild();  [CE]  orphaned  case  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  n  =  nameNode.getFirstChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  nameNode.getFirstChild();	      Node    n    =    parent.getFirstChild();    	non-compiled	[CE]  orphaned  case	10	None	replace
223	[BUG]  [BUGGY]  Node  c  =  n.getCurrentNode();  [CE]  orphaned  case  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  c  =  n.getCurrentNode();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getCurrentNode();	      Node    c    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	13	None	replace
224	[BUG]  [BUGGY]  Node  c  =  n.getFirstChild().getNext();  [CE]  orphaned  case  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  c  =  n.getFirstChild().getNext();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.getFirstChild().getNext();	      Node    c    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	13	None	replace
225	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()  ==  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	26	None	replace
226	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	26	None	replace
227	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [CE]  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  n.getFirstChild()!=  null  &&  NodeUtil.isFunctionDeclaration(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	26	None	replace
228	[BUG]  [BUGGY]  Node  var  =  node.getFirstChild();  [CE]  orphaned  case  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  var  =  node.getFirstChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  node.getFirstChild();	      Node    var    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	23	None	replace
229	[BUG]  [BUGGY]  Node  var  =  n.getParent();  [CE]  orphaned  case  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  var  =  n.getParent();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  n.getParent();	      Node    var    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	23	None	replace
230	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||!NodeUtil.isFunctionDeclaration(n));  [CE]  orphaned  case  [FE]        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||!NodeUtil.isFunctionDeclaration(n));  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  ||!NodeUtil.isFunctionDeclaration(n));	      Preconditions.checkState(n.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	28	None	replace
231	[BUG]  [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(scope.getType()  ==  Token.VAR);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(scope.getType()  ==  Token.VAR);	      Preconditions.checkState(n.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	28	None	replace
232	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  type  ==  Token.NAME);  [CE]  orphaned  case  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  type  ==  Token.NAME);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  ||  type  ==  Token.NAME);	      Preconditions.checkState(n.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	28	None	replace
233	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	3	None	replace
234	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  scope!=  null)  {  [CE]  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  scope!=  null)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  scope!=  null)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	3	None	replace
235	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  parent!=  null)  {  [CE]  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  parent!=  null)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  parent!=  null)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	3	None	replace
236	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  isRemovableVar(n))  {  [CE]  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  isRemovableVar(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  isRemovableVar(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	3	None	replace
237	[BUG]  [BUGGY]  if(fnScope!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(fnScope!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(fnScope!=  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	25	None	replace
238	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||!NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||!NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||!NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	25	None	replace
239	[BUG]  [BUGGY]  if(scope  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(scope  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope  ==  null  &&  NodeUtil.isFunctionDeclaration(n))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	25	None	replace
240	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()  ==  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()  ==  null  ||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()  ==  null  ||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	26	None	replace
241	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  parent.getFirstChild()!=  null  &&  NodeUtil.mayHaveSideEffects(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getFirstChild()!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	26	None	replace
242	[BUG]  [BUGGY]  Node  c  =  n.removeFirstChild();  [CE]  orphaned  case  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  c  =  n.removeFirstChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  c  =  n.removeFirstChild();	      Node    c    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	13	None	replace
243	[BUG]  [BUGGY]  var  =  parent.getFirstChild().getVar(n.getFirstChild().getString());  [CE]  orphaned  case  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  var  =  parent.getFirstChild().getVar(n.getFirstChild().getString());  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  parent.getFirstChild().getVar(n.getFirstChild().getString());	      var    =    scope.getVar(n.getFirstChild().getString());    	non-compiled	[CE]  orphaned  case	22	None	replace
244	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(parent))  {  [CE]  [FE]        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(parent))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isExpressionNode(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isExpressionNode(parent))    {    	non-compiled	[CE]  	6	None	replace
245	[BUG]  [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionObjectCall(n));  [CE]  orphaned  case  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionObjectCall(n));  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Context.checkState(n.getType()  ==  Token.FUNCTION  ||!NodeUtil.isFunctionObjectCall(n));	      Context.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	29	None	replace
246	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [CE]  [FE]        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isRemovableVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	19	None	replace
247	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  modifiedVar.equals(var))  {  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  modifiedVar.equals(var))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  modifiedVar.equals(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	19	None	replace
248	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isDefinedVar(var))  {  [CE]  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isDefinedVar(var))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  scope.getVar(n.getFirstChild().getString())!=  null  &&  isDefinedVar(var))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    scope.getVar(n.getFirstChild().getString())!=    null    &&    isRemovableVar(var))    {    	non-compiled	[CE]  	19	None	replace
249	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [CE]  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  type  ==  Token.VAR)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	3	None	replace
250	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  type  ==  Token.NAME)  {  [CE]  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  type  ==  Token.NAME)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION  ||  type  ==  Token.NAME)  {	  if(NodeUtil.isFunctionDeclaration(n)||    type    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	3	None	replace
251	[BUG]  [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(n.getType()  ==  Token.FUNCTION);	      Preconditions.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	12	None	replace
252	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.VAR);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild().getType()  ==  Token.VAR);	      Preconditions.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	12	None	replace
253	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild()!=  null);  [CE]  orphaned  case  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild()!=  null);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.FUNCTION  ||  n.getFirstChild()!=  null);	      Preconditions.checkState(n.getType()    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	12	None	replace
254	[BUG]  [BUGGY]  Node  var  =  n.removeFirstChild();  [CE]  orphaned  case  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  var  =  n.removeFirstChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  var  =  n.removeFirstChild();	      Node    var    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	23	None	replace
255	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  n.getFirstChild();  [CE]  orphaned  case  [FE]                  AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  n.getFirstChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  n.getFirstChild();	      Node    scope    =    n.getLastChild();    	non-compiled	[CE]  orphaned  case	14	None	replace
256	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  n;  [CE]  orphaned  case  [FE]                    AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  n;  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  n;	      Node    scope    =    n.getLastChild();    	non-compiled	[CE]  orphaned  case	14	None	replace
257	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  parent.getFirstChild()  :  n.getLastChild();  [CE]  orphaned  case  [FE]                      AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  parent.getFirstChild()  :  n.getLastChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()  ==  null)?  parent.getFirstChild()  :  n.getLastChild();	      Node    scope    =    n.getLastChild();    	non-compiled	[CE]  orphaned  case	14	None	replace
258	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  n.getString();  [CE]  orphaned  case  [FE]                        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  n.getString();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()  ==  null)?  n.getLastChild()  :  n.getString();	      Node    scope    =    n.getLastChild();    	non-compiled	[CE]  orphaned  case	14	None	replace
259	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getString()  :  n.getLastChild();  [CE]  orphaned  case  [FE]                          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  n.getString()  :  n.getLastChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()  ==  null)?  n.getString()  :  n.getLastChild();	      Node    scope    =    n.getLastChild();    	non-compiled	[CE]  orphaned  case	14	None	replace
260	[BUG]  [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  parent.getLastChild()  :  n.getFirstChild();  [CE]  orphaned  case  [FE]                            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  scope  =(n.getFirstChild()  ==  null)?  parent.getLastChild()  :  n.getFirstChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  scope  =(n.getFirstChild()  ==  null)?  parent.getLastChild()  :  n.getFirstChild();	      Node    scope    =    n.getLastChild();    	non-compiled	[CE]  orphaned  case	14	None	replace
261	[BUG]  [BUGGY]  n  =  n.removeFirstChild();  [CE]  orphaned  case  [FE]                          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  n  =  n.removeFirstChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.removeFirstChild();	      n    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	18	None	replace
262	[BUG]  [BUGGY]  n  =  n.getPreviousSibling();  [CE]  orphaned  case  [FE]                            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  n  =  n.getPreviousSibling();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	n  =  n.getPreviousSibling();	      n    =    n.getFirstChild();    	non-compiled	[CE]  orphaned  case	18	None	replace
263	[BUG]  [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.VAR);  [CE]  orphaned  case  [FE]        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkArgument(n.getType()  ==  Token.VAR);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkArgument(n.getType()  ==  Token.VAR);	      Preconditions.checkState(n.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	28	None	replace
264	[BUG]  [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  parent.getType()  ==  Token.FUNCTION);  [CE]  orphaned  case  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(n.getType()  ==  Token.VAR  ||  parent.getType()  ==  Token.FUNCTION);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(n.getType()  ==  Token.VAR  ||  parent.getType()  ==  Token.FUNCTION);	      Preconditions.checkState(n.getType()    ==    Token.VAR);    	non-compiled	[CE]  orphaned  case	28	None	replace
265	[BUG]  [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.CATCH);  [CE]  orphaned  case  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.CATCH);  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Preconditions.checkState(type  ==  Token.FUNCTION  ||  type  ==  Token.CATCH);	      Preconditions.checkState(type    ==    Token.FUNCTION);    	non-compiled	[CE]  orphaned  case	24	None	replace
266	[BUG]  [BUGGY]  Node  n  =  n.removeFirstChild();  [CE]  orphaned  case  [FE]                    AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  n  =  n.removeFirstChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  n.removeFirstChild();	      Node    n    =    n.getLastChild();    	non-compiled	[CE]  orphaned  case	15	None	replace
267	[BUG]  [BUGGY]  Node  n  =  parent.getfirstChild();  [CE]  orphaned  case  [FE]                      AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  n  =  parent.getfirstChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  parent.getfirstChild();	      Node    n    =    n.getLastChild();    	non-compiled	[CE]  orphaned  case	15	None	replace
268	[BUG]  [BUGGY]  var  =  this.fnScope.getVar(n.getLastChild());  [CE]  orphaned  case  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  var  =  this.fnScope.getVar(n.getLastChild());  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  this.fnScope.getVar(n.getLastChild());	      var    =    scope.getVar(n.getLastChild());    	non-compiled	[CE]  orphaned  case	30	None	replace
269	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)||  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isVar(n)||  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)||  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	4	None	replace
270	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	7	None	replace
271	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n,  parent))  {  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n,  parent))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)&&  NodeUtil.isFunctionDeclaration(n,  parent))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	7	None	replace
272	[BUG]  [BUGGY]  if(NodeUtil.isVar(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isVar(n)&&  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isVar(n)&&  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)&&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	7	None	replace
273	[BUG]  [BUGGY]  Node  n  =  getFunctionScope().getFirstChild();  [CE]  orphaned  case  [FE]                      AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  Node  n  =  getFunctionScope().getFirstChild();  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	Node  n  =  getFunctionScope().getFirstChild();	      Node    n    =    scope.getFirstChild();    	non-compiled	[CE]  orphaned  case	16	None	replace
274	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [CE]  [FE]        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  type  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	1	None	replace
275	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	1	None	replace
276	[BUG]  [BUGGY]  var  =  parent.getFirstChild().getVar(n.getLastChild().getString());  [CE]  orphaned  case  [FE]        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  var  =  parent.getFirstChild().getVar(n.getLastChild().getString());  [BUGGY]    if  (NodeUtil.isFunctionDeclaration(n))  {  var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	var  =  parent.getFirstChild().getVar(n.getLastChild().getString());	      var    =    scope.getVar(n.getLastChild().getString());    	non-compiled	[CE]  orphaned  case	21	None	replace
277	[BUG]  [BUGGY]  if(NodeUtil.isLiteralValue(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isLiteralValue(n)&&  parent.getType()  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isLiteralValue(n)&&  parent.getType()  ==  Token.FUNCTION)  {	  if(NodeUtil.isFunctionDeclaration(n)&&    parent.getType()    ==    Token.FUNCTION)    {    	non-compiled	[CE]  	8	None	replace
278	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	27	None	replace
279	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects  [CE]  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	27	None	replace
280	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [CE]  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isGetProp(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	27	None	replace
281	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null)  {  [CE]  [FE]        AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getVar(n.getFirstChild().getString())!=  null)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	25	None	replace
282	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getType()  ==  Token.FUNCTION)  {  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getType()  ==  Token.FUNCTION)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getType()  ==  Token.FUNCTION)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	25	None	replace
283	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.VAR)  {  [CE]  [FE]            AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.VAR)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  scope.getType()  ==  Token.VAR)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	25	None	replace
284	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getString().equals( "function "))  {  [CE]  [FE]              AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getString().equals( "function "))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getString().equals( "function "))  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	25	None	replace
285	[BUG]  [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getType()  ==  Token.VAR)  {  [CE]  [FE]                AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getType()  ==  Token.VAR)  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(scope!=  null  &&  NodeUtil.isFunctionDeclaration(n)||  n.getFirstChild().getType()  ==  Token.VAR)  {	  if(scope!=    null    &&    NodeUtil.isFunctionDeclaration(n))    {    	non-compiled	[CE]  	25	None	replace
286	[BUG]  [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(parent))  {  [CE]  [FE]          AssertionFailedError    [CONTEXT]    private  void  traverseNode(Node  n,  Node  parent,  Scope  scope)  {  int  type  =  n.getType();  Var  var  =  null;  switch  (type)  {  case  Token.FUNCTION:      [BUGGY]  if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(parent))  {  [BUGGY]    var  =  scope.getVar(n.getFirstChild().getString());  }  if  (var  !=  null  &&  isRemovableVar(var))  {  continuations.put(var,  new  Continuation(n,  scope));  }  else  {  traverseFunction(n,  scope);  }  return;  [CLASS]  RemoveUnusedVars  CallSiteOptimizer  Continuation  Assign  [METHOD]  traverseNode  [RETURN_TYPE]  void  Node  n  Node  parent  Scope  scope  [VARIABLES]  Set  referenced  Var  modifiedVar  var  Node  a  assignNode  c  externs  lp  n  nameNode  node  parent  root  value  SubclassRelationship  subclassRelationship  SimpleDefinitionFinder  defFinder  String  className  int  type  Multimap  assignsByVar  classDefiningCalls  continuations  CallSiteOptimizer  callSiteOptimizer  AbstractCompiler  compiler  boolean  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  Scope  fnScope  scope  CodingConvention  codingConvention  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  Assign  maybeAssign  Map  assignsByNode  	projects/Closure1/src/com/google/javascript/jscomp/RemoveUnusedVars.java	0.2817180849095055	199	199	5	replace	if(NodeUtil.isFunctionDeclaration(n)||  NodeUtil.isFunctionDeclaration(n)||  NodeUtil.mayHaveSideEffects(parent))  {	  if(NodeUtil.isFunctionDeclaration(n)||    NodeUtil.isFunctionDeclaration(parent))    {    	non-compiled	[CE]  	2	None	replace
