bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] throw new IllegalArgumentException("Types array must not contain duplicate: " +   types[i - 1].getName() + " and " + loopType.getName()); [FE] IllegalArgumentException [CONTEXT] DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { [BUGGY] throw new IllegalArgumentException("Types array must not contain duplicate: " +           types[i - 1].getName() + " and " + loopType.getName()); [BUGGY] types[i - 1].getName() + " and " + loopType.getName()); } } else { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (lastRangeField.compareTo(loopRangeField) < 0) { [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	replace	
2	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { [BUGGY] [BUGGY] throw new IllegalArgumentException("Types array must not contain duplicate: " +           types[i - 1].getName() + " and " + loopType.getName()); types[i - 1].getName() + " and " + loopType.getName()); } } else { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (lastRangeField.compareTo(loopRangeField) < 0) { [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	1.0	224	225	1	add	
3	[BUG] [BUGGY] return 0; [FE] IllegalArgumentException [CONTEXT] public int compareTo(DurationField durationField) { [BUGGY] return 0; [BUGGY] } [CLASS] UnsupportedDurationField [METHOD] compareTo [RETURN_TYPE] int  DurationField durationField [VARIABLES] boolean HashMap cCache DurationField durationField long duration instant minuendInstant serialVersionUID subtrahendInstant value DurationFieldType iType type  	projects/Time2/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.4472135954999579	227	227	1	replace	
4	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public int compareTo(DurationField durationField) { [BUGGY] [BUGGY] return 0; } [CLASS] UnsupportedDurationField [METHOD] compareTo [RETURN_TYPE] int  DurationField durationField [VARIABLES] boolean HashMap cCache DurationField durationField long duration instant minuendInstant serialVersionUID subtrahendInstant value DurationFieldType iType type  	projects/Time2/src/main/java/org/joda/time/field/UnsupportedDurationField.java	0.4472135954999579	227	227	1	add	
5	[BUG] [BUGGY] if (loopType.getRangeDurationType() == null) { [FE] IllegalArgumentException [CONTEXT] for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { [BUGGY] if (loopType.getRangeDurationType() == null) { [BUGGY] throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); } } else { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.4472135954999579	223	223	1	replace	
6	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { [BUGGY] [BUGGY] if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); } } else { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.4472135954999579	223	223	1	add	
7	[BUG] [BUGGY] if (types[i - 1].getRangeDurationType() == null) { [FE] IllegalArgumentException [CONTEXT] DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { [BUGGY] if (types[i - 1].getRangeDurationType() == null) { [BUGGY] if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); } } else { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.3333333333333333	222	222	1	replace	
8	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { [BUGGY] [BUGGY] if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); } } else { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType[] types int[] values Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes types Partial iPartial DateTimeFieldType loopType int[] iValues values Chronology chrono chronology iChronology DurationField lastRangeField lastUnitField loopRangeField loopUnitField long serialVersionUID DateTimeFormatter[] iFormatter int compare i iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.3333333333333333	222	222	1	add	
9	[BUG] [BUGGY] this(type, value, null); [FE] IllegalArgumentException [CONTEXT] public Partial(DateTimeFieldType type, int value) { [BUGGY] this(type, value, null); [BUGGY] } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] DateTimeFieldType,int)  DateTimeFieldType type int value [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	139	139	1	replace	
10	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public Partial(DateTimeFieldType type, int value) { [BUGGY] [BUGGY] this(type, value, null); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] DateTimeFieldType,int)  DateTimeFieldType type int value [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	139	139	1	add	
11	[BUG] [BUGGY] } [FE] IllegalArgumentException [CONTEXT] public Partial(DateTimeFieldType type, int value) { this(type, value, null); [BUGGY] } [BUGGY]  [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] DateTimeFieldType,int)  DateTimeFieldType type int value [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	140	140	1	replace	
12	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public Partial(DateTimeFieldType type, int value) { this(type, value, null); [BUGGY] [BUGGY] } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] DateTimeFieldType,int)  DateTimeFieldType type int value [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	140	140	1	add	
13	[BUG] [BUGGY] super(); [FE] IllegalArgumentException [CONTEXT] public Partial(DateTimeFieldType type, int value, Chronology chronology) { [BUGGY] super(); [BUGGY] chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (type == null) { throw new IllegalArgumentException("The field type must not be null"); } iTypes = new DateTimeFieldType[] {type}; iValues = new int[] {value}; chronology.validate(this, iValues); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType type int value Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	153	153	1	replace	
14	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public Partial(DateTimeFieldType type, int value, Chronology chronology) { [BUGGY] [BUGGY] super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (type == null) { throw new IllegalArgumentException("The field type must not be null"); } iTypes = new DateTimeFieldType[] {type}; iValues = new int[] {value}; chronology.validate(this, iValues); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType type int value Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	153	153	1	add	
15	[BUG] [BUGGY] chronology = DateTimeUtils.getChronology(chronology).withUTC(); [FE] IllegalArgumentException [CONTEXT] public Partial(DateTimeFieldType type, int value, Chronology chronology) { super(); [BUGGY] chronology = DateTimeUtils.getChronology(chronology).withUTC(); [BUGGY] iChronology = chronology; if (type == null) { throw new IllegalArgumentException("The field type must not be null"); } iTypes = new DateTimeFieldType[] {type}; iValues = new int[] {value}; chronology.validate(this, iValues); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType type int value Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	154	154	1	replace	
16	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public Partial(DateTimeFieldType type, int value, Chronology chronology) { super(); [BUGGY] [BUGGY] chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (type == null) { throw new IllegalArgumentException("The field type must not be null"); } iTypes = new DateTimeFieldType[] {type}; iValues = new int[] {value}; chronology.validate(this, iValues); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType type int value Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	154	154	1	add	
17	[BUG] [BUGGY] iChronology = chronology; [FE] IllegalArgumentException [CONTEXT] public Partial(DateTimeFieldType type, int value, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); [BUGGY] iChronology = chronology; [BUGGY] if (type == null) { throw new IllegalArgumentException("The field type must not be null"); } iTypes = new DateTimeFieldType[] {type}; iValues = new int[] {value}; chronology.validate(this, iValues); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType type int value Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	155	155	1	replace	
18	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public Partial(DateTimeFieldType type, int value, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); [BUGGY] [BUGGY] iChronology = chronology; if (type == null) { throw new IllegalArgumentException("The field type must not be null"); } iTypes = new DateTimeFieldType[] {type}; iValues = new int[] {value}; chronology.validate(this, iValues); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType type int value Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	155	155	1	add	
19	[BUG] [BUGGY] if (type == null) { [FE] IllegalArgumentException [CONTEXT] public Partial(DateTimeFieldType type, int value, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; [BUGGY] if (type == null) { [BUGGY] throw new IllegalArgumentException("The field type must not be null"); } iTypes = new DateTimeFieldType[] {type}; iValues = new int[] {value}; chronology.validate(this, iValues); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType type int value Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	156	156	1	replace	
20	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public Partial(DateTimeFieldType type, int value, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; [BUGGY] [BUGGY] if (type == null) { throw new IllegalArgumentException("The field type must not be null"); } iTypes = new DateTimeFieldType[] {type}; iValues = new int[] {value}; chronology.validate(this, iValues); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType type int value Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	156	156	1	add	
21	[BUG] [BUGGY] iTypes = new DateTimeFieldType[] {type}; [FE] IllegalArgumentException [CONTEXT] public Partial(DateTimeFieldType type, int value, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (type == null) { throw new IllegalArgumentException("The field type must not be null"); } [BUGGY] iTypes = new DateTimeFieldType[] {type}; [BUGGY] iValues = new int[] {value}; chronology.validate(this, iValues); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType type int value Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	159	159	1	replace	
22	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public Partial(DateTimeFieldType type, int value, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (type == null) { throw new IllegalArgumentException("The field type must not be null"); } [BUGGY] [BUGGY] iTypes = new DateTimeFieldType[] {type}; iValues = new int[] {value}; chronology.validate(this, iValues); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType type int value Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	159	159	1	add	
23	[BUG] [BUGGY] iValues = new int[] {value}; [FE] IllegalArgumentException [CONTEXT] public Partial(DateTimeFieldType type, int value, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (type == null) { throw new IllegalArgumentException("The field type must not be null"); } iTypes = new DateTimeFieldType[] {type}; [BUGGY] iValues = new int[] {value}; [BUGGY] chronology.validate(this, iValues); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType type int value Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	160	160	1	replace	
24	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public Partial(DateTimeFieldType type, int value, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (type == null) { throw new IllegalArgumentException("The field type must not be null"); } iTypes = new DateTimeFieldType[] {type}; [BUGGY] [BUGGY] iValues = new int[] {value}; chronology.validate(this, iValues); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType type int value Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	160	160	1	add	
25	[BUG] [BUGGY] chronology.validate(this, iValues); [FE] IllegalArgumentException [CONTEXT] public Partial(DateTimeFieldType type, int value, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (type == null) { throw new IllegalArgumentException("The field type must not be null"); } iTypes = new DateTimeFieldType[] {type}; iValues = new int[] {value}; [BUGGY] chronology.validate(this, iValues); [BUGGY] } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType type int value Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	161	161	1	replace	
26	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public Partial(DateTimeFieldType type, int value, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (type == null) { throw new IllegalArgumentException("The field type must not be null"); } iTypes = new DateTimeFieldType[] {type}; iValues = new int[] {value}; [BUGGY] [BUGGY] chronology.validate(this, iValues); } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType type int value Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	161	161	1	add	
27	[BUG] [BUGGY] } [FE] IllegalArgumentException [CONTEXT] public Partial(DateTimeFieldType type, int value, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (type == null) { throw new IllegalArgumentException("The field type must not be null"); } iTypes = new DateTimeFieldType[] {type}; iValues = new int[] {value}; chronology.validate(this, iValues); [BUGGY] } [BUGGY]  [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType type int value Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	162	162	1	replace	
28	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public Partial(DateTimeFieldType type, int value, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (type == null) { throw new IllegalArgumentException("The field type must not be null"); } iTypes = new DateTimeFieldType[] {type}; iValues = new int[] {value}; chronology.validate(this, iValues); [BUGGY] [BUGGY] } [CLASS] Partial Property [METHOD] <init> [RETURN_TYPE] Chronology)  DateTimeFieldType type int value Chronology chronology [VARIABLES] boolean DateTimeFieldType[] iTypes Partial iPartial DateTimeFieldType type int[] iValues Chronology chrono chronology iChronology long serialVersionUID DateTimeFormatter[] iFormatter int iFieldIndex value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.2886751345948129	162	162	1	add	
29	[BUG] [BUGGY] DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; [FE] IllegalArgumentException [CONTEXT] public Partial with(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException("The field type must not be null"); } int index = indexOf(fieldType); if (index == -1) { [BUGGY] DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; [BUGGY] int[] newValues = new int[newTypes.length];  int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.25	434	434	1	replace	
30	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public Partial with(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException("The field type must not be null"); } int index = indexOf(fieldType); if (index == -1) { [BUGGY] [BUGGY] DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; int[] newValues = new int[newTypes.length];  int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.25	434	434	1	add	
31	[BUG] [BUGGY] int[] newValues = new int[newTypes.length]; [FE] IllegalArgumentException [CONTEXT] public Partial with(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException("The field type must not be null"); } int index = indexOf(fieldType); if (index == -1) { DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; [BUGGY] int[] newValues = new int[newTypes.length]; [BUGGY]   int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.25	435	435	1	replace	
32	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public Partial with(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException("The field type must not be null"); } int index = indexOf(fieldType); if (index == -1) { DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; [BUGGY] [BUGGY] int[] newValues = new int[newTypes.length];  int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.25	435	435	1	add	
33	[BUG] [BUGGY] int i = 0; [FE] IllegalArgumentException [CONTEXT] public Partial with(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException("The field type must not be null"); } int index = indexOf(fieldType); if (index == -1) { DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; int[] newValues = new int[newTypes.length];  [BUGGY] int i = 0; [BUGGY] DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { break; } else if (compare == 0) { [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.25	438	438	1	replace	
34	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public Partial with(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException("The field type must not be null"); } int index = indexOf(fieldType); if (index == -1) { DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; int[] newValues = new int[newTypes.length];  [BUGGY] [BUGGY] int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { break; } else if (compare == 0) { [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.25	438	438	1	add	
35	[BUG] [BUGGY] DurationField unitField = fieldType.getDurationType().getField(iChronology); [FE] IllegalArgumentException [CONTEXT] if (fieldType == null) { throw new IllegalArgumentException("The field type must not be null"); } int index = indexOf(fieldType); if (index == -1) { DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; int[] newValues = new int[newTypes.length];  int i = 0; [BUGGY] DurationField unitField = fieldType.getDurationType().getField(iChronology); [BUGGY] if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { break; } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.25	439	439	1	replace	
36	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] if (fieldType == null) { throw new IllegalArgumentException("The field type must not be null"); } int index = indexOf(fieldType); if (index == -1) { DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; int[] newValues = new int[newTypes.length];  int i = 0; [BUGGY] [BUGGY] DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { break; } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.25	439	439	1	add	
37	[BUG] [BUGGY] if (unitField.isSupported()) { [FE] IllegalArgumentException [CONTEXT] throw new IllegalArgumentException("The field type must not be null"); } int index = indexOf(fieldType); if (index == -1) { DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; int[] newValues = new int[newTypes.length];  int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); [BUGGY] if (unitField.isSupported()) { [BUGGY] for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { break; } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.25	440	440	1	replace	
38	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] throw new IllegalArgumentException("The field type must not be null"); } int index = indexOf(fieldType); if (index == -1) { DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; int[] newValues = new int[newTypes.length];  int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); [BUGGY] [BUGGY] if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { break; } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.25	440	440	1	add	
39	[BUG] [BUGGY] System.arraycopy(iTypes, 0, newTypes, 0, i); [FE] IllegalArgumentException [CONTEXT] } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } [BUGGY] System.arraycopy(iTypes, 0, newTypes, 0, i); [BUGGY] System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; newValues[i] = value; System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);   Partial newPartial = new Partial(newTypes, newValues, iChronology); iChronology.validate(newPartial, newValues); return newPartial; [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.25	458	458	1	replace	
40	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } [BUGGY] [BUGGY] System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; newValues[i] = value; System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);   Partial newPartial = new Partial(newTypes, newValues, iChronology); iChronology.validate(newPartial, newValues); return newPartial; [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.25	458	458	1	add	
41	[BUG] [BUGGY] System.arraycopy(iValues, 0, newValues, 0, i); [FE] IllegalArgumentException [CONTEXT] DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); [BUGGY] System.arraycopy(iValues, 0, newValues, 0, i); [BUGGY] newTypes[i] = fieldType; newValues[i] = value; System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);   Partial newPartial = new Partial(newTypes, newValues, iChronology); iChronology.validate(newPartial, newValues); return newPartial; } [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.25	459	459	1	replace	
42	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); [BUGGY] [BUGGY] System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; newValues[i] = value; System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);   Partial newPartial = new Partial(newTypes, newValues, iChronology); iChronology.validate(newPartial, newValues); return newPartial; } [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.25	459	459	1	add	
43	[BUG] [BUGGY] newTypes[i] = fieldType; [FE] IllegalArgumentException [CONTEXT] DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); [BUGGY] newTypes[i] = fieldType; [BUGGY] newValues[i] = value; System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);   Partial newPartial = new Partial(newTypes, newValues, iChronology); iChronology.validate(newPartial, newValues); return newPartial; } if (value == getValue(index)) { [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.25	460	460	1	replace	
44	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); [BUGGY] [BUGGY] newTypes[i] = fieldType; newValues[i] = value; System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);   Partial newPartial = new Partial(newTypes, newValues, iChronology); iChronology.validate(newPartial, newValues); return newPartial; } if (value == getValue(index)) { [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.25	460	460	1	add	
45	[BUG] [BUGGY] newValues[i] = value; [FE] IllegalArgumentException [CONTEXT] if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; [BUGGY] newValues[i] = value; [BUGGY] System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);   Partial newPartial = new Partial(newTypes, newValues, iChronology); iChronology.validate(newPartial, newValues); return newPartial; } if (value == getValue(index)) { return this; [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.25	461	461	1	replace	
46	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; [BUGGY] [BUGGY] newValues[i] = value; System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);   Partial newPartial = new Partial(newTypes, newValues, iChronology); iChronology.validate(newPartial, newValues); return newPartial; } if (value == getValue(index)) { return this; [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.25	461	461	1	add	
47	[BUG] [BUGGY] System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); [FE] IllegalArgumentException [CONTEXT] break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; newValues[i] = value; [BUGGY] System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); [BUGGY] System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);   Partial newPartial = new Partial(newTypes, newValues, iChronology); iChronology.validate(newPartial, newValues); return newPartial; } if (value == getValue(index)) { return this; } [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.25	462	462	1	replace	
48	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; newValues[i] = value; [BUGGY] [BUGGY] System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);   Partial newPartial = new Partial(newTypes, newValues, iChronology); iChronology.validate(newPartial, newValues); return newPartial; } if (value == getValue(index)) { return this; } [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.25	462	462	1	add	
49	[BUG] [BUGGY] System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); [FE] IllegalArgumentException [CONTEXT] } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; newValues[i] = value; System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); [BUGGY] System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); [BUGGY]   Partial newPartial = new Partial(newTypes, newValues, iChronology); iChronology.validate(newPartial, newValues); return newPartial; } if (value == getValue(index)) { return this; } int[] newValues = getValues(); [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.25	463	463	1	replace	
50	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; newValues[i] = value; System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); [BUGGY] [BUGGY] System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);   Partial newPartial = new Partial(newTypes, newValues, iChronology); iChronology.validate(newPartial, newValues); return newPartial; } if (value == getValue(index)) { return this; } int[] newValues = getValues(); [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.25	463	463	1	add	
51	[BUG] [BUGGY] Partial newPartial = new Partial(newTypes, newValues, iChronology); [FE] IllegalArgumentException [CONTEXT] } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; newValues[i] = value; System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);   [BUGGY] Partial newPartial = new Partial(newTypes, newValues, iChronology); [BUGGY] iChronology.validate(newPartial, newValues); return newPartial; } if (value == getValue(index)) { return this; } int[] newValues = getValues(); newValues = getField(index).set(this, index, newValues, value); return new Partial(this, newValues); } [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.25	466	466	1	replace	
52	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; newValues[i] = value; System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);   [BUGGY] [BUGGY] Partial newPartial = new Partial(newTypes, newValues, iChronology); iChronology.validate(newPartial, newValues); return newPartial; } if (value == getValue(index)) { return this; } int[] newValues = getValues(); newValues = getField(index).set(this, index, newValues, value); return new Partial(this, newValues); } [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.25	466	466	1	add	
53	[BUG] [BUGGY] int index = indexOf(fieldType); [FE] IllegalArgumentException [CONTEXT] public Partial with(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException("The field type must not be null"); } [BUGGY] int index = indexOf(fieldType); [BUGGY] if (index == -1) { DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; int[] newValues = new int[newTypes.length];  int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.23570226039551587	432	432	1	replace	
54	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public Partial with(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException("The field type must not be null"); } [BUGGY] [BUGGY] int index = indexOf(fieldType); if (index == -1) { DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; int[] newValues = new int[newTypes.length];  int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.23570226039551587	432	432	1	add	
55	[BUG] [BUGGY] if (index == -1) { [FE] IllegalArgumentException [CONTEXT] public Partial with(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException("The field type must not be null"); } int index = indexOf(fieldType); [BUGGY] if (index == -1) { [BUGGY] DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; int[] newValues = new int[newTypes.length];  int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.23570226039551587	433	433	1	replace	
56	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public Partial with(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException("The field type must not be null"); } int index = indexOf(fieldType); [BUGGY] [BUGGY] if (index == -1) { DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; int[] newValues = new int[newTypes.length];  int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.23570226039551587	433	433	1	add	
57	[BUG] [BUGGY] if (fieldType == null) { [FE] IllegalArgumentException [CONTEXT] public Partial with(DateTimeFieldType fieldType, int value) { [BUGGY] if (fieldType == null) { [BUGGY] throw new IllegalArgumentException("The field type must not be null"); } int index = indexOf(fieldType); if (index == -1) { DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; int[] newValues = new int[newTypes.length];  int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.22941573387056174	429	429	1	replace	
58	[BUG] [BUGGY] [FE] IllegalArgumentException [CONTEXT] public Partial with(DateTimeFieldType fieldType, int value) { [BUGGY] [BUGGY] if (fieldType == null) { throw new IllegalArgumentException("The field type must not be null"); } int index = indexOf(fieldType); if (index == -1) { DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; int[] newValues = new int[newTypes.length];  int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial  DateTimeFieldType fieldType int value [VARIABLES] boolean DateTimeFieldType[] iTypes newTypes types Partial iPartial newPartial partial DateTimeFieldType fieldType loopType int[] iValues newValues values Chronology chrono chronology iChronology newChronology DurationField loopRangeField loopUnitField rangeField unitField long serialVersionUID DateTimeFormatter[] iFormatter int compare fieldIndex i iFieldIndex index value  	projects/Time2/src/main/java/org/joda/time/Partial.java	0.22941573387056174	429	429	1	add	
