bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  if(header  ==  null  ||  header.size()  >  0)  {  [CE]  :  expected  [FE]                      AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  ==  null  ||  header.size()  >  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  ==  null  ||  header.size()  >  0)  {	  if(header    ==    null    ||    nextRecord.size()    >    0)    {    	non-compiled	[CE]  :  expected	24	None	replace
2	[BUG]  [BUGGY]  if(header  ==  null  ||  nextRecord.size()  ==  0)  {  [CE]  :  expected  [FE]                        AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  ==  null  ||  nextRecord.size()  ==  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  ==  null  ||  nextRecord.size()  ==  0)  {	  if(header    ==    null    ||    nextRecord.size()    >    0)    {    	non-compiled	[CE]  :  expected	24	None	replace
3	[BUG]  [BUGGY]  if(header  ==  null  ||  nextRecord.size()!=  0)  {  [CE]  :  expected  [FE]                          AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  ==  null  ||  nextRecord.size()!=  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  ==  null  ||  nextRecord.size()!=  0)  {	  if(header    ==    null    ||    nextRecord.size()    >    0)    {    	non-compiled	[CE]  :  expected	24	None	replace
4	[BUG]  [BUGGY]  if(header  ==  null  ||  nextRecord.size()  >=  0)  {  [CE]  :  expected  [FE]                            AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  ==  null  ||  nextRecord.size()  >=  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  ==  null  ||  nextRecord.size()  >=  0)  {	  if(header    ==    null    ||    nextRecord.size()    >    0)    {    	non-compiled	[CE]  :  expected	24	None	replace
5	[BUG]  [BUGGY]  if(header  ==  null  ||  header.size()  <  0)  {  [CE]  :  expected  [FE]                              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  ==  null  ||  header.size()  <  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  ==  null  ||  header.size()  <  0)  {	  if(header    ==    null    ||    nextRecord.size()    >    0)    {    	non-compiled	[CE]  :  expected	24	None	replace
6	[BUG]  [BUGGY]  hdrMap.put(header[i],  this.format.getSkipHeaderRecord());  [CE]  :  expected  [FE]                      AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header[i],  this.format.getSkipHeaderRecord());  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header[i],  this.format.getSkipHeaderRecord());	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    this.format.getSkipHeaderRecord());    }    	non-compiled	[CE]  :  expected	28	None	replace
7	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  this.format.getHeaderRecord();  i++)  {  hdrMap.put(header[i],  this.format.getSkipHeaderRecord());  }  [CE]  :  expected  [FE]                        AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  this.format.getHeaderRecord();  i++)  {  hdrMap.put(header[i],  this.format.getSkipHeaderRecord());  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  this.format.getHeaderRecord();  i++)  {  hdrMap.put(header[i],  this.format.getSkipHeaderRecord());  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    this.format.getSkipHeaderRecord());    }    	non-compiled	[CE]  :  expected	28	None	replace
8	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  this.format.getHeaderCount();  i++)  {  hdrMap.put(header[i],  this.format.getSkipHeaderRecord());  }  [CE]  :  expected  [FE]                          AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  this.format.getHeaderCount();  i++)  {  hdrMap.put(header[i],  this.format.getSkipHeaderRecord());  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  this.format.getHeaderCount();  i++)  {  hdrMap.put(header[i],  this.format.getSkipHeaderRecord());  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    this.format.getSkipHeaderRecord());    }    	non-compiled	[CE]  :  expected	28	None	replace
9	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  this.format.getSkipHeaderRecord();  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  [CE]  :  expected  [FE]                            AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  this.format.getSkipHeaderRecord();  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  this.format.getSkipHeaderRecord();  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    this.format.getSkipHeaderRecord());    }    	non-compiled	[CE]  :  expected	28	None	replace
10	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  this.format.getSkipHeaderRecord();  i++)  {  hdrMap.put(header[i],  this.format.getSkipHeaderRecord());  }  [CE]  :  expected  [FE]                              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  this.format.getSkipHeaderRecord();  i++)  {  hdrMap.put(header[i],  this.format.getSkipHeaderRecord());  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  this.format.getSkipHeaderRecord();  i++)  {  hdrMap.put(header[i],  this.format.getSkipHeaderRecord());  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    this.format.getSkipHeaderRecord());    }    	non-compiled	[CE]  :  expected	28	None	replace
11	[BUG]  [BUGGY]  if(header  ==  null  ||  header.length  <  1)  {  [CE]  :  expected  [FE]                  AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  ==  null  ||  header.length  <  1)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  ==  null  ||  header.length  <  1)  {	  if(header    ==    null    ||    header.length    <    2)    {    	non-compiled	[CE]  :  expected	40	None	replace
12	[BUG]  [BUGGY]  if(header  ==  null  ||  header.length  <  2  ||  this.format.getSkipHeaderRecord().equals(header))  {  [CE]  :  expected  [FE]                    AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  ==  null  ||  header.length  <  2  ||  this.format.getSkipHeaderRecord().equals(header))  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  ==  null  ||  header.length  <  2  ||  this.format.getSkipHeaderRecord().equals(header))  {	  if(header    ==    null    ||    header.length    <    2)    {    	non-compiled	[CE]  :  expected	40	None	replace
13	[BUG]  [BUGGY]  if(header  ==  null  ||  header.length  <  2  ||  this.format.getSkipHeaderRecord().contains(header))  {  [CE]  :  expected  [FE]                      AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  ==  null  ||  header.length  <  2  ||  this.format.getSkipHeaderRecord().contains(header))  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  ==  null  ||  header.length  <  2  ||  this.format.getSkipHeaderRecord().contains(header))  {	  if(header    ==    null    ||    header.length    <    2)    {    	non-compiled	[CE]  :  expected	40	None	replace
14	[BUG]  [BUGGY]  if(header  ==  null  ||  header.length  <  1  ||  header.length  <  2)  {  [CE]  :  expected  [FE]                        AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  ==  null  ||  header.length  <  1  ||  header.length  <  2)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  ==  null  ||  header.length  <  1  ||  header.length  <  2)  {	  if(header    ==    null    ||    header.length    <    2)    {    	non-compiled	[CE]  :  expected	40	None	replace
15	[BUG]  [BUGGY]  if(header  ==  null  ||  header.length  <  2  ||  header.length  >  0)  {  [CE]  :  expected  [FE]                          AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  ==  null  ||  header.length  <  2  ||  header.length  >  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  ==  null  ||  header.length  <  2  ||  header.length  >  0)  {	  if(header    ==    null    ||    header.length    <    2)    {    	non-compiled	[CE]  :  expected	40	None	replace
16	[BUG]  [BUGGY]  if(header!=  null  ||  header.length  <  =  0)  {  [CE]  :  expected  [FE]                  AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header!=  null  ||  header.length  <  =  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header!=  null  ||  header.length  <  =  0)  {	  if(header!=    null    &&    header.length    <    =    0)    {    	non-compiled	[CE]  :  expected	14	None	replace
17	[BUG]  [BUGGY]  if(header!=  null  &&  header.length  <  =  1)  {  [CE]  :  expected  [FE]                    AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header!=  null  &&  header.length  <  =  1)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header!=  null  &&  header.length  <  =  1)  {	  if(header!=    null    &&    header.length    <    =    0)    {    	non-compiled	[CE]  :  expected	14	None	replace
18	[BUG]  [BUGGY]  hdrMap.put(header,  rec);  [CE]  :  expected  [FE]                            AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header,  rec);  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header,  rec);	  hdrMap.put(rec,    header);    	non-compiled	[CE]  :  expected	5	None	replace
19	[BUG]  [BUGGY]  hdrMap.put(record,  header);  [CE]  :  expected  [FE]                              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(record,  header);  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(record,  header);	  hdrMap.put(rec,    header);    	non-compiled	[CE]  :  expected	5	None	replace
20	[BUG]  [BUGGY]  hdrMap.put(header[i],  header);  [CE]  :  expected  [FE]                                AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header[i],  header);  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header[i],  header);	  hdrMap.put(rec,    header);    	non-compiled	[CE]  :  expected	5	None	replace
21	[BUG]  [BUGGY]  hdrMap.put(header[0],  header);  [CE]  :  expected  [FE]                                  AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header[0],  header);  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header[0],  header);	  hdrMap.put(rec,    header);    	non-compiled	[CE]  :  expected	5	None	replace
22	[BUG]  [BUGGY]  ger  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  [CE]  :  expected  [FE]                                AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  ger  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	ger  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    String.valueOf(i));    }    	non-compiled	[CE]  :  expected	33	None	replace
23	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  header.length  -  1;  i++)  {  hdrMap.put(header[i],  String.valueOf(i));  }  [CE]  :  expected  [FE]                                  AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  header.length  -  1;  i++)  {  hdrMap.put(header[i],  String.valueOf(i));  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  header.length  -  1;  i++)  {  hdrMap.put(header[i],  String.valueOf(i));  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    String.valueOf(i));    }    	non-compiled	[CE]  :  expected	33	None	replace
24	[BUG]  [BUGGY]  For(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  [CE]  :  expected  [FE]                                    AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  For(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	For(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    String.valueOf(i));    }    	non-compiled	[CE]  :  expected	33	None	replace
25	[BUG]  [BUGGY]  int  i  =  0;  hdrMap.put(header[i],  Integer.valueOf(i));  [CE]  :  expected  [FE]                                      AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  int  i  =  0;  hdrMap.put(header[i],  Integer.valueOf(i));  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	int  i  =  0;  hdrMap.put(header[i],  Integer.valueOf(i));	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    String.valueOf(i));    }    	non-compiled	[CE]  :  expected	33	None	replace
26	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.toString(i));  }  [CE]  :  expected  [FE]                                        AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.toString(i));  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.toString(i));  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    String.valueOf(i));    }    	non-compiled	[CE]  :  expected	33	None	replace
27	[BUG]  [BUGGY]  hdrMap.put(header[i],  new  CSVFormat(this.format.getSkipHeaderRecord()));  [CE]  :  expected  [FE]                        AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header[i],  new  CSVFormat(this.format.getSkipHeaderRecord()));  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header[i],  new  CSVFormat(this.format.getSkipHeaderRecord()));	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    new    CSVFormat(this.format.getSkipHeaderRecord()));    }    	non-compiled	[CE]  :  expected	29	None	replace
28	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  this.header.length;  i++)  {  hdrMap.put(header[i],  new  CSVFormat(this.format.getSkipHeaderRecord()));  }  [CE]  :  expected  [FE]                          AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  this.header.length;  i++)  {  hdrMap.put(header[i],  new  CSVFormat(this.format.getSkipHeaderRecord()));  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  this.header.length;  i++)  {  hdrMap.put(header[i],  new  CSVFormat(this.format.getSkipHeaderRecord()));  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    new    CSVFormat(this.format.getSkipHeaderRecord()));    }    	non-compiled	[CE]  :  expected	29	None	replace
29	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  new  CSVFormat(this.format.getHeaderRecord()));  }  [CE]  :  expected  [FE]                            AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  new  CSVFormat(this.format.getHeaderRecord()));  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  new  CSVFormat(this.format.getHeaderRecord()));  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    new    CSVFormat(this.format.getSkipHeaderRecord()));    }    	non-compiled	[CE]  :  expected	29	None	replace
30	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  this.format.getHeaderRecord();  i++)  {  hdrMap.put(header[i],  new  CSVFormat(this.format.getSkipHeaderRecord()));  }  [CE]  :  expected  [FE]                              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  this.format.getHeaderRecord();  i++)  {  hdrMap.put(header[i],  new  CSVFormat(this.format.getSkipHeaderRecord()));  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  this.format.getHeaderRecord();  i++)  {  hdrMap.put(header[i],  new  CSVFormat(this.format.getSkipHeaderRecord()));  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    new    CSVFormat(this.format.getSkipHeaderRecord()));    }    	non-compiled	[CE]  :  expected	29	None	replace
31	[BUG]  [BUGGY]  hdrMap.put(header[0],  new  CSVFormat(this.format.getSkipHeaderRecord()));  [CE]  :  expected  [FE]                                AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header[0],  new  CSVFormat(this.format.getSkipHeaderRecord()));  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header[0],  new  CSVFormat(this.format.getSkipHeaderRecord()));	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    new    CSVFormat(this.format.getSkipHeaderRecord()));    }    	non-compiled	[CE]  :  expected	29	None	replace
32	[BUG]  [BUGGY]  int  i  =  0;  hdrMap.put(header[i],  new  CSVFormat(this.format.getSkipHeaderRecord()));  [CE]  :  expected  [FE]                                  AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  int  i  =  0;  hdrMap.put(header[i],  new  CSVFormat(this.format.getSkipHeaderRecord()));  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	int  i  =  0;  hdrMap.put(header[i],  new  CSVFormat(this.format.getSkipHeaderRecord()));	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    new    CSVFormat(this.format.getSkipHeaderRecord()));    }    	non-compiled	[CE]  :  expected	29	None	replace
33	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  this.header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  [CE]  :  expected  [FE]                    AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  this.header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  this.header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    Integer.valueOf(i),    this.format.getSkipHeaderRecord());    }    	non-compiled	[CE]  :  expected	41	None	replace
34	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  this.header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i),  this.format.getSkipHeaderRecord());  }  [CE]  :  expected  [FE]                      AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  this.header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i),  this.format.getSkipHeaderRecord());  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  this.header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i),  this.format.getSkipHeaderRecord());  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    Integer.valueOf(i),    this.format.getSkipHeaderRecord());    }    	non-compiled	[CE]  :  expected	41	None	replace
35	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  this.format.getHeaderCount();  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  [CE]  :  expected  [FE]                        AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  this.format.getHeaderCount();  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  this.format.getHeaderCount();  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    Integer.valueOf(i),    this.format.getSkipHeaderRecord());    }    	non-compiled	[CE]  :  expected	41	None	replace
36	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(0),  this.format.getSkipHeaderRecord());  }  [CE]  :  expected  [FE]                          AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(0),  this.format.getSkipHeaderRecord());  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(0),  this.format.getSkipHeaderRecord());  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    Integer.valueOf(i),    this.format.getSkipHeaderRecord());    }    	non-compiled	[CE]  :  expected	41	None	replace
37	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(0));  }  [CE]  :  expected  [FE]                    AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(0));  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(0));  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    Integer.valueOf(i));    }    	non-compiled	[CE]  :  expected	27	None	replace
38	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  header.length  -  1;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  [CE]  :  expected  [FE]                      AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  header.length  -  1;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  header.length  -  1;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    Integer.valueOf(i));    }    	non-compiled	[CE]  :  expected	27	None	replace
39	[BUG]  [BUGGY]  hdrMap.put(header[0],  this.format.getRecordNumber());  [CE]  :  expected  [FE]                          AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header[0],  this.format.getRecordNumber());  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header[0],  this.format.getRecordNumber());	  hdrMap.put(header[0],    this.format.getSkipHeaderRecord());    	non-compiled	[CE]  :  expected	30	None	replace
40	[BUG]  [BUGGY]  hdrMap.put(header[0],  this.format.getHeaderRecord());  [CE]  :  expected  [FE]                            AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header[0],  this.format.getHeaderRecord());  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header[0],  this.format.getHeaderRecord());	  hdrMap.put(header[0],    this.format.getSkipHeaderRecord());    	non-compiled	[CE]  :  expected	30	None	replace
41	[BUG]  [BUGGY]  hdrMap.put(header[0],  this.format.getRecord());  [CE]  :  expected  [FE]                              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header[0],  this.format.getRecord());  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header[0],  this.format.getRecord());	  hdrMap.put(header[0],    this.format.getSkipHeaderRecord());    	non-compiled	[CE]  :  expected	30	None	replace
42	[BUG]  [BUGGY]  hdrMap.put(rec,  this.format.getSkipHeaderRecord());  [CE]  :  expected  [FE]                                AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(rec,  this.format.getSkipHeaderRecord());  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(rec,  this.format.getSkipHeaderRecord());	  hdrMap.put(header[0],    this.format.getSkipHeaderRecord());    	non-compiled	[CE]  :  expected	30	None	replace
43	[BUG]  [BUGGY]  hdrMap.put(header[0],  this.format.getNumberRecord());  [CE]  :  expected  [FE]                                  AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header[0],  this.format.getNumberRecord());  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header[0],  this.format.getNumberRecord());	  hdrMap.put(header[0],    this.format.getSkipHeaderRecord());    	non-compiled	[CE]  :  expected	30	None	replace
44	[BUG]  [BUGGY]  if(rec  ==  null  &&  header!=  null  &&  header.length  >  0)  {  [CE]  :  expected  [FE]            AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(rec  ==  null  &&  header!=  null  &&  header.length  >  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(rec  ==  null  &&  header!=  null  &&  header.length  >  0)  {	  if(header    >=    null    &&    header.length    >    0)    {    	non-compiled	[CE]  :  expected	36	None	replace
45	[BUG]  [BUGGY]  if(header!=  null  &&  header.length  >  0  ||  this.format.getSkipHeaderRecord()  ==  null)  {  [CE]  :  expected  [FE]              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header!=  null  &&  header.length  >  0  ||  this.format.getSkipHeaderRecord()  ==  null)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header!=  null  &&  header.length  >  0  ||  this.format.getSkipHeaderRecord()  ==  null)  {	  if(header    >=    null    &&    header.length    >    0)    {    	non-compiled	[CE]  :  expected	36	None	replace
46	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i,  Integer.valueOf(0));  }  [CE]  :  expected  [FE]                      AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i,  Integer.valueOf(0));  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i,  Integer.valueOf(0));  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i,    Integer.valueOf(i));    }    	non-compiled	[CE]  :  expected	42	None	replace
47	[BUG]  [BUGGY]  if(header!=  null  &&  header.size()  ==  0)  {  [CE]  :  expected  [FE]              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header!=  null  &&  header.size()  ==  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header!=  null  &&  header.size()  ==  0)  {	  if(header!=    null    &&    header.size()    >    0)    {    	non-compiled	[CE]  :  expected	20	None	replace
48	[BUG]  [BUGGY]  if(header!=  null  &&  header.size()  <  =  0)  {  [CE]  :  expected  [FE]                AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header!=  null  &&  header.size()  <  =  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header!=  null  &&  header.size()  <  =  0)  {	  if(header!=    null    &&    header.size()    >    0)    {    	non-compiled	[CE]  :  expected	20	None	replace
49	[BUG]  [BUGGY]  if(header!=  null  &&  header.length  <  2)  {  [CE]  :  expected  [FE]            AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header!=  null  &&  header.length  <  2)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header!=  null  &&  header.length  <  2)  {	  if(header!=    null    ||    header.length    <    2)    {    	non-compiled	[CE]  :  expected	38	None	replace
50	[BUG]  [BUGGY]  if(header!=  null  ||  header.length  <  2  ||  this.format.getSkipHeaderRecord().equals(header))  {  [CE]  :  expected  [FE]              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header!=  null  ||  header.length  <  2  ||  this.format.getSkipHeaderRecord().equals(header))  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header!=  null  ||  header.length  <  2  ||  this.format.getSkipHeaderRecord().equals(header))  {	  if(header!=    null    ||    header.length    <    2)    {    	non-compiled	[CE]  :  expected	38	None	replace
51	[BUG]  [BUGGY]  if(header!=  null  ||  header.length  <  1)  {  [CE]  :  expected  [FE]                AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header!=  null  ||  header.length  <  1)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header!=  null  ||  header.length  <  1)  {	  if(header!=    null    ||    header.length    <    2)    {    	non-compiled	[CE]  :  expected	38	None	replace
52	[BUG]  [BUGGY]  if(header  ==  null  &&  receiver.size()  >  0)  {  [CE]  :  expected  [FE]              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  ==  null  &&  receiver.size()  >  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  ==  null  &&  receiver.size()  >  0)  {	  if(header!=    null    &&    receiver.size()    >    0)    {    	non-compiled	[CE]  :  expected	39	None	replace
53	[BUG]  [BUGGY]  if(rec.size()  >  0)  {  [CE]  :  expected  [FE]                AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(rec.size()  >  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(rec.size()  >  0)  {	  if(header!=    null    &&    receiver.size()    >    0)    {    	non-compiled	[CE]  :  expected	39	None	replace
54	[BUG]  [BUGGY]  if(header!=  null  ||  receiver.size()  >  0)  {  [CE]  :  expected  [FE]                  AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header!=  null  ||  receiver.size()  >  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header!=  null  ||  receiver.size()  >  0)  {	  if(header!=    null    &&    receiver.size()    >    0)    {    	non-compiled	[CE]  :  expected	39	None	replace
55	[BUG]  [BUGGY]  hdrMap.put(rec,  Integer.valueOf(i));  [CE]  :  expected  [FE]                      AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(rec,  Integer.valueOf(i));  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(rec,  Integer.valueOf(i));	  hdrMap.put(header[i],    Integer.valueOf(i));    	non-compiled	[CE]  :  expected	2	None	replace
56	[BUG]  [BUGGY]  hdrMap.put(header[i],  Integer.toString(i));  [CE]  :  expected  [FE]                        AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header[i],  Integer.toString(i));  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header[i],  Integer.toString(i));	  hdrMap.put(header[i],    Integer.valueOf(i));    	non-compiled	[CE]  :  expected	2	None	replace
57	[BUG]  [BUGGY]  hdrMap.put(rec,  Integer.valueOf(header[i]));  [CE]  :  expected  [FE]                          AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(rec,  Integer.valueOf(header[i]));  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(rec,  Integer.valueOf(header[i]));	  hdrMap.put(header[i],    Integer.valueOf(i));    	non-compiled	[CE]  :  expected	2	None	replace
58	[BUG]  [BUGGY]  hdrMap.put(header[i],  Integer.valueOf(0));  [CE]  :  expected  [FE]                            AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header[i],  Integer.valueOf(0));  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header[i],  Integer.valueOf(0));	  hdrMap.put(header[i],    Integer.valueOf(i));    	non-compiled	[CE]  :  expected	2	None	replace
59	[BUG]  [BUGGY]  hdrMap.put(header[i],  Integer.toHexString(i));  [CE]  :  expected  [FE]                              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header[i],  Integer.toHexString(i));  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header[i],  Integer.toHexString(i));	  hdrMap.put(header[i],    Integer.valueOf(i));    	non-compiled	[CE]  :  expected	2	None	replace
60	[BUG]  [BUGGY]  hdrMap.put(rec,  header[i],  Integer.valueOf(i));  [CE]  :  expected  [FE]                                AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(rec,  header[i],  Integer.valueOf(i));  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(rec,  header[i],  Integer.valueOf(i));	  hdrMap.put(header[i],    Integer.valueOf(i));    	non-compiled	[CE]  :  expected	2	None	replace
61	[BUG]  [BUGGY]  if(header  ==  null  ||  header.length  ==  1  ||  this.format.getSkipHeaderRecord().equals(header))  {  [CE]  :  expected  [FE]                    AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  ==  null  ||  header.length  ==  1  ||  this.format.getSkipHeaderRecord().equals(header))  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  ==  null  ||  header.length  ==  1  ||  this.format.getSkipHeaderRecord().equals(header))  {	  if(header    ==    null    ||    header.length    ==    1)    {    	non-compiled	[CE]  :  expected	17	None	replace
62	[BUG]  [BUGGY]  if(header  ==  null  ||  header.length!=  1)  {  [CE]  :  expected  [FE]                      AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  ==  null  ||  header.length!=  1)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  ==  null  ||  header.length!=  1)  {	  if(header    ==    null    ||    header.length    ==    1)    {    	non-compiled	[CE]  :  expected	17	None	replace
63	[BUG]  [BUGGY]  hdrMap.put(header[0],  Integer.toString(i));  [CE]  :  expected  [FE]                              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header[0],  Integer.toString(i));  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header[0],  Integer.toString(i));	  hdrMap.put(header[0],    Integer.valueOf(i));    	non-compiled	[CE]  :  expected	6	None	replace
64	[BUG]  [BUGGY]  hdrMap.put(header[0],  Integer.toHexString(i));  [CE]  :  expected  [FE]                                AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header[0],  Integer.toHexString(i));  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header[0],  Integer.toHexString(i));	  hdrMap.put(header[0],    Integer.valueOf(i));    	non-compiled	[CE]  :  expected	6	None	replace
65	[BUG]  [BUGGY]  String  header[]  =  this.format.getHeaderRecord();  [CE]  :  expected  [FE]                            AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  String  header[]  =  this.format.getHeaderRecord();  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	String  header[]  =  this.format.getHeaderRecord();	  String    header[]    =    this.format.getSkipHeaderRecord();    	non-compiled	[CE]  :  expected	31	None	replace
66	[BUG]  [BUGGY]  String  header[]  =  this.format.getRecordHeader();  [CE]  :  expected  [FE]                              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  String  header[]  =  this.format.getRecordHeader();  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	String  header[]  =  this.format.getRecordHeader();	  String    header[]    =    this.format.getSkipHeaderRecord();    	non-compiled	[CE]  :  expected	31	None	replace
67	[BUG]  [BUGGY]  String  header[]  =  rec.getSkipHeaderRecord();  [CE]  :  expected  [FE]                                AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  String  header[]  =  rec.getSkipHeaderRecord();  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	String  header[]  =  rec.getSkipHeaderRecord();	  String    header[]    =    this.format.getSkipHeaderRecord();    	non-compiled	[CE]  :  expected	31	None	replace
68	[BUG]  [BUGGY]  String  header[]  =  rec.getSkipHeader();  [CE]  :  expected  [FE]                                  AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  String  header[]  =  rec.getSkipHeader();  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	String  header[]  =  rec.getSkipHeader();	  String    header[]    =    this.format.getSkipHeaderRecord();    	non-compiled	[CE]  :  expected	31	None	replace
69	[BUG]  [BUGGY]  String  header[]  =  this.format.getRecordedHeader();  [CE]  :  expected  [FE]                                    AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  String  header[]  =  this.format.getRecordedHeader();  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	String  header[]  =  this.format.getRecordedHeader();	  String    header[]    =    this.format.getSkipHeaderRecord();    	non-compiled	[CE]  :  expected	31	None	replace
70	[BUG]  [BUGGY]  String[]  header  =  this.format.getRecordHeaders();  [CE]  :  expected  [FE]                                      AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  String[]  header  =  this.format.getRecordHeaders();  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	String[]  header  =  this.format.getRecordHeaders();	  String    header[]    =    this.format.getSkipHeaderRecord();    	non-compiled	[CE]  :  expected	31	None	replace
71	[BUG]  [BUGGY]  hdrMap.put(rec.toString(),  this.format.getSkipHeaderRecord());  [CE]  :  expected  [FE]                        AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(rec.toString(),  this.format.getSkipHeaderRecord());  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(rec.toString(),  this.format.getSkipHeaderRecord());	  hdrMap.put(rect.toString(),    this.format.getSkipHeaderRecord());    	non-compiled	[CE]  :  expected	3	None	replace
72	[BUG]  [BUGGY]  hdrMap.put(this.format.getSkipHeaderRecord(),  this.format.getSkipHeaderRecord());  [CE]  :  expected  [FE]                          AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(this.format.getSkipHeaderRecord(),  this.format.getSkipHeaderRecord());  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(this.format.getSkipHeaderRecord(),  this.format.getSkipHeaderRecord());	  hdrMap.put(rect.toString(),    this.format.getSkipHeaderRecord());    	non-compiled	[CE]  :  expected	3	None	replace
73	[BUG]  [BUGGY]  hdrMap.put(rect.toString(),  this.format.getHeaderRecord());  [CE]  :  expected  [FE]                            AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(rect.toString(),  this.format.getHeaderRecord());  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(rect.toString(),  this.format.getHeaderRecord());	  hdrMap.put(rect.toString(),    this.format.getSkipHeaderRecord());    	non-compiled	[CE]  :  expected	3	None	replace
74	[BUG]  [BUGGY]  hdrMap.put(rect.toString(),  this.format.getRecordNumber());  [CE]  :  expected  [FE]                              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(rect.toString(),  this.format.getRecordNumber());  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(rect.toString(),  this.format.getRecordNumber());	  hdrMap.put(rect.toString(),    this.format.getSkipHeaderRecord());    	non-compiled	[CE]  :  expected	3	None	replace
75	[BUG]  [BUGGY]  hdrMap.put(this.format.getSkipHeaderRecord(),rect.toString());  [CE]  :  expected  [FE]                                AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(this.format.getSkipHeaderRecord(),rect.toString());  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(this.format.getSkipHeaderRecord(),rect.toString());	  hdrMap.put(rect.toString(),    this.format.getSkipHeaderRecord());    	non-compiled	[CE]  :  expected	3	None	replace
76	[BUG]  [BUGGY]  hdrMap.put(rec,  Integer.valueOf(0));  [CE]  :  expected  [FE]                    AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(rec,  Integer.valueOf(0));  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(rec,  Integer.valueOf(0));	  hdrMap.put(header[0],    Integer.valueOf(0));    	non-compiled	[CE]  :  expected	1	None	replace
77	[BUG]  [BUGGY]  hdrMap.put(header[0],  Integer.MAX_VALUE);  [CE]  :  expected  [FE]                      AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header[0],  Integer.MAX_VALUE);  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header[0],  Integer.MAX_VALUE);	  hdrMap.put(header[0],    Integer.valueOf(0));    	non-compiled	[CE]  :  expected	1	None	replace
78	[BUG]  [BUGGY]  hdrMap.put(header[0],  Integer.toString(1L));  [CE]  :  expected  [FE]                        AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header[0],  Integer.toString(1L));  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header[0],  Integer.toString(1L));	  hdrMap.put(header[0],    Integer.valueOf(0));    	non-compiled	[CE]  :  expected	1	None	replace
79	[BUG]  [BUGGY]  hdrMap.put(header[0],  Integer.valueOf(0),  header.length);  [CE]  :  expected  [FE]                          AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header[0],  Integer.valueOf(0),  header.length);  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header[0],  Integer.valueOf(0),  header.length);	  hdrMap.put(header[0],    Integer.valueOf(0));    	non-compiled	[CE]  :  expected	1	None	replace
80	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.MAX_VALUE);  }  [CE]  :  expected  [FE]                              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.MAX_VALUE);  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.MAX_VALUE);  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    int.valueOf(i));    }    	non-compiled	[CE]  :  expected	32	None	replace
81	[BUG]  [BUGGY]  ger  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  int.valueOf(i));  }  [CE]  :  expected  [FE]                                AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  ger  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  int.valueOf(i));  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	ger  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  int.valueOf(i));  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    int.valueOf(i));    }    	non-compiled	[CE]  :  expected	32	None	replace
82	[BUG]  [BUGGY]  Lexer  hdrMap  =  this.format.getHeaderRecord();  [CE]  :  expected  [FE]                          AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  Lexer  hdrMap  =  this.format.getHeaderRecord();  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	Lexer  hdrMap  =  this.format.getHeaderRecord();	  Lexer    hdrMap    =    this.format.getSkipHeaderRecord();    	non-compiled	[CE]  :  expected	4	None	replace
83	[BUG]  [BUGGY]  Lexer  hdrMap  =  rec.getSkipHeaderRecord();  [CE]  :  expected  [FE]                            AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  Lexer  hdrMap  =  rec.getSkipHeaderRecord();  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	Lexer  hdrMap  =  rec.getSkipHeaderRecord();	  Lexer    hdrMap    =    this.format.getSkipHeaderRecord();    	non-compiled	[CE]  :  expected	4	None	replace
84	[BUG]  [BUGGY]  Lexer  hdrMap  =  this.format.getHeader();  [CE]  :  expected  [FE]                              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  Lexer  hdrMap  =  this.format.getHeader();  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	Lexer  hdrMap  =  this.format.getHeader();	  Lexer    hdrMap    =    this.format.getSkipHeaderRecord();    	non-compiled	[CE]  :  expected	4	None	replace
85	[BUG]  [BUGGY]  Lexer  hdrMap  =  this.format.getRecordHeader();  [CE]  :  expected  [FE]                                AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  Lexer  hdrMap  =  this.format.getRecordHeader();  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	Lexer  hdrMap  =  this.format.getRecordHeader();	  Lexer    hdrMap    =    this.format.getSkipHeaderRecord();    	non-compiled	[CE]  :  expected	4	None	replace
86	[BUG]  [BUGGY]  Lexer  hdrMap  =  rec.getSkipHeader();  [CE]  :  expected  [FE]                                  AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  Lexer  hdrMap  =  rec.getSkipHeader();  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	Lexer  hdrMap  =  rec.getSkipHeader();	  Lexer    hdrMap    =    this.format.getSkipHeaderRecord();    	non-compiled	[CE]  :  expected	4	None	replace
87	[BUG]  [BUGGY]  Lexer  hdrMap  =  this.format.getCSVHeaderRecord();  [CE]  :  expected  [FE]                                    AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  Lexer  hdrMap  =  this.format.getCSVHeaderRecord();  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	Lexer  hdrMap  =  this.format.getCSVHeaderRecord();	  Lexer    hdrMap    =    this.format.getSkipHeaderRecord();    	non-compiled	[CE]  :  expected	4	None	replace
88	[BUG]  [BUGGY]  if(rec  ==  null  ||  header!=  null  ||  header.length  ==  0)  {  [CE]  :  expected  [FE]                AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(rec  ==  null  ||  header!=  null  ||  header.length  ==  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(rec  ==  null  ||  header!=  null  ||  header.length  ==  0)  {	  if(rec    ==    null    &&    header!=    null    &&    header.length    ==    0)    {    	non-compiled	[CE]  :  expected	18	None	replace
89	[BUG]  [BUGGY]  if(header!=  null  &&  header!=  null  &&  header.length  ==  0)  {  [CE]  :  expected  [FE]                  AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header!=  null  &&  header!=  null  &&  header.length  ==  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header!=  null  &&  header!=  null  &&  header.length  ==  0)  {	  if(rec    ==    null    &&    header!=    null    &&    header.length    ==    0)    {    	non-compiled	[CE]  :  expected	18	None	replace
90	[BUG]  [BUGGY]  if(header  ==  null  ||  header!=  null  ||  header.length  ==  0)  {  [CE]  :  expected  [FE]                    AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  ==  null  ||  header!=  null  ||  header.length  ==  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  ==  null  ||  header!=  null  ||  header.length  ==  0)  {	  if(rec    ==    null    &&    header!=    null    &&    header.length    ==    0)    {    	non-compiled	[CE]  :  expected	18	None	replace
91	[BUG]  [BUGGY]  if(header  ==  null  &&  header!=  null  &&  header.length  >  0)  {  [CE]  :  expected  [FE]                      AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  ==  null  &&  header!=  null  &&  header.length  >  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  ==  null  &&  header!=  null  &&  header.length  >  0)  {	  if(rec    ==    null    &&    header!=    null    &&    header.length    ==    0)    {    	non-compiled	[CE]  :  expected	18	None	replace
92	[BUG]  [BUGGY]  if(header!=  null  &&  header!=  null  &&  header.length  >  0)  {  [CE]  :  expected  [FE]                        AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header!=  null  &&  header!=  null  &&  header.length  >  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header!=  null  &&  header!=  null  &&  header.length  >  0)  {	  if(rec    ==    null    &&    header!=    null    &&    header.length    ==    0)    {    	non-compiled	[CE]  :  expected	18	None	replace
93	[BUG]  [BUGGY]  if(header  ==  null  &&  header!=  null  &&  header.length  ==  0)  {  [CE]  :  expected  [FE]                          AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  ==  null  &&  header!=  null  &&  header.length  ==  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  ==  null  &&  header!=  null  &&  header.length  ==  0)  {	  if(rec    ==    null    &&    header!=    null    &&    header.length    ==    0)    {    	non-compiled	[CE]  :  expected	18	None	replace
94	[BUG]  [BUGGY]  if(header!=  null  ||  header.size()  ==  0)  {  [CE]  :  expected  [FE]                  AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header!=  null  ||  header.size()  ==  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header!=  null  ||  header.size()  ==  0)  {	  if(header!=    null    ||    header.size()    >    0)    {    	non-compiled	[CE]  :  expected	22	None	replace
95	[BUG]  [BUGGY]  if(header!=  null  ||  header.size()  >=  0)  {  [CE]  :  expected  [FE]                    AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header!=  null  ||  header.size()  >=  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header!=  null  ||  header.size()  >=  0)  {	  if(header!=    null    ||    header.size()    >    0)    {    	non-compiled	[CE]  :  expected	22	None	replace
96	[BUG]  [BUGGY]  if(header  ==  null  ||  header.size()!=  0)  {  [CE]  :  expected  [FE]                      AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  ==  null  ||  header.size()!=  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  ==  null  ||  header.size()!=  0)  {	  if(header!=    null    ||    header.size()    >    0)    {    	non-compiled	[CE]  :  expected	22	None	replace
97	[BUG]  [BUGGY]  if(header!=  null  ||  header.size()  <  0)  {  [CE]  :  expected  [FE]                        AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header!=  null  ||  header.size()  <  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header!=  null  ||  header.size()  <  0)  {	  if(header!=    null    ||    header.size()    >    0)    {    	non-compiled	[CE]  :  expected	22	None	replace
98	[BUG]  [BUGGY]  if(header!=  null  ||  nextRecord.size()  ==  0)  {  [CE]  :  expected  [FE]                AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header!=  null  ||  nextRecord.size()  ==  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header!=  null  ||  nextRecord.size()  ==  0)  {	  if(header!=    null    ||    nextRecord.size()    >    0)    {    	non-compiled	[CE]  :  expected	21	None	replace
99	[BUG]  [BUGGY]  if(header!=  null  ||  nextRecord.size()  <  =  0)  {  [CE]  :  expected  [FE]                  AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header!=  null  ||  nextRecord.size()  <  =  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header!=  null  ||  nextRecord.size()  <  =  0)  {	  if(header!=    null    ||    nextRecord.size()    >    0)    {    	non-compiled	[CE]  :  expected	21	None	replace
100	[BUG]  [BUGGY]  if(header  ==  null  ||  header.length  <  2  ||  this.format.getSkipHeaderRecord()!=  null)  {  [CE]  :  expected  [FE]                  AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  ==  null  ||  header.length  <  2  ||  this.format.getSkipHeaderRecord()!=  null)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  ==  null  ||  header.length  <  2  ||  this.format.getSkipHeaderRecord()!=  null)  {	  if(header    ==    null    ||    header.length    <    2)    {    	non-compiled	[CE]  :  expected	40	None	replace
101	[BUG]  [BUGGY]  if(header  ==  null  ||  header.length  <  2  ||  this.format.hasSkipHeaderRecord())  {  [CE]  :  expected  [FE]                    AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  ==  null  ||  header.length  <  2  ||  this.format.hasSkipHeaderRecord())  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  ==  null  ||  header.length  <  2  ||  this.format.hasSkipHeaderRecord())  {	  if(header    ==    null    ||    header.length    <    2)    {    	non-compiled	[CE]  :  expected	40	None	replace
102	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  this.format.getHeaderRecord());  }  [CE]  :  expected  [FE]                      AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  this.format.getHeaderRecord());  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  this.format.getHeaderRecord());  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    this.format.getSkipHeaderRecord());    }    	non-compiled	[CE]  :  expected	28	None	replace
103	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  header.length;  i  +=  2)  {  hdrMap.put(header[i],  this.format.getSkipHeaderRecord());  }  [CE]  :  expected  [FE]                        AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  header.length;  i  +=  2)  {  hdrMap.put(header[i],  this.format.getSkipHeaderRecord());  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  header.length;  i  +=  2)  {  hdrMap.put(header[i],  this.format.getSkipHeaderRecord());  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    this.format.getSkipHeaderRecord());    }    	non-compiled	[CE]  :  expected	28	None	replace
104	[BUG]  [BUGGY]  int  i  =  0;  hdrMap.put(header[i],  this.format.getSkipHeaderRecord());  [CE]  :  expected  [FE]                          AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  int  i  =  0;  hdrMap.put(header[i],  this.format.getSkipHeaderRecord());  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	int  i  =  0;  hdrMap.put(header[i],  this.format.getSkipHeaderRecord());	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    this.format.getSkipHeaderRecord());    }    	non-compiled	[CE]  :  expected	28	None	replace
105	[BUG]  [BUGGY]  hdrMap.put(this.format.toString(),  this.format.getSkipHeaderRecord());  [CE]  :  expected  [FE]                        AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(this.format.toString(),  this.format.getSkipHeaderRecord());  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(this.format.toString(),  this.format.getSkipHeaderRecord());	  hdrMap.put(rect.toString(),    this.format.getSkipHeaderRecord());    	non-compiled	[CE]  :  expected	3	None	replace
106	[BUG]  [BUGGY]  hdrMap.put(this.format.getSkipHeaderRecord(),rect);  [CE]  :  expected  [FE]                          AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(this.format.getSkipHeaderRecord(),rect);  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(this.format.getSkipHeaderRecord(),rect);	  hdrMap.put(rect.toString(),    this.format.getSkipHeaderRecord());    	non-compiled	[CE]  :  expected	3	None	replace
107	[BUG]  [BUGGY]  hdrMap.put(this.format.getSkipHeaderRecord(),  header);  [CE]  :  expected  [FE]                            AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(this.format.getSkipHeaderRecord(),  header);  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(this.format.getSkipHeaderRecord(),  header);	  hdrMap.put(rect.toString(),    this.format.getSkipHeaderRecord());    	non-compiled	[CE]  :  expected	3	None	replace
108	[BUG]  [BUGGY]  hdrMap.put(rect.toString(),  this.format.getRecordName());  [CE]  :  expected  [FE]                              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(rect.toString(),  this.format.getRecordName());  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(rect.toString(),  this.format.getRecordName());	  hdrMap.put(rect.toString(),    this.format.getSkipHeaderRecord());    	non-compiled	[CE]  :  expected	3	None	replace
109	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  header.length;  i  +=  2)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  [CE]  :  expected  [FE]                              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  header.length;  i  +=  2)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  header.length;  i  +=  2)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    int.valueOf(i));    }    	non-compiled	[CE]  :  expected	32	None	replace
110	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  headers.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  [CE]  :  expected  [FE]                                AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  headers.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  headers.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    int.valueOf(i));    }    	non-compiled	[CE]  :  expected	32	None	replace
111	[BUG]  [BUGGY]  if(header!=  null  &&  header.length()  >  0)  {  [CE]  :  expected  [FE]                        AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header!=  null  &&  header.length()  >  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header!=  null  &&  header.length()  >  0)  {	  if(header    ==    null    &&    header.size()    >    0)    {    	non-compiled	[CE]  :  expected	25	None	replace
112	[BUG]  [BUGGY]  hdrMap.put(header[0],  this.format.getRecordName());  [CE]  :  expected  [FE]                          AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header[0],  this.format.getRecordName());  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header[0],  this.format.getRecordName());	  hdrMap.put(header[0],    this.format.getSkipHeaderRecord());    	non-compiled	[CE]  :  expected	30	None	replace
113	[BUG]  [BUGGY]  Lexer  hdrMap  =  this.format.getRecordHeaders();  [CE]  :  expected  [FE]                          AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  Lexer  hdrMap  =  this.format.getRecordHeaders();  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	Lexer  hdrMap  =  this.format.getRecordHeaders();	  Lexer    hdrMap    =    this.format.getSkipHeaderRecord();    	non-compiled	[CE]  :  expected	4	None	replace
114	[BUG]  [BUGGY]  Lexer  hdrMap  =  this.format.getRecords();  [CE]  :  expected  [FE]                            AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  Lexer  hdrMap  =  this.format.getRecords();  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	Lexer  hdrMap  =  this.format.getRecords();	  Lexer    hdrMap    =    this.format.getSkipHeaderRecord();    	non-compiled	[CE]  :  expected	4	None	replace
115	[BUG]  [BUGGY]  hdrMap.put(record[i],  Integer.valueOf(i));  [CE]  :  expected  [FE]                      AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(record[i],  Integer.valueOf(i));  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(record[i],  Integer.valueOf(i));	  hdrMap.put(header[i],    Integer.valueOf(i));    	non-compiled	[CE]  :  expected	2	None	replace
116	[BUG]  [BUGGY]  hdrMap.put(recordNumber[i],  Integer.valueOf(i));  [CE]  :  expected  [FE]                        AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(recordNumber[i],  Integer.valueOf(i));  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(recordNumber[i],  Integer.valueOf(i));	  hdrMap.put(header[i],    Integer.valueOf(i));    	non-compiled	[CE]  :  expected	2	None	replace
117	[BUG]  [BUGGY]  hdrMap.put(record,  Integer.valueOf(i));  [CE]  :  expected  [FE]                          AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(record,  Integer.valueOf(i));  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(record,  Integer.valueOf(i));	  hdrMap.put(header[i],    Integer.valueOf(i));    	non-compiled	[CE]  :  expected	2	None	replace
118	[BUG]  [BUGGY]  if(header  ==  null  ||  header.size()  >=  0)  {  [CE]  :  expected  [FE]                  AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  ==  null  ||  header.size()  >=  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  ==  null  ||  header.size()  >=  0)  {	  if(header!=    null    ||    header.size()    >    0)    {    	non-compiled	[CE]  :  expected	22	None	replace
119	[BUG]  [BUGGY]  if(header  ==  null  ||  header.size()  ==  0)  {  [CE]  :  expected  [FE]                    AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  ==  null  ||  header.size()  ==  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  ==  null  ||  header.size()  ==  0)  {	  if(header!=    null    ||    header.size()    >    0)    {    	non-compiled	[CE]  :  expected	22	None	replace
120	[BUG]  [BUGGY]  if(header  ==  null  &&  header.length  <  =  0)  {  [CE]  :  expected  [FE]                  AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  ==  null  &&  header.length  <  =  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  ==  null  &&  header.length  <  =  0)  {	  if(header!=    null    &&    header.length    <    =    0)    {    	non-compiled	[CE]  :  expected	14	None	replace
121	[BUG]  [BUGGY]  if(header  ==  null  &&  header.length  <  0)  {  [CE]  :  expected  [FE]                    AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  ==  null  &&  header.length  <  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  ==  null  &&  header.length  <  0)  {	  if(header!=    null    &&    header.length    <    =    0)    {    	non-compiled	[CE]  :  expected	14	None	replace
122	[BUG]  [BUGGY]  if(header!=  null  &&  header!=  null  &&  header.length  >=  0)  {  [CE]  :  expected  [FE]                AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header!=  null  &&  header!=  null  &&  header.length  >=  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header!=  null  &&  header!=  null  &&  header.length  >=  0)  {	  if(rec    ==    null    &&    header!=    null    &&    header.length    ==    0)    {    	non-compiled	[CE]  :  expected	18	None	replace
123	[BUG]  [BUGGY]  hdrMap.put(header[0],  Integer.valueOf(i  +  1));  [CE]  :  expected  [FE]                              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header[0],  Integer.valueOf(i  +  1));  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header[0],  Integer.valueOf(i  +  1));	  hdrMap.put(header[0],    Integer.valueOf(i));    	non-compiled	[CE]  :  expected	6	None	replace
124	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  this.format.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  [CE]  :  expected  [FE]                    AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  this.format.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  this.format.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    Integer.valueOf(i),    this.format.getSkipHeaderRecord());    }    	non-compiled	[CE]  :  expected	41	None	replace
125	[BUG]  [BUGGY]  hdrMap.put(header[i],  rec);  [CE]  :  expected  [FE]                            AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header[i],  rec);  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header[i],  rec);	  hdrMap.put(rec,    header);    	non-compiled	[CE]  :  expected	5	None	replace
126	[BUG]  [BUGGY]  hdrMap.put(header[0],  rec);  [CE]  :  expected  [FE]                              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header[0],  rec);  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header[0],  rec);	  hdrMap.put(rec,    header);    	non-compiled	[CE]  :  expected	5	None	replace
127	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  header.length;  i  +=  2)  {  hdrMap.put(header[i],  String.valueOf(i));  }  [CE]  :  expected  [FE]                                AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  header.length;  i  +=  2)  {  hdrMap.put(header[i],  String.valueOf(i));  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  header.length;  i  +=  2)  {  hdrMap.put(header[i],  String.valueOf(i));  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    String.valueOf(i));    }    	non-compiled	[CE]  :  expected	33	None	replace
128	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i),  header);  }  [CE]  :  expected  [FE]                                  AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i),  header);  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i),  header);  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    String.valueOf(i));    }    	non-compiled	[CE]  :  expected	33	None	replace
129	[BUG]  [BUGGY]  String  header[]  =  this.format.getRecordHeaders();  [CE]  :  expected  [FE]                            AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  String  header[]  =  this.format.getRecordHeaders();  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	String  header[]  =  this.format.getRecordHeaders();	  String    header[]    =    this.format.getSkipHeaderRecord();    	non-compiled	[CE]  :  expected	31	None	replace
130	[BUG]  [BUGGY]  String  header[]  =  this.format.getHeader();  [CE]  :  expected  [FE]                              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  String  header[]  =  this.format.getHeader();  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	String  header[]  =  this.format.getHeader();	  String    header[]    =    this.format.getSkipHeaderRecord();    	non-compiled	[CE]  :  expected	31	None	replace
131	[BUG]  [BUGGY]  String  header[]  =  this.format.getRecordHeader(header);  [CE]  :  expected  [FE]                                AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  String  header[]  =  this.format.getRecordHeader(header);  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	String  header[]  =  this.format.getRecordHeader(header);	  String    header[]    =    this.format.getSkipHeaderRecord();    	non-compiled	[CE]  :  expected	31	None	replace
132	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  header.length;  i  +=  2)  {  hdrMap.put(header[i],  new  CSVFormat(this.format.getSkipHeaderRecord()));  }  [CE]  :  expected  [FE]                        AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  header.length;  i  +=  2)  {  hdrMap.put(header[i],  new  CSVFormat(this.format.getSkipHeaderRecord()));  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  header.length;  i  +=  2)  {  hdrMap.put(header[i],  new  CSVFormat(this.format.getSkipHeaderRecord()));  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    new    CSVFormat(this.format.getSkipHeaderRecord()));    }    	non-compiled	[CE]  :  expected	29	None	replace
133	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  new  CSVFormat(this.format.getRecord()));  }  [CE]  :  expected  [FE]                          AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  new  CSVFormat(this.format.getRecord()));  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  new  CSVFormat(this.format.getRecord()));  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    new    CSVFormat(this.format.getSkipHeaderRecord()));    }    	non-compiled	[CE]  :  expected	29	None	replace
134	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.MIN_VALUE);  }  [CE]  :  expected  [FE]                    AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.MIN_VALUE);  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.MIN_VALUE);  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    Integer.valueOf(i));    }    	non-compiled	[CE]  :  expected	27	None	replace
135	[BUG]  [BUGGY]  if(header  ==  null  ||  header.length()  >  0)  {  [CE]  :  expected  [FE]                      AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  ==  null  ||  header.length()  >  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  ==  null  ||  header.length()  >  0)  {	  if(header    ==    null    ||    nextRecord.size()    >    0)    {    	non-compiled	[CE]  :  expected	24	None	replace
136	[BUG]  [BUGGY]  hdrMap.put(header[0],  Integer.valueOf(1));  [CE]  :  expected  [FE]                    AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header[0],  Integer.valueOf(1));  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header[0],  Integer.valueOf(1));	  hdrMap.put(header[0],    Integer.valueOf(0));    	non-compiled	[CE]  :  expected	1	None	replace
137	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i  +  1));  }  [CE]  :  expected  [FE]                                AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i  +  1));  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i  +  1));  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    String.valueOf(i));    }    	non-compiled	[CE]  :  expected	33	None	replace
138	[BUG]  [BUGGY]  if(header  ==  null  &&  header.length  >=  0)  {  [CE]  :  expected  [FE]              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  ==  null  &&  header.length  >=  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  ==  null  &&  header.length  >=  0)  {	  if(header!=    null    &&    header.length    >=    0)    {    	non-compiled	[CE]  :  expected	34	None	replace
139	[BUG]  [BUGGY]  if(header  ==  null  ||  header.length  <  1  ||  header.length  >  0)  {  [CE]  :  expected  [FE]                  AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  ==  null  ||  header.length  <  1  ||  header.length  >  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  ==  null  ||  header.length  <  1  ||  header.length  >  0)  {	  if(header    ==    null    ||    header.length    <    2)    {    	non-compiled	[CE]  :  expected	40	None	replace
140	[BUG]  [BUGGY]  if(header  ==  null  ||  header.length  <  2  ||  header.length  >  4)  {  [CE]  :  expected  [FE]                    AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  ==  null  ||  header.length  <  2  ||  header.length  >  4)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  ==  null  ||  header.length  <  2  ||  header.length  >  4)  {	  if(header    ==    null    ||    header.length    <    2)    {    	non-compiled	[CE]  :  expected	40	None	replace
141	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  header.length;  i  +=  2)  {  hdrMap.put(header[i],  int.valueOf(i));  }  [CE]  :  expected  [FE]                              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  header.length;  i  +=  2)  {  hdrMap.put(header[i],  int.valueOf(i));  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  header.length;  i  +=  2)  {  hdrMap.put(header[i],  int.valueOf(i));  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    int.valueOf(i));    }    	non-compiled	[CE]  :  expected	32	None	replace
142	[BUG]  [BUGGY]  if(header!=  null  ||  header.length  ==  1)  {  [CE]  :  expected  [FE]                    AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header!=  null  ||  header.length  ==  1)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header!=  null  ||  header.length  ==  1)  {	  if(header    ==    null    ||    header.length    ==    1)    {    	non-compiled	[CE]  :  expected	17	None	replace
143	[BUG]  [BUGGY]  if(header!=  null  &&  header.length  ==  1)  {  [CE]  :  expected  [FE]                      AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header!=  null  &&  header.length  ==  1)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header!=  null  &&  header.length  ==  1)  {	  if(header    ==    null    ||    header.length    ==    1)    {    	non-compiled	[CE]  :  expected	17	None	replace
144	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  header.length;  i  +=  2)  {  hdrMap.put(header[i,  Integer.valueOf(i));  }  [CE]  :  expected  [FE]                      AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  header.length;  i  +=  2)  {  hdrMap.put(header[i,  Integer.valueOf(i));  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  header.length;  i  +=  2)  {  hdrMap.put(header[i,  Integer.valueOf(i));  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i,    Integer.valueOf(i));    }    	non-compiled	[CE]  :  expected	42	None	replace
145	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i,  Integer.MAX_VALUE);  }  [CE]  :  expected  [FE]                        AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i,  Integer.MAX_VALUE);  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i,  Integer.MAX_VALUE);  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i,    Integer.valueOf(i));    }    	non-compiled	[CE]  :  expected	42	None	replace
146	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i,  Integer.valueOf(i),  header[i]);  }  [CE]  :  expected  [FE]                          AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i,  Integer.valueOf(i),  header[i]);  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i,  Integer.valueOf(i),  header[i]);  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i,    Integer.valueOf(i));    }    	non-compiled	[CE]  :  expected	42	None	replace
147	[BUG]  [BUGGY]  For(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  new  CSVFormat(this.format.getSkipHeaderRecord()));  }  [CE]  :  expected  [FE]                        AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  For(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  new  CSVFormat(this.format.getSkipHeaderRecord()));  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	For(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  new  CSVFormat(this.format.getSkipHeaderRecord()));  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    new    CSVFormat(this.format.getSkipHeaderRecord()));    }    	non-compiled	[CE]  :  expected	29	None	replace
148	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  new  CSVFormat(this.format.getCSVHeaderRecord()));  }  [CE]  :  expected  [FE]                          AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  new  CSVFormat(this.format.getCSVHeaderRecord()));  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  new  CSVFormat(this.format.getCSVHeaderRecord()));  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    new    CSVFormat(this.format.getSkipHeaderRecord()));    }    	non-compiled	[CE]  :  expected	29	None	replace
149	[BUG]  [BUGGY]  Lexer  hdrMap  =  this.format.getHeaderMap();  [CE]  :  expected  [FE]                          AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  Lexer  hdrMap  =  this.format.getHeaderMap();  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	Lexer  hdrMap  =  this.format.getHeaderMap();	  Lexer    hdrMap    =    this.format.getSkipHeaderRecord();    	non-compiled	[CE]  :  expected	4	None	replace
150	[BUG]  [BUGGY]  Lexer  hdrMap  =  this.format.getHeaders();  [CE]  :  expected  [FE]                            AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  Lexer  hdrMap  =  this.format.getHeaders();  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	Lexer  hdrMap  =  this.format.getHeaders();	  Lexer    hdrMap    =    this.format.getSkipHeaderRecord();    	non-compiled	[CE]  :  expected	4	None	replace
151	[BUG]  [BUGGY]  Lexer  hdrMap  =  this.format.getHandlerRecord();  [CE]  :  expected  [FE]                              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  Lexer  hdrMap  =  this.format.getHandlerRecord();  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	Lexer  hdrMap  =  this.format.getHandlerRecord();	  Lexer    hdrMap    =    this.format.getSkipHeaderRecord();    	non-compiled	[CE]  :  expected	4	None	replace
152	[BUG]  [BUGGY]  Lexer  hdrMap  =  this.format.getHeader(rec);  [CE]  :  expected  [FE]                                AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  Lexer  hdrMap  =  this.format.getHeader(rec);  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	Lexer  hdrMap  =  this.format.getHeader(rec);	  Lexer    hdrMap    =    this.format.getSkipHeaderRecord();    	non-compiled	[CE]  :  expected	4	None	replace
153	[BUG]  [BUGGY]  if(header  >=  null  &&  header.length!=  0)  {  [CE]  :  expected  [FE]                AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  >=  null  &&  header.length!=  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  >=  null  &&  header.length!=  0)  {	  if(header    ==    null    &&    header.length!=    0)    {    	non-compiled	[CE]  :  expected	35	None	replace
154	[BUG]  [BUGGY]  if(header!=  null  &&  header.size()  >=  0)  {  [CE]  :  expected  [FE]              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header!=  null  &&  header.size()  >=  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header!=  null  &&  header.size()  >=  0)  {	  if(header!=    null    &&    header.size()    >    0)    {    	non-compiled	[CE]  :  expected	20	None	replace
155	[BUG]  [BUGGY]  String  header[]  =  this.format.getHeader(recordNumber);  [CE]  :  expected  [FE]                            AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  String  header[]  =  this.format.getHeader(recordNumber);  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	String  header[]  =  this.format.getHeader(recordNumber);	  String    header[]    =    this.format.getSkipHeaderRecord();    	non-compiled	[CE]  :  expected	31	None	replace
156	[BUG]  [BUGGY]  String  header[]  =  this.format.getHeaderFormat();  [CE]  :  expected  [FE]                              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  String  header[]  =  this.format.getHeaderFormat();  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	String  header[]  =  this.format.getHeaderFormat();	  String    header[]    =    this.format.getSkipHeaderRecord();    	non-compiled	[CE]  :  expected	31	None	replace
157	[BUG]  [BUGGY]  String  header[]  =  this.format.getHeader(rec);  [CE]  :  expected  [FE]                                AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  String  header[]  =  this.format.getHeader(rec);  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	String  header[]  =  this.format.getHeader(rec);	  String    header[]    =    this.format.getSkipHeaderRecord();    	non-compiled	[CE]  :  expected	31	None	replace
158	[BUG]  [BUGGY]  if(header!=  null  &&  currentRecord.size()  >  0)  {  [CE]  :  expected  [FE]                    AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header!=  null  &&  currentRecord.size()  >  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header!=  null  &&  currentRecord.size()  >  0)  {	  if(header    ==    null    &&    nextRecord.size()    >    0)    {    	non-compiled	[CE]  :  expected	23	None	replace
159	[BUG]  [BUGGY]  if(header  >=  null  &&  header.size()  >  0)  {  [CE]  :  expected  [FE]                  AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  >=  null  &&  header.size()  >  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  >=  null  &&  header.size()  >  0)  {	  if(header!=    null    ||    header.size()    >    0)    {    	non-compiled	[CE]  :  expected	22	None	replace
160	[BUG]  [BUGGY]  if(header  [Delete]  null  &&  header.size()  >  0)  {  [CE]  :  expected  [FE]                    AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header  [Delete]  null  &&  header.size()  >  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header  [Delete]  null  &&  header.size()  >  0)  {	  if(header!=    null    ||    header.size()    >    0)    {    	non-compiled	[CE]  :  expected	22	None	replace
161	[BUG]  [BUGGY]  hdrMap.put(header,  RectangleConstraint.NONE);  [CE]  :  expected  [FE]                            AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header,  RectangleConstraint.NONE);  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header,  RectangleConstraint.NONE);	  hdrMap.put(rec,    header);    	non-compiled	[CE]  :  expected	5	None	replace
162	[BUG]  [BUGGY]  hdrMap.put(header,  RectangleEdge.valueOf(rec));  [CE]  :  expected  [FE]                              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header,  RectangleEdge.valueOf(rec));  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header,  RectangleEdge.valueOf(rec));	  hdrMap.put(rec,    header);    	non-compiled	[CE]  :  expected	5	None	replace
163	[BUG]  [BUGGY]  hdrMap.put(header,  header);  [CE]  :  expected  [FE]                                AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header,  header);  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header,  header);	  hdrMap.put(rec,    header);    	non-compiled	[CE]  :  expected	5	None	replace
164	[BUG]  [BUGGY]  hdrMap.put(header,  new  CSVRecord(rec));  [CE]  :  expected  [FE]                                  AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header,  new  CSVRecord(rec));  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header,  new  CSVRecord(rec));	  hdrMap.put(rec,    header);    	non-compiled	[CE]  :  expected	5	None	replace
165	[BUG]  [BUGGY]  hdrMap.put(header[0],  Integer.valueOf(0),  header);  [CE]  :  expected  [FE]                    AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header[0],  Integer.valueOf(0),  header);  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header[0],  Integer.valueOf(0),  header);	  hdrMap.put(header[0],    Integer.valueOf(0));    	non-compiled	[CE]  :  expected	1	None	replace
166	[BUG]  [BUGGY]  if(header!=  null  ||  header.length  <  2  ||  header.length  >  0)  {  [CE]  :  expected  [FE]            AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header!=  null  ||  header.length  <  2  ||  header.length  >  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header!=  null  ||  header.length  <  2  ||  header.length  >  0)  {	  if(header!=    null    ||    header.length    <    2)    {    	non-compiled	[CE]  :  expected	38	None	replace
167	[BUG]  [BUGGY]  if(header!=  null  &&  header.length  <  2  ||  header.length  >  0)  {  [CE]  :  expected  [FE]              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header!=  null  &&  header.length  <  2  ||  header.length  >  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header!=  null  &&  header.length  <  2  ||  header.length  >  0)  {	  if(header!=    null    ||    header.length    <    2)    {    	non-compiled	[CE]  :  expected	38	None	replace
168	[BUG]  [BUGGY]  hdrMap.put(rec.toString(),  this.format.getHeaderRecord());  [CE]  :  expected  [FE]                        AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(rec.toString(),  this.format.getHeaderRecord());  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(rec.toString(),  this.format.getHeaderRecord());	  hdrMap.put(rect.toString(),    this.format.getSkipHeaderRecord());    	non-compiled	[CE]  :  expected	3	None	replace
169	[BUG]  [BUGGY]  hdrMap.put(this.format.toString(),  this.format.getHeaderRecord());  [CE]  :  expected  [FE]                          AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(this.format.toString(),  this.format.getHeaderRecord());  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(this.format.toString(),  this.format.getHeaderRecord());	  hdrMap.put(rect.toString(),    this.format.getSkipHeaderRecord());    	non-compiled	[CE]  :  expected	3	None	replace
170	[BUG]  [BUGGY]  hdrMap.put(header[0],  this.format.getHeader());  [CE]  :  expected  [FE]                          AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header[0],  this.format.getHeader());  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header[0],  this.format.getHeader());	  hdrMap.put(header[0],    this.format.getSkipHeaderRecord());    	non-compiled	[CE]  :  expected	30	None	replace
171	[BUG]  [BUGGY]  hdrMap.put(header[0],  this.format.getLastRecord());  [CE]  :  expected  [FE]                            AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header[0],  this.format.getLastRecord());  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header[0],  this.format.getLastRecord());	  hdrMap.put(header[0],    this.format.getSkipHeaderRecord());    	non-compiled	[CE]  :  expected	30	None	replace
172	[BUG]  [BUGGY]  hdrMap.put(header[0],  this.format.getFormatHeaderRecord());  [CE]  :  expected  [FE]                              AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  hdrMap.put(header[0],  this.format.getFormatHeaderRecord());  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	hdrMap.put(header[0],  this.format.getFormatHeaderRecord());	  hdrMap.put(header[0],    this.format.getSkipHeaderRecord());    	non-compiled	[CE]  :  expected	30	None	replace
173	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i),  this.format.getHeaderRecord());  }  [CE]  :  expected  [FE]                    AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i),  this.format.getHeaderRecord());  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i),  this.format.getHeaderRecord());  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    Integer.valueOf(i),    this.format.getSkipHeaderRecord());    }    	non-compiled	[CE]  :  expected	41	None	replace
174	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  header.length;  i  +=  2)  {  hdrMap.put(header[i],  Integer.valueOf(i),  this.format.getSkipHeaderRecord());  }  [CE]  :  expected  [FE]                      AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  header.length;  i  +=  2)  {  hdrMap.put(header[i],  Integer.valueOf(i),  this.format.getSkipHeaderRecord());  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  header.length;  i  +=  2)  {  hdrMap.put(header[i],  Integer.valueOf(i),  this.format.getSkipHeaderRecord());  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    Integer.valueOf(i),    this.format.getSkipHeaderRecord());    }    	non-compiled	[CE]  :  expected	41	None	replace
175	[BUG]  [BUGGY]  For(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i),  this.format.getSkipHeaderRecord());  }  [CE]  :  expected  [FE]                        AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  For(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i),  this.format.getSkipHeaderRecord());  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	For(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i),  this.format.getSkipHeaderRecord());  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    Integer.valueOf(i),    this.format.getSkipHeaderRecord());    }    	non-compiled	[CE]  :  expected	41	None	replace
176	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i)+  1,  this.format.getSkipHeaderRecord());  }  [CE]  :  expected  [FE]                          AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i)+  1,  this.format.getSkipHeaderRecord());  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i)+  1,  this.format.getSkipHeaderRecord());  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    Integer.valueOf(i),    this.format.getSkipHeaderRecord());    }    	non-compiled	[CE]  :  expected	41	None	replace
177	[BUG]  [BUGGY]  For(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  this.format.getSkipHeaderRecord());  }  [CE]  :  expected  [FE]                      AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  For(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  this.format.getSkipHeaderRecord());  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	For(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  this.format.getSkipHeaderRecord());  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    this.format.getSkipHeaderRecord());    }    	non-compiled	[CE]  :  expected	28	None	replace
178	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  this.format.getRecord());  }  [CE]  :  expected  [FE]                        AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  this.format.getRecord());  }  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	for(int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  this.format.getRecord());  }	  for(int    i    =    0;    i    <    header.length;    i++)    {    hdrMap.put(header[i],    this.format.getSkipHeaderRecord());    }    	non-compiled	[CE]  :  expected	28	None	replace
179	[BUG]  [BUGGY]  if(header!=  null  &&  header  ==  null  &&  header.length  ==  0)  {  [CE]  :  expected  [FE]                AssertionError      [CONTEXT]      header  =  nextRecord.values();  }  }  else  {  if  (this.format.getSkipHeaderRecord())  {  this.nextRecord();  }  header  =  formatHeader;  }        [BUGGY]  if(header!=  null  &&  header  ==  null  &&  header.length  ==  0)  {  [BUGGY]      for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }  [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map  [VARIABLES]  Lexer  lexer  boolean  CSVFormat  format  List  record  Token  reusableToken  CSVRecord  current  nextRecord  rec  String[]  formatHeader  header  Map  hdrMap  headerMap  long  recordNumber  int  i  	projects/Csv7/src/main/java/org/apache/commons/csv/CSVParser.java	0.31622776601683794	369	369	1	replace	if(header!=  null  &&  header  ==  null  &&  header.length  ==  0)  {	  if(rec    ==    null    &&    header!=    null    &&    header.length    ==    0)    {    	non-compiled	[CE]  :  expected	18	None	replace
